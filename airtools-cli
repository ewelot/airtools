#!/bin/bash

########################################################################
# airtools-cli
#   AIRTOOLS tasks command-line interface
#
# Copyright: Thomas Lehmann, 2018-2022
# License: GPL v3
#
# note: the following environment variables may be used
#       AO_SKIP  in _imageinfo
#       AO_FLATS in _flats
#       AO_LIGHT in _lights
#       AO_BGVAR in _bgvar
#       AO_REGIS in _register
#       AO_STACK in _stack and _costack
#       AO_AMASK and AO_ACOOR and AO_ABINN in _astrometry
#
########################################################################
AOVARS="AO_SKIP AO_FLATS AO_LIGHT AO_BGVAR AO_REGIS AO_STACK AO_AMASK AO_ACOOR AO_ABINN"

VERSION="1.5.1"
VINFO="T. Lehmann, Jun. 2023"
PINFO="\
    options:
      -h            show this help text
      -p projectdir start from projectdir (default: cwd) 
      -s setname    limit processing to given image set
      -c cmd        run the given user command
      -x parts      exclude/skip some program parts (proc|plot|image)
      -o            overwrite previous results without warning
      -q            lower amount of output messages
    parameters:
      task          run given task    
"
CHANGELOG="
    1.5.1 - 17 Jun 2023
        * imageinfo: bugfix to call mousepad only once and redirect stdout
            and stderr
        * new function: has_current_info

    1.5 - 09 May 2023
        * imageinfo:
            - output is written to rawfiles.dat for all types of raw images,
              including those from DSLR cameras
            - support more DSLR raw image types (more camera models)
        * flats: badpix filename is now passed to AIflat via new option
            -bad <badpix>
        * badpix: use file name badpix.<telid>.png for resulting (combined)
            badpix image file
        * AIstack: now only badpix.<set>.png is selected as badpixel map

    1.5a2 - 30 Apr 2023
        * darks: statistics is now done after creating master darks and uses
            image files in $AI_TMPDIR, mstat.dk.dat now contains 16bit scaled
            data values
        * lights: badpix filename is now passed to AIccd via new option
            -bad <badpix>
        * load_images: be aware of calibrated images in FITS format

    1.5a1 - 13 Apr 2023
        * bgvar:
            - output images are now scaled by factor 10 to enhance variations
              of small amplitude, a difference of 0 is now mapped to the value
              20000 (instead of 1000)
            - allow FITS format on input images
        * lights: handle options -f and -p to force creating FITS or PPM/PGM
            images (default: PPM for DSLR raw and FITS for anything else)

    1.4.2 - 22 Feb 2023
        * darks: recompute dark variations if new dark set has been added

    1.4.1 - 10 Dec 2022
        * astrometry:
            - do not rely on star stack image (only when using AO_MASK)
            - prefer GAIA catalogs over UCAC-4 for deep images

    1.4 - 24 Jul 2022
        * astrometry: sensible parameters for AIwcs are now taken from output
            of guess_wcsparam
        * badpix:
            - improve handling of multiple telescopes
            - added option -a to include masks of all sets of a given telescope
        * remove: disabled per task removal of files for badpix

    1.4a3 - 22 Jun 2022
        * stack, costack, load_images, load_stacks: removed calls to
            wait_for_saoimage and wait_for_frame as the same functionality has
            been added to AIexamine

    1.4a2 - 19 Jun 2022
        * badpix: by default create hotpix file for use by AIccd (including
            all daily badpix images for each telescope)
        * load_images: for raw images use a link to refer to raw image whose
            name starts with the image number
            
    1.4a1 - 30 Apr 2022
        * astrometry: exclude diffuse sources for solve-field
        * lights, flats: recognize hotpix file for all camera sensor types
            (until now it was applied with DSLR raw images only)

    1.3.9 - 26 Apr 2022
        * imageinfo: rework to allow multiple entries in AO_SKIP
        * reduce output messages if option quiet is set

    1.3.8 - 31 Mar 2022
        * stack: lower threshold for detecting sources from 5 to 3.5

    1.3.8a1 - 24 Feb 2022
        * register, stack: improve initial guess of fwhm by reducing deblending
            of stars (better match of defocused stars)
        * stack: extract sources using a background mesh size depending on
            fwhm of stars

    1.3.7 - 18 Nov 2021
        * badpix: bugfix to correctly set bandrank index in case of sets
            being rejected due to low number of images

    1.3.6 - 20 Sep 2021
        * imageinfo: bugfix to correctly handle AO_SKIP

    1.3.5 - 31 Aug 2021
        * costack: do not abort program if the object is not found by JPL
        * astrometry: improve check of valid solution by solve-field
        * stack, costack: force OBJECT keyword being of type string

    1.3.4 - 16 Jul 2021
        * check of sites.dat now depends on airfun.sh program version
        * imageinfo: recognize AO_SKIP (path in AI_RAWDIR to be ignored)
        * astrometry: make crossid radius grow faster at low altitude
        * badpix: ignore AI_EXCLUDE, set output file name according to camtype

    1.3.3 - 17 Jun 2021
        * astrometry, costack: get comet position from JPL Horizons instead
            of MPC Ephemeris Service
        * stack: use approximate estimate of FWHM when extracting sources
            in stacked image (affects deblending parameters)
        * badpix: replace convert using '-evaluate-sequence max' by vips
            bandrank function to avoid memory exhausting by imagemagick

    1.3.3a1 - 25 May 2021
        * register: bugfix: invert plot of mag diff

    1.3.2 - 04 May 2021
        * costack: bugfix: properly set OBJECT keyword

    1.3.1 - 30 Apr 2021
        * bgvar: take offset into account when plotting background values

    1.3 - 21 Apr 2021
        * flats, lights: added check for valid telid,
            deal with new camera type CMOS
        * darks: adjusted mesh size of small diff images
        * lights: always add offset of 100 ADU to avoid clipping of values at 0
        * register: determine a first guess on fwhm and use it for source
            extraction (instead of relying on a fixed value)
        * new command: terminal

    1.3a2 - 20 Mar 2021
        * astrometry: bugfix resetting the north value on new sets, use larger
            search radii to improve solving of small fields
        * OVERWRITE option implemented for all major image reduction tasks
        * added task badpix
        * rework of task remove

    1.3a1 - 27 Jan 2021
        * darks: use pnmccdred2 when estimating dark variation, applied
            change of parameters on AIraw2gray
        * costack: deal with objects unknown to MPC database by providing
            coordinates and motion vector

    1.2.2 - 18 Dez 2020
        * imageinfo: adapted to new log files from iTelescope.net, recognize
            more FITS file name extensions
        * lights: if data are not dslr raw images then assume hotpixel file
            is an image in PNG format (instead of .dat)

    1.2.1 - 19 Nov 2020
        * allow for process monitoring by setting AI_PROCMON
        * new function procmon

    1.2 - 14 Sep 2020
        * replace option -m <mode> by -x <parts> which simplifies program logic
        * astrometry:
            - improve handling of images containing a very large number of
              sources (>100000)
            - prefer ucac4 on medium size images (up to 9 deg^2)
            - reduce maxoff in case of an existing solution by solve_field

    1.2a4 - 31 Aug 2020
        * rewrite of load_images
        * lights: add 100ADU to calibrated CCD images as well

    1.2a3 - 30 Jul 2020
        * astrometry: if refraction changes by large amount across field then
            increase crossid radius and lower number of stars to be used in fit

    1.2a2 - 10 Jul 2020
        * register: bugfix when running second attempt on failed registration
        * imageinfo: allow for mixed FITS and DSLR raw files

    1.2a1 - 22 Jun 2020
        * imageinfo: support several types of compressed FITS images
        * darks: use additive normalization of images in noise estimation

    1.1.6 - 04 Jun 2020
        * bugfix in darks: compute dark variation for user provided image sets
          only (if specified)
        * stack: prefer badpix mask image specific to set if present

    1.1.5 - 19 May 2020
        * ds9cmd: quote arguments containing special characters
        * new environment variable AI_MAXPROCS to set number of jobs to run
          in parallel when calling program parallel

    1.1.4 - 12 May 2020
        * added check for correct parameter file structure
        
    1.1.3 - 24 Mar 2020
        * flats: do not use option -b if camera sensor is CCD
        * lights: add pedestal of 100 ADU if camera sensor is CCD
        
    1.1.2 - 02 Mar 2020
        * bgvar: bugfix: correctly determine column of background values to
            plot for every telescope used
        * astrometry:
            - do not write result from solve-field to image header anymore
            - rename of AO_ACCOO to AO_ACOOR
            - new env variable AO_ABINN to set value of binning
            - allow to skip solve-field by using AO_ACOOR=skipfirst

    1.1.1 - 28 Jan 2020
        * bgvar: bugfix: correctly deal with multiple set names
        * correctly handle task mode 'normal'
        * stack: always use target from set.dat to set OBJECT keyword
        * load_images: use wait_for_saoimage if SAOImage window is newly
            created
        * astrometry: improved stability when fitting large fields (>10 deg),
            if first attempt of AIwcs fails try again using fewer catalog stars
        * added check for allowed AO_ variables (defined by AOVARS)

    1.1 - 15 Dec 2019
        * darks, bgvar: bugfix for newer versions of imagemagick: when writing
          result to stdout in a specific image format then a hyphen character
          is required after the format specification (e.g. pgm:-)
        * lights: allow to use hotpixel file name hotpix.$cam.dat
        * astrometry: if using AO_ACCOO=unknown then do full sky search
        * allow for performance monitoring by using AI_DSTAT=1

    1.1a2 - 07 Nov 2019
        * imageinfo: avoid Gtk-Warning messages about theme parsing errors in
          calls of mousepad by filtering error stream

    1.1a1 - 21 Oct 2019
        * darks: run parallel jobs
        
    1.0   - 27 Aug 2019
        * set LC_NUMERIC=C required by printf and sort commands
        * register: bugfix: correctly capture exit code of the first comand in
            a pipe
        * load_images: deal with setname used as parameter

    1.0a5 - 17 Jun 2019
        * added ds9cmd wrapper for comet extraction tasks

    1.0a4 - 15 May 2019
        * imageinfo: enhanced to support newer naming scheme of fits files
        * load_stacks: wait for images to be loaded
        * new task: ds9cmd

    1.0a3 - 24 Apr 2019
        * bgvar: bugfix: corrected typo in plot filename
        * new task: load_images

    1.0a2 - 01 Mar 2019
        * lights: allow to overwrite default parameters passed to AIccd by
            setting AO_LIGHT
        * allow to use space or comma separated image set names in -s <setname>

    1.0a1 - 31 Jan 2019
        * register: if registration fails on some images then start a second pass
            using more relaxed constraints on allowed offsets
            
    0.9 - 04 Jan 2019
        * bgvar: changed default background fitting in AIbgdiff from surface fit
            to a plane for better stability in case of large offsets between
            images where extended bright sources are in the field of view
        * darks: by default run stats for new images only,
            use AI_EXCLUDE to discard images

    0.9a1 - 03 Dec 2018
        * bgvar, stack, costack: increased bgzero from 3000 to 10000

    0.8 - 29 Oct 2018
        * task darks: create noise image for larger sets (n>=15)
        * task bgvar: recognize option AO_BGVAR
        * task register: recognize option AO_REGIS
        * rename task coextract to load_stacks
        * remove hard-coded expansion of PATH variable

    0.7 - 09 Oct 2018
        * stack: stack properties: do not touch header file if all keywords
            are existing already
        * astrometry: rename wcs header file in case of failure of AIwcs
    
    0.6 - 30 Aug 2018
        * added task coextract
        * task stack: estimate noise in green channel and write AI_RMSG
            header keyword
        * task astrometry: allow to mask region for source detections by
            using env variable AO_AMASK which may point to a region file or
            holds the max distance (pixel) of valid objects from image center 

    0.5 - 26 Jun 2018
        * rework handling of AI_CCDREGION
        * added option -m <mode> to limit execution blocks of tasks
        * added option -c <cmd> to execute user defined command

    0.4 - 05 Jun 2018
        * added option -q to reduce output messages

    0.3 - 29 May 2018
        * allow for selection of a specific light image set via -s option

    0.2.1 - 28 May 2018
        * added keywords AI_TELID, BINNING to header file of stack
        * write rounded values of AI_BGG, AI_FWHM
        
    0.2 - 27 May 2018
        * added task status
        * added/improved various messages
        * write OBJECT keyword according to set.dat

    0.1 - 20 May 2018
        * initial version
"


#--------------------
#   user definitions
#--------------------
# Log file
log=airtools.log
# resources file (predefined variables, e.g. day, AI_SITE)
rcfile=.airtoolsrc


#--------------------
#   functions
#--------------------
shorthelp ()
{
    echo "usage: $(basename $0) [-h] [-p projectdir] [-x skipparts] [-o] <task> [params]"
}

longhelp ()
{
    echo $(basename $0)"   $VERSION   $VINFO"
    shorthelp
    printf "$PINFO"
}

error ()
{
    f_str="$1"
    echo "ERROR: $f_str" >&2
    exit 1
}

has_current_info ()
{
    # check log file if the version information is up to date
    local vash=$1   # current version of airfun.sh
    local vapy=$2   # current version of airfun.py
    local lnum
    local last_vash
    local last_vapy
    test ! -s $log && return -1
    # last header line
    lnum=$(grep -n "starting airtools-cli" $log | tail -1 | cut -d ':' -f1)
    test -z "$lnum" && return -1
    
    # check for log entry of the same day
    txt="starting $(basename $0) v$VERSION at $(date +'%Y-%m-%d')"
    cat airtools.log | sed -n "$lnum"',$p' | grep -q "$txt" || return -1
    
    # compare airfun.sh version
    last_vash=$(cat airtools.log | sed -n "$lnum"',$p' | head | \
        grep "airfun.sh:" | awk '{printf("%s", $NF)}')
    test "$vash" != "$last_vash" && return -1

    # compare airfun.py version
    last_vapy=$(cat airtools.log | sed -n "$lnum"',$p' | head | \
        grep "airfun.py:" | awk '{printf("%s", $NF)}')
    test "$vapy" != "$last_vapy" && return -1
    
    # all test have passed which means the header has not changed
    return 0
}

is_equal () {
    # compare two (float) numbers
    local x=$1
    local y=$2
    test $# -ne 2 && echo "ERROR: two parameters required" >&2 && return 255
    local err
    err=$(echo $x $y | awk '{
        d=$1-$2; if (d == 0) {print 0} else {print 255}
    }')
    return $err
}

is_time () {
    local x=$1
    local err
    err=$(echo $x | awk -F ':' '{
        x=0
        if (NF!=2) x=255
        if ($1!~/^[0-9][0-9]$/ || $2!~/^[0-9][0-9]$/) x=255
        if ($1>24 || $2>59) x=255
        print x
    }')
    return $err
}

match () {
    # case insensitive matching for beginning of words in a list
    local needle=$1
    local stack=$2  # values separated by space or separator character
    local sep=${3:-"|,;"}   # list of separator characters
    echo "$stack" | tr "$sep" ' ' | grep -qiE "^$needle| $needle"
}

backup () {
    # make backup of file (ignore symlinks)
    local do_echo   # if set show backup command
    test "$1" == "-e" && do_echo=1 && shift 1
    local orig=$1
    local num
    local last
    last=$(ls "$orig".bak "$orig".bak[1-9] 2>/dev/null | tail -1)
    test "$last" &&
        num=$(echo ${last: -1} | awk '{if($1~/[0-9]/){x=1+$1; print x}}')
    test "$num" && test $num -gt 9 && num=9
    test "$do_echo" && echo cp -p "$orig" "$orig".bak$num && return
    cp -p "$orig" "$orig".bak$num
}

select_item () {
    # prepend "^" to item string
    local list="$1"
    local item="$2"
    local sep=";"
    echo "$list" | awk -v s="$sep" -v x="$item" '{
        n=split($0,a,s)
        for (i=1;i<=n;i++) {
            sub(/\^/,"",a[i])
            if(i>1) printf("%s", s)
            if(a[i]==x) printf("^")
            printf("%s", a[i])
        }}'
}


#--------------------------------
#   test tasks
#--------------------------------
_setinfo () {
    local retval
    AIsetinfo
    retval=$?
    echo "... done"
    return $retval
}

_minute () {
    local i
    date
    for i in $(seq 6 -1 1)
    do
        echo "# Sleeping $((i*10))s ..."
        sleep 10
    done
    echo "... done"
    return 0
}

_endless () {
    while true
    do
        echo "# Sleeping 10s ..."
        sleep 10
    done
    echo "... done"
    return 0
}

_failure () {
    echo "# Failing in 20s ..."
    sleep 10
    for i in $(seq 10 -1 1)
    do
        echo "# Failing in ${i}s ..."
        sleep 1
    done
    echo "... done"
    return 255
}

_pipetest () {
    local retval=0
    echo "# running pipetest ..."
    __mytest () {
        local infile="$1"
        local tmp1=$(mktemp "/tmp/tmp1_stdin_XXXXXX")
        if [ "$infile" == "-" ]
        then
            cat > $tmp1
            infile=$tmp1
        fi
        sleep 2
        rm -f $tmp1
    }
    for i in $(seq 1 10)
    do
        echo "$i"
        cat /var/log/messages | __mytest -
        test $? -ne 0 && echo "ERROR" && retval=255
    done
    return $retval
}

_sexselect () {
    local retval=0
    local head=test.wcs.ahead
    local sdat=measure/0005.src.dat
    echo "# running sexselect ..."
    __mytest () {
        cat $sdat | sexselect -f - "" 0.02 | \
            addldacwcs - $head > x.fits
        sexselect $sdat "" "" 300 | sort -n -k7,7 | \
            grep -v "^#" | head -100 > x.xyref
        head x.xyref
    }
    for i in $(seq 1 10)
    do
        echo "$i"
        __mytest | tee -a x.dat
        test $? -ne 0 && echo "ERROR" && retval=255
    done
    return $retval
}

_test () {
    #_pipetest
    _sexselect
}



#--------------------------------
#   main imred reduction tasks
#--------------------------------
_imageinfo () {
    # DSLR RAW images: must be placed in $AI_RAWDIR, image number is taken from file name
    # FITS images: placed in any subdir of $AI_RAWDIR, arbitrary file names
    # note: files in directory "unused" are ignored
    #       AO_SKIP: path within AI_RAWDIR which is to be ignored
    # TODO: replace spaces in file names: for f in *; do mv -i "$f" "${f// /_}"; done
    local extlist
    local ext
    local msg
    local flist
    local tel
    local tellist
    local f
    local extargs
    local skipargs
    local rdat="rawfiles.dat"
    local rawextlist="pef,cr2,cr3,nef,arw,raf,dng"
    
    msg="# Collecting image information ..."
    if [ "$AO_SKIP" ]
    then
        echo "# using expert option: AO_SKIP=$AO_SKIP"
        skipargs=""
        for s in ${AO_SKIP//,/ }
        do
            skipargs="$skipargs -not -path \"$AI_RAWDIR/$s\"\*"
        done
    fi
    
    if ! match proc "$SKIPPARTS"
    then
        echo $msg

        if [ "$OVERWRITE" ]
        then
            test ! -f $rdat && continue
            echo "# deleting $rdat"
            rm $rdat
            test $? -ne 0 && return 255
        fi

        # scanning dslr raw images ...
        extlist=$(eval find $AI_RAWDIR/ -type f $skipargs | sed -e 's,.*\.,,' | sort -u | \
            grep -iwE "${rawextlist//,/|}")
        extargs="\( -iname \"*.${rawextlist%%,*}\""
        for s in $(echo ${rawextlist#*,} | tr ',' ' ')
        do
            extargs="$extargs -or -iname \"*.$s\""
        done
        extargs="$extargs \)"
        test "$extlist" && for ext in $extlist
        do
            echo "# scanning $ext files ..."
            test "$AI_DEBUG" && echo find $AI_RAWDIR/ -type f $extargs $skipargs "..." >&2
            flist=$(eval find $AI_RAWDIR/ -type f $extargs $skipargs \
                -not -path "$AI_RAWDIR/unused/\*")
            img_info $flist | sort -n -k 2,2 >> $rdat
            test $? -ne 0 && return 255
        done
        
        # scanning FITS images ...
        extargs="\( -iname \"*.fit\""
        for s in fits fts fit.gz fits.gz fts.gz fit.zip fits.zip fts.zip
        do
            extargs="$extargs -or -iname \"*.$s\""
        done
        extargs="$extargs \)"
        # FITS images from itelescope.net
        if grep -iq iTelescope.Net $AI_RAWDIR/[2T]*{txt,log} 2>/dev/null
        then
            if [ -e $AI_RAWDIR/obs.txt ]
            then
                itel2obs
            else
                itel2obs | tee -a $AI_RAWDIR/obs.txt
            fi
            tellist=$(get_itel_telid $AI_RAWDIR/[2T]*{txt,log} 2>/dev/null)
            test "$tellist" && for tel in $tellist
            do
                # bugfix for wrong identifiers on T16, T68, T20
                test $tel == "16" && tel=T16
                test $tel == "jbl08" && tel=T68
                test $tel == "T2" && tel=T20
                echo "# scanning fits files for $tel ..."
                test "$AI_DEBUG" && echo find $AI_RAWDIR/ -type f $extargs $skipargs "..." >&2
                flist=$(eval find $AI_RAWDIR/ -type f $extargs $skipargs \
                    -not -path "$AI_RAWDIR/unused/\*" | grep -iw $tel)
                # TODO: check JD in first file, if it is not plausible then use time
                # info from log file by providing -l option
                test "$flist" && map_rawfiles -x $flist >> $rdat
                test $? -ne 0 && return 255
            done
        else
            # scanning other FITS images
            test "$AI_DEBUG" && echo find $AI_RAWDIR/ -type f $extargs $skipargs "..." >&2
            flist=$(eval find $AI_RAWDIR/ -type f $extargs $skipargs \
                -not -path "$AI_RAWDIR/unused/\*")
            if [ "$flist" ]
            then
                echo "# scanning fits files ..."
                map_rawfiles -x $flist >> $rdat
                test $? -ne 0 && return 255
            fi
        fi
        test -s $rdat && mousepad $rdat >/dev/null 2>/dev/null &
    fi
    return 0
}

_darks () {
    # use AI_EXCLUDE to skip some images from master dark
    # TODO: make dkmn a temp file
    #       compute stats only for new images
    #       determine dark varition only for new sets
    local slist
    local dklist
    local set
    local scale
    local flip
    local opts
    local nlist
    local exlist
    local fname
    local x
    local msg
    local bs
    local has_new_dark
    local ext
    local popts
    local flist
    local tmpargs=$(mktemp "/tmp/tmp_args_XXXXXX")
    local tmpsh=$(mktemp "/tmp/tmp_script_XXXXXX.sh")
    
    #set -x
    slist=$(AIsetinfo -b | awk '{if($4=="d"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" &&
        echo "WARNING: no images to process." && return 0
    # checking valid telid
    for set in $slist
    do
        get_param camera.dat pixscale $set > /dev/null
        test $? -ne 0 &&
            echo "ERROR: unknown telescope identifier for set $set." >&2 &&
            return 255
    done

    if [ "$OVERWRITE" ] && ! match proc "$SKIPPARTS"
    then
        echo "# deleting previous results of" $slist
        _remove -x darks
        test $? -ne 0 && return 255
    fi

    msg="# Creating Master darks ..."
    ! match proc "$SKIPPARTS" && for set in $slist
    do
        # if necessary add option -r to remove row pattern
        test -f $set.pgm && continue
        test "$msg" && echo $msg && msg=""
        AIdark $set
        test $? -ne 0 && return 255
        has_new_dark=1
    done
    ! match image "$SKIPPARTS" &&
        for set in $slist; do test -f $set.pgm && dklist="$dklist $set.pgm"; done &&
        test "$dklist" &&
            AIexamine -n MasterDark_and_Flat $dklist
    

    msg="# Computing statistics of dark images ..."
    if ! match proc "$SKIPPARTS"
    then
        # determine list of images for which to estimate statistics
        ext="pgm"
        rm -f $tmpargs
        for set in $slist
        do
            AI_EXCLUDE="" AIimlist $set "" raw | while read x num fname x
            do
                if [ -s mstat.dk.dat ]
                then
                    ! grep -q "^$(basename $fname) " mstat.dk.dat &&
                        test -s $AI_TMPDIR/$num.$ext && echo $num
                else
                    test -s $AI_TMPDIR/$num.$ext && echo $num
                fi
            done
        done > $tmpargs
        
        # get stats
        if [ -s $tmpargs ]
        then
            chmod u+x $tmpsh
            cat <<EOF > $tmpsh
#!/bin/bash
. airfun.sh > /dev/null
_run_stats_parallel \$@
EOF
            test "$msg" && echo $msg && msg=""
            _run_stats_parallel () {
                local num=$1
                local ext="pgm"
                local fname=$AI_TMPDIR/$num.$ext
                local rawname=$(get_rawfile $num)
                AImstat -v -c $fname | awk -v r="$(basename "$rawname")" -v n=$num '{
                    $1=r
                    if ($2=="-") sub(/-/,n,$2)
                    print $0}'
            }
            export -f _run_stats_parallel
            popts=""; test "$AI_MAXPROCS" && popts="-P $AI_MAXPROCS"
            cat $tmpargs | parallel $popts -k $tmpsh >> mstat.dk.dat
            unset -f _run_stats_parallel
        fi
    fi

    # plot stats
    test ! -s mstat.dk.dat && return 255
    ! match plot "$SKIPPARTS" &&
        AIplot -o $AI_TMPDIR/x.darkvalue.png -t "Dark value per image" -p mstat.dk.dat 2 5
    
    # dark variation (using first dark as reference)
    msg="# Estimate dark variation ..."
    #pnmcombine dk06.pgm dk09.pgm dk11.pgm dk12.pgm dkmn.pgm     # T05 bias
    #pnmcombine dk01.pgm dk02.pgm dkmn.pgm
    tellist=$(AIsetinfo -b | grep -w d | awk '{printf("%s\n", $11)}' | sort -u)
    ! match proc "$SKIPPARTS" && for tel in $tellist
    do
        test -z "$has_new_dark" && continue
        
        # populate $tmpargs to be used by parallel
        rm -f $tmpargs
        for set in $(AIsetinfo -b | grep -w d | \
            awk -v t=$tel '{if(tolower($11)==tolower(t)){print $2}}')
        do
            echo "$slist" | grep -w -q $set || continue
            test ! -f $set.pgm &&
                echo "ERROR: $set.pgm is missing." >&2 && return 255
            bs=64
            x=$(imsize $set.pgm | awk '{x=$1; if($2<$1) x=$2; print x}')
            test $x -lt 4000 && bs=48
            test $x -lt 3000 && bs=32
            test $x -lt 2000 && bs=24
            test $x -lt 1400 && bs=18
            for num in $(AI_EXCLUDE="" AIimlist -n $set "" raw)
            do
                test ! -f $AI_TMPDIR/$num.pgm &&
                    echo "ERROR: file $AI_TMPDIR/$num.pgm is missing." >&2 &&
                    return 255
                echo $num $bs $set $tel
            done
        done >> $tmpargs
        
        if [ -s $tmpargs ]
        then
            test "$msg" && echo $msg && msg="" &&
                echo "#" $(cat $tmpargs | wc -l) "images"
            chmod u+x $tmpsh
            cat <<EOF > $tmpsh
#!/bin/bash
. airfun.sh > /dev/null
_run_darkvar_parallel \$@
EOF
            _run_darkvar_parallel () {
                num=$1
                bs=$2
                set=$3
                tel=$4
                echo "# computing diff for $num ($set $tel)" >&2
                pnmccdred2 -m 10 -a 1000 -d $set.pgm $AI_TMPDIR/$num.pgm - | \
                    pnmsmooth > $AI_TMPDIR/x.$num.pgm
                (cd $AI_TMPDIR
                    AIbgmap -q x.$num.pgm $bs 1
                    add=$(AIstat x.$num.bgm1.pgm | awk '{printf("%.0f", 1000-$5)}')
                    pnmccdred2 -a $add x.$num.bgm1.pgm $num.dkdiff.pgm
                    rm x.$num.bgm1.pgm x.$num.bg.pgm x.$num.pgm
                )
            }
            export -f _run_darkvar_parallel
            popts=""; test "$AI_MAXPROCS" && popts="-P $AI_MAXPROCS"
            cat $tmpargs | parallel $popts -k $tmpsh
            unset -f _run_var_parallel
        fi
        
        montage -background '#03c003c003c0' -fill '#050005000500' -label '%t' \
            $AI_TMPDIR/????.dkdiff.pgm -geometry +4+2 dk.var10.$tel.pgm &&
			rm -f $AI_TMPDIR/????.dkdiff.pgm
    done
    
    # dark noise estimation (per pixel)
    ! match proc "$SKIPPARTS" && for set in $slist
    do
        test -s n${set}.sd.pgm && continue
        nimg=$(AIsetinfo $set | awk '{print $9}')
        test $nimg -lt 9 && continue
        echo "# estimate dark noise in $set, nimg=$nimg"
        grep -v "^#" set.dat | awk -v s=$set '{
            if ($2==s) printf("%s n%s\n", $1, substr($0,7))}' > $AI_TMPDIR/x.nset.dat
        AI_SETS=$AI_TMPDIR/x.nset.dat AInoise -s n$set
        rm -f ndk??.mn.pgm
    done
    
    # show some stats of darks
    for set in $slist
    do
        nimg=$(AIsetinfo $set | awk '{print $9}')
        mn=$(AImstat -c $set.pgm | cut -d ' ' -f5)
        sd=""
        test -e n$set.sd.pgm && sd=$(AImstat -c n$set.sd.pgm | cut -d ' ' -f5)
        printf "$set n=%2d mean=$mn" $nimg
        test "$sd" && printf " sd=$sd"
        printf "\n"
    done

    # free disk space by removing individual images
    ! match proc "$SKIPPARTS" && for set in $slist
    do
        flist=$(AIimlist q -f $set)
        test "$flist" && rm $flist
    done
    
    ! match image "$SKIPPARTS" &&
        AIexamine -n "Dark_Variation" -l dk.var10.*pgm
    rm -f $tmpsh $tmpargs
    return 0
}

_flats () {
    local slist
    local fflist
    local ccdopts
    local texp
    local tel
    local cam
    local type
    local badpix
    local ctype
    local opts
    local set
    local flist
    slist=$(AIsetinfo -b | awk '{if($4=="f"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" &&
        echo "WARNING: no images to process." && return 0
    # checking valid telid
    for set in $slist
    do
        get_param camera.dat pixscale $set > /dev/null
        test $? -ne 0 &&
            echo "ERROR: unknown telescope identifier for set $set." >&2 &&
            return 255
    done

    echo "# Creating master flats ..."

    if [ "$OVERWRITE" ] && ! match proc "$SKIPPARTS"
    then
        echo "# deleting previous results of" $slist
        _remove -x flats
        test $? -ne 0 && return 255
    fi

    ! match proc "$SKIPPARTS" && for set in $slist
    do
        ccdopts=""
        texp=$(AIsetinfo $set | awk '{printf("%.0f", $8)}')
        tel=$(AIsetinfo $set | awk '{printf("%s", $12)}')
        cam=$(get_param camera.dat camera $tel | awk '{print $1}')
        ctype=$(get_param camera.dat ctype $tel | awk '{print $1}')
        echo "# tel=$tel  cam=$cam ($ctype)"
        # check for existing badpix file
        badpix=""
        type=long; test $texp -lt 32 && type=short
        for badext in png # dat
        do
            for f in \
                badpix.${tel,,}_$type.$badext badpix.${tel,,}.$badext \
                hotpix.${tel,,}_$type.$badext hotpix.${tel,,}.$badext
            do
                test -e $f && badpix="$f" && break
            done
            test "$badpix" && break
        done
        test "$badpix" && ccdopts="-bad $badpix"
        echo "# AIflat" $ccdopts $AO_FLATS $set
        AIflat $ccdopts $AO_FLATS $set
        test $? -ne 0 && return 255
        
        # free disk space by removing individual images
        flist=$(AIimlist q -f $set)
        test "$flist" && rm $flist
    done
    # statistics
    for set in $slist
    do
        test ! -f $set.pgm &&
            echo "WARNING: flat $set.pgm does not exist" &&
            continue
        tel=$(AIsetinfo $set | awk '{printf("%s", $12)}')
        ctype=$(get_param camera.dat ctype $tel | awk '{print $1}')
        opts="-b"
        (test "$ctype" == "CCD" || test "$ctype" == "CMOS") && opts=""
        AIstat $opts -c $set.pgm
    done
    # show normalized flat image
    if ! match image "$SKIPPARTS"
    then
        for set in $slist
        do
            test ! -f $set.pgm && continue
            AIbnorm $set.pgm > $AI_TMPDIR/$set.norm.pgm
            fflist="$fflist $AI_TMPDIR/$set.norm.pgm"
        done
        test "$fflist" && AIexamine -n MasterDark_and_Flat $fflist
    fi
    return 0
}

_lights () {
    local slist
    local set
    local num
    local texp
    local tel
    local cam
    local type
    local ctype
    local ccdopts
    local is_calibrated # check only for ctype=CCD
    local badpix
    local badext
    
    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" &&
        echo "WARNING: no images to process." && return 0
    # checking valid telid
    for set in $slist
    do
        get_param camera.dat pixscale $set > /dev/null
        test $? -ne 0 &&
            echo "ERROR: unknown telescope identifier for set $set." >&2 &&
            return 255
    done

    echo "# Calibrating light frames ..."

    if [ "$OVERWRITE" ] && ! match proc "$SKIPPARTS"
    then
        echo "# deleting previous results of" $slist
        _remove -x calib
        test $? -ne 0 && return 255
    fi
    
    ! match proc "$SKIPPARTS" &&
    for set in $slist
    do
        ccdopts=""
        texp=$(AIsetinfo $set | awk '{printf("%.0f", $8)}')
        tel=$(AIsetinfo $set | awk '{printf("%s", $12)}')
        cam=$(get_param camera.dat camera $tel | awk '{print $1}')
        ctype=$(get_param camera.dat ctype $tel | awk '{print $1}')
        echo "# tel=$tel  cam=$cam ($ctype)"
        case "$ctype" in
            CCD|CMOS)   ccdopts="$ccdopts -a 100";;
            *)          ccdopts="$ccdopts -a 100 -q 1";;
        esac
        # check for existing badpix file
        badpix=""
        type=long; test $texp -lt 32 && type=short
        for badext in png # dat
        do
            for f in \
                badpix.${tel,,}_$type.$badext badpix.${tel,,}.$badext \
                hotpix.${tel,,}_$type.$badext hotpix.${tel,,}.$badext
            do
                test -e $f && badpix="$f" && break
            done
            test "$badpix" && break
        done
        test "$badpix" && ccdopts="$ccdopts -bad $badpix"
        test -d bgvar || mkdir bgvar
        
        echo "# running: AIccd" $ccdopts $AO_LIGHT $set
        AIccd $ccdopts $AO_LIGHT $set
        test $? -ne 0 && return 255
    done
    return 0
}

_bgvar () {
    local slist
    local bgcol
    local suffix
    local set
    local inext
    local bg
    local fg
    local nlist
    local num
    local filter
    local f
    local add
    local imlist
    local tellist
    local tel
    local ncol
    local title
    local doit
    local nref
    local mult
    local outext
    
    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" &&
        echo "WARNING: no images to process." && return 0
    echo "# Estimate background variation ..."

    if [ "$OVERWRITE" ] && ! match proc "$SKIPPARTS"
    then
        echo "# deleting previous results of" $slist
        _remove -x bgvar
        test $? -ne 0 && return 255
    fi
    
    if ! match proc "$SKIPPARTS"
    then
        # recognize already processed set
        test ! -s bgdiff.dat && doit=1
        for set in $slist
        do
            nlist="$nlist $(AIimlist -q -n $set "" "" o)"
        done
        if [ "${nlist// /}" ]
        then
            for num in $nlist
            do
                test "$doit" && continue
                # TODO: determine inext
                #   determine calib. image
                #   if -f calimg && calimg newer than bgvar/$num.bgm1.$inext
                #   then rm bgvar/$num.bgm1.$inext
                #       remove entry from bgdiff.dat bgsfit.dat
                #       remove varbgm1.$set.$inext
                AIsetinfo -b | grep -w o | awk '{printf("%s ", $8)}' | \
                    grep -q -w $num && continue
                ! grep -q "^"$num"." bgdiff.dat && doit=1            
            done
        fi
        
        # check if bad region masks/images are black-and-white
        if [ "$doit" ] && [ -d "bgvar" ]
        then
            for num in $nlist
            do
                test -e bgvar/$num.bad.png &&
                    ! is_mask bgvar/$num.bad.png white &&
                    return 255
            done
        fi
        
        # compute diff images
        if [ "$doit" ]
        then
            for set in $slist
            do                
                AIbgdiff -k -a -p $AO_BGVAR "$set" >> bgdiff.dat
                test $? -ne 0 && return 255
            done
        fi
    fi
    
    # plot mean bg values
    tellist=$(AIsetinfo -b -o | grep -v "^#" | awk '{printf("%s\n", tolower($11))}' | sort -u)
    ! match plot "$SKIPPARTS" && for tel in $tellist
    do
        nlist=""
        for set in $(AIsetinfo -b -o | grep -v "^#" | \
            awk -v t=$tel '{if(tolower($11)==t){print $2}}')
        do
            echo $slist | grep -qw $set || continue
            nlist="$nlist $(AIimlist -x -q -n $set)"
        done
        test -z "${nlist// /}" && continue
        filter=""
        for num in $nlist
        do
            test "$filter" && filter="$filter|"
            filter="${filter}^$num"
        done
        ncol=$(grep -wE "$filter" bgdiff.dat | lines 1 | wc -w)
        bgcol=7 # gray in 7
        test $ncol -gt 14 && bgcol=16   # rgb in 15 16 17
        title="$tel: Average background per image"
        grep -wE "$filter" bgdiff.dat | \
            awk -v bgoff=100 -v c=$bgcol '{printf("%s %.1f\n", $2, $c-bgoff)}' | \
            AIplot -o $AI_TMPDIR/x.$tel.bg.png -t "$title" -p - 1 2
    done
    
    # show changing gradient only
    #suffix=bgdiff   # result of surface fit of diff image excl. bad regions
    suffix=bgm1     # diff image with respect to average image
    ! match proc "$SKIPPARTS" && for set in $slist
    do
        set - $(AIsetinfo $set)
        test $9 -le 1 && continue
        inext="pgm"
        test -f $AI_TMPDIR/$4.ppm && inext="ppm"
        test -f $AI_TMPDIR/$4.fits && inext="fits"
        if [ $inext != "fits" ]
        then
            outext=$inext
        else
            outext="pgm"
            test "$(get_header -q $AI_TMPDIR/$4.fits NAXIS3)" == "3" &&
                outext="ppm"
        fi
        nlist=$(AIimlist -n $set)
        test -z "$nlist" && continue
        # TODO: determine range of variations, if > 2000 then use mult=1
        # old: mult=1; newbg=1000
        mult=10
        newbg=20000
        # TODO: run parallel processes, otherwise it is really slow
        for num in $nlist
        do
            f=bgvar/$num.$suffix.$inext
            test -f $f || continue
            imcrop $f 70 > tmp1.$$.$inext
            add=$(AIstat tmp1.$$.$inext | awk -v m=$mult -v b=$newbg '{
                printf("%d",b-m*$5); if(NF>8) printf(",%d,%d", b-m*$9, b-m*$13)}')
            echo $num $f $mult $add
            pnmccdred2 -a $add -m $mult $f - | pnmscale 4 - > z.$set.$num.$outext
        done
        # note: montage changes intensities when output is 16bit grayscale
        # old: bg='#03D003D003D0'; fg='#042004200420'
        bg=$(printf "%04x\n" $(($newbg-25*$mult)) | tr '[a-f]' '[A-F]') &&
        fg=$(printf "%04x\n" $(($newbg+60*$mult)) | tr '[a-f]' '[A-F]')
        montage -background "#$bg$bg$bg" -fill "#$fg$fg$fg" -label '%t' \
            z.$set.????.$outext -geometry +4+2 ppm:- | ppm2gray - 0,1,0 > varbgm$mult.$set.$outext
        rm z.$set.????.$outext tmp1.$$.$inext
    done
    imlist=$(for set in $slist
        do
            ls varbgm[0-9]*.$set.p?m 2>/dev/null
        done)
    ! match image "$SKIPPARTS" && test "$imlist" &&
        AIexamine -l -z -n "Background_Variation" $imlist
    return 0
}

_register () {
    local slist
    local set
    local tellist
    local tel
    local nlist
    local failedlist
    local fwhm
    local num
    local img
    local fwhm
    local opts
    local filter
    local title
    local yrange
    local retval=0
    local tmpcat=$(mktemp "/tmp/tmp_reg_XXXXXX.src.dat")
    
    # if necessary set AI_TELESCOPE to a matching entry in camera.dat
    #for set in le01 co03; do AI_TELESCOPE=GSO AIsource $set; done
    #AI_TELESCOPE=GSO
    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" && return
    echo "# Source extraction and registration ..."

    if [ "$OVERWRITE" ] && ! match proc "$SKIPPARTS"
    then
        echo "# deleting previous results of" $slist
        _remove -x register
        test $? -ne 0 && return 255
    fi
    
    ! match proc "$SKIPPARTS" && for set in $slist
    do
        # TODO: check if all images have been processed
        # make first guess of fwhm
        num=$(AIsetinfo -b $set | head -1 | awk '{printf("%s", $8)}')
        img=$(AIimlist -q | awk -v n=$num '{if($2==n)print $3}')
        test -z "$img" &&
            echo "ERROR: unable to find calibrated image for nref=$num." &&
            return 255
        AI_MAGZERO=25 AIsource -q -g -o $tmpcat -dbc 0.1 $img
        fwhm=$(sexselect $tmpcat | kappasigma - 6 | awk '{printf("%.1f", $1)}')
        echo "#" AIsource -f $fwhm $set
        
        # extract sources
        AIsource -f $fwhm $set
        if [ $? -eq 0 ]
        then
            # remove failed registrations (dmag <= -2)
            nlist=$(AIimlist -n $set)
            test -s reg.dat && for num in $nlist
            do
                test "$(grep "^$num " reg.dat | awk '{if($10>-2) print "ok"}')" && continue
                rm -f measure/$num.src.head
                sed -i '/^'$num' /d' reg.dat
            done

            # run AIregister
            # rewrite AIregister using: type rvm | (head -1 ; dd of=/dev/null)
            echo "#" AIregister $AO_REGIS $set
            AIregister $AO_REGIS $set | tee -a reg.dat
            test ${PIPESTATUS[0]} -ne 0 && retval=255
            test "$AI_DEBUG" && echo "DEBUG: AI_VERSION=$AI_VERSION retval=$retval"

            # find images where registration failed, e.g. due to large center offset
            # and try registration using relaxed constraints on allowed offsets
            failedlist=""
            for num in $nlist
            do
                test "$(grep "^$num " reg.dat | awk '{if($10>-2) print "ok"}')" && continue
                rm -f measure/$num.src.head
                sed -i '/^'$num' /d' reg.dat
                failedlist="$failedlist $num"
            done
            if [ "$failedlist" ]
            then
                echo "WARNING: registration failed on $(echo $failedlist | wc -w) images, trying again ..."
                opts="-p -q"
                test -z "$AO_REGIS" && opts="-m 1.0 -p -q"
                echo "# AIregister $opts $set \"\" 0.06" >&2
                AIregister $opts $set "" 0.06 | tee -a reg.dat
                test ${PIPESTATUS[0]} -ne 0 && retval=255
            fi
        else
            retval=255
        fi
        rm -f $tmpcat
    done
    
    # show diagnostic plots
    tellist=$(AIsetinfo -b -o | grep -v "^#" | awk '{printf("%s\n", tolower($11))}' | sort -u)
    ! match plot "$SKIPPARTS" && for tel in $tellist
    do
        nlist=""
        for set in $(AIsetinfo -b -o | grep -v "^#" | \
            awk -v t=$tel '{if(tolower($11)==t){print $2}}')
        do
            echo $slist | grep -qw $set || continue
            nlist="$nlist $(AIimlist -x -q -n $set)"
        done
        test -z "$(echo $nlist)" && continue
        filter=""
        for num in $nlist
        do
            test "$filter" && filter="$filter|"
            filter="${filter}^$num"
        done
        title="$tel: FWHM in pixel"
        grep -wE "$filter" reg.dat | AIplot -o $AI_TMPDIR/x.$tel.fwhm.png -t "$title" -p - 1 7
        # mag difference (lower values = fainter than average)
        title="$tel: Mag difference to reference image"
        yrange=$(grep -wE "$filter" reg.dat | minmax - 10 | awk '{l=$1; h=$2
            if (l>-0.09) l=-0.1
            if (h<0.09) h=0.1
            m=(h-l)/20
            printf("%.2f:%.2f", l-m, h+m)}')
        grep -wE "$filter" reg.dat | \
            AIplot -o $AI_TMPDIR/x.$tel.dmag.png -t "$title" -p - 1 10 "" "" "[][$yrange]"
    done
    return $retval
}

_badpix () {
    # create bad-pixel-mask (per telescope)
    # note: at least 5 raw images must be present per set
    local use_all_images    # not implemented yet
    local use_all_sets      # if set then combine with masks of all sets of the telescope
    local i
    for i in 1 2
    do
        test "$1" == "-a" && use_all_sets=1 && shift 1
    done
    local high=${1:-""}
    local low=${2:-""}
    local msg
    local tellist
    local tel
    local slist
    local telsetlist
    local camtype
    local highlist
    local lowlist
    local difflist
    local badlist
    local badpix    # dayly badpix image
    local badpixall    # combined image used by AIccd (applying interpolation)
    local nref
    local opts
    local xhigh
    local xlow
    local s
    local f
    local n
    
    AI_EXCLUDE=""
    if [ "$setname" ]
    then
        for s in $setname
        do
            n=$(get_nraw -q $s | wc -l)
            test $n -lt 5 &&
                echo "ERROR: set $s has only $n images (min is 5)." >&2 &&
                return 255
        done
        slist=$setname
    else
        # use 4 best suited image sets (for each tel)
        tellist=$(AIsetinfo -b -o | grep -v "^#" | awk '{printf("%s\n", $11)}' | sort -u)
        for tel in $tellist
        do
            telsetlist=$(AIsetinfo -b -o | grep -v "^#" | awk -v t=$tel '{
                if (tolower($11)==tolower(t)) {print $2}}')
            xlist=$(for s in $telsetlist
            do
                n=$(get_nraw -q $s | wc -l)
                test $n -gt 4 && echo $s $n
            done | \
                sort -nr -k2,2 | head -4 | cut -d ' ' -f1)
            
            test "$xlist" && slist=$(echo $slist $xlist)
            test -z "$xlist" &&
                echo "WARNING: no suitable image sets to create badpixel mask for $tel." >&2
        done
    fi
    test -z "$slist" && return
    tellist=$(for s in $slist; do get_telescope $s; done | sort -u)
    msg="# Creating badpixel mask(s) for $tellist ..."
    echo $msg && msg=""

    if [ "$OVERWRITE" ] && ! match proc "$SKIPPARTS"
    then
        setname=$slist  # note: setname is used by remove command
        if [ "$use_all_sets" ]
        then
            # remove badpix result files for all sets related to tellist
            setname=$(for tel in $tellist
            do
                AIsetinfo -b -o | grep -v "^#" | awk -v t=$tel '{
                    if (tolower($11)==tolower(t)) {print $2}}'
            done | sort -u)
            
        fi
        echo "# deleting previous results of" $setname
        _remove -x badpix
        test $? -ne 0 && return 255
    fi

    ! match proc "$SKIPPARTS" && for tel in $tellist
    do
        badpix="badpix.${tel,,}.$day.png"
        badpixall="badpix.${tel,,}.png"
        camtype=$(get_param camera.dat ctype $tel)
        #test "$camtype" == "DSLR" && badpix="badpixall.${tel,,}.png" # for use by AIccd/dcraw
        test -e $badpix && rm $badpix
        if [ -e $badpixall ]
        then
            test ! -e ${badpixall/.png/.old.png} && mv $badpixall ${badpixall/.png/.old.png}
            # echo "WARNING: reusing existing $badpixall" && continue
        fi
        telsetlist=$(AIsetinfo -b -o | grep -v "^#" | awk -v t=$tel -v sl="$(echo $slist)" '{
            if (tolower($11)==tolower(t) && sl~$2) {print $2}}')
        test -z "$telsetlist" && continue
        echo "# Creating badpixel mask for $tel using" $telsetlist "..."
        opts="-n 12"    # limit to 12 frames per set
        test "$camtype" != "CCD" && test "$camtype" != "CMOS" && opts="$opts -s"   # do subtract bayered background 
        for set in $telsetlist
        do
            #test "$msg" && echo $msg && msg=""
            test "$AI_DEBUG" && echo "# $set: tel=$tel camtype=$camtype" >&2
            if [ -z "$use_all_images" ]
            then
                nref=$(AIsetinfo -o $set | awk '{printf("%s", $4)}')
                xhigh=$high
                n=0
                test -s reg.dat && n=$(grep -v "^#" reg.dat | \
                    awk -v ref=$nref '{if($2==ref){print $0}}' | wc -l)
                test -z "$xhigh" && test $n -eq 0 &&
                    echo "# using default high=20" >&2 &&
                    xhigh=20
                test -z "$xhigh" && test $n -lt 5 &&
                    echo "WARNING: too few registered images ($n<5), skipping set $set" >&2 &&
                    continue
                test -z "$xhigh" &&
                    xhigh=$(grep -v "^#" reg.dat | awk -v ref=$nref '{if($2==ref){print $0}}' | \
                        median - 7 | awk '{x=13;
                            if($1<2) x=16; if($1<1.8) x=20; if($1<1.6) x=30}END{print x}')
                xlow=$low
                test -z "$xlow" && xlow=10
                echo "# running AIfindbad $opts $set \"\" $xhigh $xlow"
                AIfindbad $opts $set "" $xhigh $xlow
            else
                # use all images of given sets in one AIfindbad command
                # TODO: not implemented yet
                xhigh=$high; test -z "$xhigh" && xhigh=20
                xlow=$low;   test -z "$xlow" && xlow=10
                echo "# running AIfindbad $opts $set \"\" $xhigh $xlow"
                AIfindbad -a $opts "" "" $xhigh $xlow
            fi
            test $? -ne 0 && return 255
        done
        
        # TODO: deal with different binnings

        # combining masks        
        # if requested use all sets processed for given telescope
        test "$use_all_sets" &&
            telsetlist=$(AIsetinfo -b -o | grep -v "^#" | awk -v t=$tel '{
                if (tolower($11)==tolower(t)) {print $2}}' | sort -u)
        highlist=$(for s in $telsetlist; do ls bad.$s.high.png 2>/dev/null; done)
        lowlist=$(for  s in $telsetlist; do ls bad.$s.low.png  2>/dev/null ; done)
        test -z "$highlist" && continue
        echo "#" $tel":" combining masks from $(echo "$highlist" | cut -d '.' -f2)
        n=$(echo $highlist | wc -w)
        #convert $highlist -evaluate-sequence max bad.high.${tel,,}.png
        #convert $lowlist  -evaluate-sequence max bad.low.${tel,,}.png
        vips bandrank "$highlist" bad.high.${tel,,}.png --index $((n-1))
        vips bandrank "$lowlist"  bad.low.${tel,,}.png  --index $((n-1))
        badlist="bad.high.${tel,,}.png bad.low.${tel,,}.png"

        # adding masks provided manually
        test -e bad.columns.${tel,,}.png && badlist="bad.columns.${tel,,}.png $badlist"
        test -e bad.dust.${tel,,}.png    && badlist="bad.dust.${tel,,}.png    $badlist"
        test -e bad.other.${tel,,}.png   && badlist="bad.other.${tel,,}.png   $badlist"
        #test -e ${badpix/.png/.old.png}  && badlist="${badpix/.png/.old.png}  $badlist"
        n=$(echo $badlist | wc -w)
        #convert $badlist  -evaluate-sequence max badpix.${tel,,}.png
        vips bandrank "$badlist" $badpix --index $((n-1))
        for f in $badlist $badpix
        do
            echo $tel/$f
            convert $f pbm:- | pgmhist | grep 255
        done
        
        # combine with badpix images of previous days
        badlist=$(ls badpix.${tel,,}.[0-9]*.png)
        n=$(echo $badlist | wc -w)
        if [ $n -gt 1 ]
        then
            echo "# combining $n daily badpix images to create $badpixall ..."
        else
            echo "# creating $badpixall ..."
        fi
        vips bandrank "$badlist" $badpixall --index $((n-1))
    done

    msg="# Displaying badpixel masks and check images ..."
    ! match image "$SKIPPARTS" && for tel in $tellist
    do
        badpix="badpix.${tel,,}.$day.png"
        badpixall="badpix.${tel,,}.png"
        camtype=$(get_param camera.dat ctype $tel)
        #test "$camtype" == "DSLR" && badpix="badpixall.${tel,,}.png" # for use by AIccd
        telsetlist=$(AIsetinfo -b -o | grep -v "^#" | awk -v t=$tel -v sl="$(echo $slist)" '{
            if (tolower($11)==tolower(t) && sl~$2) {print $2}}')
        test -z "$telsetlist" && continue
        test ! -e $badpix && continue
        test "$msg" && echo $msg && msg=""
        difflist=$(for s in $telsetlist; do ls bad.$s.diff.pgm 2>/dev/null; done)
        # identify clusters of bad pixels
        # TODO: replace command to avoid imagemagick (possibly running out of memory)
        convert $badpixall -define convolve:scale=0.00392 -morphology Convolve Disk:3.5 \
            pgm:- | pnmccdred2 -a -2 - - | convert - -morphology Dilate Disk:5 bad.${tel,,}.clust.png
        AIexamine -n $tel $badpix $badpixall bad.${tel,,}.clust.png $difflist
    done
}


_stack () {
    # GUI program options may be passed by env variable AO_STACK
    local stackopts
    local retval=0
    local tellist
    local tel
    local slist
    local set
    local bopts
    local img
    local ext
    local str
    local target
    local filter
    local texp
    local nexp
    local bgcol
    local bgg
    local rlim
    local fwhm
    local bgmesh
    local object
    local telid
    local bin
    local bgoff
    local imlist
    local sopt
    local x
    
    # normal stacking for all sets (default: resampling_type lanczos3)
    # DSLR with fwhm < 2.8pix use: -r bilinear
    # CCD  with fwhm < 2.5pix use: -r bilinear
    # TODO: exclude some images in case AIregister has failed, e.g. if nmag=0
    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" && return
    msg="# Stacking images ..."

    if [ "$OVERWRITE" ] && ! match proc "$SKIPPARTS"
    then
        echo "# deleting previous results of" $slist
        _remove -x stack
        test $? -ne 0 && return 255
    fi
    
    ! match proc "$SKIPPARTS" && for set in $slist
    do
        test $retval -ne 0 && continue
        test "$msg" && echo $msg && echo "# AI_EXCLUDE=$AI_EXCLUDE" && msg=""
        # TODO: improve checking of existing stack, improve warning message
        test -e $set.head &&
            echo "WARNING: output header file $set.head already exists" &&
            continue

        tel=$(get_telescope $set | awk '{printf("%s\n", tolower($0))}')
        test -z "$tel" &&
            echo "WARNING: unknown telid for set $set, skipping set." &&
            continue
        bopts=""
        test -e badpix.$set.png &&
            bopts="$bopts -bad badpix.$set.png" &&
            echo "# using badpix.$set.png"
        # old program version might use badpix.$tel.png
        test $(vcomp $VERSION 1.4.999) -eq 2 && test -z "$bopts" &&
            test -e badpix.$tel.png &&
            bopts="$bopts -bad badpix.$tel.png" &&
            echo "# using badpix.$tel.png"
        stackopts="$AO_STACK"
        echo "# running: AIstack" $stackopts $bopts $set
        AIstack $stackopts $bopts $set
        test $? -ne 0 && retval=255
        test "$stackopts" && set_header $set.head AO_STACK="$stackopts"
        # note: as of airtools-cli version 1.3 we always add pedestal to
        # calibrated light images (option "-a 100" in AIccd)
        set_header $set.head AI_BGOFF=100
    done


    # statistics (image quality)
    echo "# Stack properties:"
    echo "#set   object   telid  exp   n bin  bgg  bgoff fwhm/pix  rms  site"
    for set in $slist
    do
        stackproperties -u -f $set || return 255
    done

    # evaluate fwhm across full image
    msg="# Evaluate FWHM across image"
    ! (match proc "$SKIPPARTS" && match plot "$SKIPPARTS") && for set in $slist
    do
        if [ -f $set.src.dat ]
        then
            if [ ! -f $set.fwhm.png ] || [ $set.src.dat -nt $set.fwhm.png ]
            then
                test "$msg" && echo "$msg" >&2 && msg=""
                printf "# $set " >&2
                AIfwhm -n -o $set.fwhm.png $set.src.dat
            fi
        fi
    done
    x=$(for set in $slist
        do
            test -f $set.fwhm.png && echo $set.fwhm.png
        done)
    ! match plot "$SKIPPARTS" &&
        test "$x" && AIdisplay $x &

    # display stacked images
    imlist=$(for set in $slist
        do
            ext="pgm"; test -f $set.ppm && ext="ppm"
            test -f $set.$ext && echo $set.$ext
        done)
    if ! match image "$SKIPPARTS"
    then
        if [ "$imlist" ]
        then
            echo "# Loading stacked images ..."
            AIexamine $imlist
        fi
    fi

    return $retval
}

_astrometry () {
    # algorithm:
    # 1. check for image center coordinates
    # 2. run solve-field using center coordinates if available
    #     - if not succesful and image coordinates are unknown, try to get
    #       comet ephemerides and run solve-field again
    # 3. run AIwcs
    #     - if solve-field failed and image coordinates are known, try AIwcs
    #       using position angle from AI_NPA or from camera.dat
    #     - if solve-field has finished successfully improve solution using
    #       AIwcs
    #     - if AIwcs failes retry using limited number of source detections
    # notes about optional env variables to control program
    #   AO_AMASK - source mask, either name of a ds9 region file or
    #       a number representing max radius from image center to use
    #   AO_ACOOR - image center coordinates (RA,DEC) overwriting the
    #       values determined by imcoord automatically
    #       if set to "unknown" then do full sky search
    #       if set to "skipfirst" then skip solve_field and run AIwcs only
    local slist
    local set
    local ststack
    local w
    local h
    local imcoord
    local ra
    local dec
    local do_solve_field
    local pixscale
    local binning
    local fwhm
    local fmax
    local opts
    local north
    local catalog
    local maglim
    local thres
    local maxoff
    local ncat
    local aratio
    local x
    local str
    local msg
    local cpulim
    local fov
    local radius
    local amask
    local rlim
    local crossrad
    local sstart
    local stime
    local failed
    local wcslog=wcs/wcscalib.log
    local errval
    local retval=0
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpfits=$(mktemp "$tdir/tmp_im_XXXXXX.fits")
    local tmpcat=$(mktemp "$tdir/tmp_scat_XXXXXX.fits")
    local tmpxy=$(mktemp "$tdir/tmp_xy_XXXXXX.fits")
    local tmpmask=$(mktemp "$tdir/tmp_mask_XXXXXX.reg")
    local tmpcancel=$(mktemp "$tdir/tmp_astrometry_XXXXXX.cancel")
    
    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" && return
    msg="# Astrometric calibration ..."

    if [ "$OVERWRITE" ] && ! match proc "$SKIPPARTS"
    then
        echo "# deleting previous results of" $slist
        _remove -x wcs
        test $? -ne 0 && return 255
    fi
    
    ! match proc "$SKIPPARTS" && for set in $slist
    do
        echo "$msg" && msg=""
        echo "set=$set"
        test ! -e $set.head &&
            echo "WARNING: missing header file $set.head" && continue
        ststack=""
        test -f $set.pgm && ststack=$set.pgm
        test -f $set.ppm && ststack=$set.ppm
        if [ "$ststack" ]
        then
            set - $(imsize $ststack)
            w=$1; h=$2
        else
            set - $(get_header -s $set.head NAXIS1,NAXIS2)
            w=$1; h=$2
        fi
        test -z "$ststack" && test "$AO_AMASK" && is_number $AO_AMASK &&
            echo "WARNING: missing stacked image (required by adopting AO_MASK)" && continue
        # skip processing if wcs header exists and there is no change in AO_AMASK
        amask=$(get_header -q $set.head AO_AMASK)
        test -f $set.wcs.head &&
            test "$AO_AMASK" == "$amask" &&
            echo "WARNING: WCS header file already exists." && continue
        test -d wcs || mkdir wcs
        echo -e "\nset=$set" >> $wcslog
        test "$AO_AMASK" && echo "# AO_AMASK=$AO_AMASK" | tee -a $wcslog
        
        # determine pixscale
        pixscale=""
        binning="$AO_ABINN"
        test -z "$binning" && binning=$(get_header -q $set.head BINNING)
        test -z "$binning" && binning=$(get_header -q $set.head XBINNING)
        test -z "$binning" && binning=1
        pixscale=$(get_param camera.dat pixscale $set | \
            awk -v b=$binning '{print $1*b}')
        test -z "$pixscale" &&
            echo "ERROR: unknown pixscale in $set" && continue
        # FOV diameter in degrees
        fov=$(echo $w $h | awk -v p=$pixscale '{
            d=sqrt($1*$1+$2*$2)*p/3600
            if (d>1.501) {
                printf("%.1f", d)
            } else {
                printf("%.2f", d)
            }}')

        # check for image center coordinates
        do_solve_field=1
        north=""
        imcoord=$(imcoord $set 2>/dev/null)
        test "$AO_ACOOR" && case $AO_ACOOR in
            unknown)    imcoord="";;
            skipfirst)  do_solve_field="";;
            *)          imcoord=${AO_ACOOR/,/ };;
        esac
        # workaraoud for missing coordinates in case of image acquisition using gacam
        test "$imcoord" == "00:00:00.0 +00:00:00" &&
            test "$(get_header $set.head AI_SITE)" == "Weimar" &&
            imcoord=""

        # check for fwhm
        fwhm=$(get_header $set.head AI_FWHM)
        test -z "$fwhm" && return 255
        
        # run solve-field if necessary
        errval=""
        opts="--no-remove-lines"
        if [ "$do_solve_field" ]
        then
            sstart=$(date +"%s")
            ! type -p solve-field > /dev/null &&
                error "program solve-field (astrometry.net) is not installed."
            
            # using approx center coordinates (sexagesimal) in solve-field
            if [ "$(echo $imcoord)" ]
            then
                radius=$(echo $fov | awk '{print 0.3+1*$1}')
                cpulim=60
                set - $imcoord
                opts="$opts --ra $1 --dec $2 --radius $radius"
            else
                cpulim=120
            fi
            # range of pixel scales to check (+-15%)
            opts="$opts "$(echo $pixscale | awk -v t=15 '{
                x=1+t/100
                printf("-L %.2f -H %.2f -u app", $1/x-0.02, $1*x+0.02)}')
            # image dimension and source catalog columns to use
            opts="$opts -w $w -e $h -X XWIN_IMAGE -Y YWIN_IMAGE -s MAG_AUTO -a"

            # select sources from image
            #   determine max fwhm (exclude diffuse sources)
            fmax=$(printf "%.2f" $(echo "1+1.5*$fwhm+3*x" | bc -l))
            #   operate on green image channel
            test ! -e $set.src.dat && AIsource -q $ststack
            x=""
            test $(listhead $set.src.dat | grep LDAC_OBJECTS | wc -l) -eq 3 && x="-2"
            rlim=""
            test "$AO_AMASK" && is_number "$AO_AMASK" && rlim=$AO_AMASK
            #   select bright sources
            echo "sexselect -f $x -fm $fmax $set.src.dat \"\" 0.01 \"$rlim\" "" "" 99" >&2
            sexselect -f $x -fm $fmax $set.src.dat "" 0.01 "$rlim" "" "" 99 > $tmpcat
            stilts tcopy ifmt=fits ofmt=fits-basic in=$tmpcat"#2" out=$tmpxy
            nsrc=$(get_header $tmpxy NAXIS2)
            str="merrlim=0.01, fwhm<$fmax"
            if [ $nsrc -lt 200 ]
            then
                # relax detections
                str="merrlim=0.02, fwhm<$fmax"
                sexselect -f $x -fm $fmax $set.src.dat "" 0.02 "$rlim" "" "" 99 > $tmpcat
                stilts tcopy ifmt=fits ofmt=fits-basic in=$tmpcat"#2" out=$tmpxy
                nsrc=$(get_header $tmpxy NAXIS2)
            fi
            if [ $nsrc -lt 200 ]
            then
                # relax detections
                str="merrlim=0.05, fwhm<$fmax"
                sexselect -f $x -fm $fmax $set.src.dat "" 0.05 "$rlim" "" "" 99 > $tmpcat
                stilts tcopy ifmt=fits ofmt=fits-basic in=$tmpcat"#2" out=$tmpxy
                nsrc=$(get_header $tmpxy NAXIS2)
            fi
            test "$rlim" && str="$str, limited to r<$rlim pix"
            echo "# $nsrc sources ($str)"

            # run solve-field
            tmpsolve="tmp_${set}_solve_$RANDOM"
            echo "# running: solve-field -O -p -l $cpulim $opts $tmpxy" | tee -a $wcslog
            sleep 1
            rm -f $tmpcancel
            solve-field -O -C $tmpcancel -o $tmpsolve -p -l $cpulim $opts $tmpxy >> $wcslog
            errval=$?
            test $errval -ne 0 &&
                echo "# solve-field returns with errval=$errval" >&2
            # solve-field might fail (no solution) but not return an error
            test ! -s $tdir/$tmpsolve.wcs && errval=255
            
            # cancel solve-field process if failed
            test $errval -ne 0 &&
                echo "# first attempt failed" | tee -a $wcslog &&
                touch $tmpcancel
            
            # if required try second time using comet coordinates
            if [ $errval -ne 0 ] && [ -z "$imcoord" ] &&
                get_mpcephem -w $set 2>/dev/null &&
                get_jplcoord -w $set 2>/dev/null
            then
                radius=$(echo $fov | awk '{print 0.5+0.5*$1}')
                cpulim=60
                imcoord=$(imcoord -c $set 2>/dev/null)
                set - $imcoord
                opts="--ra $1 --dec $2 --radius $radius $opts"
                echo "# running: solve-field -O -p -l $cpulim $opts $tmpxy" | tee -a $wcslog
                sleep 1
                return 255
                rm -f $tmpcancel
                solve-field -O -C $tmpcancel -o $tmpsolve -p -l $cpulim $opts $tmpxy >> $wcslog   
                errval=$?
                # solve-field might fail (no solution) but not return an error
                test ! -s $tdir/$tmpsolve.wcs && errval=255
                test $errval -ne 0 &&
                    echo "# second attempt failed" | tee -a $wcslog
            fi
            
            # get ra dec north from solve-field solution
            if [ $errval -eq 0 ] && [ -s $tdir/$tmpsolve.wcs ]
            then
                wcsinfo $tdir/$tmpsolve.wcs > x.wcsinfo
                set - $(grep -wE "^orientation|^ra_center_hms|^dec_center_dms" x.wcsinfo)
                north=$(echo $2 | awk '{print -1*$1}')
                imcoord="$4 $6"
                stime=$(date +"%s" | awk -v s=$sstart '{printf("%d", $1-s)}')
                echo "# solve-field finished in ${stime}s, center: $imcoord"
                #set_header $set.head RA="$4" DEC="$6"
                mv $tdir/$tmpsolve.wcs wcs/$set.an.wcs &&
                    (cd $tdir; rm -f $tmpsolve.* ${tmpsolve}-indx.xyls) &&
                    rm x.wcsinfo
            else
                touch $tmpcancel
            fi
        fi
        test "$errval" && test $errval -ne 0 &&
            failed="$failed $set" &&
            echo "ERROR: solve-field failed for $set" >&2 &&
            retval=255 && continue
        

        # choose sensible parameters for AIwcs
        # determine density of image sources
        maglim=""; crossrad=""
        set - $(guess_wcsparam $set) x
        test $# -ne 7 &&
            echo "ERROR: unable to guess AIwcs parameters." >&2 && return 255
        imcoord="$1 $2"
        test "$3" != "-" && north=$3
        test "$4" != "-" && maglim=$4
        test "$5" != "-" && thres=$5
        test "$6" != "-" && crossrad=$6
        
        # choose catalog depending on maglim and fov
        allcats=$(scamp -d | awk '{
            if ($1=="ASTREF_CATALOG") {ok=1} else {if($0!~/^ [ ]*#/){ok=0}}
            if (ok==1) {print tolower($0)}}' | cut -d '#' -f2- | tr ', ' '\n' | \
            grep "[a-z]" | grep -vwE "none|file|or")
        catalog="ucac4"
        echo $allcats | grep -qw gaia-dr1 && catalog="gaia-dr1"
        echo $allcats | grep -qw gaia-dr2 && catalog="gaia-dr2"
        echo $allcats | grep -qw gaia-edr3 && catalog="gaia-edr3"
        test "$maglim" &&
            test $(echo $maglim 14.5 | awk '{if($1<$2) print "true"}') &&
            catalog="ppmx"
        test ${fov%.*} -gt 5 && catalog="ppmx"

        # options for AIwcs
        opts=""
        test "$AO_ABINN" && opts="-b $AO_ABINN"
        test "$imcoord"  && opts="$opts -c $imcoord"
        test "$north"    && opts="$opts -n $north"
        test "$crossrad" && opts="$opts -cr $crossrad"
        # set max position uncertainty (in deg)
        test "$errval" == "0" && maxoff=$(echo $fov | awk '{print 0.1+0.1*$1}')
        test "$errval" != "0" && maxoff=$(echo $fov | awk '{print 0.5+1.2*$1}')
        opts="$opts -o $maxoff"
        if [ "$AO_AMASK" ]
        then
            if [ -e $AO_AMASK ] && is_reg $AO_AMASK
            then
                opts="$opts -m $AO_AMASK"
                set_header $set.head AO_AMASK=$AO_AMASK
            else
                if is_number $AO_AMASK
                then
                    echo $w $h | awk '{printf("center %d %d\n", $1/2, $2/2)}' | \
                        xy2reg $ststack - "" "" $AO_AMASK > $tmpmask
                    opts="$opts -m $tmpmask"
                    set_header $set.head AO_AMASK=$AO_AMASK
                else
                    echo "WARNING: cannot handle AO_AMASK=$AO_AMASK"
                fi
            fi
        fi
                
        # running AIwcs
        echo "# running: AIwcs" $opts "$set $catalog \"$maglim\" $thres" | tee -a $wcslog
        AIwcs $opts $set $catalog "$maglim" $thres >> $wcslog 2>&1
        if [ $? -ne 0 ]
        then
            tail -1 $wcslog
            maglim=$(echo $maglim 16 | awk '{print $1-1.0}')
            echo "# running: AIwcs" $opts "$set $catalog \"$maglim\" $thres" | tee -a $wcslog
            AIwcs $opts $set $catalog "$maglim" $thres >> $wcslog 2>&1
        fi
        test $? -ne 0 && retval=255 &&
            failed="$failed $set" &&
            tail -1 $wcslog
        # TODO: if AIwcs failed check ncat: e.g. get_header -e LDAC_OBJECTS wcs/sa01.ucac-4.dat NAXIS2
        #   if it is > 3*nimg limit to 2*nimg, otherwise limit to 40% of ncat
        #   unfortunately the catalog file does not fill the mag column (it is always 0)
    done
    test $retval -ne 0 &&
        echo "ERROR: wcs calibration failed for $failed"
    
    # display results parsing $set.wcs.head
    msg="# Summary for astrometry:
# set  xrms    yrms     nimg  ncat nmatch nhigh  pscale north catalog   mlim"
    x=""
    for set in $slist
    do
        test -f $set.wcs.head || continue
        test "$msg" && echo "$msg" && msg=""
        north=$(get_wcsrot $set)
        pixscale=$(get_wcspscale $set)
        echo $(get_header -q -s $set.wcs.head ASTRRMS1,ASTRRMS2,NIMG,NCAT,NMATCH,NHIGH,AREFCAT,AREFMLIM) | \
            awk -v s=$set -v p=$pixscale -v n=$north '{
                printf("%s:  %.3f\"  %.3f\"", s, $1*3600, $2*3600)
                if(NF>=6) {
                    printf("  %5d %5d  %5d %5d", $3, $4, $5, $6)
                    fmt="%6.3f %6.1f"; if (p>=10) fmt="%5.2f  %6.1f"
                    printf(fmt, p, n)
                    if(NF==8) printf("  %-9s %4.1f\n", $7, $8); else printf("  %-9s\n", $7)
                } else {
                    printf("\n")
                }}'
        x="$x $(echo $(ls -1 wcs/$set.*.png))"
    done
    ! match plot "$SKIPPARTS" &&
        test "$x" && AIdisplay $x &
    test $retval -eq 0 && rm -f $tmpfits $tmpcat $tmpxy $tmpmask
    # rm -f $tmpcancel
    return $retval
}

_costack () {
    local stackopt
    local slist
    local set
    local msg
    local ext
    local params
    local val
    local oxy
    local omove
    local object
    local retval=0
    local tmplog=$(mktemp /tmp/tmp_ephem_XXXXXX.log)

    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" && return
    msg="# Stacking on comet ..."

    if [ "$OVERWRITE" ] && ! match proc "$SKIPPARTS"
    then
        echo "# deleting previous results of" $slist
        _remove -x costack
        test $? -ne 0 && return 255
    fi
    
    ! match proc "$SKIPPARTS" && for set in $slist
    do
        test ! -f $set.head && continue
        ext=""
        test -f $set.pgm && ext="pgm"; test -f $set.ppm && ext="ppm"
        test -z "$ext" && continue
        test -f ${set}_m.$ext && continue
        test "$msg" && echo $msg && echo "# AI_EXCLUDE=$AI_EXCLUDE" && msg=""
        
        # get ephemerides
        set - $(get_header -q -s $set.head AI_CORA,AI_CODEC,AI_OMOVE) xx
        if [ $# -eq 4 ]
        then
            echo "# $set: reusing motion vector (AI_OMOVE)"
        else
            echo "# $set: get ephemerides from MPC"
            object=$(get_header -q $set.head OBJECT)
            get_mpcephem -w $set 2>$tmplog
            if [ $? -ne 0 ]
            then
                grep ERROR $tmplog ||
                    echo "WARNING: skipping $set: object" $object "is not a known comet."
                continue
            fi
            # try to obtain (potentially) more precise coordinates from JPL
            echo "# $set: try to get coordinates from JPL"
            get_jplcoord -w $set 2>$tmplog
            if [ $? -ne 0 ]
            then
                grep ERROR $tmplog ||
                echo "WARNING: object" $object "is not known by JPL."
            fi
            cat /dev/null > $tmplog
        fi
        
        # check for astrometric calibration
        test ! -f $set.wcs.head &&
            echo "ERROR: missing astrometric calibration for $set" && retval=255 && continue

        params=""
        val=$(get_header -q $set.head BADPIX); test "$val" && params="-bad $val"
        val=$(get_header $set.head RESAMPT1); test "$val" && params="$params -r $val"
        set - $(get_header -q -s $set.head AI_CORA,AI_CODEC,AI_OMOVE) xx
        test $# -ne 4 &&
            echo "# skipping $set (missing comet header keywords)" >&2 && continue
        oxy=$(echo $set $1 $2 | rade2xy - $set.wcs.head | awk '{printf("%.0f,%.0f", $2, $3)}')
        omove=$3
        stackopt=$(get_header -q $set.head AO_STACK)
        echo "# running: AIstack" $stackopt $params -o \"_m\" -c $set.$ext -m $omove@$oxy $set
        AIstack $stackopt $params -o "_m" -c $set.$ext -m $omove@$oxy $set
        test $? -ne 0 && retval=255 && continue
        
        # setting some header keywords
        set_header -s ${set}_m.head OBJECT=$(get_header -q $set.head OBJECT)
        set_header $set.head AI_COMST=${set}_m.$ext
    done

    # display stacked images
    imlist=$(for set in $slist
        do
            ext="pgm"; test -f ${set}_m.ppm && ext="ppm"
            test -f ${set}_m.$ext && echo ${set}_m.$ext
        done)
    if ! match image "$SKIPPARTS"
    then
        if [ "$imlist" ]
        then
            echo "# Loading stacked images ..."
            AIexamine $imlist
        fi
    fi
    return $retval
}


#------------------------------------
#   comet extraction and photometry
#------------------------------------

_load_stacks () {
    local slist
    local set
    local msg
    local ststack
    local costack
    local ext
    local idststack
    local idcostack
    local imlist

    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" && return
    msg="# Launch SAOImage AIRTOOLS ..."
    ! match image "$SKIPPARTS" && for set in $slist
    do
        #test $retval -ne 0 && continue
        #echo "$msg"
        msg=""
        ststack=""
        ext=""
        test -f $set.pgm && ststack=$set.pgm && ext="pgm"
        test -f $set.ppm && ststack=$set.ppm && ext="ppm"
        test -z "$ststack" &&
            error "missing star stack for set $set"
        test ! -e $set.head &&
            error "missing header file $set.head"
        #test ! -f $set.wcs.head &&
        #    echo "WARNING: missing WCS header file $set.wcs.head"
        costack=$(get_header $set.head AI_COMST)
        #test -z "$costack" &&
        #    echo "WARNING: missing comet stack for set $set"
        test "$costack" && test ! -f $costack &&
            echo "WARNING: missing comet stack $costack for set $set"
        
        # check for bg subtracted images
        test -f ${ststack%.*}.bgs.$ext &&
            ststack=${ststack%.*}.bgs.$ext
        test "$costack" && test -f ${costack%.*}.bgs.$ext &&
            costack=${costack%.*}.bgs.$ext
        # TODO: replace corrupted header files
        test ! -e ${ststack%.*}".head" &&
            ln -s $set.head ${ststack%.*}".head"
        test "$costack" && test ! -e ${costack%.*}".head" &&
            ln -s $set.head ${costack%.*}".head"

        # check for running SAOImage AIRTOOLS
        xpaaccess -c -t "2,2" AIRTOOLS > /dev/null
        if [ $? -eq 0 ]
        then
            imlist="$ststack $costack"
        else
            test -z "$(get_frameno -s $ststack)" &&
                imlist="$imlist $ststack"            
            test "$costack" && test -z "$(get_frameno $costack)" &&
                imlist="$imlist $costack"
        fi
        test "$imlist" &&
            echo "# loading $imlist ..." &&
            AIexamine $imlist
    done < set.dat
    return 0
}

_ds9cmd () {
    # note: all tasks related to comet photometry must start with set name or image
    #   image - bggradient
    #   set   - psfextract, cometextract, manualdata, photcal
    local cmd=$1
    local set=$2
    local msg="# ds9cmd"
    local ststack
    local fid
    local i
    local arg
    
    # quote arguments with special characters
    for i in $(seq 1 $#)
    do
        arg=${!i}
        if [ "$arg" ] && [ "${arg/ /}" == "$arg" ] && [ "${arg/-/}" == "$arg" ]
        then
            msg="$msg $arg"
        else
            msg="$msg \"$arg\""
        fi
    done
    echo "$msg"
    
    # determine name of star stack
    test -f "$set" && ststack=$set
    if [ -z "$ststack" ]
    then
        ! is_setname "$set" &&
            error "unknown image set $set"
        test -f $set.bgs.ppm && ststack=$set.bgs.ppm
        test -z "$ststack" && test -f $set.bgs.pgm && ststack=$set.bgs.pgm
        test -z "$ststack" && test -f $set.ppm && ststack=$set.ppm
        test -z "$ststack" && test -f $set.pgm && ststack=$set.pgm
        test -z "$ststack" &&
            error "missing star stack for set $set"
        test ! -e $set.head &&
            error "missing header file $set.head"
    fi
    # check for running SAOImage AIRTOOLS
    if [ "$cmd" != "photcal" ] && [ "$cmd" != "manualdata" ]
    then
        xpaaccess -c -t "2,2" AIRTOOLS > /dev/null
        if [ $? -eq 0 ]
        then
            # load star stack
            echo "# loading $ststack ..."
            AIexamine $ststack
        fi
    fi

    if [ "$OVERWRITE" ]
    then
        ds9cmd -o "$@"
    else
        ds9cmd "$@"
    fi
    return $?
}


#-------------------------
#   miscellaneous tools
#-------------------------
__load_images () {
    # library function called by _imexa_calib and _imexa_raw
    # loading calibrated or raw images in SAOImage AIRTOOLS window
    # pass list of image numbers as arguments
    local raw   # if set use raw images instead of calibrated images
    test "$1" == "-r" && raw=1 && shift 1
    local slist
    local nlist
    local opts="-q" # AIimlist option
    local set
    local msg
    local num
    local imlist
    local rfile
    local n
    local retval=0
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpfiles=$tdir/ds9.AIRTOOLS.tmpfiles.dat  # list of file names to remove
                                                    # when closing ds9 AIRTOOLS
    local tmp1=$(mktemp "$tdir/tmp1_$$_XXXXXX.dat")
    local tmplinks=$(mktemp "$tdir/tmp_links_XXXXXX.dat")

    # checking args
    test $# -eq 0 &&
        echo "ERROR: missing arguments" >&2 &&
        rm -f $tmp1 && return 255
    echo $@ | grep -q "[a-z]" && slist=$@
    test -z "$slist" && test -z "$(echo $@ | tr -d '[0-9 ,-]')" &&
        nlist=$(mknlist $@ | sort -u)
    test -z "$slist" && test -z "$nlist" && test "$@" &&
        echo "ERROR: unsupported (mixed) arguments" >&2 &&
        rm -f $tmp1 && return 255
    test "$slist" && test ! -s set.dat &&
        echo "ERROR: missing set.dat" >&2 &&
        rm -f $tmp1 && return 255

    test "$AI_DEBUG" && echo "# slist=$slist" >&2 && echo "# nlist=$nlist" >&2
    
    # searching images
    msg="# Searching images ..."
    test "$slist" && for set in $slist
    do
        ! is_setname $slist &&
            echo "WARNING: unknown set $set" >&2 && continue
        test "$msg" && echo $msg && msg=""
        test -z "$raw" && AIimlist -f $opts $set >> $tmp1
        test    "$raw" && AIimlist -f $opts $set "" raw >> $tmp1
    done
    test "$nlist" && for num in $nlist
    do
        if [ -z "$raw" ]
        then
            test -s $AI_TMPDIR/$num.fits &&
                echo $AI_TMPDIR/$num.fits && continue
            test -s $AI_TMPDIR/$num.ppm &&
                echo $AI_TMPDIR/$num.ppm && continue
            test -s $AI_TMPDIR/$num.pgm &&
                echo $AI_TMPDIR/$num.pgm
        else
            rfile=$(get_rawfile $num 2>&1)
            (test $? -ne 0 || test -z "$rfile") && continue
            # create link to the raw image
            test -L ${num}_$(basename $rfile) && test ! -e ${num}_$(basename $rfile) &&
                rm ${num}_$(basename $rfile)
            test ! -e ${num}_$(basename $rfile) &&
                ln -s $rfile ${num}_$(basename $rfile) &&
                echo ${num}_$(basename $rfile) >> $tmplinks
            echo ${num}_$(basename $rfile)
        fi
    done > $tmp1
    ! test -s $tmp1 && echo "WARNING: no images found" >&2 &&
        rm -f $tmp1 && return
    
    # extract number and filename, sort unique entries
    n=$(cat $tmp1 | wc -l)
    imlist=$(cat $tmp1 | tr '\n' ' ')
    echo "# Loading $n images ..."
    test ! -d bgvar && mkdir bgvar # to allow storage of bad region files

    # display images
    AIexamine $imlist
    
    # delete temp links after closing ds9 AIRTOOLS
    cat $tmplinks >> $tmpfiles

    rm -f $tmp1 $tmplinks
    return 0
}

_imexa_calib () {
    # examine calibrated images
    __load_images $@
}

_imexa_raw () {
    # examine raw images
    __load_images -r $@
}

_remove () {
    # provide parts by arguments
    local do_execute
    test "$1" == "-x" && do_execute=1 && shift 1
    
    local plist=$@
    local allparts="calib,bgvar,badpix,register,stack,wcs,costack"
    local part
    local slist
    local set
    local msg
    local nlist
    local num
    local ext
    local flist
    local tel
    local n
    local f
    local tmp1=$(mktemp "/tmp/tmp1_$$_XXXXXX.dat")

    #slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" &&
        error "you must provide at least one set name."
    for set in $slist
    do
        AIsetinfo -b $set
    done
    for set in $slist
    do
        nlist="$nlist $(AI_EXCLUDE="" AIimlist -x -n $set)"
    done
    
    # parts to remove
    test -z "$plist" && plist="$allparts"
    n=$(echo ${plist//,/ } | wc -w)
    test $n -eq 1 && test "${plist%+}" != "$plist" &&
        plist=$(echo $allparts | sed -e 's|.*'${plist%+}'|'${plist%+}'|')
    test "$AI_DEBUG" && echo $plist >&2
    
    # per image result files
    for num in $nlist
    do
        if match darks "$plist"
        then
            f=$AI_TMPDIR/$num.pgm;      test -e $f && echo "rm $f"
        fi
        if match flats "$plist"
        then
            f=$AI_TMPDIR/$num.pgm;      test -e $f && echo "rm $f"
        fi
        if match calib "$plist"
        then
            f=$AI_TMPDIR/$num.fits;     test -e $f && echo "rm $f"
            f=$AI_TMPDIR/$num.ppm;      test -e $f && echo "rm $f"
            f=$AI_TMPDIR/$num.pgm;      test -e $f && echo "rm $f"
        fi
        if match bgvar "$plist"
        then
            f=bgvar/$num.bgm1.fits;     test -e $f && echo "rm $f"
            f=bgvar/$num.bgm1.ppm;      test -e $f && echo "rm $f"
            f=bgvar/$num.bgm1.pgm;      test -e $f && echo "rm $f"
            f=bgvar/$num.bgdiff.fits;   test -e $f && echo "rm $f"
            f=bgvar/$num.bgdiff.ppm;    test -e $f && echo "rm $f"
            f=bgvar/$num.bgdiff.pgm;    test -e $f && echo "rm $f"
        fi
        if match reg "$plist"
        then
            f=measure/$num.src.dat;  test -e $f && echo "rm $f"
            f=measure/$num.src.head; test -e $f && echo "rm $f"
        fi
    done | sort > $tmp1
    for num in $nlist
    do
        if match darks "$plist"
        then
            test -s mstat.dk.dat &&
                echo "sed -r -i '/^\S+\s+$num /d' mstat.dk.dat"
        fi
        if match bgvar "$plist"
        then
            test -s bgdiff.dat && echo "sed -i '/^$num\./d' bgdiff.dat"
            test -s bgsfit.dat && echo "sed -i '/^$num /d' bgsfit.dat"
        fi
        if match reg "$plist"
        then
            test -s reg.dat    && echo "sed -i '/^$num /d' reg.dat"
        fi
    done >> $tmp1

    # per imageset result files
    for set in $slist
    do
        if match darks "$plist"
        then
            flist=$(ls $set.pgm n$set.sd.pgm $AI_TMPDIR/$set.* 2>/dev/null)
            test "$flist" && for f in $flist
            do
                test -f $f && echo "rm $f"
            done
        fi
        if match flats "$plist"
        then
            flist=$(ls $set.pgm $set.norm.pgm $AI_TMPDIR/$set.* 2>/dev/null)
            test "$flist" && for f in $flist
            do
                test -f $f && echo "rm $f"
            done
        fi
        if match bgvar "$plist"
        then
            flist=$(ls varbgm*.$set.* 2>/dev/null)
            test "$flist" && for f in $flist
            do
                test -f $f && echo "rm $f"
            done
        fi
        if match badpix "$plist"
        then
            flist=$(ls bad.$set.{diff,high,low}* bad.$set.*{dat,reg} 2>/dev/null)
            test "$flist" && for f in $flist
            do
                test -f $f && echo "rm $f"
            done
        fi
        if match stack "$plist"
        then
            flist=$(ls $set.*{fits,ppm,pgm,head,src.dat,fits.gz} 2>/dev/null)
            test "$flist" && for f in $flist
            do
                test $f == $set.wcs.head && continue
                test $f == $set.head && backup -e $set.head
                test -e $f && echo "rm $f"
            done
        fi
        if match wcs "$plist"
        then
            flist=$(ls $set.wcs.* wcs/$set.* 2>/dev/null)
            test "$flist" && for f in $flist
            do
                test $f == $set.wcs.head && backup -e $set.wcs.head
                test -e $f && echo "rm $f"
            done
        fi
        if match costack "$plist"
        then
            flist=$(ls ${set}_m.*{fits,ppm,pgm,head,fits.gz} 2>/dev/null)
            test "$flist" && for f in $flist
            do
                test $f == ${set}_m.head && backup -e ${set}_m.head
                test -e $f && echo "rm $f"
            done
            # remove header keywords
            set_header $set.head AI_CORA="" AI_CODEC=""
        fi
    done >> $tmp1
    
    # TODO: per telescope result files
    # e.g. dk.var10.NVG.pgm
    for set in $slist
    do
        if match darks "$plist"
        then
            tel=$(get_telescope $set)
            flist=$(ls dk.var10.$tel.pgm 2>/dev/null)
            test "$flist" && for f in $flist
            do
                test -f $f && echo "rm $f"
            done
        fi
    done | sort -u >> $tmp1

    # per task result files
    false && if match badpix "$plist"
    then
        flist=$(ls badpix.* 2>/dev/null)
        test "$flist" && for f in $flist
        do
            ! test -L $f && echo "rm $f"
        done
    fi >> $tmp1

    # run commands if requested
    if [ -s $tmp1 ]
    then
        # exit on first error
        sed -i '1i\set -e' $tmp1

        if [ "$do_execute" ]
        then
            bash $tmp1
            test $? -ne 0 &&
                echo "ERROR: failed command: bash $tmp1" >&2 && return 255
        else
            echo "Run: bash $tmp1"
        fi
    else
        echo "# No files to remove."
        rm $tmp1
    fi
    return 0
}

_check_update () {
    check_new_version
}


_usercmd () {
    local msg="# Execute: $usercmd"
    # quote arguments with special characters
    for i in $(seq 1 $#)
    do
        arg=${!i}
        if [ "$arg" ] && [ "${arg/ /}" == "$arg" ] && [ "${arg/-/}" == "$arg" ]
        then
            msg="$msg $arg"
        else
            msg="$msg \"$arg\""
        fi
    done
    
    test -z "$quiet" && echo "$msg" >&2
    test "$AI_DEBUG" && echo "nargs=$#" >&2
    $usercmd "$@"
    return $?
}

_terminal () {
    # start x-terminal in projectdir and load airfun.sh
    x-terminal-emulator -e \
        "env PROMPT_COMMAND=\"unset PROMPT_COMMAND; . .airtoolsrc;
        . $(type -p airfun.sh)\" bash" &
}


#-------------------------
#   diagnostic tools
#-------------------------
_status () {
    echo "# Show processing info and diagnostic plots ..."
    AIsetinfo -b
    test -e reg.dat && (
        AIplot -t "FWHM in pixel" -p reg.dat 7
        AIplot -t "Mag difference to reference image" -p reg.dat 10)

    SKIPPARTS="image" _stack
    SKIPPARTS="image" _astrometry
    return 0
}

_check () {
    echo "# running AIcheck ..."
    echo "# PATH=$PATH"
    AIcheck
}

_procmon () {
    delay=2
    while true
    do
        tstamp=$(date +'%Y%m%d-%H%M%S')
        ps ux | grep -vE "^USER| Sl | /usr/| /bin/| /lib/" | sed -e 's|^|'$tstamp' |'
        sleep 2
    done
}

_kill () {
    # kill process including descendants
    pid=$1
    echo "# running kill $pid ..."
    ps $pid >/dev/null && pstree -p $pid &&
        kill -9 $(pstree -A -p $pid | tr '()' '\n' | grep -E "^[0-9]+$")
}

_args () {
    local i=1
    echo "# airtools-cli: args" $@
    while test "$1"
    do
        echo "$i:  _"$1"_"
        i=$((i+1))
        shift 1
    done

    echo "# AO_ARGS = _${AO_ARGS}_"
    test -z "$AO_ARGS" && return 0
    set - ${AO_ARGS}
    i=1
    while test "$1"
    do
        echo "$i:  _"$1"_"
        i=$((i+1))
        shift 1
    done
    return 0
}



#--------------------
#   get options
#--------------------
main () {
    : # main program starts here
}
cmdline="$(basename $0) $@"  # preserve command line
verbose=0
projectdir=""
setname=""
quiet=""
usercmd=""
SKIPPARTS=""
OVERWRITE=""
while getopts hp:s:ox:c:q c
do
    case $c in
        p)  projectdir="$OPTARG";;
        s)  setname="${OPTARG//,/ }";;
        o)  OVERWRITE=1;;
        x)  SKIPPARTS="$OPTARG";;
        c)  usercmd="$OPTARG";;
        q)  test -z "$AI_DEBUG" && quiet=1;;
        h)  longhelp; echo; task="help";;
        \?) shorthelp; exit -1;;
    esac
done
shift `expr $OPTIND - 1`


#--------------------
#   get parameter
#--------------------
if [ $# -lt 1 ] && [ -z "$usercmd" ]
then
    shorthelp; exit -1
fi
test -z "$task" && task=$1
shift 1
test "$usercmd" && task="usercmd"

# display additional info if requested
if [ "$task" == "help" ]
then
    echo "\
Available AIRTOOLS tasks:
Image reduction:
    imageinfo   - extract basic image info
    darks       - create master darks
    flats       - create master flats
    lights      - calibrate light images
    bgvar       - evaluate image background variation
    register    - register images
    stack       - stack images (on stars)
    astrometry  - astrometric calibration
    costack     - stack images on comet

Comet extraction and photometry:
    load_stacks - load stacked images

Miscellaneous tools:
    imexa_calib - load calibrated images
    imexa_raw   - load raw images
    status      - show basic results" >&2
    exit 0
fi

# check for valid entries in skipparts
if [ "$SKIPPARTS" ]
then
    x=$(echo $SKIPPARTS | tr ',' ' ' | tr ' ' '\n' | \
        grep -vwE "proc|plot|image")
    test "$x" &&
        echo "\
WARNING: stopped processing due to unknown skipparts argument

the following arguments may be used to skip selected program parts:
    proc    - skip processing of (new) sets
    image   - do not display result images
    plot    - do not show data plots" >&2 &&
    exit 0

fi

false && case "$TASKMODE" in
    normal|nodisplay|status|statusall) ;;
    *)  echo "\
WARNING: skipped processing due to unknown task mode $TASKMODE

available task modes:
    nodisplay   - skip display of new windows (images, plots)
    status      - show available results (measurements) only
    statusall   - like status but includes image display "
        exit 0
        ;;
esac


#--------------------
#   checkings
#--------------------
# check existence of projectdir
if [ "$projectdir" ]
then
    test ! -d "$projectdir" && error "projectdir $projectdir is missing."
    cd $projectdir
fi
test ! -e $rcfile && error "not a valid airtools project (missing .airtoolsrc)"

# if requested start terminal task without any further checkings
if [ "$task" == "terminal" ]
then
    echo "# Running task $task ($(date +'%H:%M')) ..."
    _terminal
    exit $?
fi

# start logging

# next two lines keep stdin/stdout separated but the order of messages on
# tty gets messed up, therefore we combine both streams here and try to
# always start messages on stderr using "#" character
#exec  > >(tee -ia $log)
#exec 2> >(tee -ia $log >&2)
exec &> >(tee -ia $log)
test ! -s $log && quiet=""
test -s $log && echo -e "\n" >> $log

# sourcing project environment
source $rcfile

# loading functions
airfun=$(which airfun.sh)
if [ -z "$airfun" ]
then
    error "missing function definition file airfun.sh
    (PATH=$PATH)"
fi
. $airfun > /dev/null

# version info
has_current_info $AI_VERSION $(airfun.py -v) && quiet=1
test ! "$quiet" &&
    echo "#### starting $(basename $0) v$VERSION at $(date +'%Y-%m-%d %H:%M')" >&2

if [ "$airfun" == "./airfun.sh" ]
then
    echo "# PWD=$PWD" >&2
    echo "# PATH=$PATH" >&2
    echo "WARNING: loading functions from local file airfun.sh ..." >&2
    sleep 10
else
    test ! "$quiet" && echo "# PATH=$PATH" >&2 && echo "# loading $airfun" >&2
fi

test ! "$quiet" &&
    echo "# airfun.sh:" $AI_VERSION >&2 &&
    echo "# airfun.py:" $(airfun.py -v) >&2

 
# check presence of required parameter files
for f in sites.dat camera.dat
do
    test ! -e "$f" && error "Missing file $f."
done

# check presence of required environment variables
! AIcheck_ok &&
    error "Unable to initialize AIRTOOLS functions."
for var in day AI_SITE AI_TMPDIR AI_RAWDIR
do
    test -z "$var" && error "Variable $var undefined."
done
test ! -d $AI_TMPDIR &&
    echo "# creating temp directory $AI_TMPDIR" >&2 &&
    mkdir -p $AI_TMPDIR
test ! -d "$AI_TMPDIR" &&
    error "temp directory $AI_TMPDIR is missing."
if [ ! -d "$AI_RAWDIR" ]
then
    if ! match proc "$SKIPPARTS" &&
        match "$task" "imageinfo|darks|flats|lights|imexa_raw" 
    then
        error "raw image directory $AI_RAWDIR is missing."
    else
        test ! "$quiet" && echo "WARNING: raw image directory $AI_RAWDIR is missing." >&2
    fi
fi

# check for allowed AO_* variables
varlist=$(env | grep "^AO_" | sed -e 's,=.*,,')
for var in $varlist
do
    echo "$AOVARS AO_ARGS" | \
        grep -qw $var
    test $? -ne 0 &&
        echo "ERROR: variable $var is not supported" >&2 &&
        exit 255
done

# check structure of parameter files
# TODO: make the check depend on parameter file format version
case $AI_VERSION in
    2*|3*|4*|5.0*) checkparamdat sites.dat 5 || error "Check of sites.dat failed.";;
    *)          checkparamdat sites.dat 6 || error "Check of sites.dat failed.";;
esac
checkparamdat camera.dat 15 || error "Check of camera.dat failed."
test -s "set.dat" && ! checkparamdat -s set.dat 11 && error "Check of set.dat failed."

# check for update if requested
if [ "$task" == "check_update" ]
then
    _check_update
    exit 0
fi

#-----------------------
#   program start
#-----------------------
export LC_NUMERIC=C
trap "" PIPE
errcode=""

# get list of existing image sets from set.dat
setlist=""
test -e set.dat && setlist=$(grep -v "^#" set.dat | awk '{
    if ($1!~/^[0-9][0-9]:[0-9][0-9]/) next
    if ($4!="o") next
    if ($5!~/^[0-9]+$/) next
    if ($6!~/^[0-9]+$/) next
    if ($7!~/^[0-9]+$/) next
    if ($8!~/^[0-9]+$/) next
    if (NF<11) next
    printf(";%s (%s)", $2, $3)
    }')

# check for valid setname
test "${setname// /}" && for set in $setname
do
    ! is_setname $set && error "Unknown image set $set."
done

# Run task
case "$task" in
    imageinfo|imexa_raw|usercmd|terminal) ;;
    check|kill) ;;
    *)  test ! -e "set.dat" && error "Missing file set.dat."
esac

# optional monitoring
DSTAT_PID=""
test "$AI_DSTAT" && DSTAT_PID=$(
    dstat --nocolor --noupdate --output dstat.log -tcdnmsp 5 >/dev/null &
    echo $!)
PROCMON_PID=""
test "$AI_PROCMON" && PROCMON_PID=$(
    _procmon >> procmon.log &
    echo $!)
if [ "$AI_PROFILE" ]
then
    exec 3>&2 2> >( tee /tmp/profile.$$.log |
                  sed -u 's/^.*$/now/' |
                  date -f - +%s.%N >/tmp/profile.$$.tim)
    set -x
fi

_cleanup () {
    test "$DSTAT_PID" && kill $DSTAT_PID
    test "$PROCMON_PID" && kill $PROCMON_PID
}
trap _cleanup EXIT


echo "
# Running task $task ($(date +'%H:%M')) ..." >&2
_$task "$@"
errcode=$?
test -z "$errcode" && error "Missing return code from task."
test "$errcode" == "0" && echo "# task finished at $(date +'%H:%M')" >&2
exit $errcode

#!/bin/bash

########################################################################
# airtools-cli
#   AIRTOOLS tasks command-line interface
#
# Copyright: Thomas Lehmann, 2018-2020
# License: GPL v3
#
# note: the following environment variables may be used
#       AO_FLATS in _flats
#       AO_LIGHT in _lights
#       AO_BGVAR in _bgvar
#       AO_REGIS in _register
#       AO_STACK in _stack and _costack
#       AO_AMASK and AO_ACOOR and AO_ABINN in _astrometry
#
########################################################################
AOVARS="AO_FLATS AO_LIGHT AO_BGVAR AO_REGIS AO_STACK AO_AMASK AO_ACOOR AO_ABINN"

VERSION="1.3.1"
VINFO="T. Lehmann, Apr. 2021"
PINFO="\
    options:
      -h            show this help text
      -p projectdir start from projectdir (default: cwd) 
      -s setname    limit processing to given image set
      -c cmd        run the given user command
      -x parts      exclude/skip some program parts (proc|plot|image)
      -o            overwrite previous results without warning
      -q            lower amount of output messages
    parameters:
      task          run given task    
"
CHANGELOG="
    1.3.1 - 30 Apr 2021
        * bgvar: take offset into account when plotting background values

    1.3 - 21 Apr 2021
        * flats, lights: added check for valid telid,
            deal with new camera type CMOS
        * darks: adjusted mesh size of small diff images
        * lights: always add offset of 100 ADU to avoid clipping of values at 0
        * register: determine a first guess on fwhm and use it for source
            extraction (instead of relying on a fixed value)
        * new command: terminal

    1.3a2 - 20 Mar 2021
        * astrometry: bugfix resetting the north value on new sets, use larger
            search radii to improve solving of small fields
        * OVERWRITE option implemented for all major image reduction tasks
        * added task badpix
        * rework of task remove

    1.3a1 - 27 Jan 2021
        * darks: use pnmccdred2 when estimating dark variation, applied
            change of parameters on AIraw2gray
        * costack: deal with objects unknown to MPC database by providing
            coordinates and motion vector

    1.2.2 - 18 Dez 2020
        * imageinfo: adapted to new log files from iTelescope.net, recognize
            more FITS file name extensions
        * lights: if data are not dslr raw images then assume hotpixel file
            is an image in PNG format (instead of .dat)

    1.2.1 - 19 Nov 2020
        * allow for process monitoring by setting AI_PROCMON
        * new function procmon

    1.2 - 14 Sep 2020
        * replace option -m <mode> by -x <parts> which simplifies program logic
        * astrometry:
            - improve handling of images containing a very large number of
              sources (>100000)
            - prefer ucac4 on medium size images (up to 9 deg^2)
            - reduce maxoff in case of an existing solution by solve_field

    1.2a4 - 31 Aug 2020
        * rewrite of load_images
        * lights: add 100ADU to calibrated CCD images as well

    1.2a3 - 30 Jul 2020
        * astrometry: if refraction changes by large amount across field then
            increase crossid radius and lower number of stars to be used in fit

    1.2a2 - 10 Jul 2020
        * register: bugfix when running second attempt on failed registration
        * imageinfo: allow for mixed FITS and DSLR raw files

    1.2a1 - 22 Jun 2020
        * imageinfo: support several types of compressed FITS images
        * darks: use additive normalization of images in noise estimation

    1.1.6 - 04 Jun 2020
        * bugfix in darks: compute dark variation for user provided image sets
          only (if specified)
        * stack: prefer badpix mask image specific to set if present

    1.1.5 - 19 May 2020
        * ds9cmd: quote arguments containing special characters
        * new environment variable AI_MAXPROCS to set number of jobs to run
          in parallel when calling program parallel

    1.1.4 - 12 May 2020
        * added check for correct parameter file structure
        
    1.1.3 - 24 Mar 2020
        * flats: do not use option -b if camera sensor is CCD
        * lights: add pedestal of 100 ADU if camera sensor is CCD
        
    1.1.2 - 02 Mar 2020
        * bgvar: bugfix: correctly determine column of background values to
            plot for every telescope used
        * astrometry:
            - do not write result from solve-field to image header anymore
            - rename of AO_ACCOO to AO_ACOOR
            - new env variable AO_ABINN to set value of binning
            - allow to skip solve-field by using AO_ACOOR=skipfirst

    1.1.1 - 28 Jan 2020
        * bgvar: bugfix: correctly deal with multiple set names
        * correctly handle task mode 'normal'
        * stack: always use target from set.dat to set OBJECT keyword
        * load_images: use wait_for_saoimage if SAOImage window is newly
            created
        * astrometry: improved stability when fitting large fields (>10 deg),
            if first attempt of AIwcs fails try again using fewer catalog stars
        * added check for allowed AO_ variables (defined by AOVARS)

    1.1 - 15 Dec 2019
        * darks, bgvar: bugfix for newer versions of imagemagick: when writing
          result to stdout in a specific image format then a hyphen character
          is required after the format specification (e.g. pgm:-)
        * lights: allow to use hotpixel file name hotpix.$cam.dat
        * astrometry: if using AO_ACCOO=unknown then do full sky search
        * allow for performance monitoring by using AI_DSTAT=1

    1.1a2 - 07 Nov 2019
        * imageinfo: avoid Gtk-Warning messages about theme parsing errors in
          calls of mousepad by filtering error stream

    1.1a1 - 21 Oct 2019
        * darks: run parallel jobs
        
    1.0   - 27 Aug 2019
        * set LC_NUMERIC=C required by printf and sort commands
        * register: bugfix: correctly capture exit code of the first comand in
            a pipe
        * load_images: deal with setname used as parameter

    1.0a5 - 17 Jun 2019
        * added ds9cmd wrapper for comet extraction tasks

    1.0a4 - 15 May 2019
        * imageinfo: enhanced to support newer naming scheme of fits files
        * load_stacks: wait for images to be loaded
        * new task: ds9cmd

    1.0a3 - 24 Apr 2019
        * bgvar: bugfix: corrected typo in plot filename
        * new task: load_images

    1.0a2 - 01 Mar 2019
        * lights: allow to overwrite default parameters passed to AIccd by
            setting AO_LIGHT
        * allow to use space or comma separated image set names in -s <setname>

    1.0a1 - 31 Jan 2019
        * register: if registration fails on some images then start a second pass
            using more relaxed constraints on allowed offsets
            
    0.9 - 04 Jan 2019
        * bgvar: changed default background fitting in AIbgdiff from surface fit
            to a plane for better stability in case of large offsets between
            images where extended bright sources are in the field of view
        * darks: by default run stats for new images only,
            use AI_EXCLUDE to discard images

    0.9a1 - 03 Dec 2018
        * bgvar, stack, costack: increased bgzero from 3000 to 10000

    0.8 - 29 Oct 2018
        * task darks: create noise image for larger sets (n>=15)
        * task bgvar: recognize option AO_BGVAR
        * task register: recognize option AO_REGIS
        * rename task coextract to load_stacks
        * remove hard-coded expansion of PATH variable

    0.7 - 09 Oct 2018
        * stack: stack properties: do not touch header file if all keywords
            are existing already
        * astrometry: rename wcs header file in case of failure of AIwcs
    
    0.6 - 30 Aug 2018
        * added task coextract
        * task stack: estimate noise in green channel and write AI_RMSG
            header keyword
        * task astrometry: allow to mask region for source detections by
            using env variable AO_AMASK which may point to a region file or
            holds the max distance (pixel) of valid objects from image center 

    0.5 - 26 Jun 2018
        * rework handling of AI_CCDREGION
        * added option -m <mode> to limit execution blocks of tasks
        * added option -c <cmd> to execute user defined command

    0.4 - 05 Jun 2018
        * added option -q to reduce output messages

    0.3 - 29 May 2018
        * allow for selection of a specific light image set via -s option

    0.2.1 - 28 May 2018
        * added keywords AI_TELID, BINNING to header file of stack
        * write rounded values of AI_BGG, AI_FWHM
        
    0.2 - 27 May 2018
        * added task status
        * added/improved various messages
        * write OBJECT keyword according to set.dat

    0.1 - 20 May 2018
        * initial version
"


#--------------------
#   user definitions
#--------------------
# Log file
log=airtools.log
# resources file (predefined variables, e.g. day, AI_SITE)
rcfile=.airtoolsrc


#--------------------
#   functions
#--------------------
shorthelp ()
{
    echo "usage: $(basename $0) [-h] [-p projectdir] [-x skipparts] [-o] <task> [params]"
}

longhelp ()
{
    echo $(basename $0)"   $VERSION   $VINFO"
    shorthelp
    printf "$PINFO"
}

error ()
{
    f_str="$1"
    echo "ERROR: $f_str" >&2
    exit 1
}

is_equal () {
    # compare two (float) numbers
    local x=$1
    local y=$2
    test $# -ne 2 && echo "ERROR: two parameters required" >&2 && return 255
    local err
    err=$(echo $x $y | awk '{
        d=$1-$2; if (d == 0) {print 0} else {print 255}
    }')
    return $err
}

is_time () {
    local x=$1
    local err
    err=$(echo $x | awk -F ':' '{
        x=0
        if (NF!=2) x=255
        if ($1!~/^[0-9][0-9]$/ || $2!~/^[0-9][0-9]$/) x=255
        if ($1>24 || $2>59) x=255
        print x
    }')
    return $err
}

match () {
    # case insensitive matching for beginning of words in a list
    local needle=$1
    local stack=$2  # values separated by space or separator character
    local sep=${3:-"|,;"}   # list of separator characters
    echo "$stack" | tr "$sep" ' ' | grep -qiE "^$needle| $needle"
}

backup () {
    # make backup of file (ignore symlinks)
    local do_echo   # if set show backup command
    test "$1" == "-e" && do_echo=1 && shift 1
    local orig=$1
    local num
    local last
    last=$(ls "$orig".bak "$orig".bak[1-9] 2>/dev/null | tail -1)
    test "$last" &&
        num=$(echo ${last: -1} | awk '{if($1~/[0-9]/){x=1+$1; print x}}')
    test "$num" && test $num -gt 9 && num=9
    test "$do_echo" && echo cp -p "$orig" "$orig".bak$num && return
    cp -p "$orig" "$orig".bak$num
}

select_item () {
    # prepend "^" to item string
    local list="$1"
    local item="$2"
    local sep=";"
    echo "$list" | awk -v s="$sep" -v x="$item" '{
        n=split($0,a,s)
        for (i=1;i<=n;i++) {
            sub(/\^/,"",a[i])
            if(i>1) printf("%s", s)
            if(a[i]==x) printf("^")
            printf("%s", a[i])
        }}'
}


#--------------------------------
#   test tasks
#--------------------------------
_setinfo () {
    local retval
    AIsetinfo
    retval=$?
    echo "... done"
    return $retval
}

_minute () {
    local i
    date
    for i in $(seq 6 -1 1)
    do
        echo "# Sleeping $((i*10))s ..."
        sleep 10
    done
    echo "... done"
    return 0
}

_endless () {
    while true
    do
        echo "# Sleeping 10s ..."
        sleep 10
    done
    echo "... done"
    return 0
}

_failure () {
    echo "# Failing in 20s ..."
    sleep 10
    for i in $(seq 10 -1 1)
    do
        echo "# Failing in ${i}s ..."
        sleep 1
    done
    echo "... done"
    return 255
}

_pipetest () {
    local retval=0
    echo "# running pipetest ..."
    __mytest () {
        local infile="$1"
        local tmp1=$(mktemp "/tmp/tmp1_stdin_XXXXXX")
        if [ "$infile" == "-" ]
        then
            cat > $tmp1
            infile=$tmp1
        fi
        sleep 2
        rm -f $tmp1
    }
    for i in $(seq 1 10)
    do
        echo "$i"
        cat /var/log/messages | __mytest -
        test $? -ne 0 && echo "ERROR" && retval=255
    done
    return $retval
}

_sexselect () {
    local retval=0
    local head=test.wcs.ahead
    local sdat=measure/0005.src.dat
    echo "# running sexselect ..."
    __mytest () {
        cat $sdat | sexselect -f - "" 0.02 | \
            addldacwcs - $head > x.fits
        sexselect $sdat "" "" 300 | sort -n -k7,7 | \
            grep -v "^#" | head -100 > x.xyref
        head x.xyref
    }
    for i in $(seq 1 10)
    do
        echo "$i"
        __mytest | tee -a x.dat
        test $? -ne 0 && echo "ERROR" && retval=255
    done
    return $retval
}

_test () {
    #_pipetest
    _sexselect
}



#--------------------------------
#   main imred reduction tasks
#--------------------------------
_imageinfo () {
    # DSLR RAW images: must be placed in $AI_RAWDIR, image number is part of file name
    # FITS images: placed in any subdir of $AI_RAWDIR, arbitrary file names
    # note: files in directory "unused" are ignored
    local extlist
    local ext
    local msg
    local flist
    local infofile
    local exifdat="exif.dat"        # DSLR RAW images
    local fitsdat="rawfiles.dat"    # all FITS raw images (CCD, DSLR, bayered CMOS)
    
    msg="# Collecting image information ..."
    extlist=$(cd $AI_RAWDIR/ && find * -type f | sed -e 's,.*\.,,' | sort -u | \
            grep -iwE "pef|cr2|nef|raf")
    if ! match proc "$SKIPPARTS"
    then
        echo $msg

        if [ "$OVERWRITE" ]
        then
            for f in $exifdat $fitsdat
            do
                test ! -f $f && continue
                echo "# deleting $f"
                rm $f
                test $? -ne 0 && return 255
            done
        fi

        # scanning dslr raw images ...
        # note: use AI_TZOFF=1 if DSLR camera time is MEZ instead of UT
        #   DSLR camera exif time is exposure end time + 30s
        infofile=$exifdat
        test "$extlist" && for ext in $extlist
        do
            echo "# scanning $ext files ..."
            img_info $(find $AI_RAWDIR/ -type f -name "*.$ext" \
                -not -path "$AI_RAWDIR/unused/*") | sort -n -k 2,2 >> $infofile
            test $? -ne 0 && return 255
        done
        test -s $infofile && 
            (mousepad $infofile 3>&1 1>&2 2>&3 | \
            grep -v "Gtk-WARNING .* Theme parsing error" | grep "[[:alnum:]]") 3>&1 1>&2 2>&3 &
        
        # scanning FITS images ...
        infofile=$fitsdat
        # FITS images from itelescope.net
        if grep -iq iTelescope.Net $AI_RAWDIR/[2T]*{txt,log} 2>/dev/null
        then
            if [ -e $AI_RAWDIR/obs.txt ]
            then
                itel2obs
            else
                itel2obs | tee -a $AI_RAWDIR/obs.txt
            fi
            tellist=$(get_itel_telid $AI_RAWDIR/[2T]*{txt,log} 2>/dev/null)
            test "$tellist" && for tel in $tellist
            do
                # bugfix for wrong identifiers on T16, T68, T20
                test $tel == "16" && tel=T16
                test $tel == "jbl08" && tel=T68
                test $tel == "T2" && tel=T20
                echo "# scanning fits files for $tel ..."
                flist=$(find $AI_RAWDIR/ \( -name "*fit.zip" -or -name "*fits" \) \
                    -not -name "calib*" \
                    -not -path "$AI_RAWDIR/unused/*" | grep -iw $tel)
                # TODO: check JD in first file, if it is not plausible then use time
                # info from log file by providing -l option
                map_rawfiles -x $flist >> $infofile
                test $? -ne 0 && return 255
            done
        else
            # scanning other FITS images
            flist=$(find $AI_RAWDIR/ -type f \( \
                   -name "*.fit"  -o -name "*.FIT"  \
                -o -name "*.fits" -o -name "*.FITS" \
                -o -name "*.fts"  -o -name "*.FTS"  \
                -o -name "*.fit.gz"  -o -name "*.fit.zip" \
                -o -name "*.fits.gz" -o -name "*.fits.zip" \
                -o -name "*.fts.gz"  -o -name "*.fts.zip" \) \
                -not -path "$AI_RAWDIR/unused/*")
            if [ "$flist" ]
            then
                echo "# scanning fits files ..."
                map_rawfiles -x $flist >> $infofile
                test $? -ne 0 && return 255
            fi
        fi
        test -s $infofile && 
            (mousepad $infofile 3>&1 1>&2 2>&3 | \
            grep -v "Gtk-WARNING .* Theme parsing error" | grep "[[:alnum:]]") 3>&1 1>&2 2>&3 &
    fi
    return 0
}

_darks () {
    # use AI_EXCLUDE to skip some images from master dark
    # TODO: make dkmn a temp file
    #       compute stats only for new images
    #       determine dark varition only for new sets
    local slist
    local dklist
    local set
    local scale
    local flip
    local opts
    local nlist
    local exlist
    local fname
    local x
    local msg
    local bs
    local popts
    local tmpargs=$(mktemp "/tmp/tmp_args_XXXXXX")
    local tmpsh=$(mktemp "/tmp/tmp_script_XXXXXX.sh")
    chmod u+x $tmpsh
    cat <<EOF > $tmpsh
#!/bin/bash
. airfun.sh > /dev/null
_run_parallel \$@
EOF
    
    #set -x
    slist=$(AIsetinfo -b | awk '{if($4=="d"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" &&
        echo "WARNING: no images to process." && return 0
    # checking valid telid
    for set in $slist
    do
        get_param camera.dat pixscale $set > /dev/null
        test $? -ne 0 &&
            echo "ERROR: unknown telescope identifier for set $set." >&2 &&
            return 255
    done

    if [ "$OVERWRITE" ] && ! match proc "$SKIPPARTS"
    then
        echo "# deleting previous results of" $slist
        _remove -x darks
        test $? -ne 0 && return 255
    fi

    msg="# Converting dark images ..."
    tellist=$(AIsetinfo -b | grep -w d | awk '{printf("%s\n", $11)}' | sort -u)
    ! match proc "$SKIPPARTS" && for tel in $tellist
    do
        # get camera dependend parameters
        # determine intensity scaling factor to stretch to full 16bit range
        # this is used by AIraw2gray in case of FITS images only
        scale=$(get_param camera.dat rawbits $tel | awk '{if ($1!="-" && $1<16) print 2^(16-$1)}')

        # check if top-down image flipping is required
        flip=$(get_param camera.dat flip $tel | awk '{if ($1=="1") print 1}')
        
        # options for raw image conversion
        opts="-c"   # apply AI_CCDREGION
        test "$scale" && opts=$(echo $opts "-s $scale")
        test "$flip"  && opts=$(echo $opts "-f")

        # determine images which need to be converted
        rm -f $tmpargs
        for set in $(AIsetinfo -b | grep -w d | \
            awk -v t=$tel '{if($11==t){print $2}}')
        do
            echo $slist | grep -q -w $set || continue
            for num in $(AI_EXCLUDE="" AIimlist -n $set "" raw)
            do
                test -f $AI_TMPDIR/$num.pgm && continue
                x=""
                test -s mstat.dk.dat &&
                    fname=$(get_rawfile $num) &&
                    x=$(grep "^$(basename $fname) " mstat.dk.dat)
                test "$x" && test -f $set.pgm &&
                    test -f dk.var10.${tel,,}.pgm && continue
                echo $num $opts >> $tmpargs
            done
        done

        if [ -s $tmpargs ]
        then
            test "$msg" && echo $msg && msg="" &&
                echo "#" $(cat $tmpargs | wc -l) "images"
            _run_parallel () {
                num=$1; shift 1
                opts=$@
                dcrawopts=""
                test "$AI_CCDREGION" && dcrawopts="-R $AI_CCDREGION"

                fname=$(get_rawfile $num)
                echo $num >&2
                #echo "# AI_DCRAWPARAM=\"$AI_DCRAWPARAM $dcrawopts\" AIraw2gray -c $opts $fname > $AI_TMPDIR/$num.pgm" >&2
                AI_DCRAWPARAM="$AI_DCRAWPARAM $dcrawopts" \
                    AIraw2gray $opts $fname $AI_TMPDIR/$num.pgm
            }
            #false && (
            export -f _run_parallel
            popts=""; test "$AI_MAXPROCS" && popts="-P $AI_MAXPROCS"
            cat $tmpargs | parallel $popts -k $tmpsh
            unset -f _run_parallel
            #)
            
            false && cat $tmpargs | while read num opts
            do
                dcrawopts=""
                test "$AI_CCDREGION" && dcrawopts="-R $AI_CCDREGION"
                fname=$(get_rawfile $num)
                echo $num >&2
                #echo "# AI_DCRAWPARAM=\"$AI_DCRAWPARAM $dcrawopts\" AIraw2gray -c $opts $fname > $AI_TMPDIR/$num.pgm" >&2
                AI_DCRAWPARAM="$AI_DCRAWPARAM $dcrawopts" \
                    AIraw2gray -c $opts $fname $AI_TMPDIR/$num.pgm
            done
        fi
    done
    
    msg="# Computing statistics of dark images ..."
    if ! match proc "$SKIPPARTS"
    then
        # determine list of images for which to estimate statistics
        rm -f $tmpargs
        for set in $slist
        do
            AI_EXCLUDE="" AIimlist $set "" raw | while read x num fname x
            do
                if [ -s mstat.dk.dat ]
                then
                    ! grep -q "^$(basename $fname) " mstat.dk.dat &&
                        echo $num
                else
                    echo $num
                fi
            done
        done > $tmpargs
        
        # get stats
        if [ -s $tmpargs ]
        then
            test "$msg" && echo $msg && msg=""
            _run_parallel () {
                local num=$1
                local fname=$(get_rawfile $num)
                AImstat -v -c $fname | awk -v n=$num '{
                    if ($2=="-") sub(/-/,n,$2)
                    print $0}'
            }
            export -f _run_parallel
            popts=""; test "$AI_MAXPROCS" && popts="-P $AI_MAXPROCS"
            cat $tmpargs | parallel $popts -k $tmpsh >> mstat.dk.dat
            unset -f _run_parallel
        fi
    fi

    # plot stats
    test ! -s mstat.dk.dat && return 255
    ! match plot "$SKIPPARTS" &&
        AIplot -o $AI_TMPDIR/x.darkvalue.png -t "Dark value per image" -p mstat.dk.dat 2 5

    msg="# Creating Master darks ..."
    ! match proc "$SKIPPARTS" && for set in $slist
    do
        # if necessary add option -r to remove row pattern
        test -f $set.pgm && continue
        test "$msg" && echo $msg && msg=""
        AIdark $set
        test $? -ne 0 && return 255
    done
    ! match image "$SKIPPARTS" &&
        for set in $slist; do test -f $set.pgm && dklist="$dklist $set.pgm"; done &&
        test "$dklist" &&
        (AIexamine -n MasterDark_and_Flat $dklist &
        sleep 3)
    
    # dark variation (using first dark as reference)
    msg="# Estimate dark variation ..."
    #pnmcombine dk06.pgm dk09.pgm dk11.pgm dk12.pgm dkmn.pgm     # T05 bias
    #pnmcombine dk01.pgm dk02.pgm dkmn.pgm
    tellist=$(AIsetinfo -b | grep -w d | awk '{printf("%s\n", $11)}' | sort -u)
    ! match proc "$SKIPPARTS" && for tel in $tellist
    do
        test -f dk.var10.$tel.pgm && continue
        
        # populate $tmpargs to be used by parallel
        rm -f $tmpargs
        for set in $(AIsetinfo -b | grep -w d | \
            awk -v t=$tel '{if(tolower($11)==tolower(t)){print $2}}')
        do
            echo "$slist" | grep -w -q $set || continue
            test ! -f $set.pgm &&
                echo "ERROR: $set.pgm is missing." >&2 && return 255
            bs=64
            x=$(imsize $set.pgm | awk '{x=$1; if($2<$1) x=$2; print x}')
            test $x -lt 4000 && bs=48
            test $x -lt 3000 && bs=32
            test $x -lt 2000 && bs=24
            test $x -lt 1400 && bs=18
            for num in $(AI_EXCLUDE="" AIimlist -n $set "" raw)
            do
                test ! -f $AI_TMPDIR/$num.pgm &&
                    echo "ERROR: file $AI_TMPDIR/$num.pgm is missing." >&2 &&
                    return 255
                echo $num $bs $set $tel
            done
        done >> $tmpargs
        
        if [ -s $tmpargs ]
        then
            test "$msg" && echo $msg && msg="" &&
                echo "#" $(cat $tmpargs | wc -l) "images"
            _run_parallel () {
                num=$1
                bs=$2
                set=$3
                tel=$4
                echo "# computing diff for $num ($set $tel)" >&2
                pnmccdred2 -m 10 -a 1000 -d $set.pgm $AI_TMPDIR/$num.pgm - | pnmsmooth > x.$num.pgm
                AIbgmap -q x.$num.pgm $bs 1
                add=$(AIstat x.$num.bgm1.pgm | awk '{printf("%.0f", 1000-$5)}')
                pnmccdred -a $add x.$num.bgm1.pgm $AI_TMPDIR/$num.dkdiff.pgm
                rm x.$num.bgm1.pgm x.$num.bg.pgm x.$num.pgm
            }
            export -f _run_parallel
            popts=""; test "$AI_MAXPROCS" && popts="-P $AI_MAXPROCS"
            cat $tmpargs | parallel $popts -k $tmpsh
            unset -f _run_parallel
        fi
        
        montage -background '#03c003c003c0' -fill '#050005000500' -label '%t' \
            $AI_TMPDIR/????.dkdiff.pgm -geometry +4+2 dk.var10.$tel.pgm &&
			rm -f $AI_TMPDIR/????.dkdiff.pgm
    done
    
    # dark noise estimation (per pixel)
    ! match proc "$SKIPPARTS" && for set in $slist
    do
        test -f n${set}.sd.pgm && continue
        nimg=$(AIsetinfo $set | awk '{print $9}')
        test $nimg -lt 12 && continue
        echo "# estimate dark noise in $set, nimg=$nimg"
        grep -v "^#" set.dat | awk -v s=$set '{
            if ($2==s) printf("%s n%s\n", $1, substr($0,7))}' > $AI_TMPDIR/x.nset.dat
        AI_SETS=$AI_TMPDIR/x.nset.dat AInoise -s n$set
        rm -f ndk??.mn.pgm
    done
    
    # show some stats of darks
    for set in $slist
    do
        nimg=$(AIsetinfo $set | awk '{print $9}')
        mn=$(AImstat -c $set.pgm | cut -d ' ' -f5)
        sd=""
        test -e n$set.sd.pgm && sd=$(AImstat -c n$set.sd.pgm | cut -d ' ' -f5)
        printf "$set n=%2d mean=$mn" $nimg
        test "$sd" && printf " sd=$sd"
        printf "\n"
    done

    ! match image "$SKIPPARTS" &&
        (AIexamine -n "Dark_Variation" -l dk.var10.*pgm &
        sleep 3)
    rm -f $tmpsh $tmpargs
    return 0
}

_flats () {
    local slist
    local fflist
    local texp
    local tel
    local cam
    local type
    local badpix
    local ctype
    local opts
    local set
    slist=$(AIsetinfo -b | awk '{if($4=="f"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" &&
        echo "WARNING: no images to process." && return 0
    # checking valid telid
    for set in $slist
    do
        get_param camera.dat pixscale $set > /dev/null
        test $? -ne 0 &&
            echo "ERROR: unknown telescope identifier for set $set." >&2 &&
            return 255
    done

    echo "# Creating master flats ..."

    if [ "$OVERWRITE" ] && ! match proc "$SKIPPARTS"
    then
        echo "# deleting previous results of" $slist
        _remove -x flats
        test $? -ne 0 && return 255
    fi

    ! match proc "$SKIPPARTS" && for set in $slist
    do
        texp=$(AIsetinfo $set | awk '{printf("%.0f", $8)}')
        tel=$(AIsetinfo $set | awk '{printf("%s", $12)}')
        cam=$(get_param camera.dat camera $tel | awk '{print tolower($1)}')
        ctype=$(get_param camera.dat ctype $tel | awk '{print $1}')
        echo "# tel=$tel  cam=$cam ($ctype)"
        opts="-b"
        (test "$ctype" == "CCD" || test "$ctype" == "CMOS") && opts=""
        type=long; test $texp -lt 32 && type=short
        badpix=hotpix.${cam}_$type.dat
        test ! -e $badpix && badpix=hotpix.${cam}.dat
        test ! -e $badpix && badpix=""
        test "$badpix" && echo "# using hotpixel file $badpix"
        echo "# AI_BADPIX=\"$badpix\" AIflat" $opts $AO_FLATS $set
        AI_BADPIX="$badpix" AIflat $opts $AO_FLATS $set
        test $? -ne 0 && return 255
    done
    # statistics
    for set in $slist
    do
        test ! -f $set.pgm &&
            echo "WARNING: flat $set.pgm does not exist" &&
            continue
        tel=$(AIsetinfo $set | awk '{printf("%s", $12)}')
        ctype=$(get_param camera.dat ctype $tel | awk '{print $1}')
        opts="-b"
        (test "$ctype" == "CCD" || test "$ctype" == "CMOS") && opts=""
        AIstat $opts -c $set.pgm
    done
    # show normalized flat image
    if ! match image "$SKIPPARTS"
    then
        for set in $slist
        do
            test ! -f $set.pgm && continue
            AIbnorm $set.pgm > $AI_TMPDIR/$set.norm.pgm
            fflist="$fflist $AI_TMPDIR/$set.norm.pgm"
        done
        test "$fflist" && AIexamine -n MasterDark_and_Flat $fflist &
        sleep 3
    fi
    return 0
}

_lights () {
    local slist
    local set
    local num
    local texp
    local tel
    local cam
    local type
    local ctype
    local ccdopts
    local is_calibrated # check only for ctype=CCD
    local badpix
    local badext
    
    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" &&
        echo "WARNING: no images to process." && return 0
    # checking valid telid
    for set in $slist
    do
        get_param camera.dat pixscale $set > /dev/null
        test $? -ne 0 &&
            echo "ERROR: unknown telescope identifier for set $set." >&2 &&
            return 255
    done

    echo "# Calibrating light frames ..."

    if [ "$OVERWRITE" ] && ! match proc "$SKIPPARTS"
    then
        echo "# deleting previous results of" $slist
        _remove -x calib
        test $? -ne 0 && return 255
    fi
    
    ! match proc "$SKIPPARTS" &&
    for set in $slist
    do
        ccdopts="$AO_LIGHT"
        if [ -z "$ccdopts" ]
        then
            texp=$(AIsetinfo $set | awk '{printf("%.0f", $8)}')
            tel=$(AIsetinfo $set | awk '{printf("%s", $12)}')
            cam=$(get_param camera.dat camera $tel | awk '{print tolower($1)}')
            ctype=$(get_param camera.dat ctype $tel | awk '{print $1}')
            echo "# tel=$tel  cam=$cam ($ctype)"
            case "$ctype" in
                CCD|CMOS)   ccdopts="-a 100";;
                *)          ccdopts="-a 100 -q 1";;
            esac
            is_calibrated=$(AIsetinfo -b $set | awk '{
                if($9=="cal" && $10=="cal") print 1}')
            test "$is_calibrated" && ccdopts="-c $ccdopts"
            badext="dat"; test $ctype != "DSLR" && badext="png"
            type=long; test $texp -lt 32 && type=short
            badpix=hotpix.${cam}_$type.$badext
            test ! -e $badpix && badpix=hotpix.${cam}.$badext
            test ! -e $badpix && badpix=""
            test "$badpix" && echo "# using hotpixel file $badpix"
        fi
        test -d bgvar || mkdir bgvar
        
        echo "# running: AI_BADPIX=\"$badpix\" AIccd" $ccdopts $set
        AI_BADPIX="$badpix" AIccd $ccdopts $set
        test $? -ne 0 && return 255
    done
    return 0
}

_bgvar () {
    local slist
    local bgcol
    local suffix
    local set
    local inext
    local bg
    local fg
    local nlist
    local num
    local filter
    local f
    local add
    local imlist
    local tellist
    local tel
    local ncol
    local title
    local doit
    
    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" &&
        echo "WARNING: no images to process." && return 0
    echo "# Estimate background variation ..."

    if [ "$OVERWRITE" ] && ! match proc "$SKIPPARTS"
    then
        echo "# deleting previous results of" $slist
        _remove -x bgvar
        test $? -ne 0 && return 255
    fi
    
    if ! match proc "$SKIPPARTS"
    then
        # recognize already processed set
        test ! -s bgdiff.dat && doit=1
        for set in $slist
        do
            nlist="$nlist $(AIimlist -q -n $set "" "" o)"
        done
        if [ "${nlist// /}" ]
        then
            for num in $nlist
            do
                test "$doit" && continue
                # TODO: determine inext
                #   determine calib. image
                #   if -f calimg && calimg newer than bgvar/$num.bgm1.$inext
                #   then rm bgvar/$num.bgm1.$inext
                #       remove entry from bgdiff.dat bgsfit.dat
                #       remove varbgm1.$set.$inext
                AIsetinfo -b | grep -w o | awk '{printf("%s ", $8)}' | \
                    grep -q -w $num && continue
                ! grep -q "^"$num"." bgdiff.dat && doit=1            
            done
        fi
        
        # check if bad region masks/images are black-and-white
        if [ "$doit" ] && [ -d "bgvar" ]
        then
            for num in $nlist
            do
                test -e bgvar/$num.bad.png &&
                    ! is_mask bgvar/$num.bad.png white &&
                    return 255
            done
        fi
    
        if [ "$doit" ]
        then
            for set in $slist
            do                
                AIbgdiff -k -a -p $AO_BGVAR "$set" >> bgdiff.dat
                test $? -ne 0 && return 255
                #AIbgdiff -k -a le01 >> bgdiff.dat
                #AIbgdiff -k "" 64 >> bgdiff.dat    # small images
            done
        fi
    fi
    
    # plot mean bg values
    tellist=$(AIsetinfo -o | grep -v "^#" | awk '{printf("%s\n", tolower($12))}' | sort -u)
    ! match plot "$SKIPPARTS" && for tel in $tellist
    do
        nlist=""
        for set in $(AIsetinfo -o | grep -v "^#" | \
            awk -v t=$tel '{if(tolower($12)==t){print $1}}')
        do
            echo $slist | grep -qw $set || continue
            nlist="$nlist $(AIimlist -x -q -n $set)"
        done
        test -z "${nlist// /}" && continue
        filter=""
        for num in $nlist
        do
            test "$filter" && filter="$filter|"
            filter="${filter}^$num"
        done
        ncol=$(grep -wE "$filter" bgdiff.dat | lines 1 | wc -w)
        bgcol=7 # gray in 7
        test $ncol -gt 14 && bgcol=16   # rgb in 15 16 17
        title="$tel: Average background per image"
        grep -wE "$filter" bgdiff.dat | \
            awk -v bgoff=100 -v c=$bgcol '{printf("%s %.1f\n", $2, $c-bgoff)}' | \
            AIplot -o $AI_TMPDIR/x.$tel.bg.png -t "$title" -p - 1 2
    done
    
    # show changing gradient only
    #suffix=bgdiff   # result of surface fit to AIbgmap of diff image excl. bad regions
    suffix=bgm1     # AIbgmap of diff image
    ! match proc "$SKIPPARTS" && for set in $slist
    do
        set - $(AIsetinfo $set)
        test $9 -le 1 && continue
        inext="pgm"; test -f $AI_TMPDIR/$4.ppm && inext="ppm"
        bg='#03D003D003D0'
        fg='#042004200420'
        nlist=$(AIimlist -n $set)
        test -z "$nlist" && continue
        for num in $nlist
        do
            f=bgvar/$num.$suffix.$inext
            test -f $f || continue
            imcrop $f 70 > tmp1.$$.$inext
            add=$(AIstat tmp1.$$.$inext | awk -v m=1000 '{
                printf("%d",m-$5); if(NF>8) printf(",%d,%d", m-$9, m-$13)}')
            echo $num $f $add
            pnmccdred -a $add $f - | pnmscale 4 - > z.$set.$num.$inext
        done
        # note: montage changes intensities when output is 16bit grayscale
        montage -background $bg -fill $fg -label '%t' \
            z.$set.????.$inext -geometry +4+2 ppm:- | ppm2gray - 0,1,0 > var$suffix.$set.$inext
        rm z.$set.????.$inext tmp1.$$.$inext
    done
    imlist=$(for set in $slist
        do
            if [ -f var$suffix.$set.ppm ]
            then
                echo var$suffix.$set.ppm
            else
                test -f var$suffix.$set.pgm && echo var$suffix.$set.pgm
            fi
        done)
    ! match image "$SKIPPARTS" && test "$imlist" &&
        AIexamine -n "Background_Variation" -l $imlist &
    return 0
}

_register () {
    local slist
    local set
    local tellist
    local tel
    local nlist
    local failedlist
    local fwhm
    local num
    local img
    local fwhm
    local opts
    local filter
    local title
    local yrange
    local retval=0
    local tmpcat=$(mktemp "/tmp/tmp_reg_XXXXXX.src.dat")
    
    # if necessary set AI_TELESCOPE to a matching entry in camera.dat
    #for set in le01 co03; do AI_TELESCOPE=GSO AIsource $set; done
    #AI_TELESCOPE=GSO
    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" && return
    echo "# Source extraction and registration ..."

    if [ "$OVERWRITE" ] && ! match proc "$SKIPPARTS"
    then
        echo "# deleting previous results of" $slist
        _remove -x register
        test $? -ne 0 && return 255
    fi
    
    ! match proc "$SKIPPARTS" && for set in $slist
    do
        # make first guess of fwhm
        num=$(AIsetinfo -b $set | head -1 | awk '{printf("%s", $8)}')
        img=$(AIimlist $set | awk -v n=$num '{if($2==n)print $3}')
        test -z "$img" &&
            echo "ERROR: unable to find calibrated image for nref=$num." &&
            return 255
        AI_MAGZERO=25 AIsource -q -g -o $tmpcat $img
        fwhm=$(sexselect $tmpcat | kappasigma - 6 | awk '{printf("%.1f", $1)}')
        echo "#" AIsource -f $fwhm $set
        
        # extract sources
        AIsource -f $fwhm $set
        if [ $? -eq 0 ]
        then
            # remove failed registrations (dmag <= -2)
            nlist=$(AIimlist -n $set)
            test -s reg.dat && for num in $nlist
            do
                test "$(grep "^$num " reg.dat | awk '{if($10>-2) print "ok"}')" && continue
                rm -f measure/$num.src.head
                sed -i '/^'$num' /d' reg.dat
            done

            # run AIregister
            # rewrite AIregister using: type rvm | (head -1 ; dd of=/dev/null)
            echo "#" AIregister $AO_REGIS $set
            AIregister $AO_REGIS $set | tee -a reg.dat
            test ${PIPESTATUS[0]} -ne 0 && retval=255
            test "$AI_DEBUG" && echo "DEBUG: AI_VERSION=$AI_VERSION retval=$retval"

            # find images where registration failed, e.g. due to large center offset
            # and try registration using relaxed constraints on allowed offsets
            failedlist=""
            for num in $nlist
            do
                test "$(grep "^$num " reg.dat | awk '{if($10>-2) print "ok"}')" && continue
                rm -f measure/$num.src.head
                sed -i '/^'$num' /d' reg.dat
                failedlist="$failedlist $num"
            done
            if [ "$failedlist" ]
            then
                echo "WARNING: registration failed on $(echo $failedlist | wc -w) images, trying again ..."
                opts="-p -q"
                test -z "$AO_REGIS" && opts="-m 1.0 -p -q"
                echo "# AIregister $opts $set \"\" 0.06" >&2
                AIregister $opts $set "" 0.06 | tee -a reg.dat
                test ${PIPESTATUS[0]} -ne 0 && retval=255
            fi
        else
            retval=255
        fi
        rm -f $tmpcat
    done
    
    # show diagnostic plots
    tellist=$(AIsetinfo -o | grep -v "^#" | awk '{printf("%s\n", tolower($12))}' | sort -u)
    ! match plot "$SKIPPARTS" && for tel in $tellist
    do
        nlist=""
        for set in $(AIsetinfo -o | grep -v "^#" | \
            awk -v t=$tel '{if(tolower($12)==t){print $1}}')
        do
            echo $slist | grep -qw $set || continue
            nlist="$nlist $(AIimlist -x -q -n $set)"
        done
        test -z "$(echo $nlist)" && continue
        filter=""
        for num in $nlist
        do
            test "$filter" && filter="$filter|"
            filter="${filter}^$num"
        done
        title="$tel: FWHM in pixel"
        grep -wE "$filter" reg.dat | AIplot -o $AI_TMPDIR/x.$tel.fwhm.png -t "$title" -p - 1 7
        # mag difference (lower values = fainter than average)
        title="$tel: Mag difference to reference image"
        yrange=$(grep -wE "$filter" reg.dat | minmax - 10 | awk '{l=$1; h=$2
            if (l>-0.09) l=-0.1
            if (h<0.09) h=0.1
            m=(h-l)/20
            printf("%.2f:%.2f", h+m, l-m)}')
        grep -wE "$filter" reg.dat | \
            AIplot -o $AI_TMPDIR/x.$tel.dmag.png -t "$title" -p - 1 10 "" "" "[][$yrange]"
    done
    return $retval
}

_badpix () {
    # create bad-pixel-mask (per telescope)
    local high=${1:-""}
    local low=${2:-""}
    local msg
    local tellist
    local tel
    local slist
    local camtype
    local highlist
    local lowlist
    local difflist
    local badlist
    local nref
    local opts
    local xhigh
    local xlow
    local s
    local f
    local n
    
    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" && return
    msg="# Creating badpixel mask ..."

    if [ "$OVERWRITE" ] && ! match proc "$SKIPPARTS"
    then
        echo "# deleting previous results of" $slist
        _remove -x badpix
        test $? -ne 0 && return 255
    fi

    tellist=$(AIsetinfo -b | grep -w o | awk '{printf("%s\n", $11)}' | sort -u)
    ! match proc "$SKIPPARTS" && for tel in $tellist
    do
        #test -e badpix.${tel,,}.png &&
        #    echo "WARNING: reusing existing badpix.${tel,,}.png" && continue
        telsetlist=$(AIsetinfo -o | awk -v t=$tel -v sl="$(echo $slist)" '{
            if (tolower($12)==tolower(t) && $9>3 && sl~$1) {print $1}}')
        test -z "$telsetlist" && continue
        opts="-n 13"    # limit to 13 frames per set
        camtype=$(get_param camera.dat ctype $tel)
        test "$camtype" != "CCD" && test "$camtype" != "CMOS" && opts="$opts -s"   # do subtract bayered background 
        for set in $telsetlist
        do
            test "$msg" && echo $msg && msg=""
            nref=$(AIsetinfo -o $set | awk '{printf("%s", $4)}')
            xhigh=$high
            test -z "$xhigh" && test ! -s reg.dat &&
                echo "WARNING: no reg.dat found, using default high=20" >&2 &&
                xhigh=20
            test -z "$xhigh" && n=$(grep -v "^#" reg.dat | awk -v ref=$nref '{if($2==ref){print $0}}' | wc -l) &&
                test $n -lt 5 &&
                echo "WARNING: too few registered images ($n<5), skipping set $set" >&2 &&
                continue
            test -z "$xhigh" &&
                xhigh=$(grep -v "^#" reg.dat | awk -v ref=$nref '{if($2==ref){print $0}}' | \
                    median - 7 | awk '{x=13;
                        if($1<2) x=16; if($1<1.8) x=20; if($1<1.6) x=30}END{print x}')
            xlow=$low
            test -z "$xlow" && xlow=10
            echo "# running AIfindbad $opts $set \"\" $xhigh $xlow"
            AIfindbad $opts $set "" $xhigh $xlow
        done

        # TODO: deal with different binnings
        highlist=$(for s in $telsetlist; do ls bad.$s.high.png 2>/dev/null; done)
        lowlist=$(for  s in $telsetlist; do ls bad.$s.low.png  2>/dev/null ; done)
        test -z "$highlist" && continue

        echo "#" $tel":" $highlist $lowlist
        convert $highlist -evaluate-sequence max bad.high.${tel,,}.png
        convert $lowlist  -evaluate-sequence max bad.low.${tel,,}.png
        badlist="bad.high.${tel,,}.png bad.low.${tel,,}.png"
        test -e bad.columns.${tel,,}.png && badlist="bad.columns.${tel,,}.png $badlist"
        test -e bad.dust.${tel,,}.png    && badlist="bad.dust.${tel,,}.png    $badlist"
        test -e bad.other.${tel,,}.png   && badlist="bad.other.${tel,,}.png   $badlist"
        test -e badpix.${tel,,}.old.png  && badlist="badpix.${tel,,}.old.png  $badlist"
        convert $badlist  -evaluate-sequence max badpix.${tel,,}.png
        for f in $badlist badpix.${tel,,}.png
        do
            echo $tel/$f
            convert $f pbm:- | pgmhist | grep 255
        done
    done
    
    msg="# Displaying badpixel masks and check images ..."
    ! match image "$SKIPPARTS" && for tel in $tellist
    do
        telsetlist=$(AIsetinfo -o | awk -v t=$tel -v sl="$slist" '{
            if (tolower($12)==tolower(t) && $9>4 && sl~$1) {print $1}}')
        test -z "$telsetlist" && continue
        test ! -e badpix.${tel,,}.png && continue
        test "$msg" && echo $msg && msg=""
        difflist=$(for s in $telsetlist; do ls bad.$s.diff.pgm 2>/dev/null; done)
        # identify clusters of bad pixels
        convert badpix.${tel,,}.png -define convolve:scale=0.00392 -morphology Convolve Disk:3.5 \
            pgm:- | pnmccdred2 -a -2 - - | convert - -morphology Dilate Disk:5 bad.clust.png
        AIexamine -n $tel badpix.${tel,,}.png bad.clust.png $difflist &
    done
}


_stack () {
    # GUI program options may be passed by env variable AO_STACK
    local stackopts
    local ctype="average"
    local rtype="bilinear"
    local retval=0
    local tellist
    local tel
    local slist
    local set
    local bopts
    local img
    local ext
    local str
    local target
    local filter
    local texp
    local nexp
    local bgcol
    local bgg
    local rlim
    local fwhm
    local object
    local telid
    local bin
    local bgoff
    local imlist
    local last
    local has_saoimage
    local sopt
    local x
    
    # normal stacking for all sets (default: resampling_type lanczos3)
    # DSLR with fwhm < 2.8pix use: -r bilinear
    # CCD  with fwhm < 2.5pix use: -r bilinear
    # TODO: exclude some images in case AIregister has failed, e.g. if nmag=0
    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" && return
    msg="# Stacking images ..."

    if [ "$OVERWRITE" ] && ! match proc "$SKIPPARTS"
    then
        echo "# deleting previous results of" $slist
        _remove -x stack
        test $? -ne 0 && return 255
    fi
    
    ! match proc "$SKIPPARTS" && for set in $slist
    do
        test $retval -ne 0 && continue
        test "$msg" && echo $msg && echo "# AI_EXCLUDE=$AI_EXCLUDE" && msg=""
        # TODO: improve checking of existing stack, improve warning message
        test -e $set.head &&
            echo "WARNING: output header file $set.head already exists" &&
            continue

        tel=$(get_telescope $set | awk '{printf("%s\n", tolower($0))}')
        test -z "$tel" &&
            echo "WARNING: unknown telid for set $set, skipping set." &&
            continue
        bopts=""
        test -e badpix.$set.png &&
            bopts="$bopts -bad badpix.$set.png" &&
            echo "# using badpix.$set.png"
        test -z "$bopts" && test -e badpix.$tel.png &&
            bopts="$bopts -bad badpix.$tel.png" &&
            echo "# using badpix.$tel.png"
        stackopts="$AO_STACK"
        echo "# running: AIstack" $stackopts $bopts "-t $ctype -r $rtype $set"
        AIstack $stackopts $bopts -t $ctype -r $rtype $set
        test $? -ne 0 && retval=255
        test "$stackopts" && set_header $set.head AO_STACK="$stackopts"
        # note: as of airtools-cli version 1.3 we always add pedestal to
        # calibrated light images (option "-a 100" in AIccd)
        set_header $set.head AI_BGOFF=100
    done


    # statistics (image quality)
    echo "# Stack properties:"
    echo "#set   object   telid  exp   n bin  bgg  bgoff fwhm/pix  rms  site"
    for set in $slist
    do
        img=""; ext=""; str=""
        test -f $set.pgm && img=$set.pgm && ext="pgm"
        test -f $set.ppm && img=$set.ppm && ext="ppm"
        if [ -z "$ext" ]
        then
            test -f ${set}_md.pgm && img=${set}_md.pgm && ext="pgm"
            test -f ${set}_md.ppm && img=${set}_md.ppm && ext="ppm"
        fi
        test -z "$ext" && continue
        target=$(AIsetinfo -b $set | head -1 | awk '{printf("%s",$3)}')
        texp=$(AIsetinfo -b $set | head -1 | awk '{printf("%s",$5)}')
        nlist=$(AIimlist -x -q -n $set 2> /dev/null)
        test -z "$nlist" && continue
        filter="^"$(echo $nlist | sed -e 's, ,\|^,g')
        
        # bgg fwhm object
        bgcol=16; test $ext == "pgm" && bgcol=7
        bgg=$(get_header -q $set.head AI_BGG)
        test -z "$bgg" && test -f bgdiff.dat &&
            bgg=$(grep -E "$filter" bgdiff.dat | mean - $bgcol | awk '{printf("%.0f", $1)}') &&
            set_header $set.head AI_BGG=$bgg
        if [ -f $set.$ext ]
        then
            test -f $set.src.dat || AIsource -q $set.$ext "" 5
            fwhm=$(get_header -q $set.head AI_FWHM)
            sopt=""; test "$ext" == "ppm" && sopt="-2"
            test -z "$fwhm" &&
                rlim=$(imsize $set.$ext | awk '{printf("%.0f", 0.25*sqrt($1*$1+$2*$2))}') &&
                fwhm=$(sexselect $sopt $set.src.dat  "" 0.02 $rlim 2>&1 | \
                    median - 6 | awk '{printf("%.1f", $1)}') &&
                set_header $set.head AI_FWHM=$fwhm
            object=$(get_header -q $set.head OBJECT | sed -e 's/^ *//; s/ *$//')
            if [ "$object" ]
            then
                str=" # orig. OBJECT=$object"
                test "$object" == "$target" && str=""
            fi
            set_header $set.head OBJECT=$target
        else
            fwhm=$(grep -E "$filter" reg.dat | mean - 7)
        fi
        
        # nexp telid binning bgoff rms
        nexp=$(get_header $set.head NEXP)
        telid=$(get_header -q $set.head AI_TELID)
        if [ -z "$telid" ]
        then
            telid=$(get_telescope -q $set)
            if [ "$telid" ]
            then
                set_header $set.head AI_TELID=$telid
            else
                telid="-"
            fi
        fi
        bin=$(get_header -q $set.head BINNING)
        test -z "$bin" && bin=$(get_header -q $set.head XBINNING)
        if [ "$bin" ]
        then
            set_header $set.head BINNING=$bin
        else
            bin=1
        fi
        # note: all lights now have pedestal of bgoff=100 ADU, this is
        # just for compatibility with old airtools-cli versions < 1.0
        bgoff=$(get_header -q $set.head AI_BGOFF)
        test -z "$bgoff" &&
            echo "Mayhill SSO Nerpio Bathurst" | grep -w -q $AI_SITE &&
            bgoff=100
        test -z "$bgoff" && bgoff=0
        rms=$(get_header -q $set.head AI_RMSG)
        if [ -z "$rms" ]
        then
            test "$ext" == "pgm" && rms=$(AIbg $img 10 | awk '{printf("%.1f", $3)}')
            test "$ext" == "ppm" && rms=$(AIbg $img 10 | grep "^2 " | awk '{printf("%.1f", $3)}')
            set_header $set.head AI_RMSG=$rms
        fi
        
        x=$(get_header -q $set.head AI_SITE)
        test -z "$x" && set_header $set.head AI_SITE=$AI_SITE
        printf "%-6s %-8s %-6s %3d %3d  %d  %4.0f  %3d   %5.1f  %6.1f  %s$str\n" \
            $set $target $telid $texp $nexp $bin $bgg $bgoff $fwhm $rms $AI_SITE
    done

    # evaluate fwhm across full image
    msg="# Evaluate FWHM across image"
    ! match proc "$SKIPPARTS" && for set in $slist
    do
        if [ -f $set.src.dat ] && [ ! -f $set.fwhm.png ]
        then
            test "$msg" && echo "$msg" >&2 && msg=""
            printf "# $set " >&2
            AIfwhm -n -o $set.fwhm.png $set.src.dat
        fi
    done
    x=$(for set in $slist
        do
            test -f $set.fwhm.png && echo $set.fwhm.png
        done)
    ! match plot "$SKIPPARTS" &&
        test "$x" && display $x &

    # display stacked images
    imlist=$(for set in $slist
        do
            ext="pgm"; test -f $set.ppm && ext="ppm"
            test -f $set.$ext && echo $set.$ext
        done)
    last=$(echo $imlist | awk '{print $NF}')
    if ! match image "$SKIPPARTS"
    then
        if [ "$imlist" ]
        then
            echo "# Loading stacked images ..."
            has_saoimage=$(xpaaccess -c -t "2,2" AIRTOOLS)
            AIexamine $imlist &
            if [ "$has_saoimage" != "yes" ]
            then
                # start new SAOImage window and load frames
                wait_for_saoimage
            else
                # append frames to a runnung SAOImage
                fid=$(wait_for_frame $last)
            fi
        fi
    fi

    return $retval
}

_astrometry () {
    # algorithm:
    # 1. check for image center coordinates
    # 2. run solve-field using center coordinates if available
    #     - if not succesful and image coordinates are unknown, try to get
    #       comet ephemerides and run solve-field again
    # 3. run AIwcs
    #     - if solve-field failed and image coordinates are known, try AIwcs
    #       using position angle from AI_NPA or from camera.dat
    #     - if solve-field has finished successfully improve solution using
    #       AIwcs
    #     - if AIwcs failes retry using limited number of source detections
    # notes about optional env variables to control program
    #   AO_AMASK - source mask, either name of a ds9 region file or
    #       a number representing max radius from image center to use
    #   AO_ACOOR - image center coordinates (RA,DEC) overwriting the
    #       values determined by imcoord automatically
    #       if set to "unknown" then do full sky search
    #       if set to "skipfirst" then skip solve_field and run AIwcs only
    local slist
    local set
    local ststack
    local imcoord
    local ra
    local dec
    local do_solve_field
    local pixscale
    local binning
    local opts
    local north
    local catalog
    local maglim
    local thres
    local ncat
    local x
    local msg
    local cpulim
    local fov
    local radius
    local amask
    local rlim
    local crossrad
    local sstart
    local stime
    local failed
    local wcslog=wcs/astrometry.log
    local errval
    local retval=0
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpfits=$(mktemp "$tdir/tmp_im_XXXXXX.fits")
    local tmpcat=$(mktemp "$tdir/tmp_scat_XXXXXX.fits")
    local tmpxy=$(mktemp "$tdir/tmp_xy_XXXXXX.fits")
    local tmpmask=$(mktemp "$tdir/tmp_mask_XXXXXX.reg")
    local tmpcancel=$(mktemp "$tdir/tmp_astrometry_XXXXXX.cancel")
    
    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" && return
    msg="# Astrometric calibration ..."

    if [ "$OVERWRITE" ] && ! match proc "$SKIPPARTS"
    then
        echo "# deleting previous results of" $slist
        _remove -x wcs
        test $? -ne 0 && return 255
    fi
    
    ! match proc "$SKIPPARTS" && for set in $slist
    do
        echo "$msg" && msg=""
        echo "set=$set"
        ststack=""
        test -f $set.pgm && ststack=$set.pgm
        test -f $set.ppm && ststack=$set.ppm
        test -z "$ststack" && continue
        test ! -e $set.head &&
            echo "WARNING: missing header file $set.head" && continue
        # skip processing if wcs header exists and there is no change in AO_AMASK
        amask=$(get_header -q $set.head AO_AMASK)
        test -f $set.wcs.head &&
            test "$AO_AMASK" == "$amask" &&
            echo "WARNING: WCS header file already exists." && continue
        test -d wcs || mkdir wcs
        echo -e "\nset=$set" >> $wcslog
        test "$AO_AMASK" && echo "# AO_AMASK=$AO_AMASK" | tee -a $wcslog
        
        # determine pixscale
        pixscale=""
        binning="$AO_ABINN"
        test -z "$binning" && binning=$(get_header -q $set.head BINNING)
        test -z "$binning" && binning=$(get_header -q $set.head XBINNING)
        test -z "$binning" && binning=1
        pixscale=$(get_param camera.dat pixscale $set | \
            awk -v b=$binning '{print $1*b}')
        test -z "$pixscale" &&
            echo "ERROR: unknown pixscale in $set" && continue
        # FOV diameter in degrees
        fov=$(imsize $ststack | awk -v p=$pixscale '{
            d=sqrt($1*$1+$2*$2)*p/3600
            if (d>1.501) {
                printf("%.1f", d)
            } else {
                printf("%.2f", d)
            }}')

        # check for image center coordinates
        do_solve_field=1
        north=""
        imcoord=$(imcoord $set 2>/dev/null)
        test "$AO_ACOOR" && case $AO_ACOOR in
            unknown)    imcoord="";;
            skipfirst)  do_solve_field="";;
            *)          imcoord=${AO_ACOOR/,/ };;
        esac
        # workaraoud for missing coordinates in case of image acquisition using gacam
        test "$imcoord" == "00:00:00.0 +00:00:00" &&
            test "$(get_header $set.head AI_SITE)" == "Weimar" &&
            imcoord=""

        # run solve-field if necessary
        errval=0
        opts=""
        if [ "$do_solve_field" ]
        then
            sstart=$(date +"%s")
            ! type -p solve-field > /dev/null &&
                error "program solve-field (astrometry.net) is not installed."
            
            # using approx center coordinates (sexagesimal) in solve-field
            if [ "$(echo $imcoord)" ]
            then
                radius=$(echo $fov | awk '{print 1.0+1*$1}')
                cpulim=60
                set - $imcoord
                opts="--ra $1 --dec $2 --radius $radius"
            else
                cpulim=120
            fi
            # range of pixel scales to check (+-20%)
            opts="$opts "$(echo $pixscale | awk -v t=20 '{
                x=1+t/100
                printf("-L %.1f -H %.1f -u app", $1/x-0.1, $1*x+0.1)}')
            # image dimension and source catalog columns to use
            set - $(imsize $ststack)
            opts="$opts -w $1 -e $2 -X XWIN_IMAGE -Y YWIN_IMAGE -s MAG_AUTO -a"

            # select sources from image
            test ! -e $set.src.dat && AIsource -q $ststack
            x=""
            is_ppm $ststack && x="-2"
            rlim=""
            test "$AO_AMASK" && is_number "$AO_AMASK" && rlim=$AO_AMASK
            sexselect -f $x $set.src.dat "" 0.01 "$rlim" "" "" 99 > $tmpcat
            stilts tcopy ifmt=fits ofmt=fits-basic in=$tmpcat"#2" out=$tmpxy
            nsrc=$(get_header $tmpxy NAXIS2)
            # TODO: if nsrc < 200 relax detections
            x=""
            test "$rlim" && x="(limited to r<$rlim pix)"
            echo "# $nsrc sources selected" $x

            # run solve-field
            tmpsolve="tmp_${set}_solve_$RANDOM"
            echo "# running: solve-field -O -p -l $cpulim $opts $tmpxy" | tee -a $wcslog
            sleep 1
            rm -f $tmpcancel
            solve-field -O -C $tmpcancel -o $tmpsolve -p -l $cpulim $opts $tmpxy >> $wcslog
            errval=$?
            
            # cancel solve-field process if failed
            (test ! $errval -eq 0 || test ! -s $tdir/$tmpsolve.wcs) &&
                echo "# first attempt failed" | tee -a $wcslog &&
                touch $tmpcancel
            
            # if required try second time using comet coordinates
            if [ $errval -ne 0 ] && [ -z "$imcoord" ] &&
                get_mpcephem -w $set 2>/dev/null
            then
                radius=$(echo $fov | awk '{print 0.5+0.5*$1}')
                cpulim=60
                imcoord=$(imcoord -c $set 2>/dev/null)
                set - $imcoord
                opts="--ra $1 --dec $2 --radius $radius $opts"
                echo "# running: solve-field -O -p -l $cpulim $opts $tmpxy" | tee -a $wcslog
                sleep 1
                rm -f $tmpcancel
                solve-field -O -C $tmpcancel -o $tmpsolve -p -l $cpulim $opts $tmpxy >> $wcslog   
                errval=$?
                (test ! $errval -eq 0 || test ! -s $tdir/$tmpsolve.wcs) &&
                    echo "# second attempt failed" | tee -a $wcslog
            fi
            
            # get ra dec north from solve-field solution
            if [ $errval -eq 0 ] && [ -s $tdir/$tmpsolve.wcs ]
            then
                wcsinfo $tdir/$tmpsolve.wcs > x.wcsinfo
                set - $(grep -wE "^orientation|^ra_center_hms|^dec_center_dms" x.wcsinfo)
                north=$(echo $2 | awk '{print -1*$1}')
                imcoord="$4 $6"
                stime=$(date +"%s" | awk -v s=$sstart '{printf("%d", $1-s)}')
                echo "# image center from solve-field (${stime}s): $imcoord"
                #set_header $set.head RA="$4" DEC="$6"
                mv $tdir/$tmpsolve.wcs wcs/$set.an.wcs &&
                    (cd $tdir; rm -f $tmpsolve.* ${tmpsolve}-indx.xyls) &&
                    rm x.wcsinfo
            else
                touch $tmpcancel
            fi
        fi
        test $errval -ne 0 &&
            failed="$failed $set" &&
            echo "ERROR: solve-field failed for $set" >&2 &&
            retval=255 && continue
        

        # choose sensible parameters for AIwcs
        # determine density of image sources
        set - $(sdensity -q -a $set) x
        test $# -ne 4 &&
            echo "ERROR: unable to determine star density." >&2 && return 255
        dens=$1; nsrc=$2; area=$3
        
        # choose catalog, initial maglim and thres
        catalog="ucac4"; maglim=""; thres=10
        test ${area%.*} -gt 2 && maglim=15.5
        test ${area%.*} -gt 4 && maglim=15
        test ${area%.*} -gt 6 && maglim=14.5
        test ${area%.*} -gt 9 && catalog="ppmx" && maglim=14
        test ${area%.*} -gt 14 && maglim=13.5
        test ${area%.*} -gt 20 && maglim=13
        test ${area%.*} -gt 40 && maglim=12
        test ${area%.*} -gt 80 && maglim=11
        test ${area%.*} -gt 150 && maglim=10
        test ${area%.*} -gt 300 && maglim=9
        test ${area%.*} -gt 600 && maglim=8
        test $nsrc -gt 2000 && thres=20
        test $nsrc -gt 5000 && thres=30
        test $nsrc -gt 10000 && thres=40
        test $nsrc -gt 15000 && thres=60
        test $nsrc -gt 30000 && thres=100
        test $nsrc -gt 50000 && thres=150
        test $nsrc -gt 80000 && thres=200
        test $nsrc -gt 120000 && thres=300
        test $nsrc -gt 200000 && thres=400
        test $nsrc -gt 20000 && maglim=$(echo $maglim 16 | awk '{print $1-0.5}')
        test $nsrc -gt 50000 && maglim=$(echo $maglim 16 | awk '{print $1-0.5}')

        # options for AIwcs
        opts=""
        test "$AO_ABINN" && opts="-b $AO_ABINN"
        test "$imcoord" && opts="$opts -c $imcoord"
        test "$north"   && opts="$opts -n $north"
        # set max position uncertainty (in deg)
        test "$errval" == "0" && opts="$opts -o $(echo $fov | awk '{print 0.1+0.1*$1}')"
        test "$errval" != "0" && opts="$opts -o $(echo $fov | awk '{print 1.0+1.0*$1}')"
        if [ "$AO_AMASK" ]
        then
            if [ -e $AO_AMASK ] && is_reg $AO_AMASK
            then
                opts="$opts -m $AO_AMASK"
                set_header $set.head AO_AMASK=$AO_AMASK
            else
                if is_number $AO_AMASK
                then
                    imsize $ststack | awk '{printf("center %d %d\n", $1/2, $2/2)}' | \
                        xy2reg $ststack - "" "" $AO_AMASK > $tmpmask
                    opts="$opts -m $tmpmask"
                    set_header $set.head AO_AMASK=$AO_AMASK
                else
                    echo "WARNING: cannot handle AO_AMASK=$AO_AMASK"
                fi
            fi
        fi
        
        # on low resolution images set crossid_radius expert options in AIwcs
        crossrad=""
        test ${pixscale%.*} -gt 3 &&
            crossrad=$(echo $pixscale | awk '{printf("%.0f", 0.6*$1)}')

        if [ "$imcoord" ]
        then
            # download reference catalog, determine star density, adjust maglim
            echo "# downloading reference catalog ..."
            AIwcs -z $opts $set $catalog "$maglim" $thres >> $wcslog 2>&1
            x=wcs/$set.$catalog.dat
            test "$catalog" == "ucac4" && x=wcs/$set.ucac-4.dat
            ncat=$(listhead $x"[2]" | grep NAXIS2 | awk '{printf("%d", $3)}')
            x=$(( (ncat-200)/(nsrc+100) ))
            test $x -gt 2  &&
                printf "# nsrc=$nsrc ncat=$ncat maglim=$maglim" &&
                maglim=$(echo $maglim 16 | awk '{print $1-0.5}')
            test $x -gt 4  && maglim=$(echo $maglim 16 | awk '{print $1-0.5}')
            test $x -gt 7  && maglim=$(echo $maglim 16 | awk '{print $1-0.5}')
            test $x -gt 10 && maglim=$(echo $maglim 16 | awk '{print $1-0.5}')
            test $x -gt 2  &&
                printf " -> $maglim\n"

            # determine differential refraction
            set - $imcoord
            alt=$(echo $(sexa2dec $1 15) $(sexa2dec $2) | rade2altaz $set - | \
                awk '{printf("%.1f", $2)}')
            # increase crossid_radius on large values of differential refraction
            set - $(echo $alt $fov | awk -v T=10 -v P=101 '{
                    # a = the object’s true altitude in degrees
                    # P = atmospheric pressure in kPa.
                    # T = temperature in Celsius.
                    # computing refraction angle in arcmin
                    a=$1-$2/2
                    x=(a + (10.3/(a + 5.11)))*3.1415926/180
                    rlow = 1.02*cos(x)/sin(x) * P/101 * (283/(273 + T))
                    a=$1+$2/2
                    x=(a + (10.3/(a + 5.11)))*3.1415926/180
                    rhigh = 1.02*cos(x)/sin(x) * P/101 * (283/(273 + T))
                    crossrad=3*(rlow-rhigh)
                    printf("%.1f %.1f %.0f\n", rlow, rhigh, crossrad)
                }')
            echo "# alt=$alt fov=$fov rlow=$1 rhigh=$2"
            x=$(echo $3 $crossrad 2 | awk '{if($1>$2){print $1}}')
            if [ "$x" ]
            then
                crossrad=$x
                printf "# using crossid_radius $crossrad (low altitude image)"
                # crossrad in pixels
                x=$(echo $crossrad $pixscale | awk '{printf("%.0f", $1/$2)}')
                # lower maglim
                test $x -gt 2 &&
                    printf ", maglim=$maglim" &&
                    maglim=$(echo $maglim 16 | awk '{print $1-0.5}')
                test $x -gt 4 && maglim=$(echo $maglim 16 | awk '{print $1-0.5}')
                test $x -gt 6 && maglim=$(echo $maglim 16 | awk '{print $1-0.5}')
                test $x -gt 2 &&
                    printf " -> $maglim"
                printf "\n"
            fi
        fi
        test "$crossrad" && opts="$opts -cr $crossrad"
        
        # running AIwcs
        echo "# running: AIwcs" $opts "$set $catalog \"$maglim\" $thres" | tee -a $wcslog
        AIwcs $opts $set $catalog "$maglim" $thres >> $wcslog 2>&1
        if [ $? -ne 0 ]
        then
            tail -1 $wcslog
            maglim=$(echo $maglim 16 | awk '{print $1-1.0}')
            echo "# running: AIwcs" $opts "$set $catalog \"$maglim\" $thres" | tee -a $wcslog
            AIwcs $opts $set $catalog "$maglim" $thres >> $wcslog 2>&1
        fi
        test $? -ne 0 && retval=255 &&
            failed="$failed $set" &&
            tail -1 $wcslog &&
            test -e $set.wcs.head && mv $set.wcs.head x.$set.wcs.failed.head
        # TODO: if AIwcs failed check ncat: e.g. get_header -e LDAC_OBJECTS wcs/sa01.ucac-4.dat NAXIS2
        #   if it is > 3*nimg limit to 2*nimg, otherwise limit to 40% of ncat
        #   unfortunately the catalog file does not fill the mag column (it is always 0)
    done
    test $retval -ne 0 &&
        echo "ERROR: wcs calibration failed for $failed"
    
    # display results parsing $set.wcs.head
    msg="# Summary for astrometry:
# set  xrms    yrms     nimg  ncat nmatch nhigh  pscale north"
    x=""
    for set in $slist
    do
        test -f $set.wcs.head || continue
        test "$msg" && echo "$msg" && msg=""
        north=$(get_wcsrot $set)
        pixscale=$(get_wcspscale $set)
        echo $(get_header -s $set.wcs.head ASTRRMS1,ASTRRMS2,NIMG,NCAT,NMATCH,NHIGH) | \
            awk -v s=$set -v p=$pixscale -v n=$north '{
                printf("%s:  %.3f\"  %.3f\"", s, $1*3600, $2*3600)
                if(NF==6) {
                    printf("  %5d %5d  %5d %5d ", $3, $4, $5, $6)
                    fmt="%6.3f %6.1f\n"; if (p>=10) fmt="%5.2f  %6.1f\n"
                    printf(fmt, p, n)
                } else {
                    printf("\n")
                }}'
        x="$x $(echo $(ls -1 wcs/$set.*.png))"
    done
    ! match plot "$SKIPPARTS" &&
        test "$x" && display $x &
    test $retval -eq 0 && rm -f $tmpfits $tmpcat $tmpxy $tmpmask
    # rm -f $tmpcancel
    return $retval
}

_costack () {
    local stackopt
    local slist
    local set
    local msg
    local ext
    local params
    local val
    local oxy
    local omove
    local object
    local retval=0

    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" && return
    msg="# Stacking on comet ..."

    if [ "$OVERWRITE" ] && ! match proc "$SKIPPARTS"
    then
        echo "# deleting previous results of" $slist
        _remove -x costack
        test $? -ne 0 && return 255
    fi
    
    ! match proc "$SKIPPARTS" && for set in $slist
    do
        test ! -f $set.head && continue
        ext=""
        test -f $set.pgm && ext="pgm"; test -f $set.ppm && ext="ppm"
        test -z "$ext" && continue
        test -f ${set}_m.$ext && continue
        test "$msg" && echo $msg && echo "# AI_EXCLUDE=$AI_EXCLUDE" && msg=""
        
        # get ephemerides
        set - $(get_header -q -s $set.head AI_CORA,AI_CODEC,AI_OMOVE) xx
        if [ $# -eq 4 ]
        then
            echo "# $set: reusing motion vector (AI_OMOVE)"
        else
            echo "# $set: get ephemerides from MPC"
            object=$(get_header -q $set.head OBJECT)
            get_mpcephem -w $set 2>/dev/null
            test $? -ne 0 &&
                echo "WARNING: skipping $set: object $object is not a known comet." && continue
        fi
        
        # check for astrometric calibration
        test ! -f $set.wcs.head &&
            echo "ERROR: missing astrometric calibration for $set" && retval=255 && continue

        params=""
        val=$(get_header $set.head BADPIX);   test "$val" && params="-bad $val"
        val=$(get_header $set.head RESAMPT1); test "$val" && params="$params -r $val"
        set - $(get_header -q -s $set.head AI_CORA,AI_CODEC,AI_OMOVE) xx
        test $# -ne 4 &&
            echo "# skipping $set (missing comet header keywords)" >&2 && continue
        oxy=$(echo $set $1 $2 | rade2xy - $set.wcs.head | awk '{printf("%.0f,%.0f", $2, $3)}')
        omove=$3
        # if necessary add -bz 5000
        stackopt=$(get_header -q $set.head AO_STACK)
        echo "# running: AIstack" $stackopt $params -o \"_m\" -c $set.$ext -m $omove@$oxy $set
        AIstack $stackopt $params -o "_m" -c $set.$ext -m $omove@$oxy $set
        test $? -ne 0 && retval=255 && continue
        
        # setting some header keywords
        set_header ${set}_m.head OBJECT=$target
        set_header $set.head AI_COMST=${set}_m.$ext
    done

    # display stacked images
    imlist=$(for set in $slist
        do
            ext="pgm"; test -f ${set}_m.ppm && ext="ppm"
            test -f ${set}_m.$ext && echo ${set}_m.$ext
        done)
    last=$(echo $imlist | awk '{print $NF}')
    if ! match image "$SKIPPARTS"
    then
        if [ "$imlist" ]
        then
            echo "# Loading stacked images ..."
            has_saoimage=$(xpaaccess -c -t "2,2" AIRTOOLS)
            AIexamine $imlist &
            if [ "$has_saoimage" != "yes" ]
            then
                # start new SAOImage window and load frames
                wait_for_saoimage
            else
                # append frames to a runnung SAOImage
                fid=$(wait_for_frame $last)
            fi
        fi
    fi
    return $retval
}


#------------------------------------
#   comet extraction and photometry
#------------------------------------

_load_stacks () {
    local slist
    local set
    local msg
    local ststack
    local costack
    local ext
    local idststack
    local idcostack

    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" && return
    msg="# Launch SAOImage AIRTOOLS ..."
    ! match image "$SKIPPARTS" && for set in $slist
    do
        #test $retval -ne 0 && continue
        #echo "$msg"
        msg=""
        ststack=""
        ext=""
        test -f $set.pgm && ststack=$set.pgm && ext="pgm"
        test -f $set.ppm && ststack=$set.ppm && ext="ppm"
        test -z "$ststack" &&
            error "missing star stack for set $set"
        test ! -e $set.head &&
            error "missing header file $set.head"
        #test ! -f $set.wcs.head &&
        #    echo "WARNING: missing WCS header file $set.wcs.head"
        costack=$(get_header $set.head AI_COMST)
        #test -z "$costack" &&
        #    echo "WARNING: missing comet stack for set $set"
        test "$costack" && test ! -f $costack &&
            echo "WARNING: missing comet stack $costack for set $set"
        
        # check for bg subtracted images
        test -f ${ststack%.*}.bgs.$ext &&
            ststack=${ststack%.*}.bgs.$ext
        test "$costack" && test -f ${costack%.*}.bgs.$ext &&
            costack=${costack%.*}.bgs.$ext
        # TODO: replace corrupted header files
        test ! -e ${ststack%.*}".head" &&
            ln -s $set.head ${ststack%.*}".head"
        test "$costack" && test ! -e ${costack%.*}".head" &&
            ln -s $set.head ${costack%.*}".head"

        # check for running SAOImage AIRTOOLS
        xpaaccess -c -t "2,2" AIRTOOLS > /dev/null
        if [ $? -eq 0 ]
        then
            # start SAOImage and load frames
            echo "# loading $ststack $costack ..."
            AIexamine $ststack $costack &
            wait_for_saoimage
        else
            # append frames to a runnung SAOImage if not already loaded
            idststack=$(get_frameno $ststack)
            test "$costack" && idcostack=$(get_frameno $costack)
            if [ -z "$idststack" ]
            then
                echo "# loading $ststack ..."
                AIexamine $ststack &
                idststack=$(wait_for_frame $ststack)
            fi
            test "$costack" && if [ -z "$idcostack" ]
            then
                echo "# loading $costack ..."
                AIexamine $costack &
                idcostack=$(wait_for_frame $costack)
            fi
            #echo "idststack=$idststack"
            xpaset -p AIRTOOLS frame $idststack
        fi
    done < set.dat
    return 0
}

_ds9cmd () {
    # note: all tasks related to comet photometry must start with set name or image
    #   image - bggradient
    #   set   - psfextract, cometextract, manualdata, photcal
    local cmd=$1
    local set=$2
    local msg="# ds9cmd"
    local ststack
    local fid
    local i
    local arg
    
    # quote arguments with special characters
    for i in $(seq 1 $#)
    do
        arg=${!i}
        if [ "$arg" ] && [ "${arg/ /}" == "$arg" ] && [ "${arg/-/}" == "$arg" ]
        then
            msg="$msg $arg"
        else
            msg="$msg \"$arg\""
        fi
    done
    echo "$msg"
    
    # determine name of star stack
    test -f "$set" && ststack=$set
    if [ -z "$ststack" ]
    then
        ! is_setname "$set" &&
            error "unknown image set $set"
        test -f $set.bgs.ppm && ststack=$set.bgs.ppm
        test -z "$ststack" && test -f $set.bgs.pgm && ststack=$set.bgs.pgm
        test -z "$ststack" && test -f $set.ppm && ststack=$set.ppm
        test -z "$ststack" && test -f $set.pgm && ststack=$set.pgm
        test -z "$ststack" &&
            error "missing star stack for set $set"
        test ! -e $set.head &&
            error "missing header file $set.head"
    fi
    # check for running SAOImage AIRTOOLS
    if [ "$cmd" != "photcal" ]
    then
        xpaaccess -c -t "2,2" AIRTOOLS > /dev/null
        if [ $? -eq 0 ]
        then
            # load star stack
            echo "# loading $ststack ..."
            AIexamine $ststack &
            fid=$(wait_for_frame $ststack)
        fi
    fi

    false && (
    # display star stack
    fid=$(get_frameno $ststack)
    if [ -z "$fid" ]
    then
        echo "# loading $ststack ..."
        AIexamine $ststack &
        wait_for_frame $ststack
    else
        # activate frame $fid
        case "$1" in
            aladindss)
                xpaset -p AIRTOOLS frame $fid
                ;;
        esac
    fi
    )
    
    if [ "$OVERWRITE" ]
    then
        ds9cmd -o "$@"
    else
        ds9cmd "$@"
    fi
    return $?
}


#-------------------------
#   miscellaneous tools
#-------------------------
__load_images () {
    # library function called by _imexa_calib and _imexa_raw
    # loading calibrated or raw images in SAOImage AIRTOOLS window
    # pass list of image numbers as arguments
    local raw   # if set use raw images instead of calibrated images
    test "$1" == "-r" && raw=1 && shift 1
    local slist
    local nlist
    local opts="-q" # AIimlist option
    local set
    local msg
    local num
    local imlist
    local n
    local first
    local last
    local has_saoimage
    local fid
    local retval=0
    local tmp1=$(mktemp "/tmp/tmp1_$$_XXXXXX.dat")
    #local tmp2=$(mktemp "/tmp/tmp2_$$_XXXXXX.dat")

    # checking args
    test $# -eq 0 &&
        echo "ERROR: missing arguments" >&2 &&
        rm -f $tmp1 && return 255
    echo $@ | grep -q "[a-z]" && slist=$@
    test -z "$slist" && test -z "$(echo $@ | tr -d '[0-9 ,-]')" &&
        nlist=$(mknlist $@ | sort -u)
    test -z "$slist" && test -z "$nlist" && test "$@" &&
        echo "ERROR: unsupported (mixed) arguments" >&2 &&
        rm -f $tmp1 && return 255
    test "$slist" && test ! -s set.dat &&
        echo "ERROR: missing set.dat" >&2 &&
        rm -f $tmp1 && return 255

    # searching images
    msg="# Searching images ..."
    test "$slist" && for set in $slist
    do
        ! is_setname $slist &&
            echo "WARNING: unknown set $set" >&2 && continue
        test "$msg" && echo $msg && msg=""
        test -z "$raw" && AIimlist -f $opts $set >> $tmp1
        test    "$raw" && AIimlist -f $opts $set "" raw >> $tmp1
    done
    test "$nlist" && for num in $nlist
    do
        echo $AI_EXCLUDE | grep -q -w $num && continue
        get_rawfile $num > /dev/null 2>&1 || continue
        test -z "$raw" && test -s $AI_TMPDIR/$num.ppm &&
            echo $AI_TMPDIR/$num.ppm && continue
        test -z "$raw" && test -s $AI_TMPDIR/$num.pgm &&
            echo $AI_TMPDIR/$num.pgm && continue
        test    "$raw" && get_rawfile $num 2>&1
    done > $tmp1
    ! test -s $tmp1 && echo "WARNING: no images found" >&2 &&
        rm -f $tmp1 && return
    
    # extract number and filename, sort unique entries
    n=$(cat $tmp1 | wc -l)
    imlist=$(cat $tmp1 | tr '\n' ' ')
    first=$(lines 1 $tmp1)
    last=$(tail -1 $tmp1)
    echo "# Loading $n images ..."
    test ! -d bgvar && mkdir bgvar # to allow storage of bad region files

    # check for running SAOImage AIRTOOLS
    has_saoimage=$(xpaaccess -c -t "2,2" AIRTOOLS)
    AIexamine $imlist &
    if [ "$has_saoimage" != "yes" ]
    then
        # start new SAOImage window and load frames
        test "$AI_DEBUG" && echo "# running wait_for_saoimage ..." >&2
        wait_for_saoimage
    else
        # append frames to a runnung SAOImage
        test "$AI_DEBUG" && echo "# running wait_for_frame ..." >&2
        fid=$(wait_for_frame $last)
    fi

    rm -f $tmp1 $tmp2
    return 0
}

_imexa_calib () {
    # examine calibrated images
    __load_images $@
}

_imexa_raw () {
    # examine raw images
    __load_images -r $@
}

_remove () {
    # provide parts by arguments
    local do_execute
    test "$1" == "-x" && do_execute=1 && shift 1
    
    local plist=$@
    local allparts="calib,bgvar,badpix,register,stack,wcs,costack"
    local part
    local slist
    local set
    local msg
    local nlist
    local num
    local ext
    local flist
    local tel
    local n
    local f
    local tmp1=$(mktemp "/tmp/tmp1_$$_XXXXXX.dat")

    #slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" &&
        error "you must provide at least one set name."
    for set in $slist
    do
        AIsetinfo -b $set
    done
    for set in $slist
    do
        nlist="$nlist $(AI_EXCLUDE="" AIimlist -x -n $set)"
    done
    
    # parts to remove
    test -z "$plist" && plist="$allparts"
    n=$(echo ${plist//,/ } | wc -w)
    test $n -eq 1 && test "${plist%+}" != "$plist" &&
        plist=$(echo $allparts | sed -e 's|.*'${plist%+}'|'${plist%+}'|')
    test "$AI_DEBUG" && echo $plist >&2
    
    # per image result files
    for num in $nlist
    do
        if match calib "$plist"
        then
            f=$AI_TMPDIR/$num.ppm;   test -e $f && echo "rm $f"
            f=$AI_TMPDIR/$num.pgm;   test -e $f && echo "rm $f"
        fi
        if match bgvar "$plist"
        then
            f=bgvar/$num.bgm1.ppm;   test -e $f && echo "rm $f"
            f=bgvar/$num.bgm1.pgm;   test -e $f && echo "rm $f"
            f=bgvar/$num.bgdiff.ppm; test -e $f && echo "rm $f"
            f=bgvar/$num.bgdiff.pgm; test -e $f && echo "rm $f"
        fi
        if match reg "$plist"
        then
            f=measure/$num.src.dat;  test -e $f && echo "rm $f"
            f=measure/$num.src.head; test -e $f && echo "rm $f"
        fi
    done | sort > $tmp1
    for num in $nlist
    do
        if match darks "$plist"
        then
            test -s mstat.dk.dat &&
                echo "sed -r -i '/^\S+\s+$num /d' mstat.dk.dat"
        fi
        if match bgvar "$plist"
        then
            test -s bgdiff.dat && echo "sed -i '/^$num.bgdiff/d' bgdiff.dat"
            test -s bgsfit.dat && echo "sed -i '/^$num /d' bgsfit.dat"
        fi
        if match reg "$plist"
        then
            test -s reg.dat    && echo "sed -i '/^$num /d' reg.dat"
        fi
    done >> $tmp1

    # per imageset result files
    for set in $slist
    do
        if match darks "$plist"
        then
            flist=$(ls $set.pgm n$set.sd.pgm $AI_TMPDIR/$set.* 2>/dev/null)
            test "$flist" && for f in $flist
            do
                test -f $f && echo "rm $f"
            done
        fi
        if match flats "$plist"
        then
            flist=$(ls $set.pgm $set.norm.pgm $AI_TMPDIR/$set.* 2>/dev/null)
            test "$flist" && for f in $flist
            do
                test -f $f && echo "rm $f"
            done
        fi
        if match bgvar "$plist"
        then
            flist=$(ls varbgm*.$set.* 2>/dev/null)
            test "$flist" && for f in $flist
            do
                test -f $f && echo "rm $f"
            done
        fi
        if match badpix "$plist"
        then
            flist=$(ls bad.$set.* 2>/dev/null)
            test "$flist" && for f in $flist
            do
                test -f $f && echo "rm $f"
            done
        fi
        if match stack "$plist"
        then
            flist=$(ls $set.*{pgm,ppm,head,src.dat,fits.gz} 2>/dev/null)
            test "$flist" && for f in $flist
            do
                test $f == $set.wcs.head && continue
                test $f == $set.head && backup -e $set.head
                test -e $f && echo "rm $f"
            done
        fi
        if match wcs "$plist"
        then
            flist=$(ls $set.wcs.* wcs/$set.* 2>/dev/null)
            test "$flist" && for f in $flist
            do
                test $f == $set.wcs.head && backup -e $set.wcs.head
                test -e $f && echo "rm $f"
            done
        fi
        if match costack "$plist"
        then
            flist=$(ls ${set}_m.*{pgm,ppm,head,fits.gz} 2>/dev/null)
            test "$flist" && for f in $flist
            do
                test $f == ${set}_m.head && backup -e ${set}_m.head
                test -e $f && echo "rm $f"
            done
            # remove header keywords
            set_header $set.head AI_CORA="" AI_CODEC=""
        fi
    done >> $tmp1
    
    # TODO: per telescope result files
    # e.g. dk.var10.NVG.pgm
    for set in $slist
    do
        if match darks "$plist"
        then
            tel=$(get_telescope $set)
            flist=$(ls dk.var10.$tel.pgm 2>/dev/null)
            test "$flist" && for f in $flist
            do
                test -f $f && echo "rm $f"
            done
        fi
    done | sort -u >> $tmp1

    # per task result files
    if match badpix "$plist"
    then
        flist=$(ls badpix.* 2>/dev/null)
        test "$flist" && for f in $flist
        do
            ! test -L $f && echo "rm $f"
        done
    fi >> $tmp1

    # run commands if requested
    if [ -s $tmp1 ]
    then
        # exit on first error
        sed -i '1i\set -e' $tmp1

        if [ "$do_execute" ]
        then
            bash $tmp1
            test $? -ne 0 &&
                echo "ERROR: failed command: bash $tmp1" >&2 && return 255
        else
            echo "Run: bash $tmp1"
        fi
    else
        echo "# No files to remove."
        rm $tmp1
    fi
    return 0
}

_usercmd () {
    local msg="# Execute: $usercmd"
    # quote arguments with special characters
    for i in $(seq 1 $#)
    do
        arg=${!i}
        if [ "$arg" ] && [ "${arg/ /}" == "$arg" ] && [ "${arg/-/}" == "$arg" ]
        then
            msg="$msg $arg"
        else
            msg="$msg \"$arg\""
        fi
    done
    
    echo "$msg"
    test "$AI_DEBUG" && echo "nargs=$#"
    $usercmd "$@"
    return $?
}

_terminal () {
    # start x-terminal in projectdir and load airfun.sh
    x-terminal-emulator -e \
        "env PROMPT_COMMAND=\"unset PROMPT_COMMAND; . .airtoolsrc;
        . $(type -p airfun.sh)\" bash" &
}


#-------------------------
#   diagnostic tools
#-------------------------
_status () {
    echo "# Show processing info and diagnostic plots ..."
    AIsetinfo -b
    test -e reg.dat && (
        AIplot -t "FWHM in pixel" -p reg.dat 7
        AIplot -t "Mag difference to reference image" -p reg.dat 10)

    SKIPPARTS="image" _stack
    SKIPPARTS="image" _astrometry
    return 0
}

_check () {
    echo "# running AIcheck ..."
    echo "# PATH=$PATH"
    AIcheck
}

_procmon () {
    delay=2
    while true
    do
        tstamp=$(date +'%Y%m%d-%H%M%S')
        ps ux | grep -vE "^USER| Sl | /usr/| /bin/| /lib/" | sed -e 's|^|'$tstamp' |'
        sleep 2
    done
}

_kill () {
    # kill process including descendants
    pid=$1
    echo "# running kill $pid ..."
    ps $pid >/dev/null && pstree -p $pid &&
        kill -9 $(pstree -A -p $pid | tr '()' '\n' | grep -E "^[0-9]+$")
}

_args () {
    local i=1
    echo "# airtools-cli: args" $@
    while test "$1"
    do
        echo "$i:  _"$1"_"
        i=$((i+1))
        shift 1
    done

    echo "# AO_ARGS = _${AO_ARGS}_"
    test -z "$AO_ARGS" && return 0
    set - ${AO_ARGS}
    i=1
    while test "$1"
    do
        echo "$i:  _"$1"_"
        i=$((i+1))
        shift 1
    done
    return 0
}



#--------------------
#   get options
#--------------------
main () {
    : # main program starts here
}
cmdline="$(basename $0) $@"  # preserve command line
verbose=0
projectdir=""
setname=""
quiet=""
usercmd=""
SKIPPARTS=""
OVERWRITE=""
while getopts hp:s:ox:c:q c
do
    case $c in
        p)  projectdir="$OPTARG";;
        s)  setname="${OPTARG//,/ }";;
        o)  OVERWRITE=1;;
        x)  SKIPPARTS="$OPTARG";;
        c)  usercmd="$OPTARG";;
        q)  quiet=1;;
        h)  longhelp; echo; task="help";;
        \?) shorthelp; exit -1;;
    esac
done
shift `expr $OPTIND - 1`


#--------------------
#   get parameter
#--------------------
if [ $# -lt 1 ] && [ -z "$usercmd" ]
then
    shorthelp; exit -1
fi
task=$1
shift 1
test "$usercmd" && task="usercmd"

# display additional info if requested
if [ "$task" == "help" ]
then
    echo "\
Available AIRTOOLS tasks:
Image reduction:
    imageinfo   - extract basic image info
    darks       - create master darks
    flats       - create master flats
    lights      - calibrate light images
    bgvar       - evaluate image background variation
    register    - register images
    stack       - stack images (on stars)
    astrometry  - astrometric calibration
    costack     - stack images on comet

Comet extraction and photometry:
    load_stacks - load stacked images

Miscellaneous tools:
    imexa_calib - load calibrated images
    imexa_raw   - load raw images
    status      - show basic results"
    exit 0
fi

# check for valid entries in skipparts
if [ "$SKIPPARTS" ]
then
    x=$(echo $SKIPPARTS | tr ',' ' ' | tr ' ' '\n' | \
        grep -vwE "proc|plot|image")
    test "$x" &&
        echo "\
WARNING: stopped processing due to unknown skipparts argument

the following arguments may be used to skip selected program parts:
    proc    - skip processing of (new) sets
    image   - do not display result images
    plot    - do not show data plots" &&
    exit 0

fi

false && case "$TASKMODE" in
    normal|nodisplay|status|statusall) ;;
    *)  echo "\
WARNING: skipped processing due to unknown task mode $TASKMODE

available task modes:
    nodisplay   - skip display of new windows (images, plots)
    status      - show available results (measurements) only
    statusall   - like status but includes image display "
        exit 0
        ;;
esac


#--------------------
#   checkings
#--------------------
# check existence of projectdir
if [ "$projectdir" ]
then
    test ! -d "$projectdir" && error "projectdir $projectdir is missing."
    cd $projectdir
fi
test ! -e $rcfile && error "not a valid airtools project (missing .airtoolsrc)"

# if requested start terminal task without any further checkings
if [ "$task" == "terminal" ]
then
    echo "# Running task $task ($(date +'%H:%M')) ..."
    _terminal
    exit $?
fi

# start logging
exec > >(tee -a $log)
exec 2>&1
test -s $log && echo -e "\n" >> $log
test ! "$quiet" &&
    echo "#### starting $(basename $0) v$VERSION at $(date +'%Y-%m-%d %H:%M')"

 
# check presence of required parameter files
for f in sites.dat camera.dat
do
    test ! -e "$f" && error "Missing file $f."
done

# check presence of required environment variables
source $rcfile
for var in day AI_SITE AI_TMPDIR AI_RAWDIR
do
    test -z "$var" && error "Variable $var undefined."
done
test ! -d $AI_TMPDIR &&
    echo "# creating temp directory $AI_TMPDIR" &&
    mkdir -p $AI_TMPDIR
test ! -d "$AI_TMPDIR" &&
    error "temp directory $AI_TMPDIR is missing."
if [ ! -d "$AI_RAWDIR" ]
then
    if ! match proc "$SKIPPARTS" &&
        match "$task" "imageinfo|darks|flats|lights|imexa_raw" 
    then
        error "raw image directory $AI_RAWDIR is missing."
    else
        echo "WARNING: raw image directory $AI_RAWDIR is missing."
    fi
fi

# check for allowed AO_* variables
varlist=$(env | grep "^AO_" | sed -e 's,=.*,,')
for var in $varlist
do
    echo "$AOVARS AO_ARGS" | \
        grep -qw $var
    test $? -ne 0 &&
        echo "ERROR: variable $var is not supported" >&2 &&
        exit 255
done

airfun=$(which airfun.sh)
echo "# airfun=$airfun"
if [ -z "$airfun" ]
then
    error "missing function definition file airfun.sh
    (PATH=$PATH)"
fi
if [ "$airfun" == "./airfun.sh" ]
then
    echo "# PWD=$PWD"
    echo "# PATH=$PATH"
    echo "WARNING: loading functions from local file airfun.sh ..."
    sleep 10
else
    test ! "$quiet" && echo "# PATH=$PATH" && echo "# loading $airfun"
fi

. $airfun > /dev/null
test ! "$quiet" &&
    echo "# AI_VERSION=$AI_VERSION" &&
    echo "# dcraw-tl $(dcraw-tl | grep "[0-9]" | head -1 | awk '{print $NF}')"
! AIcheck_ok &&
    error "Unable to initialize AIRTOOLS functions."

# check structure of parameter files
# TODO: make the check depend on parameter file format version
checkparamdat sites.dat 5 || error "Check of sites.dat failed."
checkparamdat camera.dat 15 || error "Check of camera.dat failed."
test -s "set.dat" && ! checkparamdat -s set.dat 11 && error "Check of set.dat failed."


#-----------------------
#   program start
#-----------------------
export LC_NUMERIC=C
trap "" PIPE
errcode=""

# get list of existing image sets from set.dat
setlist=""
test -e set.dat && setlist=$(grep -v "^#" set.dat | awk '{
    if ($1!~/^[0-9][0-9]:[0-9][0-9]/) next
    if ($4!="o") next
    if ($5!~/^[0-9]+$/) next
    if ($6!~/^[0-9]+$/) next
    if ($7!~/^[0-9]+$/) next
    if ($8!~/^[0-9]+$/) next
    if (NF<11) next
    printf(";%s (%s)", $2, $3)
    }')

# check for valid setname
test "${setname// /}" && for set in $setname
do
    ! is_setname $set && error "Unknown image set $set."
done

# Run task
test "$task" != "imageinfo" && test "$task" != "imexa_raw" && test "$task" != "usercmd" &&
    test "$task" != "check" && test "$task" != "kill" && test "$task" != "terminal" &&
    test ! -e "set.dat" &&
    error "Missing file set.dat."

# optional monitoring
DSTAT_PID=""
test "$AI_DSTAT" && DSTAT_PID=$(
    dstat --nocolor --noupdate --output dstat.log -tcdnmsp 5 >/dev/null &
    echo $!)
PROCMON_PID=""
test "$AI_PROCMON" && PROCMON_PID=$(
    _procmon >> procmon.log &
    echo $!)
if [ "$AI_PROFILE" ]
then
    exec 3>&2 2> >( tee /tmp/profile.$$.log |
                  sed -u 's/^.*$/now/' |
                  date -f - +%s.%N >/tmp/profile.$$.tim)
    set -x
fi

_cleanup () {
    test "$DSTAT_PID" && kill $DSTAT_PID
    test "$PROCMON_PID" && kill $PROCMON_PID
}
trap _cleanup EXIT


echo "# Running task $task ($(date +'%H:%M')) ..."
_$task "$@"
errcode=$?
test -z "$errcode" && error "Missing return code from task."
test "$errcode" == "0" && echo "# task finished at $(date +'%H:%M')"
exit $errcode

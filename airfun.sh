
########################################################################
# airfun.sh
#   shell functions aimed towards astronomical image reduction
#
# Copyright: Thomas Lehmann, 2011-2021
# License: GPL v3
#
# note:
# - you must provide a text file (default: set.dat) which describes
#   observations (image sets) as in the following two example lines:
#     # h:m set  target type texp n1 n2   nref dark flat tel # comments
#     01:03 cy01 cirr     o 120 0131 0139 0135 dk03 sk01 GSO # bin2 t=15
# - in order to use SAOImage DS9 analysis tasks (via AIexamine) you must
#   have installed files airds9.ana and aircmd.sh
########################################################################
AI_VERSION="5.1.1"
: << '----'
CHANGELOG
    5.1.1 - 07 Sep 2021
        * AIlist: added option -cs to process splitted image sets of the
            current project (under <splitdir> directory)
        * AIastrometry: added option -cs to handle splitted image sets,
            fallback to measure nuclear object magnitude if large aperture
            photometry data are missing
        * AIsetinfo: show alt/az (instead of ha) when using option -l
        * cometname: handle un-numbered asteroids and deal with comets that
            have kept provisional designation of asteroids
        * mpcreport: handle numbered and un-numbered asteroids
        * mpchecker: added option -o to create region file <set>.mpcast.reg
            containing objects
        * get_mpcephem, get_jplcoord: save reference of elements (e.g. MPEC)
        * set_header: added option -s which forces value of string type
        * new function: raw2obs AIsplitstack

    5.1 - 01 Aug 2021
        * new environment variables AI_OBSICQID AI_OBSNAME AI_OBSADDRESS
            AI_OBSEMAIL
        * AIccd: if using DSLR camera then convert hotpix file in PNG format
            to text file suitable as input to dcraw
        * AIlist: write output to text file ailist.txt in project dir
        * AImapphot, AIastrometry: reuse object center if entry exists in
            center.dat
        * icqplot: always include measurements of current project
        * icqsort: fixed sorting of unnumbered comets
        * get_cobs: work around buggy date program in Ubuntu 20.04
        * cometcenter: default dir for checkimages changed to chkctr
        * cometname: handle numbered asteroids
        * mpchecker: with setname as single argument search for all objects
        * new function vcomp

    5.1a4 - 16 Jul 2021
        * sites.dat: add column COD (MPC observatory code)
        * icqplot:
            - bugfix for perihelion distance in case of hyperbolic elements
            - rewrite of heliocentric mag and linear coma size plots
            - grab (and reuse) all observations of a comet from COBS
            - allow highlighting data according to software key
            - remove local observations record if COBS observation with the
              same date exists
            - plot to png (using pngcairo) instead of eps by default
        * mktics: create larger range of tic labels
        * gplinfit: avoid start value of 0 for fit coefficients
        * AIplot: use gplinfit for fitting
        * new functions: AIdisplay datefmt

    5.1a3 - 30 Jun 2021
        * icqplot: bugfix to correctly place xtics labels if unit is month
        * icqsort: bugfix to correctly sort short period comets
        * get_header: use awk to fetch value for speed improvement, add
            option -l to print all values in one line ("-" for missing keys)
        * AIwcs: write additional keywords (e.g. AREFCAT) to wcs header file
        * xymatch: rewrite using stilts tmatch2 function (huge speedup)
        * new function: AIastrometry
        
    5.1a2 - 15 Jun 2021
        * AIaladin: get comet coordinates from JPL instead of MPC
        * cometcenter: rework to get much better performance, lower amount of
            image blur and use much smaller bg mesh size to better locate
            the bright comet core (much less affected by tail)
        * new function: mpcreport get_jplcoord 

    5.1a1 - 02 Jun 2021
        * icqplot: bugfix to correct number of observations per observer,
            bugfix in data selection for model fit if more than 2 observer
            IDs are given
        * AIregister: bugfix to correctly match stars when estimating dmag in
            case of a meridian flip during sequence
        * reg2pbm: new option -n to negate results
        * AIexamine: support image file names containing spaces
        * AIccd: update croped calibration images in temp dir if calibration
            images were modified
        * AIbnorm: replace AIbmerge by new python function bmerge
        * AIfindbad: replace pnmccdred by pnmccdred2
        * AIval: rework to use new python function listpixels
        * imcount: rework to use vips stats
        * AIlist,phot2icq: compute mlim using AI_ALIMx
        * AIphotcal: do not write AP_MLIMx to header anymore

    5.0.4 - 09 May 2021
        * phot2icq: introduce new APASS catalog keys

    5.0.3 - 06 May 2021
        * reactivate use of pipes with pyvips functions as the issue has been
            fixed in libvips upstream
        * AIcomet: derive bgmult from file name of bgfit10
        * AIphotcal: reuse previously downloaded catalog
        * AIplot: avoid start value of 0 for fit coefficient a0
        * sexselect: remove left over temp files

    5.0.2 - 30 Apr 2021
        * AIccd: bugfix to correctly apply -a <add> on RGB images
        * AIlist: bugfix to correctly compute azimuth
        * AIraw2rgb: added option -a <add>
        * AIregister: catch error from kappasigma (if n2<3)

    5.0.1 - 29 Apr 2021
        * phot2icq: apply new ICQ keys for GAIA (BG for GBP mag)
        * AIcomet:
            - avoid piping of pnmccdred2 commands which causes file
              corruption on certain (virtual) hardware setups,
            - use imbgsub for bg subtraction of comet image
            - handle no star selection in photcorr (empty newphot file)
        * ds9cmd psfextract: make sure background subtracted images do exist
        * AIbgmap: added option to account for bg offset of the image when
            deriving background statistics
        * imbgsub: use python function for main image processing
        * AIsetinfo, AIlist: take AI_BGOFF into account when showing
            background values
        * AIplot: added option -n to skip display of resulting plot file

    5.0 - 21 Apr 2021
        * camera.dat: new ctype CMOS used for monochrome CMOS sensor
        * AIraw2rgb: bugfix to take image flip into account when debayering
        * imsize: bugfix to use image size instead of output size as reported
            by dcraw in case of DSLR raw images
        * jd2ut: bugfix to take rounding into account when computing date
            close to beginning of next day
        * dec2sexa: bugfix to take rounding into account when time is very
            close to next minute
        * AIstack: skip 2 cols/rows at edge of images to avoid artefacts
        * AIcomet: make bluring of contrast enhanced image depend on fwhm
        * AIphotcal
            - added mandatory parameter plane
            - use catalog specific color band names
            - maxdist for matching catalog stars is now based on fwhm and
              pixscale (was fixed to 2 pixels until now)
            - for gaia catalog limit stars to 0.4 < GB-GR < 1.4
        * AIbgdiff: improve error handling
        * AIflat: if number of images less then 6 use single group (like -s)
        * AIccd, AIfindbad: recognize monochrome CMOS sensor
        * AIlist: enhanced to support more user supplied field names
        * ds9cmd photcal: abort if catalog is missing in refcat.dat
        * ds9cmd bggradient: resort parameters, default bg mesh size is now
            reduced for small images

    5.0a5 - 02 Apr 2021
        * templates of parameter files used for new projects are now placed
            in config directory
        * AIphotcal:
            - bugfix when checking for param change: comparison of aprad
              is now based on numeric value (not string)
        * AIregister: use larger fraction of stars to calculate mag difference
            if number of sources in the image is small
        * AInoise: use pnmcombine2 when computing stddev
        * kappasigma: allow for small data samples (n=4, n=5) but without
            rejection of outliers
        * ds9cmd bggradient: overwrite action implemented

    5.0a4 - 08 Mar 2021
        * AIsetinfo: bugfix for longinfo to correctly read coordinates
            containing spaces instead of colons from raw FITS file
        * new function skygradient

    5.0a3 - 15 Feb 2021
        * wait_for_frame: bugfix to correctly deal with FITS images
        * AIlist: choose catalog priority according to order in refcat.dat

    5.0a2 - 05 Feb 2021
        * AIlist, get_cobs: bugfix for comets with fragments
        * AIcomet, imbgsub: fixed regression introduced in v5.0a1: both
            functions must use same algorithm to determine tmpbgcorr (the
            correction to intensity scaled background), be aware of slight
            differences in results from pnmccdred and pnmccdred2 (due to
            rounding to integers)
        * AImapphot: bugfix to handle newer dates of observations
        * AIphotcal: for gaia catalogs skip calibration stars of extreme colors
        * AIlist: limit to last 180 days by default
        * AIraw2gray: syntax change, do not write to stdout by default anymore
            but to the file name given as second parameter
        * AIdark, AIflat, AIraw2gray, AIbgdiff, AIbgmap, ppm2gray, imbgsub:
            use faster pnmccdred2/pnmcombine2
        * AIraw2gray, AIflat, AIccd: apply AI_CCDREGION on FITS images as well

    5.0a1 - 21 Jan 2020
        * new dependency on libvips and pyvips
        * newmag: bugfix to correct output (wrong start of string msg)
        * refcat.dat, mkrefcat: support of gaia2 and gaia3e
        * mkrefcat: contact multiple vizier servers in case of connection
            failure or empty result set
        * AIphotcal: detect and eliminate faint close companion stars
        * AIphotmatch: limit catalog mag precision to 3 digits after colon
        * AIpsfextract: on monochrome images use single value of psfbg, mcorr
        * AIval: correctly deal with PBM images (which have white=0)
        * AIfindbad:
            - adjust call of AIval for PBM images
            - use pnmcombine2 instead of pnmcombine
        * AIfpreview: enhanced to support zipped images
        * mkkernel: invert colors (stroke is now white=0 on black=1 background)
        * kmedian: use pnmcombine2
        * meftopnm: rework
        * imsize: speed improvement by using dedicated and faster programs for
            certain file types
        * AIsfit: create raw PNM instead of plain (ascii) PNM in case of PGM
            input files (to avoid problems with airfun.py functions)
        * AIstat: use airfun.py function imstat
        * ppm2gray: use airfun.py function ppmtogray
        * imcrop: use airfun.py function imcrop (for PPM)
        * reg2pbm: split out some code into new function reg2svg
        * starcombine, AIskygen: replace rgb3toppm by fits3toppm
        * itel2obs: adapted to new log file format at iTelescope.net
        * map_rawfiles: added option -l to read image time stamp from log file
            instead of using FITS header information
        * new functions: fits3toppm fits3tocube pnmccdred2 pnmcombine2

    4.5.2 - 29 Dec 2020
        * AIccd: bugfix when checking if all images have been processed already
        * xyinreg: bugfix to deal correctly with input from stdin
        * xy2rade: bugfix: replace space in id string by period
        * mkrefcat: bugfix to add constraint on sort column which must be
            non-empty, otherwise sorting does not work properly (e.g. on APASS)
        * AIbgmap: ignore pixels close to edge of image (1% + 1pixel)
        * AIphotcal:
            - necessary update because of recent change of APASS web form at
              AAVSO (now querying DR10 using new url and new data columns)
            - increased max number of catalog stars to download to 10000
            - allow to limit calibration stars by user provided <set>.phot.reg

    4.5.1 - 11 Dec 2020
        * starcombine: bugfix: avoid call of imarith when adding 0
        * AIcomet:
            - bugfix: computation of comet area in case of an existing bad
              mask was incorrect (and therefore the mean count as well)
            - added header keywords AC_COMUL, AC_BGSUB, a change of any
              parameter will now trigger re-processing of star subtraction
            and extract a new comet image
        * sex2rgbdat: increase precision for output mag value to 0.001 mag
        * reg2xy: added support for conversion of box region
        * ppm2gray: use AI_TMPDIR for temp files, strip off COMMENT keyword
        * ppm2mef: use AI_TMPDIR for temp files
        * _regstat: replace identify by imsize

    4.5 - 28 Nov 2020
        * AIpsfextract:
            - use somewhat larger mask radius
            - save measured background value of star stack to header keyword
              AI_PSFBG for later use by AIcomet
        * AIcomet: rework background handling
        * imblur: changed default parameters to lower degree of bluring 
        * get_wcsrot: simplify algorithm if requesting rotation at image center

    4.5a4 - 17 Nov 2020
        * AIpsfextract:
            - subtract only field stars located close to psf stars
            - do not write temporary images to project directory
        * AIcomet
            - only create new star- and comet-subtracted images if necessary
            - do not write temporary images to project directory
            - added option -r <rlim> to limit star subtraction
            - new header keywords AC_VERS (replaces AC_VERSn), AC_RLIM
        * meftopnm: use fitstopnm when processing 16bit integer data
        * imsize: use pnmfile instead of identify for improved speed
        * AIval, AIexamine: use imsize instead of identify to determine image
            width and height

    4.5a3 - 21 Oct 2020
        * AImapphot: bugfix when converting mapphot output file to icq records
            (coma diameter, name of periodic comet)
        * AIfindbad: check input images, issue warning if it is not found
        * AIwcs: consider ratio nmatch/ncat as well when checking for success
        * AIlist: added option -c to list all results from current project
        * icqplot: improve matching of obslist entries (in case of numbers);
            ignore label 'others' if all data are matched by obslist
        * new functions: cometpos eps2png

    4.5a2 - 05 Oct 2020
        * replace AIpsfmask by mkmask (which does create a mask region only)
        * split AIstarcombine into two separate functions: cropstars and
            starcombine
        * xyinreg: added optional third parameter to supply column names
        * removed: AIpsfmask AIstarcombine
        * new functions: mkmask cropstars starcombine

    4.5a1 - 03 Oct 2020
        * sexselect: added option -a to filter and output all FITS table
            extensions
        * AIpsfextract: added option -s <starstack> to provide image for
            measuring psf background
        * sex2rgbdat: added option -f <fwhmmax> to filter objects
        * AIbgmodel: added option -sd <sd> to allow for fixed amplitude scaling
          when displaying model image

    4.4 - 20 Sep 2020
        * AIphotcal:
            - bugfix: fitting function without color term works again
            - lower default search radius for calibration stars by ~20% to
              reduce effects resulting from PSF variation across field of view
        * icqplot: bugfix to match observer ids by full words
        * AIbgmodel: do not apply median kernel filtering by default, if needed
            use option -f instead
        * AIval: added options -min <minval> and -max <maxval> to only list
            pixels with values in the given range
        * AIarchive: file name filters adjusted
        * AImapphot: rework to process all observations within given date range

    4.4a3 - 31 Aug 2020
        * AIsetinfo: bugfix to correctly deal with gziped FITS images when
            using the longinfo output format
        * phot2icq: bugfix to correctly format tail lengths in arcmin
        * AIwcs, AIpsfextract, AIcomet, AIphotcal: do not create or use
            {wcs,comet}/$set.src.dat anymore, use sextractor catalog from
            project directory instead
        * gpsurfit: enhanced to support fitting of 3rd and 4th order polynoms
        * rgbscale: enhanced to support PGM images as well
        * ppm2mef, meftopnm, meftocube: rework to improve handling of
            multi-extension RGB FITS images
        * new functions: AIfpreview ahead2fits

    4.4a2 - 30 Jul 2020
        * AIregister: bugfix to correctly extract header keywords for gzipped
            FITS images
        * AIwcs: added option -cr <crossrad>
        * AIcomet: measure max intensity in cosub image and issue warning in
            case of saturated pixels
        * AIphotmatch: compute airmass for matched stars and store value in the
            last column of xphot file
        * AIphotcal:
            - bugfix: fixed error in computation of centerdeg (cxy is in FITS
              coordinates, not image coordinates)
            - added option -e to fit extinction correction
        * get_rawfile: recognize gzipped file as well
        * phot2icq: limit number of digits for (large) tail length
        * xy2rade: added option -f to accept input in FITS coordinates

    4.4a1 - 10 Jul 2020
        * AIexamine: bugfix when dealing with -w <wcshead> (regression from
            version 4.3.3)
        * AIraw2gray: support gziped FITS images
        * AIdark: added options for alternative modes of image combining
        * AInoise: run normalization in parallel
        * AIsetinfo: improved longinfo when dealing with raw FITS images
        * AIfindbad: further improvement on handling of bayered images
        * AIlist: substantial improvement on processing speed
        * AIregister: increased default for allowed mag difference (0.1->0.2)
        * AIwcs: increased posmaxerr (10->30 percent of field diameter)
        * get_mpcephem, get_cobs: enhanced to support comet names starting
            with a letter
        * icqplot: several fixes and enhancements
        * new functions: AIfwhm mktics cometname
    
    4.3.3 - 05 Jun 2020
        * AIflat: use parallel processing for dark subtraction
        * AIccd: early check if all images of a set are processed already
        * AIbnorm: added option -n nval to specify normalization level
        * AIccd, AIraw2rgb, AIraw2gray: added option -o doff to specify
            offset of counts in dark image
        * AIfindbad: deal with bayered FITS images
        * AIarchive: avoid duplicate file names
        * map_rawfiles: skip leading / in image directory name
        * ds9cmd bggradient: keep track of bg fit type by storing header
            keyword AI_BGFIT
        * ds9cmd imload: bugfix: load images into current SAOimage window
        * ds9cmd movestars: only update xy-coordinates in photometry file
            if object has been moved
        * ds9cmd regphot: increase precision of photometry to 1/1000 mag

    4.3.2 - 26 May 2020
        * AIcomet: exclude bad regions when measuring comet counts because
            manual corrections are handled easier this way, this is working
            now the same way as used before 4.3
        * AIcomet, AIpsfextract, AIaphot, AIphotmatch, newmag, sex2rgbdat:
            increase precision of stellar photometry to 1/1000 mag
        * AIstarcombine: run parallel processes when extracting sub-images
        * is_number: rework to fix some weak checkings
        * new ds9cmd coordinates
        * new function AIarchive

    4.3.1 - 19 May 2020
        * AIphotcal: bugfix to correct issues when plotting the color term
            (apass: plot was shifted vertically, tycho2: just garbage)
        * map_rawfiles: bugfix to remove $AI_RAWDIR part of FITS file name
        * new environment variable AI_MAXPROCS to set number of jobs to run
            in parallel when calling program parallel
        * use alias for new program name source-extractor (e.g. used in
            package sextractor on Ubuntu 20.04)

    4.3 - 12 May 2020
        * parameter files camera.dat and sites.dat now require more strict
            syntax (e.g. matching number of columns, comments after #)
        * ds9cmd regphot: increase of processing speed by using _regstat
        * AIcomet: use regstat for measuring comet area and use imblur
            instead of convert with simple blur to increase processing speed
        * new functions: imblur checkparamdat
        * removed: kmean, demosaic

    4.3a4 - 14 Apr 2020
        * AIcomet: do not subtract bad regions when measuring comet area
        * AIraw2rgb: support of higher quality de-bayer algorithms when
            dealing with bayered FITS input images
        * new function: gpsurfit
        * new function: ppm2mef
         
    4.3a3 - 30 Mar 2020
        * AIfindbad: rework to support both monochrome and color images
        * new functions: rgbscale, AIbgmodel, AIpretty

    4.3a2 - 02 Mar 2020
        * AIstack: added option -bin <bin> to manually set value of binning
            of raw file pixels; get pixscale from wcs header file if it exists
        * imsize: added option -d to show fov in degrees
        * icqplot: rewrite to internally use unix time in seconds for all
            time scales

    4.3a1 - 21 Feb 2020
        * mkrefcat: bugfix to correctly use sortcol
        * rade2xy: read coordinates column numbers of catalogs from refcat.dat,
            improve dealing with long object identifiers
        * AIphotmatch: read mag column numbers of catalogs from refcat.dat,
            added support for B-V, V-R columns
        * AIccd: identify calibrated raw images by dark=cal and flat=cal
        * regfilter: allow for more column names of input FITS table when
            looking up for x and y columns (in addition matches are now case
            insensitive), added third parameter to provide user defined
            column names to use as x,y columns (must be separated by |)
        * imcoord: use of comet coordinates keywords now requires -c option
        

	4.2.1 - 25 Jan 2020
		* AIstack: bugfix: propagate badpix to _fitsconv_parallel
        * bgresmodel: bugfix: take stats for scaling residuals from background
            image
		* AIcosnap: enhanced to support monochrome images
        * AIpsfextract: added options -p to stop processing after creating
            psfphot file and option -n nbright to set number of bright stars
            to use (default 30)
        * AIsetinfo: added output of hour angle when requesting longinfo (-l)
		* new function wait_for_saoimage, cometreg, rgbscale

    4.2 - 17 Dec 2019
        * AIstack: use parallel jobs when converting to FITS
        * AIsetinfo (long format): if there is only raw images available, then
            try to extract image coordinates from header of reference image
        * img_info: removed unused section _fits_extract
        * meftopnm: deal with file names containing spaces
        * icqplot: bugfix when using -x and providing start and end dates,
            deal with comet designation for interstellar objects (ending with
            the letter I)
        * new function jd2st

    4.2a2 - 07 Nov 2019
        * AIccd, AIbgdiff, AIsource, AIregister, AIaphot: run parallel jobs
        * reg2pbm, rgbsmooth, kmean, AIpublish, AIsource: bugfix for newer
          versions of imagemagick: when writing result to stdout in a
          specific image format then a hyphen character is required after the
          format specification (e.g. "pgm:-")
        * imslice: enhanced to support MEF as input
        * AIbgmap,  AIstack, ppm2gray: replaced ppmtorgb3
        * AIdark: deal with small number of images (n=3-5)
        * AIimlist: added -s to check for non-empty image file
        * ds9cmd dcontrast: adapt to new saods9 version 8 (uses iexam)

    4.2a1 - 22 Oct 2019
        * map_rawfiles, img_info: run parallel jobs
        * AIdark: keep converted raw images (pgm images) in AI_TMPDIR
        * phot2icq: improved handling of FILTER keyword
        * export variable LC_NUMERIC
        * ds9cmd bggradient: do not overwrite bg corrected image if it is a
            symbolic link to an other image
        * ds9cmd nostars: bugfix limit to marked (red) regions only
        * icqplot: added perihel label, improved plots of coma diameter and
            heliocentric mag
        * new function: rgbsmooth
        
    4.1   - 12 Sep 2019
        * AIregister: stop processing when important parameters or files are
            missing instead of progressing to the next image set
        * AIbgmap, AIsfit: added option -c to fit a parabolic surface with
            arbitrary center offset (experimental)
        * AIlist: recognize more header keywords to list on output
        * AIflat: improved error handling
        * ds9cmd nostars: match any object within selected (red) regions
        * itel2obs, get_itel_telid: adjusted to comply with newer entries in
            iTelescope log files
        * get_cobs: bugfix to correctly handle start date
        * phot2icq: for short tail lengths print value in arcminutes, comments
            reordered to comply with COBS standards
        * set LC_NUMERIC=C globally, assumed e.g. by printf and sort commands
        * new functions: get_xephemdb gplinfit icqplot
        * new dependency on airfun.py (used by icqplot)

    4.1a3 - 21 Jun 2019
        * AIregister: bugfix for low number of matched stars, now the
            registration is tried on rotated image as intented
        * AIphotmatch, rade2xy: shorten name of star identifiers
        * new ds9cmd: nostars, movestars
        * new function: imnumadd

    4.1a2 - 31 May 2019
        * AIphotcal, AIsfit, median, regstat: avoid sigpipe errors
        * ds9cmd bggradient: handle additional parameter (bsize)
        * AIlist: added fields (az, rms)
        * itel2obs: modified to match recent log format changes
        * new function: lines

    4.1a1 - 08 May 2019
        * AIstack, AIbgdiff: reading bad pixel areas from bgvar/<num>.bad.reg
            (bgvar/<num>.bad.png is now deprecated)
        * AIccd: improved checking for errors
        * mknlist: added check of input for valid numbers
        * new functions: wait_for_frame, get_frameno

    4.0   - 12 Apr 2019
        * AIccd: bugfix: scaling to 16bit was not applied in case of bayered
            images
        * AIccd: support different dark and flat images on splitted image sets
        * AIimlist: read names of dark and flat from individual lines in
            set.dat in case of splitted image sets
        * cometsmooth: enhanced to allow for float values in blurscale option
        * new function: icqlist

    4.0a5 - 03 Apr 2019
        * AIraw2rgb: bugfix: strip header from image file passed to bayer2rgb
        * imcount: rewrite to prevent rounding errors
        * AIaladin: lower opacity of comet label
        * AIpeak: set log scale for intensity and add linear model curve

    4.0a4 - 15 Mar 2019
        * new requirement: python3-ephem
        * camera.dat: evaluate column ctype to obtain bayer matrix pattern
        * AIlist: added parameter -f <fields> to print additional keywords,
            compute altitude and moon ephemerides if those keywords are missing
        * AIraw2rgb: added option -b <bayer_pattern>
        * AIccd: recognize Bayer matrix pattern via column ctype in parameter
            file camera.dat
        * AIpublish: added option -a <author>
        * AImapphot: fixed output when apertures unit is arcsec
        * cometcenter: improved stability by adding a second iteration while
            searching for maximum value
        * regshift: added support for points
        * get_jd_dmag: if registration results exist then ignore files in
            AI_TMPDIR and AI_RAWDIR when obtaining list of image numbers for
            the given set
        * get_mpcephem: bugfix in case UT time is before 10:00
        * bgresmodel: preserve average background level
        * removed function is_fitsbayer
        * new functions: AIcosnap, AIaladin, pyaltaz, regid, xy2fits, fits2xy

    4.0a3 - 07 Feb 2019
        * aphot: added option -z to ignore any zero value pixel
        * imcoord: added option -v for verbose information about used
            files and keywords
        * ds9cmd aladindss: use script command string instead of temp.
            file

    4.0a2 - 16 Jan 2019
        * cometcenter: complete rewrite, allow for choosing from different
            algorithms via -m <method>
        * focas: superceded by AImapphot, which is a major rewrite
        * new functions: AIlist, AImapphot

    4.0a1 - 17 Dec 2018
        * new requirements: parallel, gnuplot 5
        * AIbgdiff, AIstack: increased bgzero default from 3000 to 10000
        * AIbgdiff bugfix: prefer calibrated ppm image over pgm image
        * AIbgdiff: new option -p to fit plane instead of surface to
            diff image
        * AInoise bugfix: skip lines having type=a in AI_SETS
        * AIstack: do not write info about each input file to header anymore
        * AIphotcal: fit function reversed, resulting in slope=1/old value
            and color transformation coeffizient=-1*old value, the latter is
            now stored in AP_CTRAx (instead of AP_CVALx), changed format of
            residuals data file
        * AIplot: added option -q to suppress output from fit
        * AIpreview: make use of GNU parallel
        * ds9cmd bggradient: added third parameter fittype (plane|surface)

    3.4 - 23 Oct 2018
        * AIccd: return nonzero value if error occurs on any single image set
        * AIimlist: added option -r to check for entry of images in reg.dat
            instead of checking for presence of the image itself
        * AIplot: handle gnuplot terminal type according to file extension
            of the -o <printfile> argument
        * set_header: skip writing to header file if nothing has changed
        * get_param: allow for multiple comment lines before header line
        * ds9cmd aladindss: start locally installed program version if availabe,
            use aladin lite online version as fallback only
        * sites.dat: columns DST and TZ-UT removed (not used anymore)

    3.4a5 - 24 Sep 2018
        * AIpsfextract, AIcomet: saturated stars are not skipped from
            subtraction anymore (allow FLAGS<=7)
        * AIbgmap: amplitude of gradient is now computed from circular area
            instead of a rectangular one to eliminate bias from gradient
            direction
        * AIccd: make use of the flip setting in camera.dat
        * AIraw2gray, AIraw2rgb: added option -f to flip image top-down
            (FITS images only)
        * phot2icq: strip leading and trailing spaces from object and telid
        * cometsmooth: added -b <blurscale> to allow smoother transitions

    3.4a4 - 23 Aug 2018
        * AIphotcal: bugfix for selection of stars within rlim during
            large aperture correction
        * img_info: handle DSLR images in subdirectories
        * new function: cometsmooth

    3.4a3 - 08 Aug 2018
        * AIphotcal: use psf stars (if present) within rlim to determine large
            aperture correction
        * get_mpcephem: added option -a to print aladin sky view commands for
            plotting comet positions
        * get_exclude: bugfix in case of directory name containing multiple
            letters after the day
        
    3.4a2 - 13 Jul 2018
        * new requirement: bayer2rgb
        * camera.dat: added column flip (1=yes) to indicate if images
            are flipped (e.g. FITS images stored by MaximDL)
        * AIraw2rgb: added support for monochrome FITS images containing a Bayer
            filter matrix (DSLR raw image, assuming filter pattern BGGR)
        * AIdark, AIflat, AIccd, AIstat: scale FITS images to full 16bit range
        * AIraw2gray, AIraw2rgb: added option -s <scale> which is applied
            to FITS images only
        * AIcomet: increased smoothing of comet image before creating the
            comet trail
        * comet_lightcurve: bugfix to correctly read ephemeris data file for
            distant comets (r>10AU)
        * map_rawfiles: handle FITS images from sub-directories
        * new function: is_fitsbayer
        
    3.4a1 - 29 Jun 2018
        * AIdark, AIflat, AInoise: reworked handling of AI_CCDREGION
        * AIstack: when applying both -c <centerrefimg> and -f (for full
            image size), the size of the resulting stack is now taken from
            <centerrefimg> which is necessary when stacking on comet
        * AIregister: skip images where header file is present and option
            verbose is not set
        * AIbnorm: added option -s to subtract average (instead of divide)
        * AIbsplit: added options -r|g1|g2|b to limit output to specific color
        * AIcomet: renamed blurred image to reflect set name
        * bgresmodel: added option -b <bgval>
        * get_mpcephem: write errors to stderr
        * new functions: is_gacam_raw, regcopy

    3.3 - 11 Jun 2018
        * camera.dat: added column camchip to hold ICQ format CCD keys
            for camera and sensor
        * phot2icq: added option -c to include extended CCD information in
            ICQ record
        * meftopnm: improve handling of non-standard FITS files when
            extracting header data (convert umlauts to ?)
        * AIimlist: enhanced to support DSLR raw file name prefixes
        * AIbgdiff: crop the (averaged) reference image before computing
            rgb statistics to avoid outliers on edges
        * AIregister:
            - bugfix to correct wrong sign of image rotation with
              respect to reference image (rimg) when stacking on comet
            - avoid unimportant errors related to broken pipes (e.g. sort
              followed by head which finishes before the sort command)
        * AIstack: improved estimation of disk space requirement
        * AIaphot: improved performance by running parallel processes
        * AIval: speed improvement when working with pnm images (~50%)
        * AIstack: added return value
        * AIwcs: save some source detection stats to wcs header file
        * normstat: rewritten to improve performance (~30%)
        * img_info: added option -u to indicate camera time is UT
        * comet_lightcurve: reduce number of fetched ephemerides (interval now
            depends on total time span)
        * new function: AIpeak

    3.2.1 - 17 Apr 2018
        * img_info: bugfix to correctly handle CR2 files
        * ppm2gray: working around bug in sethead when string value has more
            than 18 characters and a comment is provided
        * AIphotcal: repeat measurement of large aperture correction in case
            of changes in rlim or aprad
        * AIstart: allow for multiple uses of option -k <keyword>=<value> in
            single command
        * AIpreview: enhanced to support missing flat or unknown black value
        * bgresmodel: added option -s <scale>
        * AIfocus: improve stability of statistics by ignoring objects
            with a<0.4pixel (likely hot pixel)

    3.2 - 11 Mar 2018
        * ds9cmd psfextract: bugfix: extract sources from original image
            (instead of bg subtracted image) to keep correct saturation value
        * newmag: bugfix: in case of RGB images use all three bg values
            provided instead of using only the first one
        * AIstart: allow user to define keyword JD via -k option
        * AIwcs: added option -m <maskreg> to allow a user defined mask
            to limit input image sources to the given region
        * imbgsub: increase default bg value of result image from 400 to 1000
            to better deal with very noisy images
        * AIcomet, AIpsfextract, AIpsfmask, AIstarcombine, AIskygen: increase
            default bg level of psf images from 400 to 1000
        * AIphotcal: repeat photometry (and matching against catalog) upon
            changes of critical parameters (e.g. aprad, rlim)
        * is_fitscube, meftopnm, imslice, AIexamine: added support for FITS
            RGB cubes which have additional extensions
        * phot2icq: changed method from C to Z
        * new function: imcoord

    3.1.1 - 31 Jan 2018
        * ppm2gray: improved keyword handling when creating FITS output:
            - propagate keyword description to FITS output file
            - added option -w <wcshead> to allow inclusion of wcs keywords

    3.1 - 17 Jan 2018
        * AIbgmap bugfix: take rejected background regions into account
            when computing final statistics
        * ppm2gray:
            - bugfix: prevent failure of sethead program when trying to
              assign multiple keywords of which one or more contain umlauts
            - bugfix: reject BSCALE and BZERO keywords when adding FITS header
        * map_rawfiles: use get_jd to determine JD
        * AIsfit: increase stability of fit for gnuplot version 5 by
            using much larger values for initial guess of parameters
        * AIdark: added option -r which eliminates row pattern by subtracting
            median value from each row
        * AIwcs: posmaxerr reduced from 25% to 10% of image diagonale to
            achieve better stability of astrometric fit
        * AIstart:
            - store AI_SITE to image header file
            - issue warning messages upon unusual data ranges
        * get_mpcephem: store more data into image header file
        * get_jd: increased precision (from 3 to 5 digits)
        * new function: impatsub

    3.1rc1 - 12 Dec 2017
        * get_mpcephem:
          - use new urls (mpc web pages switched from http to https)
          - support query of asteroids (by name or number)
        * get_cobs: rewrite to support new COBS analysis web url and
            query form parameters as of October 2017
        * AIsfit, AIphotcal: handle both gnuplot version 4 and 5 syntax
          on fitting
        * if necessary use aliases for sex and swarp (supporting different
          names of binaries in official Debian/Ubuntu packages)
        * sexselect, regfilter: add support for X_IMAGE,Y_IMAGE coordinates
          (when using isophotes in sextractor)
        * phot2icq: if mlim is missing then insert 4 blanks
        * new functions: mknlist cometcenter photplot AIpreview

    3.0.3 - 05 Nov 2017
        * ds9cmd aladindss: deal with spaces in FITS keywords of coordinates
        * AIsource: bugfix to correctly read parameters from camera.dat
        * AIphotcal: get image size using imsize instead of using NAXIS
            keywords
        * get_mpcephem: improve checks on parameters and keywords
        * datarange: correctly deal with fits cubes
        * map_rawfiles: added option -n <num> to set first image number
        
    3.0.2 - 25 Oct 2017
        * newmag: bugfix when operating on splitted sets (texp fixed)
        * ppm2gray: bugfix: do not propagate NAXIS keywords to FITS file
        * get_jd_dmag: bugfix to correctly deal with sets stacked on other than
            middle exposure
        * get_header, map_rawfiles, get_rawfile, meftopnm, AIstart, AIregister:
            bugfix: deal with file path names containing spaces
        * get_jd: enhanced to deal with FITS header where time of observation
            is stored in TIME-OBS and DATE-OBS provides the day only
        * AIcomet:
            - added check for correct region file format of comet regions
            - added check to ensure that comet region is not used as background
            - use much smaller aperture for measurement of stars which
              are selected for photometric correction and apply a magnitude
              correction term derived from psf profile
        * AIstart: added checks for identical image size and valid data range
            of stacks
        * new functions: imsize, datarange

    3.0.1 - 29 Sep 2017
        * ds9cmd: new tasks imload, expert
        * ds9cmd regphot: allow for simple photometry of any region
        * AIstart: allow user to provide header keywords (via -k key=value)
        * AIexamine: propagate all header keywords when converting pnm images
            to temporary FITS files
        * AIccd: added check to ensure same size of dark and flat images
        * ppm2gray: added option -c <cboxsize> which allows to blank any data
            outside a given center box area
        * mkpgm, mkppm: changed default output file name to "-" which allows
            to pipe it into other commands
        * get_jd_dmag: added option -g to guess time of exposures from mean jd,
            texp and nexp 
        * get_header: enhanced to support gziped FITS images
        * logfile of GUI tasks renamed from ds9cmd.log to airtask.log
        * new functions: is_fitsgz, get_jd, check_url

    3.0   - 13 Sep 2017
        * ds9cmd: new tasks shorthelp, usermanual and project
        * ds9cmd psfextract: handle change of psfsize
        * AIcomet: bugfix: position of initial comet region was off if images
            were not stacked at mid exposure
        * renamed tasks cometphot to cometextract, manualkeys to manualdata

    3.0a2 - 31 Aug 2017
        * new version of airds9.ana is required (version 3.0) due to changes
            in task parameters
        * AIcomet: bugfix to prevent truncation of large comet trails by
            enlarging the region used with mkcotrail
        * ds9cmd photcal: added parameter to select catalog color band and
            index, removed color index from aopts
        * set_header: setting an empty value now removes the keyword
        * AIphotcal: added option -vr to use V-R in color index term
        * AIregister: added option -n <nbright> to optionally increase number
            of brightmost stars to use in cross-matching

    3.0a1 - 20 Aug 2017
        * new version of airds9.ana is required (version 3.0) due to changes
            in task parameters
        * ds9cmd wcscalib: added parameter to adjust north position angle
            if it differs from default (as defined in camera.dat)
        * ds9cmd: new tasks imflip, aladindss
        * AIexamine:
            - added option -r which replaces currently displayed image
              by next loaded image (instead of loading in a new frame)
            - set default north angle in wcscalib by evaluating camera.dat
              and image header keyword PIERSIDE
        * AIstart:
            - rework of check for image center keywords
            - on error return string containing related keyword names
        * AIwcs: increased limits for uncertainty in position and angle

    2.9.2 - 10 Aug 2017
        * is_wcs: bugfix when dealing with CDELT/CROT keywords

    2.9.1 - 03 Aug 2017
        * AIcomet: skip regions having area<3pix from comet and background
        * AIphotcal: compute faint star limit (mlim) if not provided
        * is_wcs: show possible error message only if in debug mode
        * wcscalib: set mag limit on catalog stars only if magzero entry in
            camera.dat is below 19
        * AIfocus: automatically set AI_DCRAWPARAM according to rlim
        * AIsetinfo: added telid to output
        * focas: center coordinates are now in fits coordinate system
        * new function: regskip

    2.9   - 29 Jun 2017
        * AIcomet: sort data in comet/<set>.newphot.dat by star identifier
        * AIregister: propagate FITS header keyword OBJECT
        * ds9cmd regphot: allow multiple regions to be measured at once
        * reg2xy: use sequential number in ids of regions without text
        * new functions: get_rawfile, is_wcs

    2.9a3 - 04 Jun 2017
        * AIsetinfo: support telid from set.dat, support rawfiles.dat
        * AIflat: bugfix to support FITS images
        * get_jd_dmag: add support for rawfiles.dat
        * xy2reg: added option -f to indicate that input data are in FITS
            coordinates
        * AIregister:
            - modified star selection for computing mag difference, it now
              accounts for a given pre-defined upper mag difference (default
              0.1 mag)
            - added option -m <mdiff> to allow changing this mag difference
            - added support for rawfiles.dat
        * AIwcs: issue an error if number of matched stars is very low
        * new function: bgresmodel

    2.9a2 10 May 2017
        * new metadata file rawfiles.dat which contains mapping between
          image number and raw image file names (and additional fields
          like JD)
        * AIimlist: use rawfiles.dat to find raw images if other methods
            have failed to resolve a file name
        * AIstat: enhanced to support set name arguments, added options to
            choose all images of a given type (-d|-f|-o)
        * AImstat: this is now a wrapper for AIstat -m
        * new function: map_rawfiles

    2.9a1 23 Apr 2017
        * regstat, _regstat:
            - bugfix when processing polygon regions which results in much
              improved speed
            - added third parameter to specify optional bad region mask
            - added option -q for quick mode statistics (skips kappa-sigma
              clipping)
        * ds9cmd: explicitely setting region coordinates to physical in
            several places before saving region to file fixes problems on
            some versions of saoimage
        * AIcomet: speedup comet background measurement by using new
            capabilities from regstat; comet trail model now takes background
            measurements into account
        * AIstart: added option -f to flip FITS images top-bottom
        * AIexamine: avoid rare X errors by not setting cmap values
        * new function: AIgradient

    2.8.3 11 Apr 2017
        * AIstart: some improvements on checking of header keywords
        * AIsetinfo: added option -b to show basic information by parsing
            the observations data file (set.dat) only
        * omove2trail: bugfix to make angle the same value as measured in
            saoimage (was off by 180 degrees);
            improved handling of missing cfrac
        * AImask: modified to reflect changes in trail orientation introduced
            by new version of omove2trail
        * ds9cmd psfextract: improved handling of trail parameters;
            detect and handle change of rlim upon repeated invocations
        * AIpsfextract:
            - mask psf by using ds9 polygon region instead of using pbm image
              which now allows for mask editing by the user
            - store parameters rlim and psfsize in header of star stack
        * new function: is_equal

    2.8.2 16 Mar 2017
        * get_mpcephem: bugfix: deal with sexagesimal lat/long in image header
        * is_pnm, is_ppm, is_pgm, is_pbm: bugfix: dereference symbolic links
        * AIpsfextract:
            - bugfix to correctly estimate mcorr in case of multiple
              repeated runs of the program
            - added code for measuring psf image background
        * AIstarcombine: added option -b <imgbg> to provide psf image
            background value and skip internal measurement which might be odd
            in busy starfields and/or when long star trails are present
        * AIaphot, aphot: added option -bg to report star background
            measurements only (star photometry is skipped)
        * AIbsplit: added option -m <matrix> to set Bayer matrix color pattern
            if it is different from BGGR
        * AIphotcal: keywords MAGZERO and AI_FWHM are not required anymore
        * AIregister, AIstack: propagate additional header keywords from
            original FITS image, e.g. FILTER and BINNING
        * AIsfit, AIbgmap: improved error handling
        * get_wcspscale: enhanced to support CDELT[12]
        * omove2trail: complete rewrite
        * new function: AIstart

    2.8.1 20 Jan 2017
        * AIccd: bugfix to correctly handle fits cubes
        * AIskygen: bugfix when dealing with psf image having odd number of
            columns or rows
        * AIcomet: bugfix for large aperture photometry in case of no bgfit10
            image and comult>1
        * AIexamine: do not delete frame in ds9, this prevents an error
            message from new ds9 version 7.5
        * AIimlist, AIsetinfo, AIregister: allow raw image file names to start
            with letters
        * AIdark, AIflat: force local scope of some variables
        * AIwcs, AIstack: account for binning (via keyword BINNING)
        * AIpublish: improved detection of telescope and camera

    2.8   06 Dec 2016
        * new requirement: missfits (ref.: www.astromatic.net)
        * AIpsfextract: handle missing center parameter
        * AIcomet: bugfix: correctly set link of intermediate image headers
            (x.stsub.head and x.resid.head)
        * AIexamine:
            - enhanced to support viewing of fits cubes (RGB) by using
              the green layer only
            - removed some unnecessary parameters from analysis tasks (requires
              airds9.ana version 2.1)
        * meftopnm, imcrop: enhanced to support fits cubes (RGB)
        * AIwcs:
            - added check if given catalog is supported by scamp
            - changed default mag limit from 16 to 99 (to use all available
              stars from reference catalog)
        * AIphotcal: raised number of downloaded tycho2 ref catalog stars
        * get_telescope: make use of telescope identifier provided by set.dat
            (new field at column 11 after flat)
        * comet_lightcurve: improved xtics spacing
        * initial support for Fujifilm digital camera raw files (extension raf)
        * new functions: is_fitscube imslice is_setname AIcheck

    2.8a4 31 Oct 2016
        * AIbgdiff, AIbgmap, imbgsub, meftopnm, ppm2gray, is_mask: transition
            from imagemagick to graphicsmagick
        * ds9cmd wcscalib:
            - bugfix when parsing additional options for scamp
            - using new column in camera.dat to get camera rotation angle
              which replaces hard-coded values
        * is_ahead: bugfix to reject some FITS images
        * AIbgdiff: bugfix to correctly handle set with single image
        * AIplot: add empty border around data points (via offset)
        * mkrefcat: enhanced to support creation of reference catalogs suitable
            as input to scamp
        * phot2icq: removed hard-coded telescope specific code
        * new functions: AIcosmics findgain

    2.8a3 29 Sep 2016
        * new requirements: programs imarith and imlist from wcstools
        * AIpsfmask: do not adjust bg level anymore
        * AIpsfextract:
            - apply intensity scale for psf
            - measure mag correction on psf image and save result
              to header keyword AI_PSFMC (for later use by AIcomet)
        * AIstarcombine: added option to allow intensity scaling
        * new function rade2altaz
        * removed obsolete function imbg

    2.8a2 24 Sep 2016
        * AIcomet: improve measurement of large aperture correction on the
            starpsf image by limiting the large aperture radius to about the
            size of the starmask (improves stability when images are highly
            defocused)
        * AIwcs: replaced parameters fitdegrees and sopts by appropriate
            options
        * AIphot, aphot: added option -p precision to set number of valid
            digits of magnitudes (default: 2 digits after decimal point)
        * AIbsplit, AIbmerge, AImstat, mkkernel, immedian, kmedian: transition
            from imagemagick to graphicsmagick
        * itel2obs: improved handling of non-standard calibration file names
            on iTelescope.net T08

    2.8a1 17 Sep 2016
        * ds9cmd cometphot: bugfix to correctly deal with empty bgfit10
        * imcrop, aphot, AIcomet: replaced croping command, now using
            graphicsmagick instead of imagemagick convert, which is buggy in
            version 8:6.8.9.9-5+deb8u4
        * focas: rewrite to reflect current image header keywords (as of v2.7)

    2.7.4 01 Sep 2016
        * AIexamine: minor bugfix for retrieval of analysis file path
        * AIpublish: added option to allow setting of final jpeg quality
        * AIimlist: new option -x which skips checking for individual images
            of the given set
        * AIcomet: skip bg region if it covers less than 10 pixels
        * AIwcs: prefer keywords RA, DEC if present
        * get_jd_dmag: if individual images of a set are not available then
            try to read start of exposure from exif.dat (assuming UT in the
            column hms)
        * get_param: enhanced to support key column names in addition to key
            column numbers

    2.7.3 02 Aug 2016
        * newmag: bugfix in case of negative counts in aperture
        * AIsetinfo: enhanced evaluation of image center coordinates in
            case of missing wcs calibration
        * AIcomet: using slightly smaller radii for aperture photometry of
            stars selected for photometric correction (*.newphot.dat)
        * ds9cmd: regstat enhanced to support images without keyword AI_IMAGE

    2.7.2 23 Mai 2016
        * AIwcs: added option -p to allow for using alternate plot driver
            when creating checkplots
        * AIexamine: if input image is PNM format then propagate some ASCII
            header keywords to temporary FITS files and store original image
            name in keyword AI_IMAGE
        * ds9cmd: rework parameters on regstat, regphot, bggradient tasks,
            use new keyword AI_COMST to obtain image file name of comet stack
        * meftopnm: added option -a which creates an ASCII header file from
            FITS header keywords (instead of doing the image conversion)
        * get_mpcephem: handle missing m2 (empty value from web query)
        * comet_lightcurve: bugfix to correctly handle size option

    2.7.1 29 Apr 2016
        * AIexamine: keep current pan/zoom when adding images
        * get_mpcephem added option -w to save some data to image header file
            (e.g. comet coordinates)
        * mkcotrail: deal with empty obsdata file

    2.7   17 Apr 2016
        * changed filename from imred_fun.sh to airfun.sh
        * stop writing log entries to $HOME/.imred_version because tracking of
            version info is already done via ds9cmd.log
        * AIcomet, AIphotcal: settled on keyword names
        * AIcomet: improved handling of image sets where individual images are
            not available (e.g. only stacked images exist)
        * replaced dcraw in favour of dcraw-tl

    2.7a3 11 Apr 2016
        * reg2pbm: bugfix when converting to pbm (changed value of threshold
            from absolut intensity value to percent)
        * AIphotcal: additionally skip stars flagged in ds9 by red color circle
            bugfix when disabling flagged stars in <set>.<catalog>.xphot.dat
        * AIcomet: new optional region file <cometdir>/<set>.bad.reg which can
            be used to mask out saturated stars and other defects
        * ds9cmd task psfextract: skip stars flagged in ds9 by red color circle
        * AIflat: droped option -z because in-camera dark subtraction is now
            detected internally
        * AIimlist: removed code redundancy
        * AIwcs, AIpsfextract, AIphotcal: improved error checking
        * AIsetinfo, get_telescope: be aware of AI_TELESCOPE
        * img_info: make fits_extract be aware of AI_TZOFF
        * get_telescope, get_header: speed improvement on FITS images
        * ds9cmd: new tasks regswitch, regstat, manualkeys

    2.7a2 15 Mar 2016
        * AIcomet, AIphotcal: bugfix for RGB images when writing results to
            header keywords
        * AIpsfextract: smaller mask size for heavily defocused stars
        * AIphotcal:
            - smaller aperture for heavily defocused stars (using different
              slopes in aprad=f(fwhm))
            - creating residuals file phot/<set>.<catalog>.resid.dat
        * AIwcs: show some summary output at the end; added option -f to
            suppress output formatting (terminal escape sequences)
        * get_header: enhanced to suppport FITS extension via -e <extname>

    2.7a1 03 Mar 2016
        * AIcomet, AIphotcal: all results are now written to header keywords in
            <set>.head
        * AIbgmap: allow region file to be used as mask where regions indicate
            bad background areas
        * AIexamine: do not keep parameter files because they never get user
            modified variables written back
        * AIsetkeys: rewrite to allow keyword comments, changed keyword
            separator from "," to space
        * sethead: enhanced to deal with keyword comments
        * added parameter skip to interactive psf extraction task to allow for
            stars beeing excluded from psf creation
        * ds9cmd: new tasks wcscalib, bggradient, photcal
        * phot2icq: enhanced to evaluate new header keywords
        * new functions: is_reg sum regstat

    2.6.2 08 Feb 2016
        * reg2pbm: use rsvg-convert instead of convert for increased
            compatibility
        * itel2obs: when linking calibrated images add 9000 to the image number
            to allow working with both uncalibrated and calibrated images in
            parallel
        * AIdss: take image rotation into account
        * AIbgdiff: added option -a to use all images for computing mean image,
            even those having bad regions

    2.6.1 17 Jan 2016
        * get_telescope: bugfix in determination of nref when set is splitted
        * omove2trail: bugfix in determination of jdref
        * AIbgdiff: bugfix to correctly handle an existing <nref>.bad.png
        * AIphotcal:
            - bugfix for residual plot when using R color
            - make radius for comparison star selection depend on field
              size (smaller fraction of image for large field of view)
            - apass: flag multiple matches of the same image object
        * AIdss: added option -e to get data from ESO instead of STScI
        * AIpsfextract: field stars are no longer limited to rlim region, only
            if a region file comet/<set>.sub.reg does exist
        * AIcomet: use smaller kernel for median when creating comet trail
        * AIstack: added keywords NREF and MJD_OBS (mean jd of all stacked
            images) to output header file
        * AIsetinfo, AIpublish, phot2icq, focas: use MJD_OBS instead of MJD_REF
        * regfilter: apply region filter on all extensions having <xcol>, <ycol>
            instead of using a single user provided extension
        * kappasigma: new option -n to append number of valid data points to
            output

    2.6   23 Dec 2015
        * new interactive psf extraction using ds9 analysis scripts (substantial
          changes in functions AIexamine, ds9cmd)
        * AIcomet: make use of AI_COMULT instead of fixed 10x or 1x stretch
        * AIplot: added option -g <gpcmd>
        * AIphotcal: changed check plot to show residuals vs. ref cat mag
        * AIstack: added option -bz bgdiffzero
        * img_info: switched from exiv2 to exiftool
        * reg2pbm: bugfix: svg coordinates had to be shifted left and up by
            0.5 pixel to get a better match of created mask image
        * new function mkcotrail

    2.5.3 02 Dec 2015
        * AIstack: bugfix: background variation between individual images was
            not taken into account when operating on gray (CCD) images
        * ppm2gray: bugfix to not scale intensity on gray input image
        * comet_lightcurce:
            - bugfix when downloading ICQ observations
            - fixed few bugs dealing with comets without observations
            - fixed plotting of coma diameter
        * AIphotcal:
            - added option -d maxdist for matching between catalog and image
            - prefer manually modified refcat phot/$setname.$catalog.xymanu.reg
                e.g. when dealing with poor wcs calibration
        * AIdss: eliminate call of external program dss_search.sh, using wget
            instead
        * AIsource: increased default threshold from 5 to 10

    2.5.2 28 Oct 2015
        * AImstat, AIbsplit, immedian: bugfix for newer versions of imagemagick
            which changed the -sample algorithm (fixed by introducing correct
            sample offset)
        * comet_lightcurce: rework of distance plotting

    2.5.1 20 Oct 2015
        * AIpsfextract: bugfix to skip psf stars close to image border
        * get_header: bugfix to skip unwanted message from listhead, added
            option -q to suppress messages about missing keywords
        * AIphotcal: bugfix correcting mag zero point in case of requesting
            color calibration; added option -z <zangle> to set angle between
            zenith and north (allow to measure differential extinction)
        * img_info: recognice EXPOSURE keyword of FITS files (exposure time)
        * AIsetinfo: recognize JD keyword (if MJD_REF does not exist)
        * AIwcs: recognice OBJCTRA,OBJCTDEC keywords, query <set>.head for
            ra,de first
        * get_mpcephem: recognize JD keyword (if MJD_REF does not exist) and
            SITELONG, SITELAT in <set>.head
        * omove, omove2trail, get_jd_mag: adapted to handle set with single
            image
        * comet_lightcurve: reuse COBS/ICQ data from latest.<comet>.dat if it
            has been modified only recently
        * new function xytrans
        

    2.5   25 Sep 2015
        * AIwcs: bugfix for north angle containing a leading '+' sign
        * AIphotcal, AIphotmatch, rade2xy: added support for APASS catalog
        * AIphotcal
            - replaced extern program vget.sh by function mkrefcat
            - added option -bv to fit color transformation term
        * AIcomet: apply photometric correction to sextractor magnitudes of
            stars to obtain total flux (= large aperture magnitude) as required
            by input catalog for skymaker (AIskygen)
        * AIregister:
            - increased number of stars used in photometric calibration
            - increased anglemaxerr (5 to 10, with -p 15 to 40)
        * get_param: rewrite to read column names of the data file from first
            comment line (starting with single #)
        * comet_lightcurce: added option -v <visdb> to query visual observations
            databases (default: cobs)
        * is_ahead: improved to recognize more ASCII FITS header files
        * new functions: get_telescope get_cobs mkwcs mkrefcat
        * added more columns to camera.dat

    2.5a2 14 Aug 2015
        * pbm2reg disabled (need transition from autotrace to potrace)
        * AIstack, get_jd_mag: bugfix when using omove: if both JD and MJD_OBS
            keywords are missing then use DATE-OBS to compute julian date
        * AIsfit: bugfix to ignore comments in PNM images created by meftopnm
        * meftopnm: bugfix to correctly deal with 32bit FITS images
        * phot2icq: bugfix in computation of position angle
        * img_info: bugfixes:
            - exposure time was rounded to integer in manual mode,
              now it always uses higher precision from Pentax.ExposureTime
              if it exists, increased to show 2 decimals after comma
            - deal with image file path names containing spaces
        * AIregister: improved handling of rotated images
        * AIstack, AIwarp, AIbgmap, AIstarcombine, AIskygen: in conversion from
            FITS to PGM/PPM replace convert command by meftopnm
        * focas: added parameter to provide user defined background value
            TODO: replace evaluation of pdata by examination of keywords
        * new functions: mkregheader imbg addldacwcs
            
    2.5a1 29 Jun 2015
        * normstat: bugfix: output precision must not be truncated
        * newmag: bugfix in computation of mag difference
        * rework of AIcomet for a much faster workflow
        * AIphotcal: enhanced to support photometry data file as input for
            psf stars data (in addition to ds9 region file)
        * renamed AIimgen to AIskygen, AImkpsf to AIstarcombine
        * new functions: AIpsfextract AIpsfmask AIsetkeys
        * new helper functions: is_number is_ahead get_header set_header
            mag2i get_jd_dmag imcount sex2rgbdat omove2trail meftocube
        * removed fixldac because newer versions of stilts (3.0-2, 6 Feb 2015)
          and topcat (4.2-2, 6 Feb 2015) now support reading LDAC FITS tables
          
    2.4   03 Jun 2015
        * AIval: bugfix by declaring some variables to local scope
        * AIimgen: rewrite using skymaker
        * aphot: added option -a to return counts (ADU) instead of mag
        * comet_lightcurve: heavy rework and many extensions added
        * sexselect: added option -x which converts to image coordinates
        * removed obsolete functions: gauss fitsext
        * removed functions AIoverscan AIinspect (not tested since ~140101)
        * new functions: get_exclude focas itel2obs

    2.4a3 19 May 2015
        * AIpublish: bugfix to correctly handle gray input images
        * AIflat: replace bad pixels by interpolation of 4 second-next
            neighbors (only when used with -b option)            
        * AIbgdiff: when creating mean image skip those with bad regions
            (as found in bgvar/*.bad.*)
        * AIphotcal, AIphotmatch, rade2xy: allow reference stars from
            NOMAD catalog
        * AIphotcal:
            - new options -B, -R to use B or R magnitudes instead of V
            - new option -l <mlim> to use magnitude limit in final curve fitting
            - new option -g to skip measuring star mag correction for large
              apertures (gapcorr)
            - deal with unknown reference magnitude in the choosen color band
            - added some checks of intermittent results
        * AIaphot: changed default gap from 3 to 1.5+aprad/2 and bgwidth
            from 3 to 2.3+aprad/4
        * aphot: added option -b <bgval> to set background and ignore data
            from background annulus
        * new function: is_fitsrgb

    2.4a2 28 Apr 2015
        * AIccd:
            - removed option -z, now in-camera dark subtraction is assumed
                if black value in output of AIsetinfo is zero
            - do not apply color matrix (channel multipliers) in dcraw anymore
        * AIraw2rgb: do not apply color matrix (channel multipliers) in dcraw
            by default, use new option -m to activate it
        * AIbgdiff: images which have bad regions are no longer used when
            creating average background image
        * AIregister: improve matching between reference image and current
            image for estimation of mag difference between images
        * AIstack: now any background difference maps (in directory bgvar)
            are applied
        * AIwarp:
            - added option -r <resamptype> to optionally overwrite defaults
            - added option -q to reduce output from swarp
        * AIexamine: added option -p <ds9opts> to pass additional command line
            options to ds9
        * AIfindbad:
            - added option -m <margin> to ignore pixels near image border
            - selection of images is now equally spaced (when nmax<n)
        * new function AIimcompare (replaces AIcompare)

    2.4a1 02 Apr 2015
        * AIbnorm: added option -k to keep mean brightness instead of
            normalization to 10000 ADU
        * AIbgdiff: limit number of images to average for reference frame
            (option -n nmax, default: 11)
        * AIfindbad:
            - limit number of images to use (option -n nmax, default: 11)
            - improved to operate on ppm images as well (by means of AIccd -b)
        * AIcomet:
            - bugfix when determining nlist for comet image creation (part 4)
            - improved quality when creating blurred comet trail
            - added option -c cscale to specify intensity scaling factor of
                previously extracted comet image comet/<set>.comet.<inext>
            - do not check for presence of $tdir/$nref.p?m anymore
        * AIpsfsub:
            - removed option -s
            - added option -m to change swarp combine_type from sum to
                average (useful for motion-blur)
        * phot2icq: bugfix in extraction of telescope id for iTelescope T12
        * get_mpcephem: bugfix when building object name (e.g. for 2013US10)
        * comet_lightcurve:
            - bugfix in naming of a periodic comet in call of get_mpcephem
            - added option -p to plot tail P.A.
            - added option -c to plot coma diameter
        * xyinreg: rewrite to use regfiter resulting in huge speed-up
        * regshift: enhanced to support rotation
        * new functions aphot doubleaphot xy2ahead

    2.3 - 27 Feb 2015
        * AIbgdiff:
            - added check for valid bad area mask (b/w, mostly good pixels)
            - exclude pixels close to border in final statistics on
              bgvar/<num>.bgdiff.<inext>
            - changed default name of output directory from bgcorr to bgvar
        * AIbgmap:
            - enhanced to support subtraction of background model image
              prior to fitting a smoothed surface image
            - optionally create additional diagnostic images
        * AIcomet:
            - removed bg subtraction code
            - add larger bg offset to stsub and stempty images to avoid negative
              values, adjustable via option -s <stsubbg>, default 1000
            - added option -p <psfoff> to set background of input images and
              psf images
            - added option -n <nmax> to set max. number of bg stars to subtract,
              changed default back to 3000
        * AIpsfsub:
            - new option -b <bgoff> to optionally add a bg offset to
              resulting psf subtracted image
            - increased memory for swarp to avoid errors when using many objects
        * AIstack, AIcomet, get_omove: use header keyword DATE-OBS to determine
            jd if not read already from other keywords
        * AIstiff: added option -16 to create 16bit output image instead of 8bit
        * new functions imbgsub regmatch newmag

    2.2.6 - 11 Feb 2015
        * AIcomet:
            - small bugfix: ignore psf objects having radius=0 when
              searching for companions of psf stars
            - changed nmax from 3000 to 2000
        * AIstack: added option -n to stack images without registration (and
            using median instead of average)
        * rade2xy: enhanced to support input coordinates in sexagesimal units
        * gauss: added option -s to output gaussian starlike image (black
            background) instead of creating convolution image
        * phot2icq: improved to get pa in the range 0..360 degrees
        * new functions: kmean is_mask

    2.2.5 - 28 Jan 2015
        * AIwcs: better handling of not yet processed image sets
        * comet_lightcurve: enhancements for larger plot or setting yrange

    2.2.4 - 21 Jan 2015
        * AIpublish: bugfix of web data output in case of exptime <60s
        * AIval: improved handling of option -m (select 0 or maxval only), now
            it works with pgm files as well

    2.2.3 - 06 Jan 2015
        * AIimlist: bugfix when dealing with associated images of darks
        * AIwcs: bugfix when dealing with multiple sets and IMGROLL=Y
        * AIbgdiff: diffs are now computed with respect to mean image, the old
            way of using nref is achieved by using option -r
        * AIimlist, AIraw2gray, AIregister, AImstat, AIexamine, img_info,
            imcrop: enhanced to support zipped fits images
        * new functions: AIbmerge, is_fitzip

    2.2.2 - 21 Dec 2014
        * AIcomet: changed bg value from 200 to 400
        * get_mpcephem: allow running without specifying a set name, in which
            case sites.dat is not queried at all

    2.2.1 - 01 Dec 2014
        * phot2icq, fullicq2web: improved handling of remote observations

    2.2   - 19 Nov 2014
        * AIcomet: bugfix in generating psf: while determining companion stars
            we need to add mirrored trailmask - NEEDS VERIFICATION
        * AIccd, AIraw2gray: code to account for rotated raw FITS images moved
            from AIccd to AIraw2gray, it is now generally applied (option -r
            in AIccd has been removed), output images are always in detector
            orientation (as is bias and dark)
        * AIregister, AIstack: propagate header keyword IMGROLL from raw FITS
            input files
        * AIregister: deal with input images which are rotated with respect to
            the reference image (no match of input FITS header keyword IMGROLL)
        * AIwcs: account for rotated input image (containing IMGROLL=Y)

    2.2a3 - 15 Nov 2014
        * AIphotcal: added regfilter to preselect objects from input source
            catalog; added option -m <magerrlim>
        * regfilter: added support to read fits table from stdin

    2.2a2 - 06 Nov 2014
        * kappasigma: bugfix: do not skip data if stddev=0
        * normstat: improved handling of large and narrow samples
        * get_param, get_mpcephem: improve error handling
        * AIcomet: in part 1 changed convert command to apply 'erode' after
            'resize' resulting in smoother mask border
        * new function comet_lightcurve

    2.2a1 - 25 Oct 2014
        * AIdss: bugfix: a typo was causing crash when operating on gray
            input image
        * AIregister:
            - bugfix: center pixel coordinates in <num>.src.head were off
              by 0.5 pixel
            - lower fixed arbitrary pixscale from 0.001 to 0.0003 deg
        * AIpsfsub: rework to use swarp instead of pnmaffine for stacking of
          subimages (pnmaffine is not required anymore)
        * AIcomet: keep initial cosub image (as cosub0)
        * AIfindbad: changed the way of rms determination (use kappasigma
            instead of AImstat)

    2.1.5 - 17 Oct 2014
        * AIsetinfo: improved handling of splitted image sets when determining
            number of images
        * get_mpcephem: bugfix: start time is now handled at best precision
        * ppm2gray: bugfix: keep intensity of PGM input images
        * AImkpsf: added option to set resampling type in swarp
        * AIcomet: propagate resampling type of star stack to AImkpsf

    2.1.4 - 24 Sep 2014
        * AIsource: bugfix: saturation was not read from header file
        * AIstack:
            - bugfix: saturation value was not set
            - added option to set resampling type in swarp
            - store some comand line options in output header file keywords
        * AIwarp: bugfix: some variables had to be declared local
        * AIfindbad: improved algorithm for better consistency of results
        * ppm2rgb: default ratio of rgb intensities changed
        
    2.1.3 - 19 Sep 2014
        * get_mpcephem: improve the way utday and uttime is determined
        * AIphotcal: make gap in call to AIaphot depend on aprad
        * AIimlist: enhanced to support splitted image sets, where associated
            images are sets of the same name but of type==a in sdat (must 
            match exposure time as well)
        * AIaphot: added parameter -a dr,dg,db to brighten mags by some amount
        * new function AIcompare (initial version)

    2.1.2 - 15 Sep 2014
        * AIfindbad: bugfix in calculation of rms
        * jd2ut: bugfix: prec was not initialized
        * get_param: bugfix: lat/long column numbers were swapped
        * AIccd: added option -a <add> to add an offset to output image (applies
            to gray output images only)
        * AIbgdiff: added option -k to keep bg mesh of diff image before fitting
            a suface

    2.1.1 - 12 Sep 2014
        * AIregister: propagate some FITS keywords to measure/<num>.src.head

    2.1 - 29 Aug 2014
        * AIflat: bugfix: now ccdregion is propagated to dcrawopts
        * AIwcs: bugfix: parameter threshold was not used
        * AIcomet: bugfix in psf extraction routine: deal with 0 companions
        * AIsetinfo: bugfix deal with unknown ts,black in output formatting
        * imcrop: bugfix to keep image format for PPM/PGM/PBM input images
        * AIregister:
            - bugfix: added LANG=C to printf and sort statements to correctly
              deal with float numbers
            - now relies on times in exif.dat in UT, do not use AI_TZOFF anymore
            - now register sets using an arbitrary pixscale (fixed to 0.001 deg)
            - get original image size from LDAC_IMHEAD of the reference
              catalog and release dependency on reference image
            - if measure/<num>.src.head exists skip call to scamp but show
              (most) registration results
        * AIccd: added option -r to deal with IMGROLL keyword if operating on
          FITS images
        * AIstack: added option -bad <badpix> to reject those input pixels
        * AIsource, AIregister, AIstack, AIwcs, AIaphot, AIphotcal, phot2icq:
          replaced get_magzero and get_pixscale by new function get_param
        * AIaphot: enhanced to support ring aperture photometry
        * AIphotcal: improved selection of sources, added parameters for user
          defined object center (-c xc,yc), rlim (-r rlim), nlim (-n nlim)
        * AIval: added option -0|1 to output only pixels of the given intensity
          (applies to b/w bitmap images only and requires option -c)
        * AIstack, AIcomet: recognize object location on extended parameter
          omove and use it in call of new function get_wcsrot
        * AIpublish: added parameters for text scaling and output file name
        * jd2ut: added option -t to print UTC time instead of fraction of day
        * replaced function get_rot by get_wcsrot with added parameters for
          xy-position on image
        * xymatch: added parameters to deal with image rotation
        * added functions: img_info get_param is_pbm mkkernel kmedian
        * added env variable AI_SITE
        * removed functions get_magzero get_pixscale
          
    2.1a3 - 06 Aug 2014
        * AIregister: rework of photometric calibration, which is now based
          on photometry of brightest central sources in sextractor catalogues;
          values of fits header keywords CRPIX1/2 of reference image were
          shifted by 0.5 pixel (now sx/sy of reference image are at 0)

    2.1a2 - 25 Jul 2014
        * meftopnm: bugfix to correctly handle symlink to input image
        * AIbgdiff: bugfix when resizing images using convert, now it uses the
          given dimension exactly
        * AIimlist: added fits to the list of recognized extensions for raw
          images
        * AIraw2gray, AIdark, AIccd: enhanced to support fits images on input
        * AIbgmap, AIsfit, AIbgdiff, AIaphot, AImkpsf, AIpsfsub, AIcomet,
          AIphotcal: enhanced to work with pgm images as input
        * AImkpsf, AIpsfsub: changed default spatial psf scale from 2 to 3
        * AImkpsf: changed resample_type from lanczos3 to lanczos2
        * AIcomet: adjustments for identifying bg image, added parameter
          merrlimpsf
        * AIpublish: adjustments in determining text size
        * AIphotcal:
            - added option -e <yc> to include extinction correction
            - added parameter to define aperture radius
            - radii for large aperture correction are now calculated from aprad
        * AIexamine: added support of png images
        * new function AIskygen AIfindbad

    2.1a1 - 06 Jun 2014
        * AIsource, AIstack, AIwcs: bugfix when dealing with pgm images as input
        * AIbgdiff, AIstack: bugfix: skip set if nref is missing
        * mean: bugfix to handle empty data file
        * AIbgmap: added options -p/-s to optionally smooth result by fitting a
          plane/curved surface
        * AIcomet: removed calls to AIbgmap, but reuse existing bg map if it
          exists (comet/<set>.bgm.ppm)

    2.0.5 - 31 May 2014
        * AIphotcal: bugfix for images from telephoto lens which have no entry
          in comet/aicomet.dat (simply use region around image center)
        * AIcomet: enlarged region when searching for psf companions (trailmask
          region size is now resized to 110% instead of 80%)
        * AInoise: rework to allow operating on bayer images without color
          interpolation (use option -b)
        * AIdark: added check for output file and skip processing if it exists
        * AIflat: deal with darks of larger image size by setting AI_CCDREGION
          variable accordingly, added check for output file and skip processing
          if it exists
        * get_mpcephem: improved to produce lists of any number of data rows

    2.0.4 - 05 May 2014
        * AIcomet: bugfix in parsing output from pgmhist (now return unique
          number of white pixels)
        * AIstack: added option -2 to create separate stacks for first and
          second half of images in a set
        * AIdss: added option -1 to get images from dss1r instead of dss2r,
          added option -o outfile to set outfile name (overwriting default)
        * get_omove: error messages improved
        * new helper functions phot2icq fullicq2web

    2.0.3 - 28 Mar 2014
        * AIbgdiff: small bugfix: bgdiff stats of nref is now written only
          once to stdout 
        * AIcomet: droped option -b, background subtraction is now performed on
          setting bgsize>0; default value of psfoff increased from 100 to 200
        * AIwarp: enhanced to work with pgm images as well
        * AIregister: added fallback if files AI_RAWDIR/<num>.hdr are missing
        * AIsetinfo: added options -q, -l
        * AIdss: enhanced to support more use cases (e.g. by providing center
          position on command line)
        * dec2sexa: added options -h, -m to limit output to hours, minutes
        * jd2ut: complete rewrite
        * regfilter: added support for reading region file from stdin
        * new function: AIpublish
        * new helper functions reg2reg is_ppm

    2.0.2 - 11 Mar 2014
        * AIbgdiff:
            - bugfix to handle the case where only the reference image contains
              bad region mask
            - bugfix for AIbgmap of reference image: changed msize from 3 to 1
            - better support for debugging
        * AIwcs: do not depend on AI_RAWDIR anymore
        * AIsetinfo: improved on getting n,nref
        * AIdss: added parameter for dss image chunksize
        * AIexamine: added option -a <anafile>

    2.0.1 - 21 Feb 2014
        * AIcomet: bugfix in algorithm to determine gapcorr
        * AIsfit: bugfix to return exit code of last processing step
        * AIbgdiff: added parameter bgzero, abort program on AIsfit error
        * AIexamine: added random number to name of temporary fits file

    2.0 - 30 Jan 2014
        * AIraw2rgb:
            - removed '-r 1 1 1 1' from dcraw parameters because AHD
              interpolation requires correct color channel intensity ratios,
              using '-r 1 1 1 1' would produce strange artifacts (blocks)
              most notably in red/blue
            - changed default bayer demosaicing algorithm from VNG to AHD
              and added option -q <quality> to set it differently
            - allow for gray flat image division using modded dcraw
        * AIflat: added option -b to keep bayer matrix and create gray
          output image
        * AIccd:
            - added option -b to keep bayer matrix and create gray output images
            - added option -q <quality> to specify bayer demosaicing algorithm
              (default q=3 is for using AHD interpolation)
            - preferably use gray flat field image (bayer matrix)
        * AIbgdiff: added option -b to operate on gray bayer matrix images
        * AIsource: added option -b to operate on bayer matrix images (using
          g1/g2 pixels only)
        * AIregister: bugfix for working with gray images, bugfix for CRPIX[12]
          keyword values (off by 0.5 pixel in x and y)
        * AIstack:
            - changed default combine_type from weighted to average and
              added option -w to set combine_type to weighted if desired
            - ignore FLXSCALE keyword by default
            - rework to allow grayscale input images
            - added -p sparam
            - added -s xyscale
            - added option -b to create rgb from gray bayer matrix images
            - propagate MJD of nref to output header file
        * AImkpsf: rewrite to use swarp instead of pnmaffine
        * AIpsfsub: changed algorithm to better avoid clipping of intensity
          by sequentially adding psf and subtracting background for each image
        * AIcomet: process manually defined background stars before creating
          the comet trail
        * AIsetinfo: added option -x to deal with missing/empty AI_RAWDIR
        * AIexamine: allow for any number/order of images and region files
        * AIinspect: added option -n <num> to limit number of images,
            replaced montage by pnmcat (to preserve intensities)
        * AIaphot: for stars without photometry in a channel the data from
            other channels are now included in output
        * AIbsplit: bugfix using temporary image filename, changed names of
          output files
        * AIdss: enhanced to allow any image size, download images in chunks
            of 30x30 arcmin, rescale to pixelscale of input image
        * new functions dmag2di demosaic AIbnorm AIphotcal

    2.0a8 - 04 Dec 2013
        * AIstack: bugfix: when stacking with -m dr@pa the rotation of the
          reference image with respect to ref was not accounted for
        * AIexamine:
            - bugfix: add -log for every frame
            - start with increased window size (option -s to reduce it)
        * AIcomet
            - set psfoff to ~5*rms (min=100)
            - improved background subtraction algorithm
        * new function get_mpcephem

    2.0a7 - 21 Nov 2013
        * AIccd: bugfix in handling of ccdregion
        * AIimlist: added option -q to suppress warning messages
        * AIpsfsub: added option -s which triggers intensity scaling on
          shifted psf-subimages to preserve faint signal on overlapping objects
          (which would be truncated due to integer arithmetics otherwise)
        * AIregister:
            - changed the way for setting max errors of position and angle to
              avoid mismatches on certain images (e.g. if num==nref)
            - added parameters magerrlim and scampopts
            - replaced -crossid_radius by -match_resol
            - make S/N threshold for high-S/N sample depend on magerrlim
        * AIwcs: replaced -crossid_radius by -match_resol
        * AIflat: added option -z to allow processing of in-camera dark
          subtracted flat field images
        * AIaphot: get magzero from input image header if it exists
        * AIsource, AIregister, AIwcs, AIstack: if operating on image set
          then try to derive pixscale and magzero from camera.dat (using
          AIsetinfo) before using fallback values AI_PIXSCALE and AI_MAGZERO
        * xy2reg: add magnitude to id string if it exists
        * new functions minmax AIsetinfo get_pixscale get_magzero ut2jd
        * new environment variable AI_TELESCOPE containing diameter/focal_length
          to be used by AIsetinfo if focal length and f-ratio are not provided
          by exif info file for a given reference image of an image set
        * removed function AIskypos

    2.0a6 - 25 Oct 2013
        * AIsource, AIfocus, AIaphot: use normalized AI_MAGZERO (for an
          exposure time of 1 sec) and get image exposure time from $AI_SETS
          or image header <img>.head or exif data
        * AIfocus: small bugfix to support reading single digit focus value
          from header file
        * AImkpsf: bugfix to allow pathname in input image
        * AIbgdiff: bugfix when dealing with bad pixel maps: added
          thresholding to have correct black/white image after scaling
        * AIsfit:
            - bugfix to correctly ignore any zero intensity data points
              (e.g. masked areas)
            - trim pixel intensity values of output image within 0 and maxval
        * sexselect:
            - bugfix in case where no rrange and center were provided on
              command line: the filter has been corrected to honor flagsmax
              instead of hard-coded flags<4
            - bugfix when selecting from catalog containing single source
        * AIpsfsub: added option -a which inverts default behaviour of
          subtracting psfimg from img to adding psfimg to img
        * kappasigma: added option -n to skip any zero value data
        * AIval: added option -a to show data for all pixels
        * is_fits: bugfix to correctly follow symbolic links
        * AIccd: added option -z to allow processing of in-camera dark
          subtracted images
        * AIsource: added option [-o outname] to set output file name in case
          of single input image
        * AIexamine: support pbm and pgm images
        * AIwcs:
            - added option -o <maxoff> (in degrees) to use higher posmaxerr
              (without -o the posmaxerr is set to 20% of image diagonale)
            - enhanced to accept omove in format <dr>@<pa> (asec/hr, deg)
        * i2mag: added texp as second parameter
        * ppm2gray: allow reading image from stdin
        * ds9match: added option -n to reject matched objects
        * rade2xy: changed order of parameters, allow to specify column numbers
          for idcol,racol,decol
        * xy2reg: added parameters to shift coordinates before conversion
        * new function AIcomet (preliminary version)
        * new functions get_pscale, regfilter, pbm2reg, xy2rade, regshift
        * rename function ds92pbm to reg2pbm, ds92xy to reg2xy, xy2ds9 to xy2reg

    2.0a5 - 27 Sep 2013
        * new functions AIsfit (replacing AIplane), ds92pbm, xyinreg, normstat,
          kappasigma
        * AIbgdiff: replaced AIplane by AIsfit, applying quadratic surface fit
          by default (option -p to fit planar surface)
        * AIaphot:
            - bugfix in computing photometry error
            - use kappa-sigma-clipping to gather background stats
            - speed improvement by replacing AIval with direct call to convert
        * AIval: bugfix: now pbm images are handled correctly
        * xy2ds9: added parameter to define object radius
        * imcrop: do modulo operation only if necessary
        * removed function AIplane
        
    2.0a4 - 17 Sep 2013
        * AIsource: bugfix: declare sopts as local variable
        * sexa2dec, dec2sexa: bugfix in handling of DE<0
        * AIregister: the stars sample for determining a,e,fwhm has been further
          limited by reducing the max allowed distance from image center (dlim
          changed from 0.4 to 0.3)
        * AIwcs: added option to be passed to scamp
        * AIphotmatch,rade2xy: for tycho catalog objects the id is now build
          from first 2 columns (TYC1 and TYC2)
        * AIbgdiff: add output for num=nref
        * ds9match: input from stdin is now handled (via -)
        * sexselect: abort if input catalog is missing
        * new function exiv2hdr

    2.0a3 - 02 Sep 2013
        * keep track on program version number used ($HOME/.imred_version)
        * AIregister: bugfix in setting projection constants in fits header
          file, now it handles AI_PIXSCALE correctly
        * AIregister, AIwcs:
            - use subset of refldac, inldac tables with limits on magerr
            - added sn_threshold and crossid_radius (3*AI_PIXSCALE) to
              scamp parameters
            - make position_maxerr depend on $AI_PIXSCALE
        * AIsource: do not overwrite existing source catalogs
        * AIplot: allow sexagesimal data on x
        * AIbgdiff: do not overwrite existing diff images
        * sexselect: allow to read input catalog from stdin, added option -f
          to write output table in FITS_LDAC format (to stdout)
        * sexa2dec: implement precision parameter

    2.0a2 - 08 Aug 2013
        * AIsource: bugfix in handling of color channel to be processed
          (default was to use gray conversion, now it is set to process
          all individual color channels by default)
        * AIregister: new options to select measurements for a specific
          color channel from sextractor source catalog
        * sexselect, sexstat, fixldac: parameter changed
          to handle multiple extension FITS tables
        * fixldac, ahead2ldac: output is now written to stdout
        * new env variable AI_MAGZERO
        * new function fitsext
        * removed functions sex2ds9, sexstat (instead use sexselect with
          options -r or -s)

    2.0a1 - 05 Aug 2013
        * AIraw2rgb, AIsubdark2rgb: switch from AHD interpolation to
          VNG interpolation
        * AIsource: changed default type of output catalog from
          ASCII_HEAD to FITS_LDAC, added option -q to suppress
          sextractor messages, get effective gain from ascii fits header
          file if present, added parameter: threshold
        * AIregister: complete rewrite to use scamp instead of crossmatch
        * AIval, AIstat: enhanced to work correctly with FITS images
        * AIbgmap: added option -q to suppress sextractor messages
        * AIaphot: allow ds9 region file format as object catalog, added
          some error statistics
        * AIexamine: added new option -r to load ds9 region file,
          added new option -w to load wcs information, added new
          option -a to add image into new frame of a running ds9
        * AIfocus: use sexstat to extract object statistics
        * AIphotmatch: bugfix to handle missing B,V mags in vizcat
        * new env variable AI_SATURATION
        * rade2xy: enhanced to use wcs distortion parameters
        * xymatch: added parameters for user defined x/y offsets
        * AIraw2gray, AIraw2rgb: implemented dark reduction and removed
          AIsubdark* functions
        * new functions: AIstack meftopnm fixldac ahead2ldac sexstat
          hdr2ahead get_omove
        * removed functions: AImosaic (replaced by AIstack) AIaffine
          AIcombine crossmatch

    1.2 - 05 Jul 2013
        * AIwcs: reuse ahead file if program call is using option -s,
          new parameter refcat (2nd param), changed default reference
          catalog magnitude limit from 18 to 16
        * AIsource: default gain changed from 0.1 to AI_GAIN or 1 
        * new env variable AI_GAIN
        * AImosaic: enhancements to also operate on image sets

    1.2a3 - 27 Jun 2013
        * new functions AIphotmatch, xymatch, rade2xy, gauss
        * AIccd: creation of gray FITS images not required anymore
        * AIwcs: lowerd high s/n threshold (100->40)
        * AIsource: added FWHM_IMAGE to sextractor output catalog file

    1.2a2 - 14 Jun 2013
        * bugfix in AIval: row and col info was off by 1
        * bugfix in median: explicitely use LANG=C because sorting is
          locale dependant
        * AIsource: added deblending parameters (5,6),
          added ability to work on single image file,
          added columns NUMBER EXT_NUMBER to begin of output catalog file
        * rework of AIstar, AIpsfsub
        * AIexamine: better support for MEF fits files
        * replaced ppmtograyfits by a more general function ppm2gray,
          allow for a user-defined set of color ratios,
          use switch -f to get output in FITS format
        * AIval: cx, cy are not limited to integer values anymore
        * crossmatch: rework to get rid of fixed column order in
          sextractor catalog
        * new function AIaphot
        * new functions is_pnm, sexselect, sex2ds9
        * removed function get_pointsource
        
    1.2a1 - 07 Jun 2013
        * AIwcs: added switch -n to disable creation of checkplots,
          added switch -s to use existing sextractor catalog,
          added switch -r to use existing reference star catalog
        * new helper function is_fits
        
    1.1.5 - 17 Mai 2013
        * AIinspect: create montage from individual images (when using
          default viewer imagej)
        * AIdss: use wcs header to determine width and height of DSS image
          region instead of using fixed values
        * AIwarp: do not save coadded weight fits file if there were no
          weight maps for input images
        * new function AIbgdiff
          
    1.1.4 - 30 Apr 2013
        * bugfix in AIpsfsub: final image was to low by 2x $psfbg
        * bugfix in AIimgen: showhelp was not declared local
        * bugfix in AIflat: i was not local and modified by AImstat
        * AIval: added option -c to add image coordinates in output
        * AIaffine: use bad region masks if present (bgvar/$num.bad.png)
        * AIwarp: rework to allow combining multiple images
        * AIfocus: rework to include more stars, additional parameters
        * new functions AIplane, ds9match
        * added usage help to some functions

    1.1.3 - 14 Apr 2013
        * new env variable AI_PIXSCALE
        * AIsource, AIwcs, AIstar, AImkpsf: new parameter bgsize
        * bugfix in AIccd: was still accepting cr2 raw files only
        * bugfix in AIwcs: parameter 3 was set to both maglim and fitdegrees
        * AIwcs: increase robustness of fit by providing north axis position
          angle in degrees instead of just using 4 fixed orientations 
        * AInoise, AIbg, get_imfilename: add support for more raw image formats
        * AIfocus: use get_imfilename to find image
        * AIpsfsub: improved subtraction algorithm (by using imagemagick
          convert) resulting in a large speed-up
        * new function get_rot

    1.1.2 - 26 Mar 2013
        * AIplot: additional error checkings, allow to set custom title (-t)

    1.1.1 - 21 Mar 2013
        * AIstar: improve matching sextractor catalog by choosing the closest
          object
        * AIflat,AIccd,AIsource,AIregister: support for more raw image types
        * AIimgen: added option -p to produce ppm output file (instead of fits)

    1.1 - 08 Mar 2013
        * initial basic support for several raw image types other than Canon
          cr2 (AIimlist, AIdark)
        * new functions: AIbgmap, AIstar, AIpsf, AIpsfsub
        * new helper functions is_integer, is_pgm, i2mag, di2dmag, jd2ut,
          ds92xy xy2ds9
        * bugfix: do not use printf shell buildin anymore because it interprets
          strings starting with zero as octal numbers
        * always use AIimlist to find images for a given set (instead of
          calling: seq n1 n2)
        * new env variable AI_OVERSCAN, if it contain a valid text file name
          which consists of lines with fields <imnum> <16bit_overscan_value>
          then correct for overscan in all raw image conversion commands
          (AIraw*, AIsubdark*)
        * AIsource: added parameters for better control of results: fwhm
          (changing default from 1.2 to 4), pixscale (from 1 to 1.32),
          gain (from 0 to 0.1) and magzero (keeping default 25.5)
        * AIimlist: less restrictive handling of missing images: return error
          only if there are no images at all in a set,
          added options -f and -n to only show filename or image number,
          handle set where image numbers run over 9999 and continue with 0001,
          if parameter set is used then intype is not evaluated anymore
        * AIaffine: added parameter to set interpolation degree (default value
          is 1=linear), added check for free disk space
        * AImstat: added support for stats on bayer grid cells,
          added support for reading image from stdin (using -)
        * AIoverscan: new default is to measure left side overscan area,
          adopted to use new imcrop syntax
        * AIplot: added several options (-a, -f, -p|b, -s|w), e.g. option -a
          deal with image numbers which run over 9999 and continue at 0001
        * AInoise: if intype is d then use second bayer cell in statistics
          for intensity correction, adopted to use new imcrop syntax
        * AIstiff: added several parameters
        * AIbsplit: make it work for pgm images too
        * imcrop, AIval parameters changed
        * immedian modified to use pgmhist instead of AIval and median
        * get_imfilename: deal with image numbers of less than 4 digits
        * no need for library stat_fun.sh anymore (loading disabled)

    1.0 - 06 Nov 2012
        * AIwcs: added parameter fitdegrees to set degrees of polynomial fit
          to image distortions used by scamp, removed code for image warping
        * new function AIwarp
        * new function AImosaic
        * new function ppmtograyfits
        * new function AIoverscan
        * new function AIraw2fullgray
        * new parameter AI_DEBUG, if it is not the empty string some additional
          information is written to stderr
        * AInoise: added parameter for input image type
        * in all function reading raw images saturation value lowered by 1
          
    0.9.1 - 10 Okt 2012
        * AIccd, AInoise: take account of AI_EXCLUDE
        * AIplot: introduce AI_XSKIP to skip points according to their x
          value
          
    0.9 - 28 Sep 2012
        * introduced option in dcraw calls to disable all flipping (rotation)
          which means you should not set -t option in AI_DCRAWPARAM anymore,
          AIcheck_ok issues now a warning message if AI_DCRAWPARAM or AI_SETS
          is defined
        * imcrop, _imstat, immedian: changed intensity scaling in case of raw
          images, now it calls AIraw2gray (with scaling to 16bit) instead of
          'dcraw -D -4' (without scaling)
        * imcrop: changed output image format from ppm to pnm
        * immedian: add code to support non-raw images
        * AIstat, AImstat: changed default to use full image, to get statistics
          for center region only (old behaviour) you must use option -c,
          functions AIflat, AIccd, AInoise adapted
        * AIfocus: changed default for dlim from 0.3 to 0.4, if image width
          and height are below 1000 set dlim=1, to quickly determine best focus
          you should crop images in dcraw using appropriate parameters, e.g.
            AI_DCRAWPARAM='-R 600 600' AIfocus <first> <last>
        * AIval: replace convert by pnmnoraw to output ascii data
          results in a huge speed-up (however output text format changed)
        * AIplot: reduce gnuplot fit output (remove all but last iteration)
        * AIdark, AIflat: add parameter to optionally process a single set only
        * AInoise: changed the way of bg correction from scaling (multiply)
          to offset (add) per default, added parameter do_bgscale to change
          this back to scaling
        * AInoise: running without setname now processes all sets

    0.8 - 24 Apr 2012
        * all measurements data (AIsource, AIregister, AIbg) are now written
          to directory measure instead of current directory
        * new functions AIdss, AIimgen
        * AIwcs modified to run without arguments (evaluates set.dat and
          header file for reference image)
        * dec2sexa: implemented use of prec
        * rename imstat() to _imstat() to avoid collision with program imstat
          from cfitsio examples
        * added usage info to several functions
        
    0.7 - 14 Oct 2011
        * bugfix in AIccd: changed the way mrgb is obtained to support
            the use of (artificial) gray flatfield image
        * fixed some tempfile issues
        * modified AIsource to use windowed positional parameter
            for measurements (sextractor) instead of isophotes which
            considerably reduces magnitude biased results (e.g. for a),
            increased default threshold in sextractor from 3 to 5
        * support AI_EXCLUDE in AIsource and AIregister
        * changed limits xlim,ylim in crossmatch from 200,100 to 300,200
        * replace (obsolete) pnmaverage by pnmcombine
        * stddev: use mean instead of median
        * crossmatch: additional parameters
        * AIinspect: major rewrite, use imagej as default viewer (to use ds9
            via AIexamine instead you must set parameter no. 8 to 'ds9')
        * AIbg: major rewrite, e.g. new parameters geomlist, useaff
        * new functions: mean, roi2geom, get_pointsources, AIimlist,
            AIplot, AIstiff, AIwcs, AIfocus
        * new functions AIaffine AIcombine to replace AIstack
        * added -h switch for usage info to several functions (must be the
            first parameter)
          
    0.6 - 25 Aug 2011
        * introduced mandatory env variable AI_RAWBITS to specify the
          dynamic range of the CCD in bits
        * introduced optional env variable AI_DCRAWPARAM to specify
          additional options for dcraw (e.g. rotation)
        * AIccd: reuse images already processed
        * AIstack: added support for stacking on moving object
        
    0.5 - 16 May 2011
        * implemented AIstack
        
    0.4 - 13 May 2011
        * implemented AIccd, AIsource, AIregister

    0.3 - 10 May 2011
        * new format of AI_SETS file using the following fields now:
          ltime sname target type texp n1 n2 nref dark flat
        * added support for bad pixel file via AI_BADPIX

    0.2 - 27 Apr 2011
        * finished AIdark and AIflat
        * started AInoise

    0.1 - 20 Apr 2011
        * initial version

----


# notes on image coordinates:
# image size w x h
# coordinates of center of upper-left pixel
#   FITS: (1.0, h)
#   PPM:  (0.5, 0.5)
#   pixel index (e.g. in imagemagick and imagej):  (0,   0)

# note on PBM image masks: white corresponds to value 0


#------------------------
#   language settings
#------------------------
export LC_NUMERIC=C


#------------------------
#   program aliases
#------------------------
load_aliases () {
    # define aliases if binary names have changed
    shopt -s expand_aliases
    type -p sextractor > /dev/null 2>&1 &&
        alias sex=sextractor
    type -p source-extractor > /dev/null 2>&1 &&
        alias sex=source-extractor
    type -p SWarp > /dev/null 2>&1 &&
        alias swarp=SWarp
}

load_aliases


#--------------------
#   checkings
#--------------------

# environment variables
AIenv () {
    local verbose
    test "$1" == "-v" && verbose=1 && shift 1
    local var
    
    for var in AI_RAWDIR AI_TMPDIR AI_SITE
    do
        if [ "${!var}" ]
        then
            echo "$var=${!var}"
        else
            echo "$var undefined"
        fi
    done
    
    for var in AI_TELESCOPE AI_EXCLUDE AI_DEBUG AI_MAXPROCS \
        AI_RAWBITS AI_PIXSCALE AI_GAIN AI_SATURATION AI_MAGZERO \
        AI_BADPIX AI_OVERSCAN AI_LATITUDE AI_LONGITUDE AI_TZOFF \
        AI_OBSICQID AI_OBSERVER AI_CCDREGION AI_SETS AI_XSKIP AI_DCRAWPARAM
    do
        if [ "${!var}" ]
        then
            echo "$var=${!var}"
        else
            test "$verbose" && echo "$var undefined"
        fi
    done
}

# check structure of parameter files
checkparamdat () {
    local showhelp
    local skip_check_header
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-s" && skip_check_header=1 && shift 1
    done
    
    local pdat=$1
    local ncol=$2
    local x
    local line
    local lnum
    local retval=0
    
    (test "$showhelp" || test $# -ne 2) &&
        echo -e "usage: checkparamdat [-s] <paramdat> <ncolumns>" >&2 &&
        return 1

    # check for header line containing column names
    if [ ! "$skip_check_header" ]
    then
        ! (grep -v "^$" $pdat | lines 1 | grep -q "^# ") &&
            echo "ERROR: missing header line (starting with \"# \") in $pdat" >&2 &&
            retval=255
        x=$(grep -v "^$" $pdat | lines 1 | sed -e 's,^# ,,' | sed -e 's,#.*,,' | wc -w)
        test $x -ne $ncol &&
            echo "ERROR: found $x instead of $ncol column names in $pdat" >&2 &&
            retval=255
    fi
    
    # check each entry (line) for correct number of fields
    lnum=0
    while read
    do
        lnum=$((lnum + 1))
        line=$(echo $REPLY | sed -e 's,#.*,,')
        test -z "$line" && continue
        x=$(echo $line | wc -w)
        # ignore lines from iTelescope plans
        test $pdat == "set.dat" && test "${line:0:1}" == ";" && continue
        test $pdat == "set.dat" && test $x -eq 3 && continue
        test $x -ne $ncol &&
            echo "ERROR: found $x instead of $ncol fields in $pdat (line $lnum)" >&2 &&
            retval=255
    done < $pdat
    
    # check for newline at end of file
    ! (tail -1 $pdat | cat -ev | grep -q "\$$") &&
        echo "ERROR: missing newline at end of $pdat" >&2 &&
        retval=255

    return $retval
}

# check for dependencies
AIcheck () {
    AIcheck_ok -r -v 2>&1
}

AIcheck_ok () {
    local retval=0
    local quiet     # if set, warning messages are suppressed
    local do_check_rawdir
    local verbose
    local i
    local str
    for i in 1 2 3
    do
        test "$1" == "-q" && quiet=1 && shift 1
        test "$1" == "-r" && do_check_rawdir=1 && shift 1
        test "$1" == "-v" && verbose=1 && shift 1
    done
    
    load_aliases

    # show info about OS and installed packages
    if [ "$verbose" ]
    then
        echo "# operating system information:"
        uname -a
        lsb_release -a
        echo
        echo "# language settings"
        locale
        echo
        
        str="imagemagick|graphicsmagick|libvips|gnuplot|plplot|parallel "
        str="$str|^....python3 |python3-pyvips|python3-numpy|python3-ephem"
        str="$str|saods9 |xpa-tools|wcstools|aladin|libcfitsio"
        str="$str|missfits|scamp|sextractor|skymaker|stiff|swarp|cfitsio|stilts |airtools"
        echo "# installed packages:"
        dpkg -l | grep -E "$str" | grep -vwE "libieee1284-3:amd64|startpar" | \
            awk '{printf("%-4s %-32s %s\n", $1, $2, $3)}'
        echo
    fi >&2
    
    # check dependencies
    # libcfitsio/cexamples
    #   imcopy:   meftopnm AIskygen
    #   imarith:  imbgsub starcombine
    #   fitscopy: regfilter AIregister AIcomet
    #   listhead: many functions
    # wcstools
    #   imhead sethead sky2xy xy2sky newfits delwcs
    for p in dcraw-tl gm convert rsvg-convert potrace exiftool gnuplot curl wget \
             ds9 xpaget xpaset parallel \
             pnmcombine pnmccdred pnmtomef pnmrowsort \
             imcopy imarith imlist imstat fitscopy listhead \
             imhead sethead sky2xy xy2sky newfits delhead delwcs \
             stilts sex scamp swarp stiff sky missfits vips python3
    do
        ! type -p $p > /dev/null 2>&1 && retval=255 &&
            echo "ERROR: program $p not in search path" >&2
    done
    test $retval -ne 0 && return $retval
    
    # check for aclient if scamp version < 2.2
    p=aclient
    test "$(scamp -v | cut -d " " -f3 | awk -F "." '{
        if($1<2 || ($1==2 && $2<2)){print "old"}}')" && 
        ! type -p $p > /dev/null 2>&1 && retval=255 &&
            echo "ERROR: program $p not in search path" >&2

    # check if graphicsmagick is compiled with q16
    gm -version | grep -q "\-\-with-quantum-depth=16"
    test $? -ne 0 &&
        echo "ERROR: incompatible version of graphicsmagick." >&2 &&
        retval=255
    # check AI_TMPDIR
    test "$AI_TMPDIR" && test ! -d "$AI_TMPDIR" &&
        echo "ERROR: temp directory $AI_TMPDIR does not exist." >&2 &&
        retval=255
    (test $retval -ne 0 || test "$quiet") && return $retval
    
    # show version information of some programs
    if [ "$verbose" ]
    then
        echo "# version information of programs:"
        echo "# airfun.sh:" $AI_VERSION
        echo "# dcraw-tl: " $(dcraw-tl | grep -i v | lines 1)
        echo "# ds9:      " $(ds9 -version | grep ds9)
        echo "# stilts:   " $(stilts -version | grep -i "STILTS.*version")
        echo "# missfits: " $(missfits -v)
        echo "# scamp:    " $(scamp -v)
        echo "# sex:      " $(sex -v)
        echo "# sky:      " $(sky -v)
        echo "# stiff:    " $(stiff -v)
        echo "# swarp:    " $(swarp -v)
        echo
    fi >&2
    
    # issue some warnings if AI_RAWDIR does not exist or AI_SETS are defined
    test "$AI_RAWDIR" && test ! -d "$AI_RAWDIR" &&
		test "$do_check_rawdir" &&
        echo "WARNING: raw file directory $AI_RAWDIR does not exist." >&2
    test "$verbose" && test "$AI_SETS" && echo "WARNING: AI_SETS=$AI_SETS" >&2
    
    # check for camera and sites data files
    test ! -f camera.dat &&
        echo "WARNING: missing camera database (camera.dat)." >&2
    test ! -f sites.dat &&
        echo "WARNING: missing sites database (sites.dat)." >&2
    test ! -f refcat.dat &&
        echo "WARNING: missing reference catalog database (refcat.dat)." >&2
    return $retval
}


debuglog () {
    # write some debug log information
    test "$USER" != "lehmann" && return
    local logfile=/tmp/aidebug.log
    local msg="$1"
    test -z "$msg" && return
    test "AI_DEBUGLOG" && echo $(date +"%y%m%d %H:%M:%S") "$msg" >> $logfile
}


showprof () {
    # show profiling results as written by airtools-cli when AI_PROFILE=1
    # ref: https://stackoverflow.com/questions/5014823/how-to-profile-a-bash-shell-script-slow-startup
    local pid=$1
    local prefix=/tmp/profile
    local last
    local first
    local crt
    local ctot
    test -z "$pid" &&
        pid=$(ls -dtr $prefix.[0-9]*.tim 2>/dev/null | tail -1 | cut -d '.' -f2)
    test -z "$pid" && echo "ERROR: missing pid" >&2 && return 255
    test ! -s $prefix.$pid.tim &&
        echo "ERROR: missing profiler data for pid=$pid" >&2 && return 255
    paste <(
    while read tim
    do
        [ -z "$last" ] && last=${tim//.} && first=${tim//.}
        crt=000000000$((${tim//.}-10#0$last))
        ctot=000000000$((${tim//.}-10#0$first))
        printf "%12.9f %12.9f\n" ${crt:0:${#crt}-9}.${crt:${#crt}-9} \
                                 ${ctot:0:${#ctot}-9}.${ctot:${#ctot}-9}
        last=${tim//.}
    done < $prefix.$pid.tim
    ) $prefix.$pid.log
}

# compare version numbers (print index of higher version number)
vcomp () {
    # output value is index of higher version: 1: v1>v2, 2: v1<v2, 0: v1=v1
    # notes: version parts are splitted by .
    #   any part must start with number (n) optionally followed by text string (a),
    #   optionally followed by another number (x)
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1    
    local v1=$1
    local v2=$2
    local n=0
    local p1
    local p2
    local n1
    local n2
    local a1
    local a2
    local x1
    local x2
    local val
    
    (test "$showhelp" || test $# -ne 2) &&
        echo "usage: vcomp <vers1> <vers2>" >&2 &&
        return 1

    for p1 in ${v1//./ }
    do
        n=$((n+1))
        p2=$(echo ${v2//./ } | cut -d ' ' -f$n)
        test "$AI_DEBUG" && printf "%-2s %-6s %-6s\n" $n $p1 $p2
        test "$p1" == "$p2" && continue
        test -z "$p2" && val=1 && break
        # evaluate n
        n1=$(echo $p1 | sed -e 's,[a-zA-Z]\+[0-9]*$,,')
        n2=$(echo $p2 | sed -e 's,[a-zA-Z]\+[0-9]*$,,')
        test "$AI_DEBUG" && printf "   %6s %6s\n" $n1 $n2
        test $n1 -gt $n2 && val=1 && break
        test $n1 -lt $n2 && val=2 && break
        # evaluate a
        a1=$(echo $p1 | sed -e 's,^'$n1',,; s,[0-9]*$,,')
        a2=$(echo $p2 | sed -e 's,^'$n2',,; s,[0-9]*$,,')
        test "$AI_DEBUG" && printf "   %6s %6s\n" $a1 $a2
        test -z "$a1" && test -z "$a2" && continue
        test -z "$a1" && test "$a2" && val=1 && break
        test "$a1" && test -z "$a2" && val=2 && break
        test "$a1" \> "$a2" && val=1 && break
        test "$a1" \< "$a2" && val=2 && break
        # evaluate x
        x1=$(echo $p1 | sed -e 's,^'$n1$a1',,')
        x2=$(echo $p2 | sed -e 's,^'$n2$a2',,')
        test "$AI_DEBUG" && printf "   %6s %6s\n" $x1 $x2
        test -z "$x1" && test -z "$x2" && continue
        test -z "$x1" && test "$x2" && val=2 && break
        test "$x1" && test -z "$x2" && val=1 && break
        test "$x1" -gt "$x2" && val=1 && break
        test "$x1" -lt "$x2" && val=2 && break
    done
    if [ -z "$val" ]
    then
        n=$((n+1))
        p2=$(echo ${v2//./ } | cut -d ' ' -f$n)
        test "$p2" && val=2
    fi
    test -z "$val" && val=0
    echo $val
}


#------------------------
#   low level functions
#------------------------

is_integer () {
    local x=$*
    local err
    err=$(echo $x | awk '{
        if ($0~/^[+-]?[[:digit:]]+$/) {print 0} else {print 255}
    }')
    return $err
}

is_number () {
    local x=$*
    local err
    echo $x | grep "[0-9]" > /dev/null || err=255
    test -z "$err" && err=$(echo $x | awk '{
        if ($0~/^[+-]?[[:digit:]]*[\.]?[[:digit:]]*$/) {print 0} else {print 255}
    }')
    return $err
}

is_equal () {
    # compare two numbers
    local x=$1
    local y=$2
    test $# -ne 2 && echo "ERROR: two parameters required" >&2 && return 255
    local err
    err=$(echo $x $y | awk '{
        d=$1-$2; if (d == 0) {print 0} else {print 255}
    }')
    return $err
}

is_setname () {
    local quiet
    test "$1" == "-q" && quiet=1 && shift 1
    local str=$1
    local sdat=${AI_SETS:-"set.dat"}
    local found
    
    test ! -f $sdat && test "$quiet" && return 255
    found=$(grep -v "^#" $sdat | awk -v s="$str" '{
        if ($1!~/^[0-9][0-9]:[0-9][0-9]/) next
        if ($2!=s) next
        if ($5!~/^[0-9]+$/) next
        if ($6!~/^[0-9]+$/) next
        if ($7!~/^[0-9]+$/) next
        if ($8!~/^[0-9]+$/ && $8!="-") next
        if (NF<10) next
        x=1
        }END{print x}')
    test -z "$found" && return 255
    return 0
}

is_reg () {
    # check if file is a valid ds9 region file
    local f=$1
    file -L "$1" | grep -qiw "text"
    test $? -ne 0 && return 255
    head -1 $1 | grep -q "^# Region file format: DS9 version [4-9]"
    test $? -ne 0 && return 255
    return 0
}

is_ahead () {
    # check if it is an ASCII representation of a FITS header file
    debuglog "is_ahead"
    local f=$1
    local str=$(file -L "$1" | cut -d ":" -f2)
    #file -L "$1" | cut -d ":" -f2 | grep -q "empty" && return 0
    #file -L "$1" | cut -d ":" -f2 | grep -q "FITS image"
    test "${str/empty/}" != "$str" && return 0
    
    if [ "${str/FITS image/}" != "$str" ]
    then
        listhead "$f" 2> /dev/null | grep -wq HDU && return 255
        test $(cut -c 1 $f | grep -v "[A-Z]" | wc -l) -ne 0 && return 255
    else
        test "${str/ASCII text/}" == "$str" && test "${str/ISO-8859 text/}" == "$str" &&
            return 255
        grep -Ev "^COMMENT|^HISTORY|^END" "$f" | grep -qEv "^[A-Z][A-Z0-9_ \-]{,7}=" &&
            return 255
    fi
    return 0
}

is_wcs () {
    # check whether the given image or header file contains a valid wcs calibration
    debuglog "is_wcs"
    local f=$1
    local x
    
    # check input file type
    if ! (is_ahead $f || is_fits $f || is_fitzip $f)
    then
        test "$AI_DEBUG" && echo "ERROR in is_wcs: $f has unsupported file type." >&2
        return 255
    fi
    
    x=$(get_header -q $f CTYPE1,CTYPE2,CRVAL1,CRVAL2,CRPIX1,CRPIX2 | wc -l)
    test $x -ne 6 && return 255

    x=$(get_header -q $f CD1_1,CD1_2,CD2_1,CD2_2 | wc -l)
    if [ $x -eq 4 ]
    then
        # TODO: handle no-coord registration with fixed CDX_Y values
        x=$(get_header -s $f CD1_1,CD1_2,CD2_1,CD2_2 | \
            awk -v a=3.000111E-04 -v b=0 -v e=1E-10 '{
                x=1*$1; if(x<0){x=-1*x}; d1=x-a; d2=x-b
                if(d1>e && d2>e){wcs=1}}END{if(wcs==1){print "ok"}}')
        test "$x" && return 0
    else
        x=$(get_header -q $f CDELT1,CDELT2,CROT1,CROT2 | wc -l)
        test $x -eq 4 && return 0
    fi
    
    return 255
}

is_raw () {
    # check if file is DSLR camera RAW file
    dcraw-tl -i "$1" > /dev/null 2>&1
    test $? -ne 0 && return 255
    return 0
}

is_gacam_raw () {
    local file=$(readlink -f "$1")
    local model
    local rows
    dcraw-tl -i "$file" > /dev/null 2>&1
    test $? -ne 0 && return 255
    model=$(exiftool -S -Model $file | sed -e 's|.*: ||')
    echo "$model" | grep -q "PENTAX K-5 II"
    rows=$(exiftool -S -RowsPerStrip $file | sed -e 's|.*: ||')
    case "$model" in
        "PENTAX K-5 II"*) test $rows -ne 3344 && return 255;;
        *)  return 255;;
    esac
    return 0
}

is_pnm () {
    local file=$(readlink -f "$1")
    pnmfile "$file" > /dev/null 2>&1
    test $? -ne 0 && return 255
    #gm identify "$file" > /dev/null 2>&1
    #test $? -ne 0 && return 255
    return 0
}

is_ppm () {
    local file=$(readlink -f "$1")
    is_pnm "$file" && pnmfile "$file" | cut -d ":" -f2 | grep -wq PPM
    test $? -ne 0 && return 255
    return 0
}

is_pgm () {
    local file=$(readlink -f "$1")
    is_pnm "$file" && pnmfile "$file" | cut -d ":" -f2 | grep -wq PGM
    test $? -ne 0 && return 255
    return 0
}

is_pbm () {
    local file=$(readlink -f "$1")
    is_pnm "$file" && pnmfile "$file" | cut -d ":" -f2 | grep -wq PBM
    test $? -ne 0 && return 255
    return 0
}

is_png () {
    local file=$(readlink -f "$1")
    file "$file" | cut -d ":" -f2 | grep -q "^ PNG"
    test $? -ne 0 && return 255
    return 0
}

is_mask () {
    # check, if image has 2 colors and at most 50% forground pixels (inside mask area)
    local img=$1
    local fgcolor=$2  # color of pixels inside mask area (=foreground)
    local limit=${3:-50}
    local ncol
    local val
    local npix
    local fgpercent
    
    (test $# -gt 3 || test $# -lt 1 || test "$1" == "-h") &&
        echo "usage: is_mask <img> [fgcolor] [max%|$limit]" >&2 && return 1
    test "$fgcolor" != "white" && test "$fgcolor" != "black" &&
        echo "ERROR: fgcolor must be either white or black." >&2 && return 255

    ncol=$(identify -format "%k" $img)
    case $ncol in
        -1) # TODO: handle image of unique color
            test $fgcolor == "white" && val=0
            test $fgcolor == "black" && val=65535
            ;;
        2)  test $fgcolor == "white" && val=65535
            test $fgcolor == "black" && val=0;;
        *)  echo "ERROR: $img is not b/w image." >&2 &&
            return 255;
    esac
    
    npix=$(identify $img | cut -d ' ' -f3 | tr 'x' '*' | bc)
    fgpercent=$(gm convert $img -depth 16 pgm:- | pgmhist - | grep "^$val" | \
        awk -v n=$npix '{if (NF>2) printf("%.0f", $2*100/n)}')
    test "$AI_DEBUG" && echo "$img: $fgpercent% $fgcolor (ncol=$ncol)." >&2
    test -z "$fgpercent" &&
        echo "ERROR: no foreground pixels." >&2 &&
        return 255
    test $fgpercent -gt $limit &&
        echo "ERROR: too many foreground pixels ($fgpercent% > $limit%)." >&2 &&
        return 255
    return 0
}

is_fits () {
    debuglog "is_fits"
    file -L "$1" | cut -d ":" -f2 | grep -q "FITS image"
    test $? -ne 0 && return 255
    listhead "$1" 2> /dev/null | grep -wq HDU
    test $? -ne 0 && return 255
    return 0
}

is_fitsrgb () {
    # MEF with 3 extensions of 2D images
    local f="$1"
    local str
    file -L "$f" | cut -d ":" -f2 | grep -q "FITS image"
    test $? -ne 0 && return 255
    test $(listhead "$f" | grep -w HDU | wc -l) -ne 3 && return 255
    str=$(listhead "$f" | grep -w "^NAXIS" | awk '{printf("%s ", $3)}')
    test "$str" != "2 2 2 " && return 255
    return 0
}

_unused_is_fitsrgb () {
    # MEF with min 3 extensions, 3 of those are 2D images
    local f="$1"
    local nimg
    file -L "$f" | cut -d ":" -f2 | grep -q "FITS image"
    test $? -ne 0 && return 255
    nimg=$(listhead "$f" | grep -w "^NAXIS" | grep -w 2 | wc -l)
    test $nimg -ne 3 && return 255
    return 0
}

is_fitscube () {
    # fits cube with 3 2D image planes in first HDU
    local f="$1"
    local str
    file -L "$f" | cut -d ":" -f2 | grep -q "FITS image"
    test $? -ne 0 && return 255
    #test $(listhead "$f" | grep -w HDU | wc -l) -ne 1 && return 255
    str=$(listhead "$f[0]" | grep -wE "^NAXIS|^NAXIS3" | awk '{printf("%s ", $3)}')
    test "$str" != "3 3 " && return 255
    return 0
}

is_fitzip () {
    file -L "$1" | cut -d ":" -f2 | grep -q "Zip archive"
    test $? -ne 0 && return 255
    unzip -p "$1" | dd bs=2880c count=1 status=noxfer 2>/dev/null | \
        file - | cut -d ":" -f2 | grep -q "FITS image"
    test $? -ne 0 && return 255
    unzip -p "$1" | listhead - 2> /dev/null | grep -wq HDU
    test $? -ne 0 && return 255
    return 0
}

is_fitsgz () {
    file -L "$1" | cut -d ":" -f2 | grep -qi "gzip"
    test $? -ne 0 && return 255
    #gunzip -c "$1" | dd bs=2880c count=1 status=noxfer 2>/dev/null | \
    #    file - | cut -d ":" -f2 | grep -q "FITS image"
    #test $? -ne 0 && return 255
    #gunzip -c "$1" | listhead - 2> /dev/null | grep -wq HDU
    listhead "$1" 2> /dev/null | grep -wq HDU
    test $? -ne 0 && return 255
    return 0
}

is_diskspace_ok () {
    # check if there is enough disk space to hold nimg images
    local showhelp
    local verbose
    local i=$1
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-v" && verbose=1 && shift 1
    done
    
    local dir=$1
    local img=$2
    local nimg=$3
    local bytes=${4:-6} # bytes per pixel required
    local size=${5:-""}
    local mbextra=${6:-20}
    local w
    local h
    local mbneeded
    local mbfree

    (test "$showhelp" || test $# -lt 3) &&
        echo -e "usage: is_diskspace_ok [-v] <dir> <img> <nimg> [Bpp|$bytes]" >&2 &&
        return 1

    # get image width and height from reference image $img
    w=$(identify $img | cut -d " " -f3 | cut -d "x" -f1)
    h=$(identify $img | cut -d " " -f3 | cut -d "x" -f2)
    mbneeded=$((w*h*nimg*bytes/1024/1024 + mbextra))
    mbfree=$(/bin/df -B 1M "$dir" | tail -1 | awk '{print $4}')
    test $mbneeded -ge $mbfree &&
        echo "ERROR: $mbneeded MB disk space needed ($mbfree MB free)." >&2 &&
        return 255
    test "$verbose" && echo "# requesting $mbneeded/$mbfree MB." >&2
    return 0
}

log10 () {
    echo $1 | awk '{print log($1)/log(10)}'
}

exp10 () {
    echo $1 | awk '{print exp($1*log(10))}'
}

sqrt () {
    echo $1 | awk '{print sqrt($1)}'
}

# intensity to magnitude
i2mag () {
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    local i=$1
    local texp=${2:-"1"}
    local zero=${3:-"25.5"} # zero point magnitude
    
    (test "$showhelp" || test $# -lt 1) &&
        echo -e "usage: i2mag <intensity> [texp|$texp] [magzero|$zero]" >&2 &&
        return 1

    echo $zero $texp $i | awk '{printf("%.3f\n", $1-2.5/log(10)*log($3/$2))}'
}

mag2i () {
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    local mag=$1
    local texp=${2:-"1"}
    local zero=${3:-"25.5"} # zero point magnitude
    
    (test "$showhelp" || test $# -lt 1) &&
        echo -e "usage: mag2i <mag> [texp|$texp] [magzero|$zero]" >&2 &&
        return 1

    echo $zero $texp $mag | awk '{printf("%.0f\n", $2*exp(log(10)*0.4*($1-$3)))}'
}

# intensity ratio to magnitude difference
di2dmag () {
    local di=$1
    echo $di | awk '{printf("%.3f\n", -2.5/log(10)*log($1))}'
}

# mag diff to intensity ratio
dmag2di () {
    local dm=$1
    echo $dm | awk '{print exp(0.4*$1*log(10))}'
}

# determine new mag of object from measurement in residual image
# using previous mag estimate from a photometry data file
newmag () {
    local showhelp
    local doublemagdiff # if set, split intensity into two components with the
                        # given magnitude difference
    local do_quiet      # if set, reduce some output messages
    local i
    for i in 1 2 3
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-d" && doublemagdiff=$2 && shift 2
        test "$1" == "-q" && do_quiet=1 && shift 1
    done
    local set=$1
    local photcat=$2
    local id=$3
    local area=$4       # area size in pixels
    local mrgb=$5       # mean rgb intensity within area, comma separated
    local scale=${6:-4} # xy-scale factor of the image, where mrgb has been measured
    local bg=${7:-1000}
    local line
    local texp
    local mzero
    local c
    local oldmag
    local bgc
    local mag
    local val
    local sign
    local di
    local resmag
    local dmag
    local omag
    local odiff
    local off
    local x
    local y
    local msg
    
    (test "$showhelp" || test $# -lt 4) &&
        echo "usage: newmag [-d doublemagdiff] <set> <photcat> <id> <area> <mrgb> [scale|$scale] [bg|$bg]" >&2 &&
        return 1
    test "$photcat" && test ! -f $photcat &&
        echo "ERROR: photometry file $photcat does not exist." >&2 &&
        return 255
    
    test "$id" && test "$photcat" && line=$(grep "^$id " $photcat)
    #echo "line=$line"
    test "$id" && test -z "$line" && test ! "$do_quiet" &&
        echo "WARNING: object $id not found in $photcat" >&2
    test -z "$id" && id="XXXXX"
    texp=$(AIsetinfo -b $set | lines 1 | awk '{print $5}')
    mzero=$(get_param camera.dat magzero $set)
    test ! "$do_quiet" && echo "# texp=$texp mzero=$mzero"
    x=$(echo $line | cut -d " " -f2)
    y=$(echo $line | cut -d " " -f3)
    msg=$(echo "$line" | cut -c 52-)
    for c in $(seq 1 $(echo $mrgb | awk -F ',' '{print NF}'))
    do
        oldmag=$(echo $line | cut -d " " -f$((3+c)))
        bgc=$(echo $bg | cut -d ',' -f$c)
        val=$(echo $mrgb | cut -d ',' -f$c | \
            awk -v a=$area -v b=$bgc -v s=$scale '{printf("%d", ($1-b)*a/s/s)}')
        sign=1; test $val -lt 0 && val=$((-1*val)) && sign=-1
        if [ $val -eq 0 ]
        then
            resmag=99.999; dmag=0.000; mag=$oldmag; val=1
            test -z "$oldmag" && mag="-" && oldmag="-"
        else
            resmag=$(i2mag $val $texp $mzero | awk '{printf("%.3f", $1)}')
            if [ "$oldmag" ]
            then
                val=$(echo $sign $val $(mag2i $oldmag $texp $mzero) | awk '{print $1*$2+$3}')
                if [ $val -le 0 ]
                then
                    dmag=2.00
                    mag=$(echo $dmag $oldmag | awk '{printf("%.3f", $1+$2)}')
                else
                    mag=$(i2mag $val $texp $mzero | awk '{printf("%.3f", $1)}')
                    dmag=$(echo $mag $oldmag | awk '{printf("%.3f", $1-$2)}')
                fi
            else
                dmag=0; mag=$resmag; oldmag="-"
            fi
        fi
        test ! "$do_quiet" && test $id != "XXXXX" && echo "#" $c $oldmag $resmag $dmag $mag
        omag="$omag $mag"
        odiff="$odiff $(echo $dmag | awk '{print $1*1000}')"
    done
    if [ "$doublemagdiff" ]
    then
        for off in  $(di2dmag $(echo "$(dmag2di -$doublemagdiff) + 1" | bc -l)) \
                    $(di2dmag $(echo "$(dmag2di  $doublemagdiff) + 1" | bc -l))
        do
            echo $omag $odiff | awk -v c=$c -v o=$off -v id=$id -v x=$x -v y=$y -v m="$msg" '{
                if (c==1) {
                    printf("%-10s  %7.2f %7.2f  %6.3f %6.3f %6.3f  %s  dm %.0f\n",
                        id, x, y, $1-o, $1-o, $1-o, m, $2-1000*o)
                } else {
                    printf("%-10s  %7.2f %7.2f  %6.3f %6.3f %6.3f  %s  dm %.0f/%.0f/%.0f\n",
                        id, x, y, $1-o, $2-o, $3-o, m, $4-1000*o, $5-1000*o, $6-1000*o)
                }}'
        done
    else
        echo $omag $odiff | awk -v c=$c -v id=$id -v x=$x -v y=$y -v m="$msg" '{
                if (c==1) {
                    printf("%-10s  %7.2f %7.2f  %6.3f %6.3f %6.3f  %s  dm %.0f\n",
                        id, x, y, $1, $1, $1, m, $2)
                } else {
                    printf("%-10s  %7.2f %7.2f  %6.3f %6.3f %6.3f  %s  dm %.0f/%.0f/%.0f\n",
                        id, x, y, $1, $2, $3, m, $4, $5, $6)
                }}'
    fi
    return
}

# aperture photometry on single star or double star
aphot () {
    local showhelp
    local xy2           # xy image coordinates of companion star
    local texp=1        # effective exposure time (single exposure)
    local magzero=25.5
    local gain=1        # effective gain
    local drgb=0
    local bgval         # if set then use this background value(s) and ignore
                        #   the background annulus
    local do_adu=0      # if 1 return counts (ADU) instead of magnitude
    local do_bg_only    # if set then only bg measurement is returned
    local precision=3   # number of digits after decimal point
    local skip_zero=0   # skip any pixel having zero intensity
    local i
    for i in $(seq 1 11)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-c" && xy2=$2 && shift 2
        test "$1" == "-t" && texp=$2 && shift 2
        test "$1" == "-m" && magzero=$2 && shift 2
        test "$1" == "-g" && gain=$2 && shift 2
        test "$1" == "-d" && drgb=$2 && shift 2
        test "$1" == "-b" && bgval="$2" && shift 2
        test "$1" == "-a" && do_adu=1 && shift 1
        test "$1" == "-p" && precision="$2" && shift 2
        test "$1" == "-bg" && do_bg_only=1 && shift 1
        test "$1" == "-z" && skip_zero=1 && shift 1
    done
    
    local img="$1"      # image to be measured
    local xy=${2:-""}   # xy image coordinates of star, comma separated
    local rad=${3:-3}   # aperture radius or radii for aperture ring <r1>,<r2>
    local gap=${4:-3}   # gap between aperture and bg region
    local bgwidth=${5:-3} # bg annulus width
    local x
    local y
    local x2
    local y2
    local bsize
    local mag0
    local xi
    local yi
    local bgarea
    local bgr
    local bgg
    local bgb
    local sr
    local sg
    local sb
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmp1=$(mktemp "$tdir/tmp_dat1.XXXXXX.dat")
    local tmp2=$(mktemp "$tdir/tmp_dat2.XXXXXX.dat")

    (test "$showhelp" || test $# -lt 2) &&
        echo -e "usage: aphot [-a] [-z] [-bg] [-c xcomp,ycomp] [-t texp] [-m magzero|$magzero]" \
            "[-g gain] [-d drgb] [-b bgval] [-p precision|$precision]" \
            "<img> <xstar,ystar> [rad|$rad] [gap|$gap] [bgwidth|$bgwidth]" >&2 &&
        return 1

    test ! -f "$img" &&
        echo "ERROR: image $img not found." >&2 && return 255

    # split object coordinates into separate variables
    x=${xy%,*}
    y=${xy#*,}
    x2=${xy2%,*}
    y2=${xy2#*,}
    
    # get pixel intensities around x,y
    bsize=$(echo $rad $gap $bgwidth | awk '{
        na=split($1,a,",")
        printf 2*int(a[na]+$2+$3+1.5)}')
    xi=$(echo $x $bsize | awk '{print int($1-$2/2)}')
    yi=$(echo $y $bsize | awk '{print int($1-$2/2)}')
    #AIval -c $img $bsize $bsize $xi $yi > $tmp1
    gm convert $img -crop ${bsize}x${bsize}+${xi}+${yi} - | pnmnoraw | \
        awk -v cw=$bsize -v cx=$xi -v cy=$yi 'BEGIN{row=1; col=1; skip=3}{
            if((NR==1) && ($0=="P3")) {isppm=1}
            if((NR==1) && ($0=="P1")) {skip=2}
            if(NR>skip) {
                if(isppm==1) {np=split($0, p, "  ")} else {np=split($0, p, " ")}
                for(i=1;i<=np;i++) {
                    printf("%d %d %s\n", cx+col-1, cy+row-1, p[i])
                    col++
                    if (col>cw) {row++; col=1}
                }
            }
        }' > $tmp1
    

    # determine if pixel belongs to star or background area
    cat $tmp1 | awk -v x=$x -v y=$y -v zskip="$skip_zero" \
        -v rad=$rad -v gap=$gap -v bgwidth=$bgwidth 'BEGIN{na=split(rad,a,",")}{
            if (zskip==1) {
                if ($3==0) next
                if ($4!="" && $4==0) next
                if ($5!="" && $4==0) next
            } 
            dx=$1+0.5-x; dy=$2+0.5-y
            r=sqrt(dx*dx+dy*dy)
            # check if pixel counts as star pixel
            # z is fraction of pixel area within aperture
            z=a[na]+0.5-r
            if ((na>1) && (z>0)) {
                # zz is fraction of pixel outside of inner ring radius
                zz=r-(a[1]+0.5)
                if (zz<0) z=0
                if (zz<1) z=z-(1-zz)
            }
            if (z>1) z=1; if(z<0) z=0
            if (z>0) {
                type=1
            } else {
                # check if pixel is from bg region
                if ((r>=a[na]+gap) && (r<a[na]+gap+bgwidth)) {
                    type=2
                } else {
                    type=0
                }
            }
            if (type>=0) printf("%s %s %s %s %s  %7.2f %7.2f %7.2f\n",
                type, z, $3, $4, $5, x, y, r)
        }' > $tmp2

    
    # determine background
    if [ -z "$bgval" ]
    then
        bgarea=$(grep "^2 " $tmp2 | wc -l)
        set - $(grep "^2 " $tmp2 | kappasigma - 3 4 4)
        bgr=$1; sr=$2
        if [ $(grep "^2 " $tmp2 | tail -1 | wc -w) -gt 6 ]
        then
            set - $(grep "^2 " $tmp2 | kappasigma - 4 4 4)
            bgg=$1; sg=$2
            set - $(grep "^2 " $tmp2 | kappasigma - 5 4 4)
            bgb=$1; sb=$2
        else
            bgg=$bgr; sg=$sr
            bgb=$bgr; sb=$sr
        fi
    else
        set - ${bgval//,/ }
        bgr=$1; bgg=$1; bgb=$1; sr=1; sg=1; sb=1; bgarea=1
        test $# -gt 1 && bgg=$2
        test $# -gt 2 && bgb=$3
    fi
    
    if [ "$do_bg_only" ]
    then
        echo $bgr $bgg $bgb $bgarea $sr $sg $sb | awk '{
            printf("%6.1f %6.1f %6.1f  %4d  %4.1f %4.1f %4.1f\n",
                $1, $2, $3, $4, $5, $6, $7)}'
    else
        # measure star
        mag0=$(echo $magzero $texp | awk '{
            printf("%.3f\n", $1+2.5/log(10)*log($2))}')
        grep "^1 " $tmp2 | awk -v x=$x -v y=$y \
            -v bgr=$bgr -v bgg=$bgg -v bgb=$bgb \
            -v sr=$sr   -v sg=$sg   -v sb=$sb \
            -v bgarea=$bgarea -v m0=$mag0 -v gain=$gain -v drgb=$drgb \
            -v adu=$do_adu -v prec=$precision '{
                a=a+$2
                if (NF==8) {
                    r=r+$2*($3-bgr); g=g+$2*($4-bgg); b=b+$2*($5-bgb)
                    png2=png2+$2*$4/gain
                } else {
                    r=r+$2*($3-bgr); g=r; b=r
                    png2=png2+$2*$3/gain
                }
            }END{
                fmt="%"prec+3"."prec"f"
                fmt=fmt" "fmt" "fmt
                if (adu==1) {
                    printf("%7.2f %7.2f  %5.0f %5.0f %5.0f  %3d %3d  %4d %3d 99\n",
                        x, y, r, g, b, a, bgarea, bgg, sg)
                } else {
                    nrgb=split(drgb,arr,",")
                    dr=arr[1]; dg=dr; if(nrgb>1) dg=arr[2]; db=dg; if(nrgb>2) db=arr[3]
                    mr=99; mg=99; mb=99; errg=99; ok=1
                    if (r<0) {ok=0; r=-1*r}
                    if (g<0) {ok=0; g=-1*g}
                    if (b<0) {ok=0; b=-1*b}
                    if (r>0) mr=m0-2.5/log(10)*log(r)-dr
                    if (g>0) {
                        mg=m0-2.5/log(10)*log(g)-dg
                        errg=2.5/log(10)*log(1+sqrt(png2)/g+1.2*sg/sqrt(bgarea)*a/g)
                    }
                    if (b>0) mb=m0-2.5/log(10)*log(b)-db
                    if (ok==0) printf("# ")
                    printf("%7.2f %7.2f  "fmt"  %3d %3d  %4d %3d %.3f",
                        x, y, mr, mg, mb, a, bgarea, bgg, sg, errg)
                    if (ok==0) printf("  # below background")
                    printf("\n")
                }
            }'
    fi
    
    if is_number "$AI_DEBUG" &&  [ $AI_DEBUG -gt 1 ]
    then
        echo "# intensities in image section: $tmp1" >&2
        echo "# type,fraction,intensity,... : $tmp2" >&2
    else
        rm -f $tmp1 $tmp2
    fi
}

# aperture photometry on double star
doubleaphot () {
    local showhelp
    local doublemagdiff # if set, split intensity into two components with the
                        # given magnitude difference
    local i=$1
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-d" && doublemagdiff=$2 && shift 2
    done
    local img="$1"      # image to be measured
    local xydat="$2"    # object catalog with lines id x y or ds9 region file
    local id1="$3"
    local id2="$4"
    local rad=${5:-3}   # aperture radius or radii for aperture ring <r1>,<r2>
    local gap=${6:-3}   # gap between aperture and bg region
    local bgwidth=${7:-3} # bg annulus width
    local idcol=1
    local xcol=2
    local ycol=3

    (test "$showhelp" || test $# -lt 4) &&
        echo -e "usage: doublephot <img> <xydat> <id1> <id2> [rad|$rad] [gap|$gap]" \
            "[bgwidth|$bgwidth]" >&2 &&
        return 1

    test ! -f "$img" &&
        echo "ERROR: image $img not found." >&2 && return 255
    test "$xydat" != "-" && test ! -f "$xydat" &&
        echo "ERROR: object catalog $xydat not found." >&2 && return 255
    cat $xydat > $tmpxy
    if $(head -1 $tmpxy | grep -qi "region file")
    then
        cmd="reg2xy $img $tmpxy"
    else
        cmd="cat $tmpxy"
    fi


}

jd2st () {
    local showhelp
    local use_jd_now
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-n" && use_jd_now=1 && shift 1
    done
    local jd=$1
    local long
    
    (test "$showhelp" || test $# -lt 1) &&
        echo -e "usage: jd2st [-n] <jd>" >&2 &&
        return 1
    
    test -z "$AI_SITE" && echo "ERROR: AI_SITE is not set" >&2 && return 255
    long=$(get_param -k location sites.dat long $AI_SITE)
    test -z "$long" && echo "ERROR: cannot derive longitude" >&2 && return 255
    if [ "$use_jd_now" ]
    then
        jd=$(ut2jd $(date -u +"%H:%M:%S %y%m%d"))
    fi
    # sidereal time in hr
    st=$(echo $jd $long | awk '{x=18.697374558+24.06570982441908*($1-2451545.0)+$2/15;
        x=x%24; if(x<0) x=x+24
        printf("%.4f", x)}')
    dec2sexa $st | tr -d '+'
    return 0
}

# convert from julian day to ut date
jd2ut () {
    # ref: http://quasar.as.utexas.edu/BillInfo/JulianDatesG.html
    local showhelp
    local timeformat=1  # 1-fraction of day, 2-HH:MM:SS
    local prec=3
    local i
    for i in 1 2 3
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-p" && prec=$2 && shift 2
        test "$1" == "-t" && timeformat=2 && shift 1
    done
    local jd=$1

    (test "$showhelp" || test $# -lt 1) &&
        echo -e "usage: jd2ut [-p prec|$prec] [-t] <jd>" >&2 &&
        return 1
    
    echo $jd | awk -v p=$prec -v tf=$timeformat '{
        if (tf==1) {
            fmt="%."p"f"
            q=sprintf(fmt, $1+0.5)
        } else {
            q=$1+0.5
        }
        z=int(q)
        w=int((z - 1867216.25)/36524.25)
        x=int(w/4)
        a = z+1+w-x
        b = a+1524
        c = int((b-122.1)/365.25)
        d = int(365.25*c)
        e = int((b-d)/30.600001)
        f = int(30.600001*e)
        dd=b-d-f+(q-z)
        mm=e-1; if (mm>12) mm=e-13
        yy=c-4715; if (mm>2) yy=c-4716
        #printf("%4d-%02d-%06.3f\n", yy, mm, dd)
        if (tf==1) {
            fmt="%4d-%02d-%"sprintf("%02d.%1df", p+3, p)"\n"
            printf(fmt, yy, mm, dd)
        }
        if (tf==2) {
            d=int(dd)
            h=int((dd-d)*24)
            m=int((dd-d)*24*60-h*60)
            s=int((dd-d)*24*3600-h*3600-m*60)
            fmt="%4d-%02d-%02d %02d:%02d:%02d\n"
            printf(fmt, yy, mm, d, h, m, s)
        }
    }'
}

ut2jd () {
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    
    local ut=$1     # h:m:s
    local utday=${2:-"$(date +"%y%m%d")"}

    (test "$showhelp" || test $# -lt 1) &&
        echo -e "usage: ut2jd <uttime-h:m:s> [utdate-yymmdd|$utday]" >&2 &&
        return 1

    # convert day from yyyy-mm-dd to yyyymmdd
    test "$utday" && test ${#utday} -eq 10 &&
        utday=${utday:0:4}${utday:5:2}${utday:8:2}

    echo "$ut $utday" | awk '{
        n=split($1,arr,/:/)
        h=arr[1]; if(n>1) h=h+arr[2]/60; if(n>2) h=h+arr[3]/3600
        if (length($2) == 8) {
            y=substr($2,1,4)
            m=substr($2,5,2)
            d=substr($2,7,2)
        } else {
            y="20"substr($2,1,2)
            m=substr($2,3,2)
            d=substr($2,5,2)
        }
        if (1*m<=2) {y=y-1; m=m+12}
        a=int(y/100); b=2-a+int(a/4)
        jd=int(365.25*(y+4716)) + int(30.6001*(m+1)) + d + h/24 + b - 1524.5
        printf("%.5f\n", jd)
    }'
}

datefmt () {
    # convert several date strings to iso format (yyyy-mm-dd) or other formats
    # note: fractional days or any parameter after te third one are ignored
    local showhelp
    local type="iso"
    local i
    for i in 1 2 3
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-i" && type="iso" && shift 1
        test "$1" == "-6" && type="6digits" && shift 1
        test "$1" == "-8" && type="8digits" && shift 1
    done    
    local str="$1 $2 $3"
    local isodate

    (test "$showhelp" || test $# -lt 1) &&
        echo -e "usage: datefmt [-i|-6|-8] <datestring>" >&2 &&
        return 1

    idate=$(echo ${str//-/ } | sed -e 's,\.[0-9:]*,,' | awk '{
        if ($0~/^[0-9]{6}$/) {
            # yymmdd
            printf("20%s-%s-%s\n", substr($0,1,2), substr($0,3,2), substr($0,5,2))
        } else if ($0~/^[0-9]{2} [0-9]{2} [0-9]{2}$/) {
            # yy mm dd
            printf("20%s-%s-%s\n", $1, $2, $3)
        } else if ($0~/^[0-9]{8}$/) {
            # yyyymmdd
            printf("%s-%s-%s\n", substr($0,1,4), substr($0,5,2), substr($0,7,2))
        } else if ($0~/^[0-9]{4} [0-9]{2} [0-9]{2}$/) {
            # yyyy mm dd
            printf("%s-%s-%s\n", $1, $2, $3)
        }}')
    test -z "$idate" && return 255
    case $type in
        iso)    echo $idate;;
        6digits) echo ${idate:2} | tr -d '-';;
        8digits) echo ${idate//-/}
    esac
}

mknlist () {
    # create list of 4-digit numbers
    local str
    local x
    for str in ${@//,/ }
    do
        if [ "${str/-//}" != "$str" ]
        then
            for x in $(seq ${str%-*} ${str#*-})
            do
                ! is_number $x &&
                    echo "ERROR: $x is not a number" >&2 && return 255
                printf "%04g\n" $x
            done
        else
            ! is_number $str &&
                echo "ERROR: $str is not a number" >&2 && return 255
            printf "%04g\n" $str
        fi
    done
    return 0
}

filesize () {
    # show approximate file size
    local fname="$1"
    local s
    
    s=$(stat --format="%s" "$fname")
    test $s -gt 10000000 && echo $s | awk '{printf("%.0fMB", $1/2^20)}' && return
    test $s -gt  1000000 && echo $s | awk '{printf("%.1fMB", $1/2^20)}' && return
    test $s -gt    10000 && echo $s | awk '{printf("%.0fkB", $1/2^10)}' && return
    test $s -gt     1000 && echo $s | awk '{printf("%.1fkB", $1/2^10)}' && return
    printf "%sB" $s
}

# wrapper for "head -n" to work around sigpipe errors
lines () {
    local n=$1
    local f=${2:-"-"}
    #sed -e ''$((n+1))',$d'
    if [ "$f" == "-" ]
    then
        awk -v n=$n '{if(NR<=n) printf("%s\n", $0)}'
    else
        awk -v n=$n '{if(NR<=n) printf("%s\n", $0)}' $f
    fi
}

get_imfilename () {
    # search for image in current working directory and AI_RAWDIR
    # try with several extensions appended to the provided string
    local img="$1"
    local fname=""
    local extlist="cr2 pef nef raf dng fit fits ppm pgm pnm png tif jpg"
    local d
    local b
    local i4
    local ext
    for d in "$(dirname "$img")" "$AI_RAWDIR/$(dirname "$img")"
    do
        test ! -d "$d" && continue
        b=$(basename $img)
        is_integer $b && i4=$(echo $b | awk '{printf("%04d", 1*$1)}')
        test "$fname" && break
        test -f "$d/$b" && fname="$d/$b" && break
        for ext in $extlist
        do
            test -f "$d/$b.$ext" && fname="$d/$b.$ext" && break
            is_integer $b && test -f "$d/$i4.$ext" && fname="$d/$i4.$ext" && break
            is_integer $b && test -f "$d/IMG_$i4.$ext" && fname="$d/IMG_$i4.$ext" && break
        done
    done
    test -z "$fname" &&
        echo "ERROR: image $img not found." >&2 && return 255
    echo "$fname"
}

get_rawfile () {
    # get raw image file name by searching exifdat and rawfilesdat
    local showhelp
    local do_quiet
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-q" && do_quiet=1 && shift 1
    done
    local num=$1
    local exifdat="exif.dat"
    local rawfilesdat="rawfiles.dat"
    local rfile
    local gzrfile
    local f
    
    (test "$showhelp" || test $# -ne 1) &&
        echo "usage: get_rawfile [-q] <num>" >&2 &&
        return 1
    
    test -e "$exifdat" &&
        rfile=$(grep -v "^#" $exifdat | awk -v n=$num '{if($2==n){printf("%s", $1)}}' | lines 1)
    test -z "$rfile" && test -e "$rawfilesdat" &&
        rfile=$(grep -v "^#" $rawfilesdat | awk -v n=$num '{if($1==n){printf("%s", $2)}}' | lines 1)
    test -z "$rfile" &&
        echo "ERROR: no entry for $nref in $exifdat/$rawfilesdat." >&2 && return 255

    if [ "${rfile%.gz}" != "$rfile" ]
    then
        gzrfile="$rfile"
        rfile="${rfile%.gz}"
    else
        gzrfile="${rfile}.gz"
    fi
    
    for f in "$AI_RAWDIR/$rfile"     "$AI_RAWDIR/$gzrfile" \
        "$AI_RAWDIR/${rfile//_/ }"   "$AI_RAWDIR/${gzrfile//_/ }" \
        "$rfile"                     "$gzrfile" \
        "${rfile//_/ }"              "${gzrfile//_/ }"
    do
        if [ -f "$AI_RAWDIR/$f" ]
        then
            readlink -f "$AI_RAWDIR/$f"
            return $?
        fi
    done
    test -z "$do_quiet" && echo "ERROR: file $rfile not found." >&2
    return 255
}

get_header () {
    # get value of some image header keyword(s)
    debuglog "get_header"
    local showhelp
    local mode="keyval" # keyval: for matching keys print lines <key>=<value>
                        # value:  for matching keys print lines <value>
                        # oneline: print <val1> <val2> ...
                        #   value is "-" in case of non-matching keys
                        #   string values are within single quotes
    local do_quiet      # if set then missing header keywords are not reported
    local extension
    for i in 1 2 3 4
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-q" && do_quiet=1 && shift 1
        test "$1" == "-s" && mode="value" && shift 1
        test "$1" == "-l" && mode="oneline" && shift 1
        test "$1" == "-e" && extension="[${2}]" && shift 2
    done

    local tmp1=$(mktemp "/tmp/tmp_header_$$.XXXXXX")
    local img=$1
    shift 1
    local keylist=${@//,/ } # separated by ',' or spaces
    local hdr
    local k
    #local line
    local val
    local vstr          # string of space separated values
    local retval

    (test "$showhelp" || test -z "$keylist") &&
        echo "usage: get_header [-q] [-s|-l] [-e extname] <img|hdrfile> <keylist>" >&2 &&
        return 1

    test ! -e "$img" &&
        echo "ERROR: file $img not found." >&2 && return 255
    if is_ahead "$img"
    then
        hdr="$img"
    else
        ! is_pnm "$img" && ! is_fits "$img" && ! is_fitzip "$img" && ! is_fitsgz "$img" &&
            echo "ERROR: $img has unsupported image format." >&2 && return 255
        is_pnm "$img" && hdr="${img%.*}.head" && test ! -e "$hdr" &&
            echo "ERROR: missing ascii header file $hdr." >&2 && return 255
        is_fits "$img"   && listhead "${img}$extension" | grep "=" > $tmp1 && hdr=$tmp1
        is_fitzip "$img" && unzip -p "$img" | listhead -  | grep "=" > $tmp1 && hdr=$tmp1
        is_fitsgz "$img" && listhead "$img" | grep "=" > $tmp1 && hdr=$tmp1
    fi
    
    test "$keylist" == "all" && cat $hdr && rm $tmp1 && return
    
    retval=1
    for k in $keylist
    do
        false && (
        line=$(grep -i "^$k[ ]*=" "$hdr" | lines 1)
        test -z "$line" && test -z "$do_quiet" && echo "# $k not found." >&2 &&
            test "$mode" == "oneline" && vstr="$vstr -"
        test -z "$line" && continue
        retval=0    # there is at least one matching key
        val=$(echo "$line" | sed -e 's,/.*,,' | cut -d '=' -f2- | \
            sed -e 's,^[ ]*,,' | sed -e 's,[ ]*$,,' | sed -e "s,^',," | sed -e "s,'$,,")
        )
        
        val=$(awk -v k=$k -v m=$mode '{
            kw=$0
            sub(/[ ]*=.*/,"",kw)
            if (kw == k) {
                val=$0
                sub(/^[A-Z0-9_\- ]*=/,"",val)
                sub(/\/.*/,"",val)
                sub(/^[ ]*/,"",val)
                sub(/[ ]*$/,"",val)
                if (m != "oneline" || val !~ / /) {
                    sub(/^\x27/,"",val)
                    sub(/\x27$/,"",val)
                }
                printf("%s", val); nextfile
            }
        }' "$hdr")
        test -z "$val" && test -z "$do_quiet" && echo "# $k not found." >&2
        test -z "$val" && test "$mode" == "oneline" && vstr="$vstr -"
        test -z "$val" && continue
        retval=0    # there is at least one matching key

        # single key
        test "${keylist// /}" == "$(echo $keylist)" &&
            test "$mode" != "oneline" &&
            echo "${val}" && continue
        
        # multiple keys
        case "$mode" in
            oneline) vstr="$vstr ${val// /_}";;
            value)  echo "${val}";;
            *)      echo "${k^^}=${val}";;
        esac
    done
    test "$mode" == "oneline" && echo $vstr
    rm $tmp1
    return $retval
}

set_header () {
    # write value of given keyword to image header
    # keyword parameter and value syntax: keyword=value/comment
    # strings values should be quoted: "'new string value'"
    local showhelp
    local verbose
    local no_update     # if set then header keywords are not modified/added
    local is_string     # if set the value is always meant to be a string
    local i
    for i in 1 2 3 4
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-v" && verbose=1 && shift 1
        test "$1" == "-n" && no_update=1 && shift 1
        test "$1" == "-s" && is_string=1 && shift 1
    done

    local img=$1    # either image or ahead file
    local hdr
    local kv
    local k
    local val
    local c
    local s
    local n
    local oldval
    local oldcomm

    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: set_header [-n] [-s] <img|hdrfile> <keyword=value/description> [keyword2=value2/description2] ..." >&2 &&
        return 1
    
    test ! -e $img &&
        echo "ERROR: file $img not found." >&2 && return 255
    if is_ahead $img
    then
        hdr=$img
    else
        ! is_pnm $img && ! is_fits $img &&
        echo "ERROR: $img has unsupported format." >&2 && return 255
        is_pnm $img && hdr=${img%.*}.head && test ! -e $hdr &&
            echo "ERROR: missing ascii header file $hdr." >&2 && return 255
    fi

    test "$no_update" &&
        echo "WARNING: header keywords are not modified!" >&2
    shift 1
    if is_fits $img
    then
        for kv in "$@"
        do
            sethead $img ${kv#*/}
        done
        return
    fi

    for kv in "$@"
    do
        k=$(printf "%-8s" ${kv%%=*}); k=${k^^}
        s=$(echo "${kv#*=}" | sed -e 's/^[ ]*//; s/[ ]*$//')
        val=$(echo "${s%%/*}" | sed -e 's/^[ ]*//; s/[ ]*$//')
        test "$AI_DEBUG" && echo "k=_${k}_ s=_${s}_ val=_${val}_" >&2

        # read original value and comment
        oldval=$(get_header -q $hdr $k)
        oldcomm=$(grep "^${k}=.*/.*[a-zA-Z]" $hdr | sed -e "s|.*/[ ]*||")

        # empty value removes keyword from header file
        if [ -z "$val" ] && [ "$oldval" ]
        then
            test -z "$no_update" &&
                sed --follow-symlinks -i '/^'${k/ */}'[ ]*=/d' $hdr
            continue
        fi
        
        # keep comment from original keyword if not set
        c=""
        test "$s" != "$val" && c=$(echo "${s#*/}" | sed -e 's/^[ ]*//; s/[ ]*$//')
        test -z "$c" && c="$oldcomm"

        # skip writing to header if nothing has changed
        if [ "$val" == "$oldval" ] && [ "$c" == "$oldcomm" ]
        then
            test "$verbose" && echo "#" $k "is unchanged" >&2
            continue
        else
            test "$verbose" && echo "# val:  \"$oldval\" -> \"$val\""  >&2
            test "$verbose" && echo "# comm: \"$oldcomm\" -> \"$c\""  >&2
        fi
        
        # quote string value if necessary
        if [ "$is_string" ]
        then
            val="'${val}'"
        else
            ! is_number "$val" &&
                ! is_number "$(echo $val | sed -e 's/E[+-]*[0-9][0-9]*$//')" &&
                test "${val:0:1}" != "'" &&
                test "$val" != "T" &&
                test "$val" != "F" &&
                val="'${val}'"
        fi
        
        # pad spaces around value
        test "${val:0:1}" == "'" && val=$(printf "%-20s" "$val")
        test "${val:0:1}" != "'" && val=$(printf "%20s"  "$val")
        
        # create record optionally trimming comment
        s="${k}= ${val}"
        n=$(echo ${#s} ${#c} | awk '{x=80-$1-3; if($2<x) x=$2; print x}')
        test "$c" && s="$s / ${c:0:n}"
        test "$verbose" && echo "$s" >&2
        if [ -z "$no_update" ]
        then
            if grep -q "^${k}=" $hdr
            then
                sed --follow-symlinks -i "s/^${k}=.*/${s//\//\\/}/" $hdr
            else
                sed --follow-symlinks -i '/^END[ ]*$/d' $hdr
                echo "${s}" >> $hdr
                echo "END" >> $hdr
            fi
        fi
    done
    return
}

get_exclude () {
    # read AI_EXCLUDE by evaluating last definition in imred_$day.txt
    local showhelp
    local i
    for i in 1
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    done
    local adir=$1
    local f
    local l

    (test "$showhelp" || test $# -ne 1) &&
        echo "usage: get_exclude <adir>" >&2 &&
        return 1

    test ! -d "$adir" && echo "ERROR: $adir not found." && return 255
    f=$(cd $adir; ls | grep -E "imred_[0-9]{6}[a-z]*.txt" 2>/dev/null | wc -l)
    test $f -eq 0 && echo "ERROR: file imred_[0-9]*.txt not found." && return 255
    test $f -gt 1 && echo "ERROR: file imred_[0-9]*.txt not unique." && return 255

    f=$(cd $adir; ls | grep -E "imred_[0-9]{6}[a-z]*.txt")
    l=$(grep -n "^AI_EXCLUDE=" $adir/$f | tail -1 | cut -d ':' -f1)
    test "$AI_DEBUG" && echo "f=$f" && echo "l=$l"
    echo $(cat $adir/$f | awk -v l=$l '{
        if(NR==l){ok=1}
        if(ok==1) {print $0}
        if(NR>l && $1!~/[0-9]/) ok=0
    }' | tr -d '\\\\' | tr '"' '\n' | grep "[0-9]")
}

getImageDateSec () {
    local num=$1
    local imDateTime=$(exiv2 -g "Exif.Image.DateTime" \
        $(get_imfilename $num) | awk '{print $4" "$5}' | \
        sed -e 's|:|-|;s|:|-|')
    local imSec=$(date -d "$imDateTime" +"%s")
    echo $imSec
}

get_jd () {
    # get jd by testing several keywords
    local klist="JD,DATE-OBS"   # keywords to check in order
    local do_quiet
    local showhelp
    local i
    for i in 1 2 3
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-k" && klist=$2 && shift 2
        test "$1" == "-q" && do_quiet=1 && shift 1
    done

    local hdr=$1    # image name or header file
    local k
    local jd
    local dobs
    local tobs
    
    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: get_jd [-q] [-k key1,key2,...|$klist] <hdr>" >&2 &&
        return 1

    for k in ${klist//,/ }
    do
        test -z "$jd" &&
        if [ "$k" != "DATE-OBS" ]
        then
            jd=$(get_header -q $hdr $k | awk '{printf("%.5f\n", $1)}')
        else
            dobs=$(get_header -q $hdr DATE-OBS)
            test "$AI_DEBUG" && echo "DATE-OBS=$dobs" >&2
            if [ "${dobs/T/}" != "$dobs" ]
            then
                jd=$(ut2jd $(echo $dobs | tr -d '-' | awk -F "T" '{
                    print $2" "substr($1,3)}'))
            else
                tobs=$(get_header -q $hdr TIME-OBS)
                test "$tobs" &&
                    echo ${dobs:2} $tobs | tr -d '-' >&2 &&
                    jd=$(ut2jd $(echo $tobs ${dobs:2} | tr -d '-'))
            fi
        fi
    done
    test -z "$jd" && ! test "$do_quiet" &&
        echo "ERROR: unable to obtain JD." >&2 && return 255
    echo $jd
}

get_jd_dmag () {
    # extract JD and dmag for individual images of a set using
    # measure/$num.src.head and reg.dat
    local guesstime # if set guess jd by means of mean jd of set and exposure time
    local showhelp
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-g" && guesstime=1 && shift 1
    done

    local set=$1
    local reg="reg.dat"
    local exifdat="exif.dat"
    local rawfilesdat="rawfiles.dat"
    local nlist
    local num
    local ut
    local tzoff
    local jd
    local dateobs
    local dmag
    
    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: get_jd_dmag [-g] <set>" >&2 &&
        return 1

    test -f $reg && nlist=$(AIimlist -q -x $set)
    test -z "$nlist" && nlist=$(AIimlist -n $set 2>/dev/null)
    test -z "$nlist" && nlist=$(AIimlist -n $set "" raw 2>/dev/null)
    test -z "$nlist" && nlist=$(AIimlist -q -x $set)
    test -z "$nlist" && 
        echo "ERROR: unable to obtain image numbers of set $set" >&2 &&
        return 255

    if [ "$guesstime" ]
    then
        jd=$(get_jd $set.head)
        test $? -ne 0 && return 255
        texp=$(get_header $set.head EXPTIME)
        test $? -ne 0 && return 255
        nexp=$(get_header $set.head NEXP)
        test $? -ne 0 && return 255
        # determine time of reference image
        nref=$(AIsetinfo -b $set | grep -w o | lines 1 | awk '{printf("%s", $8)}' )
        for num in $nlist
        do
            echo $num $nref $nexp $texp $jd | awk -v d=15 '{
                ds=($1-$2)*($4/$3+d)
                printf("%s %.3f %s\n", $1, $5+ds/3600/24, 0)}'
            i=$((i+1))
        done
        return
        
        i=1
        for num in $nlist
        do
            echo $i $nexp $texp $jd | awk -v n=$num -v d=15 '{
                m=(1+$2)/2
                ds=($1-m)*($3/$2+d)
                printf("%s %.3f %s\n", n, $4+ds/3600/24, 0)}'
            i=$((i+1))
        done
        return
    fi
    for num in $nlist
    do
        if [ -f measure/$num.src.head ]
        then
            jd=$(grep -E "^MJD_|^JD " measure/$num.src.head | lines 1 | tr '=' ' ' | \
                awk '{printf("%s", $2)}')
            if [ -z "$jd" ]
            then
                dateobs=$(grep "^DATE-OBS=" measure/$num.src.head | tr -d "'" | awk '{print $2}')
                test "$dateobs" && jd=$(ut2jd $(echo $dateobs | tr -d '-' | \
                    awk -F "T" '{print $2" "substr($1,3)}'))
            fi
            test -z "$jd" &&
                echo "ERROR: failed to get jd from measure/$num.src.head." >&2 && return 255
        else
            # get texp jd from exifdat
            set - $(test -e $exifdat && grep -v "^#" $exifdat | \
                awk -v n=$num '{if($2==n){printf("%s", $0)}}' | lines 1) x
            if [ $# -ge 3 ]
            then
                # we assume that time is in UT already
                jd=$(ut2jd $3 $day | awk '{printf("%.5f", $1)}')
                test ${3:0:1} -eq 0 && x=$(echo $x | awk '{printf("%.5f", $1+1)}')
            else
                # get texp jd from rawfilesdat
                set - $(test -e $rawfilesdat && grep -v "^#" $rawfilesdat | \
                    awk -v n=$num '{if($1==n){printf("%s", $0)}}' | lines 1) x
                if [ $# -ge 5 ]
                then
                    jd=$5
                else
                    echo "ERROR: unable to determine JD for image $num." >&2 && return 255
                fi
            fi
        fi
        
        if [ -f $reg ]
        then
            dmag=$(grep "^$num " $reg | awk '{printf("%.3f", $10)}')
            test -z "$dmag" &&
                echo "ERROR: failed to get dmag from $reg ($num)." >&2 && return 255
        else
            dmag=0
        fi
        echo $num $jd $dmag
    done
    return
}

cometreg () {
    # create region file for comet position
    local hdr=$1
    local whdr=$2
    local ra=$3 # sexagesimal coordinates
    local de=$4
    local id=${5:-"comet"}
    local size
    local tmpim=$(mktemp /tmp/tmp_im1_XXXXXX.pgm)
    
    (test $# -lt 1 || test "$1" == "-h") &&
        echo "usage: cometreg <hdr> <whdr> [ra] [de]" >&2 && return
    
    # check for header files
    test ! -f $hdr &&
        echo "ERROR: header file $hdr does not exist" >&2 &&
        return 255
    test -z "$whdr" && whdr=${hdr/.head/.wcs.head}
    test ! -f $whdr &&
        echo "ERROR: wcs header file $whdr does not exist" >&2 &&
        return 255
    
    # if necessary read coordinates from header file
    test -z "$ra" && ra=$(get_header $hdr AI_CORA)
    test -z "$de" && de=$(get_header $hdr AI_CODEC)
    (test -z "$ra" || test -z "$de") &&
        echo "ERROR: missing coordinates" >&2 &&
        return 255

    # create artificial image
    size=$(get_header -s $hdr NAXIS1,NAXIS2 | tr '\n' ' ')
    mkpgm 0 $size $tmpim

    echo $id $ra $de | rade2xy - $whdr | xy2reg $tmpim -
    
    rm -f $tmpim
    return 0
}

cometpos () {
    # create region file containing comet position, optionally show on image
    local showhelp
    local do_mpcephem   # if set additionally query coordinates from MPC
    local do_jplcoord   # if set additionally query JPL HORIZONS
    local do_display    # if set show region in image
    local project       # if set then change to the given project
    local i
    for i in 1 2 3 4 5
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-m" && do_mpcephem=1 && shift 1
        test "$1" == "-j" && do_jplcoord=1 && shift 1
        test "$1" == "-d" && do_display=1 && shift 1
        test "$1" == "-p" && project=$2 && shift 2
    done
    local set=$1
    local pdir="."
    local mpcreg=x.$set.mpc.reg
    local hdr
    local whdr
    local cosub
    local ra
    local dec
    local f
    local tmpdat=$(mktemp "/tmp/tmp_dat_$$.XXXXXX.dat")
    
    (test "$showhelp" || test $# -ne 1) &&
        echo "usage: cometpos [-m] [-p projectdir] <set>" >&2 &&
        return 1
    
    test "$project" && pdir="../$project" && mpcreg=x.$project.$set.mpc.reg
    hdr=$pdir/$set.head
    whdr=$pdir/$set.wcs.head
    for f in $hdr $whdr
    do
        test ! -e $f && echo "ERROR: file $f is missing" >&2 && return 255
    done

    if [ "$do_display" ]
    then
        # search for cosub image
        for f in $pdir/comet/$set.cosub1.ppm $pdir/comet/$set.cosub10.ppm \
                 $pdir/comet/$set.cosub1.pgm $pdir/comet/$set.cosub10.pgm
        do
            test -z "$cosub" && test -e $f && cosub=$f
        done
        test -z "$cosub" &&
            echo "ERROR: cosub image is missing" >&2 && return 255
    fi

    # get comet coordinates
    cometreg $hdr $whdr > $mpcreg
    if [ "$do_jplcoord" ]
    then
        (cd $pdir && get_jplcoord $set) | tee $tmpdat
        test $? -ne 0 &&
            echo "ERROR: failed command: get_jplcoord $$set" >&2 && return 255
        set - $(tail -1 $tmpdat)
        echo "# JPL: $1 $2" >&2
        cometreg $hdr $whdr $1 $2 jpl >> $mpcreg
    fi
    if [ "$do_mpcephem" ]
    then
        (cd $pdir && get_mpcephem $set) | tee $tmpdat
        test $? -ne 0 &&
            echo "ERROR: failed command: get_mpcephem $set" >&2 && return 255
        set - $(tail -1 $tmpdat)
        shift 4
        ra=$1:$2:$3; dec=$4:$5:$6
        echo "# MPC: $ra $dec" >&2
        cometreg $hdr $whdr $ra $dec mpc >> $mpcreg
    fi
    
    # display cosub image and reg
    test "$do_display" && AIexamine -n CometPos $cosub $mpcreg &
    
    # print some info
    (cd $pdir && get_header co01.head AI_CORA,AI_CODEC)
    echo "# pixscale:" $(cd $pdir && get_wcspscale $set)
    echo "# rotation:" $(cd $pdir && get_wcsrot $set) "(90: N is right)"
    
    rm -f $tmpdat
    return
}

cometcenter () {
    # determine object center (color image is converted using ppm2gray first)
    # output (stdout): day set object xfits yfits method blur fitrad mag
    #   if requesting checkimage then create images / region file in <odir>:
    #   cropped costack image: <day>.<set>_m.c.<ext>
    #   cropped and blurred costack image: <day>.<set>_m.cb.<ext>
    #   region file (comet region, sextractor object, fit position): <day>.<set>_m.c.reg
    local use_isophotes # if set use isophotes in sextractor (AIsource)
    local method=maxval # algorithm to determine center: maxval|object|fit
    local blur          # degree of bluring (default: auto)
    local fitrad        # max dist from center pixel used by fit (default: auto)
    local csize         # if set then create small checkimages and -regions
    local odir="chkctr" # output dir for checkimages and -regions
    local showhelp
    local i
    for i in 1 2 3 4 5 6
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-b" && blur=$2 && shift 2
        test "$1" == "-f" && fitrad=$2 && shift 2
        test "$1" == "-m" && method=$2 && shift 2
        test "$1" == "-s" && csize=$2 && shift 2
        test "$1" == "-o" && odir=$2 && shift 2
    done
    local dir=$1
    local set=$2
    local cosub=${3:-""}

    local coreg=$dir/comet/$set.comet.reg
    local bgreg=$dir/comet/$set.cometbg.reg
    local badreg=$dir/comet/$set.bad.reg     # optional
    local ccimg     # cropped checkimage (from costack)
    local ccbimg    # cropped and blurred checkimage
    local ccreg     # region file name associated with cropped checkimage
    local cosub
    local hdr
    local imult=1
    local ext
    local f
    local cropsize
    local croparea
    local mzero
    local object
    local texp
    local nexp
    local fwhm
    local area
    local opts
    local xysource
    local maxbox
    local cmag
    local crad
    local x1
    local y1
    local fx1
    local fy1
    local x
    local dist
    local tmpim1=$(mktemp "/tmp/tmp_im1_$$.XXXXXX.pnm")
    local tmpim2=$(mktemp "/tmp/tmp_im2_$$.XXXXXX.pnm")
    local tmpreg=$(mktemp "/tmp/tmp_reg_$$.XXXXXX.reg")
    local tmpsrc=$(mktemp "/tmp/tmp_src_$$.XXXXXX.dat")
    local tmpdat=$(mktemp "/tmp/tmp_dat_$$.XXXXXX.dat")
    local tmpgp=$(mktemp "/tmp/tmp_gp_$$.XXXXXX.gp")
    
    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: cometcenter [-m method|$method] [-b blur] [-f fitrad] [-o odir|$odir] [-s checkimg_size] <dir> <set> [cosub]" >&2 &&
        return 1
    

    case "$method" in
        max*)               method="maxval";;
        object|sex*|source) method="object";;
        fit|parab*|surface) method="fit";;
        *)  echo "ERROR: unsupported method, use one of maxval|object|fit." >&2
            return 255;;
    esac
    
    test -e $dir/$set.ppm && ext=ppm
    test -z "$ext" && test -e $dir/$set.pgm && ext=pgm
    test -z "$ext" &&
        echo "ERROR: no image stack ($set.ppm or $set.pgm) found." >&2 && return 255
    
    if [ -z "$cosub" ]
    then
        cosub=$dir/comet/$set.cosub.$ext
        test ! -e $cosub && cosub=$dir/comet/$set.cosub10.$ext && imult=10
    fi
    test ! -e $cosub &&
        echo "ERROR: no cosub image found." >&2 && return 255
    hdr=$dir/$set.head
    test ! -e $hdr &&
        echo "ERROR: header file $hdr not found." >&2 && return 255

    for f in $cosub $coreg
    do
        test ! -e $f &&
            echo "ERROR: region file $f not found." >&2 && return 255
    done
    
    if [ "$csize" ]
    then
        test ! -d "$odir" && mkdir $odir
        ccimg=$odir/$(basename $(realpath $dir)).${set}_m.c.$ext
        ccbimg=$odir/$(basename $(realpath $dir)).${set}_m.cb.$ext
        ccreg=$odir/$(basename $(realpath $dir)).${set}_m.c.reg
    fi

    # get object name, total exposure time, number of images and stars FWHM
    object=$(get_header $hdr OBJECT)
    test $? -ne 0 &&
        echo "ERROR: missing header keyword OBJECT." >&2 && return 255
    texp=$(get_header $hdr EXPTIME)
    test $? -ne 0 &&
        echo "ERROR: missing header keyword EXPTIME." >&2 && return 255
    nexp=$(get_header $hdr NEXP)
    test $? -ne 0 &&
        echo "ERROR: missing header keyword NEXP." >&2 && return 255
    fwhm=$(get_header $hdr AI_FWHM)
    test -z "$fwhm" &&
        echo "ERROR: missing header keyword AI_FWHM." >&2 && return 255
    # determine mag zero point of cosub image
    #mzero=$(get_param camera.dat magzero $set AI_MAGZERO 25.5)
    mzero=$(get_header $hdr MAGZERO)
    test $? -ne 0 &&
        echo "ERROR: missing header keyword MAGZERO." >&2 && return 255
    x=$(di2dmag $(echo "$texp / $nexp * $imult" | bc -l))
    mzero=$(echo "$mzero $x" | awk '{printf("%.2f", $1-$2)}')
    false && (
    # get comet area in pixels
    area=$(get_header $hdr AC_AREA1)
    test -z "$area" &&
        echo "ERROR: missing comet area size (AC_AREA1)" >&2 && return 255
    )
    
    # determine croparea (fitting coreg extent)
    cropsize=480
    set - $(get_extent $coreg)
    croparea=$(echo $(fits2xy -i $cosub $1 $4) $(fits2xy -i $cosub $2 $3) $(imsize $cosub) | \
    awk -v s=$cropsize '{
        xc=($1+$3)/2
        yc=($2+$4)/2
        x1=int(xc-s/2); x2=x1+s-1; if (x1<0) x1=0; if (x2>=$5) x2=$5-1
        y1=int(yc-s/2); y2=y1+s-1; if (y1<0) y1=0; if (y2>=$6) y2=$6-1
        printf("%d %d %d %d", x2-x1+1, y2-y1+1, x1, y1)
        }')
    echo "# croparea=$croparea" >&2

    # smooth cosub image
    # TODO: fill bad region with bg value
    h=$(imsize $cosub | cut -d " " -f2)
    # old blur used by convert ... -blur $0x$blur:
    #   blur=$(echo $fwhm | awk '{printf("%.1f", sqrt(5+$1*$1/4))}')
    test -z "$blur" &&
        blur=$(echo $fwhm | awk '{printf("%.1f", 0.2*sqrt(5+$1*$1/4))}')
    if [ $ext == "ppm" ]
    then
        imcrop -1 $cosub $croparea | ppm2gray - | convert - -blur 0x$blur $tmpim1
    else
        imcrop -1 $cosub $croparea | convert - -blur 0x$blur $tmpim1
    fi
    
    # get brightest source within coreg
    test ! "$AI_DEBUG" && opts="-q"
    AI_MAGZERO=$mzero AIsource $opts -2 -o $tmpsrc $tmpim1 "${use_isophotes}" 5 32
    reg2reg $coreg $cosub $tmpim1 "$croparea" > $tmpreg
    if [ -e $badreg ]
    then
        reg2reg $badreg $cosub $tmpim1 "$croparea" | \
            grep -E "^circle|^polygon|^box" | sed -e 's|^|-|' >> $tmpreg
    fi
    regfilter $tmpsrc $tmpreg | sexselect - "" "" "" "" "" 99 | grep -v "^#" | \
        sort -n -k7 > $tmpdat
    test "$AI_DEBUG" &&
        echo $tmpsrc $tmpim1 $tmpreg $tmpdat opts=$opts >&2 &&
        head -5 $tmpdat >&2 &&
        printf "# sleeping for 10 seconds " >&2 &&
        for i in $(seq 1 10); do sleep 1; printf "." >&2; done && printf "\n" >&2
    
    # TODO: check for some reasonable object fwhm>2px
    if [ -s $tmpdat ]
    then
        # get object center from brightest source in sextractor catalog
        set - $(head -1 $tmpdat)
        fx1=$2
        fy1=$3
        crad=$(echo $6 | awk '{printf("%.1f", $1/2)}')
        cmag=$7
        # print fits coordinates of source in orig image
        set - $(echo $fx1 $fy1 $croparea $h | awk '{printf("%f %f\n", $1+$5, $2+($7-$6-$4))}')
        printf "# object=%.1f,%.1f crad=%.1f mag=%.1f\n" $1 $2 $crad $cmag >&2
        xysource=$1","$2
    else
        # no source found
        # determine xc,yc,rad from outer bounds of comet region
        set - $(grep "^polygon(" $tmpreg | tr '() ' ' ' | awk '{
            n=split($2,a,/,/)
            for (i=0;i<n/2;i++) {
                x=a[2*i+1]; y=a[2*i+2]
                if (i==0) {
                    x1=x; x2=x; y1=y; y2=y
                } else {
                    if (x<x1) x1=x
                    if (x>x2) x2=x
                    if (y<y1) y1=y
                    if (y>y2) y2=y
                }
            }
            printf("%.2f %.2f %.1f\n", (x1+x2)/2, (y1+y2)/2, (x2-x1+y2-y1)/4)
            }')
        fx1=$1
        fy1=$2
        crad=$3
        cmag=0
        echo $fx1 $fy1 | awk '{
            printf("# WARNING: no source found, using regcenter=%.1f,%.1f\n", $1, $2)}' >&2
        method="region"
    fi
    # convert to image pixel coordinates
    set - $(fits2xy -i $tmpim1 $fx1 $fy1)
    x1=$1
    y1=$2

    # determine box sizes depending on stars fwhm and comet size
    maxbox=$(echo $blur $crad | awk '{
        x=2+7*$1+$2/3
        printf("%.0f", 2*int(x/2)+1)}')
    test -z "$fitrad" && fitrad=$(echo $blur $crad | awk '{
        x=1+2*$1+0.5*log($2)
        if(x<2.5) x=2.5
        printf("%.1f", x)}')
    echo "# fwhm=$fwhm blur=$blur crad=$crad maxbox=$maxbox fitrad=$fitrad" >&2

    if [ "$method" == "maxval" ] || [ "$method" == "fit" ]
    then
        x1=$(echo $x1 $maxbox | awk '{printf("%.0f", $1-$2/2)}')
        y1=$(echo $y1 $maxbox | awk '{printf("%.0f", $1-$2/2)}')
        # echo "# x1=$x1 y1=$y1" >&2
        AIval -c $tmpim1 $maxbox $maxbox $x1 $y1 | sort -n -k 3,3 | tail -9 > $tmpdat
        x1=$(median $tmpdat 1)
        y1=$(median $tmpdat 2)
        # fits coords of max intensity
        #echo "# max=$(xy2fits -i $tmpim1 $x1 $y1 | tr ' ' ',')" >&2
        
        # repeat with shifted box if position is close to edge of box
        dist=$(echo $fx1 $fy1 $(xy2fits -i $tmpim1 $x1 $y1) | awk '{
            dx=$1-$3; dy=$2-$4
            dist=sqrt(dx*dx + dy*dy)
            printf("%.0f", dist)
        }')
        if [ $dist -gt $((maxbox*2/6)) ]
        then
            echo "# shift box (object close to edge)" >&2
            x1=$(echo $x1 $maxbox | awk '{printf("%.0f", $1-$2/2)}')
            y1=$(echo $y1 $maxbox | awk '{printf("%.0f", $1-$2/2)}')
            # echo "# x1=$x1 y1=$y1" >&2
            AIval -c $tmpim1 $maxbox $maxbox $x1 $y1 | sort -n -k 3,3 | tail -9 > $tmpdat
            x1=$(median $tmpdat 1)
            y1=$(median $tmpdat 2)
            # fits coords of max intensity
            #echo "# max=$(xy2fits -i $tmpim1 $x1 $y1 | tr ' ' ',')" >&2
        fi
    fi
    
    if [ "$method" == "fit" ]
    then
        x1=$(echo $x1 $maxbox | awk '{printf("%.0f", $1-($2-1)/2)}')
        y1=$(echo $y1 $maxbox | awk '{printf("%.0f", $1-($2-1)/2)}')
        AIval -c $tmpim1 $maxbox $maxbox $x1 $y1 | \
            awk -v m=$maxbox -v f=$fitrad '{
                if(NR==1) {xc=$1+(m-1)/2; yc=$2+(m-1)/2}
                r=sqrt(($1-xc)^2+($2-yc)^2)
                if (r<=f) printf("%s %.1f\n", $0, r)
            }' > $tmpdat
        # tmpdat: x y z
        
        # determine comet center by fitting parabolic surface to high signal pixels
        echo "# initial guess
            xm=$(mean $tmpdat 1)
            ym=$(mean $tmpdat 2)
            a=$(mean $tmpdat 3)
            b=-50
            xoff=0.1
            yoff=0.1
            
            set fit quiet
            f(x,y) = a + b*(x-xm+xoff)*(x-xm+xoff) + b*(y-ym+yoff)*(y-ym+yoff)
            fit f(x,y) '$tmpdat' using 1:2:3 via a, b, xoff, yoff
            out=sprintf(\"%d %6.3f %7.1f %7.1f %7.2f %7.2f\", \
                FIT_NDF, FIT_STDFIT, a, b, xm-xoff, ym-yoff)
            print out
            #show variables all
        " > $tmpgp
        x=$(gnuplot -p $tmpgp 2>&1)
        echo "# gpfit: $x" >&2
        # result is in image pixel indexes
        set - $(echo $x)
        x1=$5
        y1=$6
        # echo "# fit: $x1,$y1" >&2
    fi
    
    # convert xy image coordinates measured in tmpim1 to match cosub size
    set - $(echo $x1 $y1 $croparea | awk '{printf("%.2f %.2f\n", $1+$5, $2+$6)}')
    x1=$1
    y1=$2
    echo "# center (fits): $(xy2fits -i $cosub $x1 $y1)" >&2
    
    false && (
    # write region file to stdout
    echo "# Region file format: DS9 version 4.1
global color=green dashlist=8 3 width=1 font=\"helvetica 10 normal roman\" \
select=1 highlite=1 dash=0 fixed=0 edit=1 move=1 delete=1 include=1 source=1
physical"
    printf "circle(%.2f,%.2f,%.1f) # text={%.1f %s}\n" \
        $(xy2fits -i $cosub $x1 $y1) $crad $cmag ${method:0:3}
    )
    
    # write results to stdout
    printf "%-9s %-6s %-8s" $(basename $(realpath $dir)) $set $object
    printf " %7.2f %7.2f" $(xy2fits -i $cosub $x1 $y1)
    printf "  %3s %3.1f %4.1f %4.1f\n" ${method:0:3} $blur $fitrad $cmag
    
    # optionally create check image and shifted region file
    if [ "$csize" ]
    then
        xoff=$(echo $x1 $csize | awk '{printf("%.0f", 10*int(($1-$2/2)/10))}')
        yoff=$(echo $y1 $csize | awk '{printf("%.0f", 10*int(($1-$2/2)/10))}')
        imcrop -1 $cosub $csize $csize $xoff $yoff | imblur -b $blur - > $ccbimg
        cp $hdr ${ccreg/.reg/b.head}

        # copy subsection of costack
        costack=""
        test -e $dir/${set}_m.$ext && costack=$dir/${set}_m.$ext
        test -e $dir/${set}_m.bgs.$ext && costack=$dir/${set}_m.bgs.$ext
        test "$costack" &&
            imcrop -1 $costack $csize $csize $xoff $yoff > $ccimg &&
            cp $hdr ${ccreg/.reg/.head}
        
        # copy comet region used in large aperture photometry
        cp $coreg $tmpreg
        
        # cross at center position
        printf "point(%.2f,%.2f) # point=cross color=blue text={%s}\n" \
            $(xy2fits -i $cosub $x1 $y1) ${method:0:3} >> $tmpreg
        
        # circle showing sextractor source
        test "$xysource" &&
            printf "circle(%.2f,%.2f,%.1f)\n" ${xysource/,/ } $crad >> $tmpreg
        
        # shift regions to match small image
        regshift $tmpreg -$xoff -$((h-yoff-csize)) > $ccreg
    fi

    test "$AI_DEBUG"    && echo  $tmpim1 $tmpreg $tmpsrc $tmpdat $tmpgp >&2
    test -z "$AI_DEBUG" && rm -f $tmpim1 $tmpreg $tmpsrc $tmpdat $tmpgp
    return
}

mpcreport () {
    # write MPC report of objects astrometry (stdout)
    # ref https://minorplanetcenter.net/iau/info/ObsDetails.html
    #     https://minorplanetcenter.net/iau/info/OpticalObs.html
    #     https://minorplanetcenter.net/iau/info/Astrometry
    local showhelp
    local obscode=${AI_OBSCODE:-""} # MPC observatory code
    local author=${AI_OBSNAME:-"My Full Name"}
    local address=${AI_OBSADDRESS:-"My Street, My Country"}
    local email=${AI_OBSEMAIL:-"mymail@xxx"}
    local acat  # name of astrometric reference catalog
    local m1    # total comet magnitude
    local m2    # nuclear comet magnitude
    local cameradat="camera.dat"
    local sitesdat="sites.dat"
    local i
    for i in $(seq 1 9)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-a" && author=$2 && shift 2
        test "$1" == "-p" && address=$2 && shift 2
        test "$1" == "-e" && email=$2 && shift 2
        test "$1" == "-c" && obscode=$2 && shift 2
        test "$1" == "-r" && acat=${2^^} && shift 2
        test "$1" == "-m1" && m1=$2 && shift 2
        test "$1" == "-m2" && m2=$2 && shift 2
        test "$1" == "-s" && sitesdat=$2 && shift 2
    done
    local setname=$1
    local xfits=$2
    local yfits=$3
    local hdr
    local whdr
    local object
    local jdref     # JD at start of reference image
    local texp
    local nexp
    local telid
    local ctype
    local ttype
    local site
    local lat
    local long
    local alt
    local sitecoord
    local mpcname   # object name used in MPC report (12 chars)
    local utmid     # UT date at middle of exposure
    local telinfo   # telescope/camera information
    local stacknote # for stacked image set to "K"
    local camnote   # letter C/B indicating CCD/CMOS
    local mag       # total/nuclear magnitude (%4.1)
    local mtype     # either T or N
    local filter
    local ra
    local dec
    local str
    local x
    local h
    
    (test "$showhelp" || test $# -ne 3) &&
        echo "usage: mpcreport [-a author] [-p address] [-e email] [-c obscode]" \
            "[-s sitesdat|$sitesdat] [-r arefcat] [-m1 mag|-m2 mag] <set> <xfits> <yfits>" >&2 &&
        return 1
    
    hdr=$setname.head
    whdr=$setname.wcs.head
    
    # read header data
    object=$(get_header $hdr OBJECT)
    test -z "$object" && return 255
    jdref=$(get_header $hdr MJD_REF)
    test -z "$jdref" && return 255
    texp=$(get_header -s $hdr EXPTIME,NEXP | tr '\n' ' ' | \
        awk '{if(NF==2) printf("%.1f", $1/$2)}')
    test -z "$texp" && return 255
    nexp=$(get_header $hdr NEXP)
    test -z "$nexp" && return 255
    telid=$(get_header $hdr AI_TELID)
    test -z "$telid" && return 255
    site=$(get_header $hdr AI_SITE)
    test -z "$site" && return 255

    # handle unknown obscode
    test -z "$obscode" &&
        x=$(get_param -q -k location $sitesdat COD $site) && obscode=$x
    (test -z "$obscode" || test "$obscode" == "-") && obscode="XXX"
    if [ "$obscode" == "XXX" ]
    then
        # get observatory site coordinates
        long=$(get_param -k location $sitesdat long $site)
        lat=$(get_param -k location $sitesdat lat $site)
        alt=$(get_param -k location $sitesdat alt $site)
        if [ "$long" ] && [ "$lat" ] && [ "$alt" ]
        then
            sitecoord=$(echo $(dec2sexa $long) $(dec2sexa $lat) $alt | tr -d '+' | awk '{
            lon=$1; sub("-","",lon); X="E"; if (lon!=$1) X="W"
            lat=$2; sub("-","",lat); Y="N"; if (lat!=$2) Y="S"
            printf("Long. %s %s, Lat. %s %s, Alt. %sm, Google Earth", lon, X, lat, Y, $3)
            }' | tr ':' ' ')
        else
            echo "WARNING: unable to get coordinates for $site" >&2
        fi
    fi

    # get astrometric catalog
    if [ -z "$acat" ]
    then
        x=$(get_header -q $whdr AREFCAT)
        test -z "$x" && x=$(ls -t wcs/$setname.*.dat 2>/dev/null | \
            grep -E "ucac|ppmx|2mass|nomad" | \
            lines 1 | sed -e 's,^wcs/'$setname'\.,,; s,\.dat$,,')
        if [ -z "$x" ]
        then
            # try reading from airtools.log
            x=$(grep "^# running: AIwcs .* $setname" airtools.log | tail -1 | \
                awk -v s=$setname '{for(i=1;i<NF;i++) {if($i==s) {x=i+1; print $x}}}')
            if [ "$x" ]
            then
                echo "WARNING: got astrometric catalog $x from log" >&2
                case "$x" in
                    ucac4) x="ucac-4";;
                esac
            fi
        fi
        test -z "$x" &&
            echo "WARNING: unknown astrometric catalog (assuming UCAC-4)" >&2 &&
            x="ucac-4"
        acat=${x^^}
    fi
    
    # indicate stacking
    stacknote=""
    test $nexp -gt 1 && stacknote="K"
    
    # telescope information
    ctype=$(get_param $cameradat ctype $telid)
    test -z "$ctype" && return 255
    camnote="B"
    test "$ctype" == "CCD" && camnote="C"
    telinfo=$(echo $(get_param $cameradat aperture $telid) \
        $(get_param $cameradat fratio $telid) | awk '{printf("%.2f-m f/%.1f", $1/1000, $2)}')
    ttype=$(get_param $cameradat ttype $telid)
    case "$ttype" in
        L)  telinfo="$telinfo reflector";;
        *)  telinfo="$telinfo refractor";;
    esac
    case "$ctype" in
        CCD) telinfo="$telinfo + CCD";;
    #    *)  telinfo="$telinfo + CMOS";;
    esac
    
    # get photometric information (magnitude and filter)
    mtype=""
    test "$m1" && mag=$m1 && mtype="T"
    test -z "$mag" && test "$m2" && mag=$m2 && mtype="N"
    test "$mag" == "-" && mag="" && mtype=""
    test "$mag" && mag=$(echo $mag | awk '{printf("%4.1f", $1)}')
    # note: filter is not indicated if mtype is given

    # convert object name to MPC report compact name (12 chars)
    # notes: not tested for NEO's and unnumbered asteroids
    mpcname=$(cometname $object | awk '{
        if ($0~/^[0-9]/) {
            sub("/P/","")
            printf("%04dP       ", $0)
        } else {
            type=substr($0,1,1)
            if (type == "(") {
                # numbered asteroid
                num=$0; gsub(/[()]/,"",num)
                num=1*num
                if (num<100000) {
                    printf("%05d       ", num)
                } else {
                    # note: max num is 359999 resulting in Z9999
                    c=sprintf("%c", 55+substr(num,1,2))
                    printf("%s%04d       ", c, substr(num,3))
                }
            } else {
                x=substr($0,3,2)
                if(x==18) Y="I"; if(x==19) Y="J"; if(x==20) Y="K"; if(x==21) Y="L"
                yy=substr($0,5,2)
                m=substr($0,8,1)
                n=substr($0,9,1)
                frag=0
                printf("    %s%s%s%s%02d%s", type, Y, yy, m, n, frag)
            }
        }}')
    test "$AI_DEBUG" && echo "# object=$object mpcname=_${mpcname}_" >&2
    
    # get date at middle of nref
    x=$(echo $jdref $texp | awk '{printf("%.5f", $1+$2/2/3600/24)}')
    utmid=$(jd2ut -p 5 $x | tr '-' ' ')
    test "$AI_DEBUG" && echo "# utmid=$utmid"
    
    # print header of report
    x=$(echo $author | awk '{for(i=1;i<NF;i++)printf("%s. ", substr($i,1,1)); printf("%s", $NF)}')
    echo "COD $obscode"
    test "$sitecoord" && echo "COM $sitecoord"
    echo "\
        CON ${author}, $address [$email]
        OBS $x
        MEA $x
        TEL $telinfo
        NET $acat
        " | sed -e 's,^[ ]*,,'
    # convert coordinates (J2000)
    # TODO: for stacks use K in column 14
    #   photometric band or nuclear/total flag in column 71 (filter/mtype)
    echo "id" $xfits $yfits | xy2rade -f -s - $whdr | while read ra dec x
    do
        printf "%s %s%s%s %-12s%-12s %7s %4s %1s %4s %s\n" \
            "$mpcname" "$stacknote" "$camnote" "$utmid" "${ra//:/ }" "${dec//:/ }" "" \
            "$mag" "$mtype" "" $obscode
    done
}

mpcsort () {
    # combine and sort MPCReports of astrometric measurements
    local codlist
    local netlist
    local replist=$@
    local flist
    local fflist
    local f
    codlist=$(cat $replist | grep "^COD " | sort -u | awk '{print $2}')
    for cod in $codlist
    do
        flist=$(grep -l "^COD $cod" $replist)
        test -z "$flist" && continue
        netlist=$(cat $flist | grep "^NET " | sort -u | awk '{print $2}')
        for net in $netlist
        do
            fflist=$(grep -l "^NET $net" $flist)
            test -z "$fflist" && continue
            for key in COD COM CON OBS MEA TEL NET
            do
                cat $fflist | grep "^$key " | sort -u
            done
            cat $fflist | grep -v "^[A-Z][A-Z][A-Z] " | sort -u
            echo ""
        done
    done
}

cometsmooth () {
    # smooth comet image to enhance structure and eliminate background stars
    # TODO: operate on smaller image area only (outer coma region + trail_length + 2*20px)
    #       eliminate bg stars
    local showhelp
    local blurscale=1   # scale blurring distance on edges
    local bgcoimg       # bg in coimg
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-b" && blurscale=$2 && shift 2
        test "$1" == "-bg" && bgcoimg=$2 && shift 2
    done
    local set=$1
    local coimg=$2      # comet image (comet stack without star trails,
                        #   stretched by comult)
    local smoothreg=$3  # ds9 region file with polygon masks named core,
                        # inner, outer and optionally bad for core
                        #   (unsmoothed), inner coma, outer coma and excluded areas
    local bgval=2000    # bg val in result image
    local comult
    local ext
    local hdr
    local reg
    local rms
    local a
    local b
    local p
    local m
    local cobad=comet/$set.bad.reg
    local tdir=${AI_TMPDIR:-"/tmp"}
    local wdir=$(mktemp -d "$tdir/tmp_cosmooth_XXXXXX")

    (test "$showhelp" || test $# -ne 3) &&
        echo "usage: cometsmooth [-b blurscale|$blurscale] [-bg bgr,bgg,bgb] <set> <coimg> <smoothreg>" >&2 &&
        return 1
    
    test -e $set.ppm && ext=ppm
    test -z "$ext" && test -e $set.pgm && ext=pgm
    test -z "$ext" &&
        echo "ERROR: no image stack ($set.ppm or $set.pgm) found." >&2 && return 255

    test ! -e $coimg &&
        echo "ERROR: image $coimg does not exist." >&2 && return 255
    hdr=$set.head
    test ! -e $hdr &&
        echo "ERROR: header file $hdr not found." >&2 && return 255
    test ! -e $smoothreg &&
        echo "ERROR: region file $smoothreg does not exist." >&2 && return 255
    # check for required regions
    for reg in core inner outer
    do
        ! regid $smoothreg | sort -u | grep -q "^$reg$" &&
            echo "ERROR: missing region $reg in $smoothreg." >&2 && return 255
    done
    rms=$(get_header $hdr AI_RMSG)
    test -z "$rms" &&
        echo "ERROR: missing keyword AI_RMSG" >&2 && return 255
    
    # create mask images
    reg2pbm $coimg $smoothreg core  > $wdir/x.core.m.pbm
    reg2pbm $coimg $smoothreg inner > $wdir/x.inner.m.pbm
    reg2pbm $coimg $smoothreg outer > $wdir/x.outer.m.pbm

    # TODO: measure bg in coimg just outside of outer region
    false && convert $wdir/x.outer.m.pbm -dilate 5 - | \
        pnmarith -sub - $wdir/x.outer.m.pbm > $wdir/x.bgmask.pbm
    test -z "$bgcoimg" && bgcoimg=2000
    test "$ext" == "ppm" &&
        test $(echo $bgcoimg | tr ',' ' ' | wc -w) -eq 1 &&
        bgcoimg="$bgcoimg,$bgcoimg,$bgcoimg"
    
    # replace bad areas and fill holes more than 5 sigma below bgcoimg
    p=$(echo $blurscale | awk '{printf("%.0f", 8+10/$1)}')
    m=$(echo $blurscale | awk '{x=int($1+0.5); printf("%d", 1+2*x)}')
    min=$(echo $rms | awk -v bg=$bgval '{printf("%.0f", bg-5*$1-1)}')
    pnmccdred -a $min -m 0 $coimg $wdir/x.min.ppm
    if [ -e $cobad ]
    then
        a=$(get_header $set.head AI_OMOVE | awk -F '@' '{printf("%.0f", -1*$2)}')
        convert $coimg -resize ${p}% -median $m $wdir/x.small.ppm
        # exclude center 3x3 pixel
        mkkernel 11 3 $a | convert - -fill white -draw "rectangle 4,4 6,6" $wdir/x.kern.pbm
        kmedian $wdir/x.small.ppm $wdir/x.kern.pbm > $wdir/x.smallmd.ppm
        convert $wdir/x.smallmd.ppm -resize $(imsize $coimg | tr ' ' 'x')\! $wdir/x.smooth.ppm
        reg2pbm $coimg $cobad > $wdir/x.mask.pbm
        pnmcomp -alpha $wdir/x.mask.pbm $wdir/x.smooth.ppm $coimg | \
            convert - $wdir/x.min.ppm -evaluate-sequence max $wdir/x.newsub.ppm
    else
        convert $coimg $wdir/x.min.ppm -evaluate-sequence max $wdir/x.newsub.ppm
    fi
    
    # create smoothed images
    # blur 0x1.8 2xS/N
    # blur 0x4   5xS/N
    add=$(echo $bgcoimg | tr ',' ' ' | awk -v b=$bgval '{
        printf("%.0f", b-$1)
        if (NF==3) printf(",%.0f,%.0f", b-$2, b-$3)}')
    echo "# add=$add" >&2
    pnmccdred -a $add $wdir/x.newsub.ppm $wdir/x.core.$ext   # bright core - not smoothed
    convert $wdir/x.core.$ext -blur 0x1.0 $wdir/x.inner.$ext # center coma
    convert $wdir/x.core.$ext -blur 0x2.6 $wdir/x.outer.$ext # outer coma and tail
        
    # TODO: measure size of regions to determine amount of blurring
    
    # blur edges of mask images
    # the second number in the blur parameter approximatly corresponds
    # to the distance of blurring at both sides of the edge
    (cd $wdir
    pnmdepth 65535 x.core.m.pbm 2>/dev/null  | convert - -blur 0x$blurscale x.core.mb.pgm
    b=$(echo "3*$blurscale" | bc)
    pnmdepth 65535 x.inner.m.pbm 2>/dev/null | convert - -blur 0x$b - | \
        pnmccdred -d x.core.mb.pgm - x.inner.mb.pgm
    b=$(echo "9*$blurscale" | bc)
    pnmdepth 65535 x.outer.m.pbm 2>/dev/null | convert - -blur 0x$b - | \
        pnmccdred -d x.core.mb.pgm - - | \
        pnmccdred -d x.inner.mb.pgm - x.outer.mb.pgm
    # outside of comet area
    pnmarith -add x.core.mb.pgm x.inner.mb.pgm | \
        pnmarith -add - x.outer.mb.pgm | pnminvert > x.outside.mb.pgm
    )
    
    # create smoothed comet image
    # TODO: maybe compensate for integer truncation on x.inner and x.outer
    (cd $wdir
    pnmarith -mul x.core.$ext  x.core.mb.pgm 2>/dev/null    > x.core.part.$ext
    pnmarith -mul x.inner.$ext x.inner.mb.pgm 2>/dev/null   > x.inner.part.$ext
    pnmarith -mul x.outer.$ext x.outer.mb.pgm 2>/dev/null   > x.outer.part.$ext
    pnmccdred -m 0 -a $bgval x.core.$ext - | \
        pnmarith -mul -        x.outside.mb.pgm 2>/dev/null > x.outside.part.$ext
    )
    pnmarith -add $wdir/x.core.part.$ext $wdir/x.inner.part.$ext | \
        pnmarith -add - $wdir/x.outer.part.$ext | \
        pnmarith -add - $wdir/x.outside.part.$ext

    test "$AI_DEBUG" && echo $wdir >&2 && return
    rm -rf $wdir
    return
}

mkcotrail () {
    # create artificial motion blur of comet image corresponding to exposures
    # and mag differences read from <obsdata> text file
    local showhelp
    local outimg        # name of output image
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-o" && outimg=$2 && shift 2
    done
    local set=$1
    local coimg=$2      # comet image
    local omove=$3      # dr@pa@x,y: dr - object move on the sky in "/hr
                        # pa - pa in deg (N over W)
                        # x,y - object position in costack (image coord. system)
    local obsdata=$4    # observations data for individual images of ststack
                        # lines: imageID JD dmag (dmag with arbitrary zero point)
    local bgval=${5:-2000} # bg value in coimg
    
    local tmp1=$(mktemp "/tmp/tmp_cophot_$$.XXXXXX")
    local ext
    local wcshdr
    local jdref
    local magzero
    local texp
    local r
    local p
    local mmag
    local w
    local h
    local cmag
    local val
    local id
    local jd
    local mag
    local dm
    local dt
    local x
    local y
    
    (test "$showhelp" || test $# -lt 4) &&
        echo "usage: mkcotrail [-o outimg] <set> <coimg> <omove> <obsdata> [bgval|$bgval]" >&2 &&
        return 1

    # set output image name
    ext=${coimg##*.}
    test -z "$outimg" && outimg=$set.cotrail.$ext

    # read some header keywords
    wcshdr=$set.wcs.head
    jdref=$(get_header -q $set.head JD_REF)
    test -z "$jdref" && jdref=$(get_header -q $set.head MJD_REF)
    test -z "$jdref" && jdref=$(get_header -q $set.head JD_OBS)
    test -z "$jdref" && jdref=$(get_header -q $set.head MJD_OBS)
    test -z "$jdref" && jdref=$(get_header -q $set.head JD)
    test -z "$jdref" &&
        echo "ERROR: unknown JD." >&2 && return 255
    magzero=$(get_header $set.head MAGZERO)
    texp=$(get_header -s $set.head EXPTIME,NEXP | tr '\n' ' ' | awk '{print $1/$2}')
    r=$(get_wcsrot $wcshdr $(echo $omove | awk -F "@" '{print $3}' | tr ',' ' '))
    p=$(get_wcspscale $wcshdr)

    # round bgval to nearest integer
    bgval=$(echo $bgval | awk '{printf("%.0f", $1)}')
    
    # measure comet brightness (arbitrary zeropoint)
    w=$(identify $coimg | cut -d " " -f3 | cut -d "x" -f1)
    h=$(identify $coimg | cut -d " " -f3 | cut -d "x" -f2)
    x=$(imcount $coimg)
    cmag=$(for y in ${x//,/ }
        do
            val=$((y-w*h*bgval))
            test $val -gt 0 && i2mag $val $texp $magzero
            test $val -le 0 && echo 99
        done | \
        tr '\n' ',' | sed -e 's/,$//')
    echo "# cmag=$cmag" >&2

    # deal with empty obsdata file (no info about individual exposures)
    x=$(grep -v "^#" $obsdata | wc -l)
    test $x -eq 0 &&
        pnmccdred -a -$bgval $coimg $outimg &&
        rm -f $tmp1 && return

    
    # process obsdata file
    mmag=$(grep -v "^#" $obsdata | awk '{x=x+exp(-0.4*$3*log(10))}
            END {printf("%.3f\n", -2.5/log(10)*log(x/NR))}')
    grep -v "^#" $obsdata | while read id jd mag
    do
        # determine photometric correction with respect to ststack
        dm=$(echo $mmag $mag | awk '{printf("%.3f", $1-$2)}')
        
        # time offset with respect to nref in seconds
        dt=$(echo $jdref $jd | awk  '{printf("%d", ($2-$1)*24*3600)}')
        
        # determine comets offset with respect to jdref in cartesian x/y
        x=$(echo $omove $dt $r $p | awk '{
            split($1,a,/@/)
            r=(a[2]-$3)*3.1415926/180
            printf("%.2f", -1*a[1]*sin(r)*$2/$4/3600)}')
        y=$(echo $omove $dt $r $p | awk '{
            split($1,a,/@/)
            r=(a[2]-$3)*3.1415926/180
            printf("%.2f", a[1]*cos(r)*$2/$4/3600)}')

        test "$AI_DEBUG" && echo "# $dt $x $y" >&2
        # create "photometry" data file
        # x,y starting at upper left image corner = 0,0
        echo "$id $x $y $dm $dt ${cmag//,/ }" | awk -v w=$w -v h=$h '{
            r0=$6; g0=$6; b0=$6; if (NF==8) {g0=$7; b0=$8}
            printf("%s  %.2f %.2f  %.3f %.3f %.3f  %5d\n",
                $1, w/2+$2, h/2-$3, $4+r0, $4+g0, $4+b0, $5)
        }'
    done > $tmp1

    x=$(echo $texp $(wc -l $tmp1) | awk '{printf("%f", $1/$2)}')
    test "$AI_DEBUG" &&
        echo AIskygen -o $outimg $tmp1 $coimg $x $magzero 1 $w $h $bgval >&2
    AIskygen -o $outimg $tmp1 $coimg $x $magzero 1 $w $h $bgval
    
    test "$AI_DEBUG" || rm -f $tmp1
    return
}

rgbshift () {
    local showhelp
    local wbmul="1,1,1"
    local i
    for i in $(seq 1 2)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-w" && wbmul=$2 && shift 2
    done
    local rgb=$1
    local bg=$2     # 3 numbers
    local bgnew=$3  # 1 number
    local add
    
    (test "$showhelp" || test $# -lt 3) &&
        echo "usage: rgbshift [-w RGBmult|$wbmul] <rgbimg> <bgR,bgG,bgB> <bgnew>" >&2 &&
        return 1
    
    # apply white balance, scale intensity and shift bg
    add=$(echo ${bg//,/ } ${wbmul//,/ } | awk -v bgnew=$bgnew '{
        printf("%.1f,%.1f,%.1f", bgnew-$1*$4, bgnew-$2*$5, bgnew-$3*$6)}')
    pnmccdred -a $add -m $wbmul $rgb -
  
}

# pseudo LRGB processing
rgbsmooth () {
    # smoothing color, optionally stretch and white balance
    local showhelp
    local wbmul="1,1,1"
    local outmult=1
    local boxsize=3 # boxsize of median filter
    local i
    for i in $(seq 1 4)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-b" && boxsize=$2 && shift 2
        test "$1" == "-m" && outmult=$2 && shift 2
        test "$1" == "-w" && wbmul=$2 && shift 2
    done
    local rgb=$1
    local bg=$2
    local rmsg=$3
    local bgnew
    local add
    local ext=ppm
    #local tdir=${AI_TMPDIR:-"/tmp"}
    #local tmp1=$(mktemp "$tdir/tmp_data_$$.XXXXXX.dat")
    
    (test "$showhelp" || test $# -lt 3) &&
        echo "usage: rgbsmooth [-w RGBmult|$wbmul] [-m mult|$outmult] [-b boxsize|$boxsize] <rgbimg> <bgR,bgG,bgB> <rmsg>" >&2 &&
        return 1

    # image used for luminance: apply white balance, scale and shift bg to 2*stddev
    bgnew=$(echo $rmsg | awk -v m=$outmult '{printf("%.0f", 2*m*$1+1)}')
    add=$(echo ${bg//,/ } ${wbmul//,/ } | awk -v bgnew=$bgnew '{
        printf("%.1f,%.1f,%.1f", bgnew-$1*$4, bgnew-$2*$5, bgnew-$3*$6)}')
    echo "# bgnew=$bgnew  add=$add  mul=$wbmul" >&2
    pnmccdred2 -a $add -m $wbmul $rgb x.lum.$ext
    # color image: apply white balance, scale and shift bg to 6*stddev and blur
    bgnew=$(echo $rmsg | awk -v m=$outmult '{printf("%.0f", 6*m*$1+1)}')
    add=$(echo ${bg//,/ } ${wbmul//,/ } | awk -v bgnew=$bgnew '{
        printf("%.1f,%.1f,%.1f", bgnew-$1*$4, bgnew-$2*$5, bgnew-$3*$6)}')
    echo "# bgnew=$bgnew  add=$add  mul=$wbmul" >&2
    pnmccdred2 -a $add -m $wbmul $rgb - | convert - -median $boxsize x.col.$ext
    # combine luminance and color images, apply gamma curve
    convert x.col.ppm x.lum.ppm \
        -colorspace HSL     \
        -separate           \
        -delete 2-4         \
        -combine            \
        -set colorspace HSL \
        -colorspace rgb     \
        ppm:-
}


rgbscale () {
    # scale intensity of 16bit rgb image to examine background
    local showhelp
    local thres="5,3"
    local verbose
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-v" && verbose=1 && shift 1
        test "$1" == "-t" && thres=$2 && shift 2
    done
    
    local img=$1
    local sd=$2
    local outsize=240   # output image size (only enlarge)
    local high=${thres%,*}
    local low=${thres#*,}
    local rmult
    local radd
    local gmult
    local gadd
    local bmult
    local badd
    local x
    local tmpimg=$(mktemp /tmp/tmp_im1_XXXXXX.pnm)
    local tmpdat=$(mktemp /tmp/tmp_val_XXXXXX.dat)
        
    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: rgbscale [-v] [-t thres|$thres] <img> [sd]" >&2 &&
        return 1

    ! is_ppm $img && ! is_pgm $img &&
        echo "ERROR: input image is not in PPM or PGM format" >&2 && return 255
    # shrink large input image (max 400px), remove border
    convert $img -sample 400\> $tmpimg
    imcrop $tmpimg 90 | AIval -a - > $tmpdat
    
    # red channel
    x=""; test "$sd" && x=$((sd*100/170))
    set -- $(kappasigma $tmpdat 1)
    test "$verbose" && echo -ne "sd=${2%%.*}" >&2
    set -- $(echo $1 $2 $x | awk -v b=16 -v l=$low -v h=$high '{
            m=2^b/$NF/(l+h)
            a=2^b*l/(l+h)-$1*m
            printf("%.1f %.0f\n", m, a)
        }')
    rmult=$1; radd=$2
    
    if is_ppm $img
    then
        # green channel
        set -- $(kappasigma $tmpdat 2)
        test "$verbose" && echo -n ",${2%%.*}" >&2
        set -- $(echo $1 $2 $sd | awk -v b=16 -v l=$low -v h=$high '{
                m=2^b/$NF/(l+h)
                a=2^b*l/(l+h)-$1*m
                printf("%.1f %.0f\n", m, a)
            }')
        gmult=$1; gadd=$2
        
        # blue channel
        x=""; test "$sd" && x=$((sd*100/125))
        set -- $(kappasigma $tmpdat 3)
        test "$verbose" && echo ",${2%%.*}" >&2
        set -- $(echo $1 $2 $x | awk -v b=16 -v l=$low -v h=$high '{
                m=2^b/$NF/(l+h)
                a=2^b*l/(l+h)-$1*m
                printf("%.1f %.0f\n", m, a)
            }')
        bmult=$1; badd=$2
        
        pnmccdred -m $rmult,$gmult,$bmult -a $radd,$gadd,$badd $tmpimg - | \
            convert - -depth 8 -scale $outsize\< -
    else
        pnmccdred -m $rmult -a $radd $tmpimg - | \
            convert - -depth 8 -scale $outsize\< -
    fi
    
    test "$verbose" && wc -l $tmpdat >&2
    rm -f $tmpimg $tmpdat
    return 0
}


get_telescope () {
    # get telescope identifier of the given set evaluating
    #   - $sname.head
    #   - measure/$nref.src.head
    #   - rawfile starting with $nref
    # fallback: unique entry in camera.dat according to flen,fratio
    local showhelp
    local quiet
    local i
    for i in 1 2
    do
        test "$1" == "-q" && quiet=1 && shift 1
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    done
    local sname=$1
    local sdat=${AI_SETS:-"set.dat"}
    local tel
    local exifdat="exif.dat"
    local cameradat="camera.dat"
    local nlist
    local nref
    local flen
    local fratio
    local line
    local fname
    
    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: get_telinfo <set|img>" >&2 &&
        return 1

    # examine environment
    test "$AI_TELESCOPE" && echo $AI_TELESCOPE && return
    
    # examine keywords TELESCOP and OBSERVAT in $sname.head
    fname="$sname.head"
    if [ -f $fname ]
    then
        tel=$(get_header -q $fname AI_TELID)
        test -z "$tel" &&
            tel=$(grep "^TELESCOP=" $fname | tr ' ' '\n' | tr -d "'i" | \
            grep "^T[0-9]*$" | lines 1)
        test -z "$tel" &&
            tel=$(grep "^OBSERVAT=" $fname | tr ' ' '\n' | tr -d "'i" | \
            grep "^T[0-9]*$" | lines 1)
        test "$AI_DEBUG" && test -z "$tel" && echo "INFO: tel not in $fname" >&2
    else
        test "$AI_DEBUG" && echo "WARNING: file $fname not found" >&2
    fi
    test "$tel" && echo "$tel" && return

    # try to obtain telescope identifier from set.dat (field 11)
    tel=$(grep -v "^#" $sdat | egrep "^[0-9]{2}:[0-9]{2} $sname " | lines 1 | awk '{
        if ($11!~/^#/) {printf("%s", $11)}}')
    test "$AI_DEBUG" && test -z "$tel" && echo "INFO: tel not in $sdat" >&2
    test "$tel" && echo "$tel" && return
  
    # determine nref
    nref=$(grep -v "^#" $sdat | grep "^[0-9]*:[0-9]* $sname " | lines 1 | awk '{
        printf("%s", $8)}')
    test "$AI_DEBUG" && echo "nref(1)=$nref" >&2
    if ! is_integer "$nref"
    then
        nref=""
        nlist=$(AIimlist -n $sname 2>/dev/null)
        test -z "$nlist" && nlist=$(AIimlist -n $sname "" raw 2>/dev/null)
        test "$nlist" && nref=$(echo $nlist | awk '{i=int(NF/2)+1; printf("%s", $i)}')
        test "$AI_DEBUG" && echo "nref(2)=$nref" >&2
    fi
    ! is_integer "$nref" &&
        echo "ERROR: cannot determine nref in set $sname." >&2 && return 255

    # examine measure/$nref.src.head
    fname="measure/$nref.src.head"
    if [ -f $fname ]
    then
        tel=$(grep "^TELESCOP=" $fname | tr ' ' '\n' | tr -d "'i" | \
            grep "^T[0-9]*$" | lines 1)
        test -z "$tel" &&
            tel=$(grep "^OBSERVAT=" $fname | tr ' ' '\n' | tr -d "'i" | \
            grep "^T[0-9]*$" | lines 1)
        test "$AI_DEBUG" && test -z "$tel" && echo "INFO: tel not in $fname" >&2
    else
        test "$AI_DEBUG" && echo "WARNING: file $fname not found" >&2
    fi
    test "$tel" && echo "$tel" && return
    
    # examine raw file
    fname=$(AIimlist -f $sname "" raw 2>&1 | grep "/$nref\.")
    #test -z "$fname" && fname=$(get_imfilename $nref)
    test ! "$quiet" && test -z "$fname" &&
        echo "WARNING: no image for nref=$nref found." >&2
    if [ -f "$fname" ]
    then
        if is_raw $fname
        then
            test "$AI_DEBUG" &&
                echo "INFO: $fname is DSLR camera RAW file" >&2
        else
            tel=$(get_header -q -s $fname TELESCOP,OBSERVAT | tr ' ' '\n' | tr -d "i" | \
                grep "^T[0-9]*$" | lines 1)
            test "$AI_DEBUG" && test -z "$tel" &&
                echo "WARNING: tel not in $fname" >&2
        fi
    fi
    test "$tel" && echo "$tel" && return

    
    # examine header file associated with raw file
    fname=${fname%.*}".hdr"
    if [ -f $fname ]
    then
        tel=$(get_header -q $fname TELESCOP 2>/dev/null)
    fi
    test "$tel" && echo "$tel" && return
    
    # try to find unique entry for flen/fratio (from exif.dat) in cameradat
    test ! -f $cameradat && echo "ERROR: file $cameradat not found." >&2 && return 255
    if [ -e $exifdat ]
    then
        flen=$(get_param -k 2 $exifdat flen $nref)
        fratio=$(get_param -k 2 $exifdat fn $nref)
        line=$(cat $cameradat | awk -v flen=$flen -v fratio=$fratio 'BEGIN{hfound=0}{
            if(hfound==0 && $1=="#") {
                hfound=1
                for(i=1;i<=NF;i++) {if($i=="flen") cflen=i-1; if($i=="fratio") cfratio=i-1}
            }
            if (hfound>0 && cflen>0 && cfratio>0) {
                if ($cflen == flen && $cfratio == fratio) {
                    printf("%s\n", $1)
                }
            }
        } END {
            if (cflen==0 && cfratio==0) printf("ERROR: column(s) flen and/or fratio not found")
        }')
    fi

    test "$AI_DEBUG" && echo "line=$line" >&2
    if [ $(echo $line | wc -w) -eq 0 ]
    then
        test ! "$quiet" &&
            echo "WARNING: no match of flen=$flen fratio=$fratio in $cameradat" >&2
        return 255
        # fallback: first entry in cameradat
        #tel=$(grep -v "^#" $cameradat | head -1 | cut -d ' ' -f1)
    else
        test $(echo $line | wc -w) -eq 1 && echo $line && return
        test $(echo $line | wc -w) -ge 2 && echo "$line" | grep -q -w ERROR - &&
            echo "$line" >&2 && return 255
        if [ $(echo $line | wc -w) -ge 2 ]
        then
            test ! "$quiet" &&
                echo "WARNING: multiple matches of flen=$flen fratio=$fratio in $cameradat" >&2
            return 255
        fi
    fi
}

get_param () {
    # get parameter from environment or named column in data file or from
    #   default value (5th parameter)
    # requires column names at start of data file like: # col1 col2 ... colN
    local showhelp
    local quiet
    local kname=1   # either column name or number
    local i
    for i in 1 2 3
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-q" && quiet=1 && shift 1
        test "$1" == "-k" && kname=$2 && shift 2
    done
    local dat=$1
    local paramname=$2
    local sname=$3  # set name or column name
    local envname=${4:-""}
    local valdefault=${5:-""}
    local val
    local line
    local errmsg
    local keyval
    
    (test "$showhelp" || test $# -lt 3) &&
        echo "usage: get_param [-q] [-k keyname|keycolumn] <datafile> <paramname> <keyvalue|setname> [envname] [default]" >&2 &&
        return 1
    
    # get value of envname from environment
    test "$envname" && val=$(eval echo \$$envname)
    test "$val" && echo "$val" && return
    
    # checkings
    test ! -f "$dat" &&
        echo "ERROR: data base file $dat not found." >&2 && return 255

    # set keyvalue for given data file
    case "$dat" in
        camera.dat)     if [ "$AI_TELESCOPE" ]
                        then
                            keyval=$AI_TELESCOPE
                        else
                            keyval=$sname
                            # check if sname has matching entry in set.dat
                            if is_setname -q $sname
                            then
                                keyval=$(get_telescope $sname 2>/dev/null)
                                test $? -ne 0 &&
                                    echo "ERROR: failed command: get_telescope $sname" >&2 &&
                                    return 255
                            fi
                        fi
                        ;;
        *)              keyval=$sname;;
    esac
    test "$AI_DEBUG" &&
        echo "cat $dat | awk -v keyval=\"$keyval\" -v kname=$kname -v pname=\"$paramname\" ..." >&2
    line=$(cat $dat | awk -v keyval="$keyval" -v kname=$kname -v pname="$paramname" \
    'BEGIN{hfound=0; hline=""; kcol=0; pcol=0}{
        if(NF==0) next
        if(hfound==0 && $1=="#") {
            hline=$0
            if(kname~/^[0-9]+$/) {kcol=kname} else {
                for(i=1;i<=NF;i++) if($i==kname) kcol=i-1
            }
            for(i=1;i<=NF;i++) if($i==pname) pcol=i-1
        } else {
            if (length(hline)>0) hfound=1
        }
        if (hfound>0 && kcol>0 && pcol>0) {
            if ($kcol == keyval) printf("%s\n", $pcol)
        }
    } END {
        if (kcol==0) printf("column %s not found\n", kname)
        if (pcol==0) printf("column %s not found\n", pname)
    }')
    test "$AI_DEBUG" && echo "line=$line" >&2
    test $(echo $line | wc -w) -eq 1 && echo $line && return


    # no unique match
    # create error message
    test $(echo $line | wc -w) -eq 0 &&
        errmsg="no match of $keyval in column $kname of $dat"
    test $(echo $line | wc -w) -ge 2 &&
        echo "$line" | grep -q "column .* not found" - && errmsg="$line"
    test -z "$errmsg" &&
        errmsg="multiple matches of $keyval in column $kname of $dat"
    
    # use default value if defined
    test "$valdefault" && echo "WARNING: $errmsg" >&2 &&
        echo "$valdefault" && return

    # otherwise exit with error
    test -z "$quiet" && echo "ERROR: $errmsg" >&2
    return 255
}

# extract image rotation angle from wcs header at arbitrary position on image
# value 90 means true north is right
get_wcsrot () {
    local showhelp
    local i
    for i in 1
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    done
    local whdr=$1       # ascii wcs header file or set name
    local x=${2:-""}    # image coordinate, if empty use CRPIXn
    local y=${3:-""}
    local w
    local wdeg
    local rad
    local ded
    local xy1
    local xy2
    
    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: get_wcsrot <set|wcshead> [x] [y]" >&2 &&
        return 1
    
    test $# -lt 1 && echo "ERROR: missing parameter <wcshdr>." >&2 && return 255
    test ! -f $whdr && whdr=$1.wcs.head
    test ! -f $whdr && echo "ERROR: file $whdr not found." >&2 && return 255
    
    if [ -z "$x$y" ]
    then
        # using image center
        # analyze wcs header keywords CDX_Y 
        set - $(get_header -s $whdr CD1_1,CD1_2,CD2_1,CD2_2 | tr '\n' ' ' | awk '{
            pi=3.141592653
            a1=90+atan2($1, $2)*180/pi
            a2=atan2($3, $4)*180/pi
            if (a1>180) a1=a1-360
            d=a2-a1; if (d<0) d=-1*d
            if (d>3) printf("# ")
            printf("%.3f %.3f %.3f\n", (a1+a2)/2, a1, a2)
        }')
        if [ $1 != "#" ]
        then
            test "$AI_DEBUG" && echo "# rot=$1 a1=$2 a2=$3" >&2
            echo $1
            return
        else
            echo "# check a1=$3 a2=$4" >&2
        fi
    fi
    
    test -z "$x" && x=$(grep "^CRPIX1 " $whdr | awk '{print 1*$3}')
    test -z "$y" && y=$(grep "^CRPIX2 " $whdr | awk '{print 1*$3}')
    ps=$(get_wcspscale $whdr)

    # measure two points separated +-100px in dec from nominal position
    set - $(echo "id1 $x $y" | xy2rade - $whdr)
    rad=$1; ded=$2
    xy1=$(echo $rad $ded $ps | awk '{printf("id1 %f %f", $1, $2-$3/36)}' | \
        rade2xy - $whdr)
    xy2=$(echo $rad $ded $ps | awk '{printf("id2 %f %f", $1, $2+$3/36)}' | \
        rade2xy - $whdr)
    echo $xy1 $xy2 | awk '{printf("%.3f\n", atan2($5-$2,$3-$6)*180/3.1415926)}'
}

# extract pixel scale from wcs projection matrix data
get_wcspscale () {
    local whdr=$1   # ascii wcs header file
    local ps

    test $# -lt 1 && echo "ERROR: missing parameter <wcshdr>." >&2 && return 255
    test ! -f $whdr && whdr=$1.wcs.head
    test ! -f $whdr && echo "ERROR: file $whdr not found." >&2 && return 255

    ps=$(grep "^CD[12]_[12] " $whdr | awk '{print $3}' | tr '\n' ' ' | awk '{
        pi=3.141592653
        r1=sqrt($1*$1 + $2*$2)
        r2=sqrt($3*$3 + $4*$4)
        printf("%.5f\n", 3600*(r1+r2)/2)
    }')
    test -z "$ps" &&
    ps=$(get_header -q -s $whdr CDELT1,CDELT2 | tr '\n' ' ' | awk '{
        pi=3.141592653
        r1=sqrt($1*$1)
        r2=sqrt($2*$2)
        printf("%.5f\n", 3600*(r1+r2)/2)
    }')
    test -z "$ps" && return 255
    echo $ps
}

get_omove () {
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    
    local sname=$1          # set name
    local wcshdr=${2:-""}   # ascii fits header file containing wcs data
    local dt=${3:-""}       # time diff in hours
    local dra=${4:-""}      # in sec
    local dde=${5:-""}      # in asec
    local de=${6:-""}       # in deg
    local ox=${7:-""}       # object position on image (default: CRPIXn in wcshdr)
    local oy=${8:-""}
    local sdat=${AI_SETS:-"set.dat"}
    local n1
    local n2
    local nref
    local jd1
    local jd2
    local jdref
    local dateobs
    
    (test "$showhelp" || test $# -lt 1) &&
        echo -e "usage: get_omove <set> [wcshdr] [dt/hrs] [dra/s] [dde/\"] [de/deg] [ox/px] [oy/px]" >&2 &&
        return 1

    if [ $# -lt 6 ]
    then
        if [ -f $sname.head ] && [ "$(get_header -q $sname.head NEXP)" == "1" ]
        then
            jdref=$(get_header -q $sname.head MJD_REF)
            test -z "$jdref" && jdref=$(get_header -q $sname.head MJD_OBS)
            test -z "$jdref" && jdref=$(get_header -q $sname.head JD)
            test -z "$jdref" && echo "ERROR: unable to determine jdref." >&2 && return 255
            set - $(grep   -v "^#" $sdat | awk -v s=$sname '{if($2==s){print $0}}')
            echo $3 $(jd2ut -t $jdref | cut -d ' ' -f2) 0
            return
        fi
        
        n1=$(AIimlist -n $sname 2>/dev/null | lines 1)
        test -z "$n1" && echo "ERROR: no images found, missing AIccd?" >&2 && return 255
        n2=$(AIimlist -n $sname 2>/dev/null | tail -1)
        set - $(grep   -v "^#" $sdat | awk -v s=$sname '{if($2==s){print $0}}')
        for f in measure/$n1.src.head measure/$n2.src.head measure/$8.src.head
        do
            test ! -f "$f" && echo "ERROR: header file $f does not exist." >&2 &&
            return 255
        done
        jd1=$(grep -E "^MJD_OBS[ ]*=|^JD " measure/$n1.src.head  | lines 1 | tr '=' ' ' | \
            awk '{printf("%s", $2)}')
        if [ -z "$jd1" ]
        then
            dateobs=$(grep "^DATE-OBS=" measure/$n1.src.head | tr -d "'" | awk '{print $2}')
            test "$dateobs" && jd1=$(ut2jd $(echo $dateobs | tr -d '-' | \
                awk -F "T" '{print $2" "substr($1,3)}'))
        fi
        jd2=$(grep -E "^MJD_OBS[ ]*=|^JD " measure/$n2.src.head  | lines 1 | tr '=' ' ' | \
            awk '{printf("%s", $2)}')
        if [ -z "$jd2" ]
        then
            dateobs=$(grep "^DATE-OBS=" measure/$n2.src.head | tr -d "'" | awk '{print $2}')
            test "$dateobs" && jd2=$(ut2jd $(echo $dateobs | tr -d '-' | \
                awk -F "T" '{print $2" "substr($1,3)}'))
        fi
        jdref=$(grep -E "^MJD_OBS[ ]*=|^JD " measure/$8.src.head | lines 1 | tr '=' ' ' | \
            awk '{printf("%s", $2)}')
        if [ -z "$jdref" ]
        then
            dateobs=$(grep "^DATE-OBS=" measure/$8.src.head | tr -d "'" | awk '{print $2}')
            test "$dateobs" && jdref=$(ut2jd $(echo $dateobs | tr -d '-' | \
                awk -F "T" '{print $2" "substr($1,3)}'))
        fi
        echo $3 $jd1 $jd2 $jdref | awk '{
                f=$4-int($4); x=f*24+12; h=int(x);
                y=(x-h)*60; m=int(y);
                s=(y-m)*60
            } END {
                printf("%s %d:%02d:%02.0f %.1f\n",
                    $1, h, m, s, ($3-$2)*24)
            }'
        return 255
    fi

    # dt in hrs, dra in sec, dde in arcsec, de in deg
    # get move in pix/min, x>0: move right (W), y>0: move up (N)
    oxy=$(echo "dt=$dt; dra=$dra; dde=$dde; de=$de;
        ox=-1*dra*15/dt/60*c(de*3.14159/180)/$AI_PIXSCALE;
        oy=dde/dt/60/$AI_PIXSCALE; ox; oy" | bc -l)

    # correct for field rotation (from wcs fit)
    rot=$(get_wcsrot $sname "$ox" "$oy")

    echo $oxy $rot | awk '{pi=3.141592;
        r=atan2($2, $1)*180/pi-$3; l=sqrt($1*$1+$2*$2)
        x=l*cos(r*pi/180); y=l*sin(r*pi/180)
        printf("oxmove=%.3f; oymove=%.3f; rot=%.3f\n", x, y, $3)}'
}


# convert from omove (dr/"@pa (N over W)) to trail vector parameters
# length,angle,centerfrac
omove2trail () {
    local showhelp
    local duration  # duration of image sequence in minutes
    local cfrac     # star stack reference point (0=start, 1=end of image sequence)
    for i in 1 2 3
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-d" && duration=$2 && shift 2
        test "$1" == "-c" && cfrac=$2 && shift 2
    done
    local set=$1
    local omove=$2  # dr@pa, where dr is object move in "/hr, pa is direction
                    #   of move on sky (N over W)
    local sdat=${AI_SETS:-"set.dat"}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpdat=$(mktemp "$tdir/tmp_dat_XXXXXX.dat")
    local trail     # length,angle,centerfrac - length in pix, pa in deg from
                    #   right over top, center fraction (0=start, 1=end of trail)
    local hdr=$set.head
    local whdr
    local nexp
    local nref
    local jd1
    local jd2
    local jdref
    local pscale
    local rot
    local length
    local angle
    local line
    
    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: omove2trail [-h] [-d duration_minutes] [-c cfrac]" \
            "<set> [omove_\"/hr@pa]" >&2 &&
        return 1

    ! is_setname $set &&
        echo "ERROR: entry for set $set in $sdat is missing (or incomplete)" >&2 && return 255
    test ! -e $hdr &&
        echo "ERROR: file $hdr not found." >&2 && return 255
    test -e $set.wcs.head && whdr=$set.wcs.head
    test -z "$whdr" && whdr=$hdr && test "$AI_DEBUG" &&
        echo "WARNING: $set.wcs.head not found" >&2
    
    # TODO check for valid wcs header
    pscale=$(get_wcspscale $whdr)
    test -z "$pscale" &&
        echo "ERROR: unable to determine pixel scale from $whdr" >&2 && return 255
    
    test -z "$omove" && omove=$(get_header $hdr AI_OMOVE)
    test -z "$omove" && echo "ERROR: unknown omove" >&2 && return 255

    if [ -z "$duration" ]
    then
        nexp=$(get_header $hdr NEXP)
        if [ "$nexp" == "1" ]
        then
            duration=$(get_header $hdr EXPTIME | awk '{print $1/60}')
            cfrac=0.5
            test $? -eq 0 && test "$AI_DEBUG" &&
                echo "# DEBUG $FUNCNAME: duration=$duration (nexp=1)" >&2
        fi
    fi
    if [ -z "$duration" ]
    then
        nref=$(AIsetinfo $set | awk '{printf("%s", $4)}')
        test -z "$nref" && echo "ERROR: unable to determine nref." >&2 && return 255
        get_jd_dmag $set > $tmpdat
        test ! -s $tmpdat && echo "ERROR: unknown duration of image sequence" >&2 && return 255
        
        jd1=$(grep -v "^#" $tmpdat | sort -n -k 2,2 | lines 1 | awk '{printf("%s", $2)}')
        jd2=$(grep -v "^#" $tmpdat | sort -n -k 2,2 | tail -1 | awk '{printf("%s", $2)}')
        duration=$(echo $jd1 $jd2 | awk '{printf("%.1f", ($2-$1)*24*60)}')
        test "$AI_DEBUG" &&
            echo "# DEBUG $FUNCNAME: duration=$duration" >&2
    fi
    test "$duration" == "0" && echo "0,0,0" && return

    if [ -z "$cfrac" ] && [ "$jd1" ] && [ "$jd2" ]
    then
        # get jdref from $set.head or measure/$nref.src.head
        if [ -f $set.head ]
        then
            jdref=$(get_header -q $set.head JD_REF)
            test -z "$jdref" && jdref=$(get_header -q $set.head MJD_REF)
            test -z "$jdref" && jdref=$(get_header -q $set.head JD_OBS)
            test -z "$jdref" && jdref=$(get_header -q $set.head MJD_OBS)
        fi
        test -z "$jdref" && echo "WARNING: no JD_REF/JD_OBS in $set.head" >&2
        test -z "$jdref" && test -f measure/$nref.src.head &&
            jdref=$(get_header -q measure/$nref.src.head MJD_OBS)
        test -z "$jdref" &&
            jdref=$(grep -w "^$nref" $tmpdat | awk '{printf("%s", $2)}')
        test -z "$jdref" &&
            echo "ERROR: jdref undefined." >&2 && return 255
        cfrac=$(echo $jd1 $jd2 $jdref | awk '{printf("%.2f", ($3-$1)/($2-$1))}')
    fi
    if [ -z "$cfrac" ]
    then
        # determine cfrac from n1 n2 nref in set.dat
        # assuming set of continuous images
        line=$(grep -v "^#" $sdat | sed -e 's|#.*||' | \
            awk -v s=$set '{if($2==s && $4=="o") {print $0}}')
        cfrac=$(echo $line | awk '{x=0.5; if($6!=$7){x=($8-$6)/($7-$6)}; printf("%.2f", x)}')
    fi
    test -z "$cfrac" &&
        echo "ERROR: unknown cfrac (reference point of star stack)" >&2 && return 255
    
    length=$(echo $duration $pscale ${omove//@/ } | awk '{printf("%.0f", $1/60/$2*$3)}')
    rot=$(get_wcsrot $whdr $(echo $omove | awk -F "@" '{print $3}' | tr ',' ' '))
    angle=$(echo $rot ${omove//@/ } | awk '{printf("%.0f", ($3-$1+90)%360)}')
    echo $length","$angle,"$cfrac"

    # TODO: get dt(nref-first) dt(last-nref) from $tmpdat
    #   get dr1 dr2 and compute length and cfract
    #   get_wcsrot $set.wcs.head $center and compute angle
    rm -f $tmpdat
    return
}


eps2png () {
    local showhelp
    local dpi=150
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-d" && dpi=$2 && shift 2
    done
    local eps=$1
    local out=$2

    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: $(basename $0) [-d dpi|$dpi] <eps> [out]" &&
        exit 1

    test -z "$out" && out=${eps%.*}.png
    convert -render -density $dpi -flatten $eps $out
}

img_info () {
    # extract image meta data from raw/jpeg images
    # note: output times are UT, DSLR camera local time is converted to UT
    #   by querying sites.dat using the value of AI_SITE
    # TODO: add utdate, camera
    local showhelp
    local cam_is_ut     # if set then camera time is in UT otherwise LT
    local gpsinfo=""    # if set then include gps tags
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-u" && cam_is_ut=1 && shift 1
        test "$1" == "-g" && gpsinfo=1 && shift 1
    done
    local tzoff=${AI_TZOFF:-"0"}
    local exifdat="exif.dat"
    local filter
    local method
    local shortname
    local num
    local found
    local line
    local f
    local x
    local slen=12
    local tmpargs=$(mktemp "/tmp/tmp_args_XXXXXX")
    local tmpsh=$(mktemp "/tmp/tmp_script_XXXXXX.sh")
    chmod u+x $tmpsh
    cat <<EOF > $tmpsh
#!/bin/bash
. airfun.sh > /dev/null
_run_parallel \$@
EOF
    
    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: img_info [-u] [-g] <image1> [image2 ...]" >&2 &&
        return 1

    test "$cam_is_ut" && tzoff=0
    filter="DateTimeOriginal|ImageWidth|ImageHeight|ExposureTime|FNumber|ISO|\
FocalLength|SRFocalLength"
    # Pentax
    filter="$filter|CameraTemperature|BlackPoint|PictureMode"

    # check for GPS keywords
    test -z "$gpsinfo" &&
        test "$(exiftool -q -GPSLongitude "$@")" && gpsinfo=1
    test "$gpsinfo" && filter="$filter|GPSTimeStamp|GPSLatitude|GPSLongitude\
|GPSAltitude|GPSSatellites|GPSTrack|GPSImgDirection|PitchAngle|RollAngle"

    for f in "$@"
    do
        # check for raw DSLR image
        ! is_raw "$f" && continue
        
        # determine longest name
        shortname=$(echo $f | sed -e 's,^'$AI_RAWDIR',,; s,^/,,')
        x=$(echo $shortname | wc -c)
        test $x -gt $slen && slen=$x

        grep -q "^"$shortname" " $exifdat && continue
        echo $f $tzoff
    done > $tmpargs
    
    if [ -s $tmpargs ]
    then
        echo "# scanning exif header of" $(cat $tmpargs | wc -l) "images ..." >&2
        # header
        printf "%-${slen}s num  hms        texp  iso fn  flen" "# name"
        printf " temp black mode   w    h"
        test "$gpsinfo" && printf "   gpstime  latitude longitude   alt sat trck azimuth pitch roll"
        printf "\n"
            
        _run_parallel () {
            fname=$1
            tzoff=$2
            shortname=$(echo $fname | sed -e 's,^'$AI_RAWDIR',,; s,^/,,')
            num=$(basename "$fname" | sed -e 's/\.[A-Za-z0-9]*$//; s/^[^0-9]*//')
            test -z "$num" && num="-"
            ! is_number $num && num="-"
            printf "%-${slen}s  %-4s" $shortname $num
            exiftool -S -c "%.5f" "$fname" | grep -wE "$filter" | awk -v tzoff=$tzoff 'BEGIN{
                fn="-"; fl="-"; ms=0; temp="-"; black="-"; mode="-"
                gtime="-"; lat="-"; lon="-"; alt=-1; sat=-1; trck=-1; az=-1; pitch=-1; roll=-1}
            {
                if ($1=="DateTimeOriginal:")          {
                    gsub(/:/, " ")
                    hms=strftime("%H:%M:%S", mktime($2" "$3" "$4" "$5" "$6" "$7)-tzoff*3600)
                }
                if ($1=="ImageWidth:")      w=$2
                if ($1=="ImageHeight:")     h=$2
                if ($1=="ExposureTime:")    texp=$2
                if ($1=="ISO:")             iso=$2
                if ($1=="FNumber:")         if ($2~/^[+-]?[[:digit:]\.]+$/) {fn=$2}
                if ($1=="FocalLength:")     if ($2~/^[+-]?[[:digit:]\.]+$/) {fl=sprintf("%3.0f", $2)}
                #if ($1=="SRFocalLength:" && 1*fl==0 && $2~/^[+-]?[[:digit:]\.]+$/) {fl=sprintf("%3.0f", $2)}

                if ($1=="CameraTemperature:")   temp=$2
                if ($1=="BlackPoint:")          black=$2+$3+$4+$5
                if ($1=="PictureMode:")         mode=$2
                sub(/[,;]/,"",mode)

                # GPS Info, Kompass Info
                if ($1=="GPSTimeStamp:")    gtime=$2
                if ($1=="GPSLatitude:")     lat=$2
                if ($1=="GPSLongitude:")    long=$2
                if ($1=="GPSAltitude:")     alt=$2
                if ($1=="GPSSatellites:")   sat=$2
                if ($1=="GPSTrack:")        trck=$2
                if ($1=="GPSImgDirection:") az=$2
                if ($1=="PitchAngle:")      pitch=$2
                if ($1=="RollAngle:")       roll=$2
            }
            END{
                n=split(texp,a,"/"); if (n==2) texp=a[1]/a[2]
                if (ms!=0) texp=ms/1000
                printf(" %s %6.2f %4d %-4s %s", hms, texp, iso, fn, fl)
                printf(" %2s %4s %-6s %d %d", temp, black, mode, w, h)
                if (lat!="-") printf("   %s %s %s %6.1f %2d %6.2f %6.2f %.1f %.1f",
                    gtime, lat, long, alt, sat, trck, az, pitch, roll)
                printf("\n")
            }'
        }
        export -f _run_parallel
        cat $tmpargs | parallel -k $tmpsh
        #cat $tmpargs | xjobs -v 1 $tmpsh
        unset -f _run_parallel
    fi
    rm -f $tmpsh $tmpargs
    return 0
}

exiv2hdr () {
    # extract some image tags
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    local img=$1
    local obj=$2
    local jd0=$3          # julian day of last noon
    local dt=${4:-"1"}    # offset between camera time and UT
    #local flen=${5:-"800"}   # focal length in mm - if not found in image metadata
    #local fratio=${6:-"4.0"} # f/d ratio - if not found in image metadata

    (test "$showhelp" || test $# -lt 3) &&
        echo -e "usage: exiv2hdr <img> <object> <jd0> [camtime-UT|$dt] [flen|$flen] [fratio|$fratio]" >&2 &&
        return 1

    echo "imnum=$(basename $img | sed -e 's/.[a-zA-Z]*$//')"
    echo "object=$obj"
    exiv2 -pa $img | awk -v j=$jd0 -v dt=$dt 'BEGIN{
        fn="-"; fl="-"; ms=0; temp="-"; black="-"; mode="-"}
    {
        if ($1=="Exif.Image.DateTime")          hms=$5
        if ($1=="Exif.Photo.ExposureTime")      texp=$4
        # special tags
        if ($1=="Exif.Pentax.ExposureTime")     ms=$4
    }
    END{
        n=split(texp,a,"/"); if (n==2) texp=a[1]/a[2]
        if (mode=="Bulb") texp=ms/1000
        nn=split(hms,a,":"); hut=a[1]+a[2]/60+a[3]/3600-dt-12; if(hut<0) hut+=24
        printf("exptime=%.1f\njdmid=%.5f\n", texp, j+hut/24)
    }'
}

hdr2ahead () {
    # read some data from hdr file and write ascii FITS header keywords
    # to stdout
    local hdr=$1
    local jdref
    local epoch
    local exptime
    local object
    local ratel
    local detel
    local sidtime
    
    test ! -f "$hdr" &&
        echo "ERROR: file $hdr not found." >&2 && return 255

    # determine time of observation and exposure time
    jdref=$(grep "^jdmid=" $hdr | cut -d '=' -f2)
    epoch=$(echo $jdref | awk '{printf("%.1f", ($1-2451544.5)/365.25+2000)}')
    exptime=$(grep "^exptime=" $hdr | cut -d '=' -f2)
    test -z "$jdref" &&
        echo "WARNING: unknown observation time." >&2
    test -z "$exptime" &&
        echo "WARNING: unknown exposure time." >&2

    # extract telescope position
    object=$(grep "^object=" $hdr | cut -d '=' -f2)
    ratel=$(grep "^ra=" $hdr | cut -d '=' -f2)
    detel=$(grep "^de=" $hdr | cut -d '=' -f2)
    sidtime=$(grep "^st=" $hdr | cut -d '=' -f2)
    # TODO: compute airmass
    
    # write keywords to header file
    echo "OBJECT  = '$object'"
    test "$ratel" &&
        echo "RATEL   = '$ratel'"
    test "$detel" &&
        echo "DETEL   = '$detel'"
    test "$sidtime" &&
        echo "SIDTIME = '$sidtime'"
    test "$exptime" &&
        echo "EXPTIME =      $exptime / Exposure time in seconds"
    test "$jdref" &&
        echo "MJD_OBS =      $jdref  / Time of observation in julian days" &&
        echo "EPOCH   =      $epoch  / Epoch"
    return
}

# convert from sexagesimal to decimal units
sexa2dec () {
    local hms=$1
    local mult=${2:-1}
    local prec=${3:-4}
    (test "$1" == "-h" || test $# -lt 1) &&
        echo "usage: sexa2dec <hms> [mult] [prec]" >&2 &&
        return 1
    
    test "${hms%%:*}" == "$hms" && echo $hms && return
    echo $hms | awk -F ":" -v m=$mult -v p=$prec '{
        fmt="%."p"f\n"
        if($1~/^-/) {x=$1-$2/60-$3/3600} else {x=$1+$2/60+$3/3600}
        printf(fmt, m*x)}'
}

# convert from decimal to sexagesimal units
dec2sexa () {
    local num_units=3   # number of units, default 3 means hour:minutes:seconds
    local i
    for i in 1 2
    do
        test "$1" == "-h" && num_units=1 && shift 1
        test "$1" == "-m" && num_units=2 && shift 1
    done
    local h=$1
    local div=${2:-1}
    local prec=${3:-1}
    test $# -lt 1 &&
        echo "usage: dec2sexa <-h|-m> <dec> [div] [prec]" >&2 &&
        return 1

    echo $h | awk -v d=$div -v p=$prec -v l=$num_units '{
        fmt="%."p"f"
        x=sprintf(fmt, $1*3600./d)
        if (x<0) {x=-1*x; sign="-"} else {sign="+"}
        h=int(x/3600.); m=int((x-h*3600)/60.); s=x-h*3600-m*60
        ns=2+p+1; if (p==0) ns=2
        if (l==1) {
            fmt="%s%0"ns"."p"f\n"
            printf(fmt, sign, x/3600.)
        }
        if (l==2) {
            fmt="%s%02d:%0"ns"."p"f\n"
            printf(fmt, sign, h, (x-h*3600)/60.)
        }
        if (l==3) {
            fmt="%s%02d:%02d:%0"ns"."p"f\n"
            printf(fmt, sign, h, m, s)
        }
    }'
}

minmax () {
    # return min/max from values of given column in data file
    local fname=${1:-"-"}
    local col=${2:-"1"}
    local min
    local max
    local tmp1=$(mktemp "/tmp/tmp_dat_$$.XXXXXX")
    grep -v "^#" $fname | grep "[0-9]" | awk -v c=$col '{print 1*$c}' > $tmp1
    min=$(sort -n  $tmp1 | lines 1)
    max=$(sort -nr $tmp1 | lines 1)
    echo $min $max
    rm $tmp1
}

cliprange () {
    # return min/max from values of given column in data file
    # after clipping low and high values
    local fname=${1:-"-"}
    local col=${2:-"1"}
    local low=${3:-"5"}     # clip percentage
    local high=${4:-"90"}
    local min
    local max
    local n
    local tmp1=$(mktemp "/tmp/tmp_dat_$$.XXXXXX")
    grep -v "^#" $fname | grep "[0-9]" | awk -v c=$col '{print 1*$c}' | sort -n > $tmp1
    n=$(cat $tmp1 | wc -l)
    min=$(cat $tmp1 | lines $((1 + n*low/100)) | tail -1)
    max=$(cat $tmp1 | lines $((1 + n*high/100)) | tail -1)
    echo $min $max
    rm $tmp1
}

sum () {
    # return sum from values of given column in data file
    local fname=${1:-"-"}
    local col=${2:-"1"}
    local n
    local tmp1=$(mktemp "/tmp/tmp_dat_$$.XXXXXX")
    grep -v "^#" $fname | grep "[0-9]" > $tmp1
    n=$(cat $tmp1 | wc -l)
    test $n -eq 0 && echo "ERROR: no data to compute mean from." >&2 && return 255
    cat $tmp1 | awk -v c=$col '{x=x+$c} END {printf("%.15g\n", x)}'
    rm $tmp1
}

mean () {
    # return mean from values of given column in data file
    local fname=${1:-"-"}
    local col=${2:-"1"}
    local n
    local tmp1=$(mktemp "/tmp/tmp_dat_$$.XXXXXX")
    grep -v "^#" $fname | grep "[0-9]" > $tmp1
    n=$(cat $tmp1 | wc -l)
    test $n -eq 0 && echo "ERROR: no data to compute mean from." >&2 && return 255
    cat $tmp1 | awk -v c=$col '{x=x+$c} END {printf("%.15g\n", x/NR)}'
    rm $tmp1
}

median () {
    # return median from values of given column in data file
    local fname=${1:-"-"}
    local col=${2:-"1"}
    local n
    local tmp1=$(mktemp "/tmp/tmp_dat_$$.XXXXXX")
    grep -v "^#" $fname | grep "[0-9]" > $tmp1
    n=$(cat $tmp1 | wc -l)
    test $n -eq 0 && echo "ERROR: no data to compute median from." >&2 && return 255
    cat $tmp1 | awk -v c=$col '{printf("%.15g\n", 1*$c)}' | \
        sort -n | awk -v n=$(((n+1)/2)) '{if(NR==n) printf("%s\n", $0)}'
    rm $tmp1
}

stddev () {
    # return stddev from values of given column in data file
    local fname=${1:-"-"}
    local col=${2:-"1"}
    local mean
    local tmp1=$(mktemp "/tmp/tmp_dat_$$.XXXXXX")
    grep -v "^#" $fname | grep "[0-9]" > $tmp1
    mean=$(mean $tmp1 $col)  # $(median $fname $col)
    grep -v "^#" $tmp1 | awk -v c=$col -v m=$mean '{
        x=x+($c-m)^2} END {print sqrt(x/(NR-1))}'
    rm $tmp1
}


normstat () {
    # return median,stddev from values of given column in data file
    # using probability function (assuming normal distribution)
    # n<40: measure low1 (+-1.0*stddev) at 0.1586 and high at 0.8414, stddev1=(high-low)/2
    # n>40: measure low2 (+-1.5*stddev) at 0.0668 and high at 0.9332, stddev2=(high-low)/3
    # TODO: recheck code if data is float values
    local fname=${1:-"-"}
    local col=${2:-"1"}
    local n
    local debug
    
    test "$AI_DEBUG" && test $AI_DEBUG -gt 1 && debug="yes"
    cat $fname | grep -v "^#" | grep "[0-9]" | sort -n -k$col,$col | \
    awk -v c=$col -v debug="$debug" '{
        count++;
        val[count]=1*$c
    }END{
        if (count<40) {
            nlow=0.1586*count+0.5; nhigh=0.8414*count+0.5; width=2
        } else {
            nlow=0.0668*count+0.5; nhigh=0.9332*count+0.5; width=3
        }
        if (debug) print "nlim: "int(nlow)" "int(nhigh)
        lowval=val[int(nlow)] + (val[int(nlow)+1]-val[int(nlow)]) * (nlow-int(nlow))
        highval=val[int(nhigh)] + (val[int(nhigh)+1]-val[int(nhigh)]) * (nhigh-int(nhigh))
        if (debug) print "val: "lowval" "highval
        
        if (count % 2 == 0) {
            md=(val[count/2]+val[count/2+1])/2
        } else {
            md=val[(count+1)/2]
        }

        printf("%f %f\n", md, (highval-lowval)/width)
    }'
}


_stat () {
    # return mean or median, stddev from values of given column in data file
    local method="median"
    test "$1" == "-m" && method="mean" && shift 1
    local fname=${1:-"-"}
    local col=${2:-"1"}

    cat $fname | grep -v "^#" | grep "[0-9]" | sort -n -k$col,$col | \
        awk -v c=$col -v m=$method '{
            count++;
            val[count]=1*$c
            sum+=1*$c
            sumsq+=1*$c*$c
        }END{
            mean=sum/count
            sd=sqrt(sumsq/count - (mean)**2)
            if (m=="median") {
                # compute median
                if (count % 2 == 0) {
                    md=(val[count/2]+val[count/2+1])/2
                } else {
                    md=val[(count+1)/2]
                }
                printf("%f %f\n", md, sd)
            } else {
                printf("%f %f\n", mean, sd)
            }
        }'
}

_stat2 () {
    # return median,stddev from values of given column in data file
    # note: requires external program sta (https://github.com/simonccarter/sta)
    local fname=${1:-"-"}
    local col=${2:-"1"}
    cat $fname | grep -v "^#" | grep "[0-9]" | awk -v c=$col '{print 1*$c}' | sta --brief --median --sd
}

kappasigma () {
    # statistics (mean/stddev) after kappa-sigma-clipping
    local verbose
    local showhelp
    local do_nonzero    # if set any data values <=0 are rejected
    local do_print_n    # if set append number of valid data points
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-v" && verbose=1 && shift 1
        test "$1" == "-p" && do_nonzero=1 && shift 1
        test "$1" == "-n" && do_print_n=1 && shift 1
    done
    local fname=${1:-"-"}
    local col=${2:-"1"}
    local kappa=${3:-"3.5"}
    local iter=${4:-"4"}
    local md
    local sd
    local n
    local n2
    local tmp1=$(mktemp "/tmp/tmp_dat1_$$.XXXXXX")
    local tmp2=$(mktemp "/tmp/tmp_dat2_$$.XXXXXX")

    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: kappasigma [-p(ositiv)] [-n(umber)] <dat> [col|$col] [kappa|$kappa] [iter|$iter]" >&2 &&
        return 1
    
    grep -v "^#" $fname | grep "[0-9]" | awk -v c=$col -v z=${do_nonzero:-0} '{
        x=1*$c; if ((x>0) || (z==0)) print x}' | \
        sort -n > $tmp1
    n=$(cat $tmp1 | wc -l)
    test $n -lt 5 && iter=1
    test $n -lt 3 &&
        echo "ERROR: too few data samples (n<3)." >&2 && return 255
    cp $tmp1 $tmp2
    for i in $(seq 1 $iter)
    do
        set - $(normstat $tmp2)
        n1=$(cat $tmp2 | wc -l)
        md=$1
        sd=$2
        cat $tmp1 | awk -v md=$md -v sd=$sd -v k=$kappa 'BEGIN{low=md-k*sd; high=md+k*sd}{
            if (sd>0) {
                if (($1>=low) && ($1<=high)) printf("%s\n", $1)
            } else {
                printf("%s\n", $1)
            }
        }' > $tmp2
        n2=$(cat $tmp2 | wc -l)
        test "$verbose" &&
            printf "# i=%d  md=%.1f sd=%.1f  skip=%d\n" $i $md $sd $((n-n2)) >&2
        test $n2 -lt 4 &&
            echo "ERROR: too few data samples (n2<3)." >&2 && return 255
        test $n2 -eq $n1 && break
    done
    if [ "$do_print_n" ]
    then
        echo $(_stat -m $tmp2) $n2
    else
        _stat -m $tmp2
    fi
    rm $tmp1 $tmp2
}


#------------------------------------------
#   conversion functions for object lists
#------------------------------------------

roi2geom () {
    # convert ROI's from ImageJ measurements file into list of geometry specs
    # columns Label BX BY Width Height must be present
    local mfile="$1"
    local cl
    local cx
    local cy
    local cw
    local ch
    local tmp1=$(mktemp "/tmp/tmp_roi_$$.XXXXXX")
    # find column index of BX BY Width Height
    head -1 $mfile | tr ' \t' '\n' | grep -v "^$" > $tmp1
    cl=$(grep -nw "Label" $tmp1 | cut -d ":" -f1)
    test -z "$cl" &&
        echo "roi2geom: ERROR: column Label not found." >&2 && return 255
    cl=$(($cl + 1))
    cx=$(grep -nw "BX" $tmp1 | cut -d ":" -f1)
    test -z "$cx" &&
        echo "roi2geom: ERROR: column BX not found." >&2 && return 255
    cx=$(($cx + 1))
    cy=$(grep -nw "BY" $tmp1 | cut -d ":" -f1)
    test -z "$cy" &&
        echo "roi2geom: ERROR: column BY not found." >&2 && return 255
    cy=$(($cy + 1))
    cw=$(grep -nw "Width" $tmp1 | cut -d ":" -f1)
    test -z "$cw" &&
        echo "roi2geom: ERROR: column Width not found." >&2 && return 255
    cw=$(($cw + 1))
    ch=$(grep -nw "Height" $tmp1 | cut -d ":" -f1)
    test -z "$ch" &&
        echo "roi2geom: ERROR: column Height not found." >&2 && return 255
    ch=$(($ch + 1))
    #echo "  cx=$cx  cy=$cy  cw=$cw  ch=$ch" >&2
    
    # extract ROI's, make geom unique, sort in x
    cat $mfile | awk -v cl=$cl -v cx=$cx -v cy=$cy -v cw=$cw -v ch=$ch '{
        if (NR>1) {
            printf("%s %s\n", $cl, $cw"x"$ch"+"$cx"+"$cy)
        }
    }' | tr ':' ' ' | cut -d ' ' -f4 | sort -t "+" -n -k 2,2 -u

    rm $tmp1
}

# dump contents of ImageJ binary ROI file
# ref: imagej-1.47c/ij/io/RoiDecoder.java
#      http://dylan-muir.com/resources/code/ReadImageJROI.m
# note: converting decimal to hex in bash: printf "%02X\n" 10
roi2xy () {
    local roi=$1
    local hdr
    local type=""
    local ncoo=0
    
    hdr=$(hexdump -v -e '/1 "%02X" ""' 0001-0563-1521.roi -n 64 $roi)
    test "${hdr:0:8}" != "496F7574" &&
        echo "ERROR: this is not a valid ImageJ ROI file." >&2 && return 255
    version=$((16#${hdr:8:4}))
    roitype=$((16#${hdr:12:2}))
    top=$((16#${hdr:16:4}))
    left=$((16#${hdr:20:4}))
    bottom=$((16#${hdr:24:4}))
    right=$((16#${hdr:28:4}))
    ncoo=$((16#${hdr:32:4}))
    subtype=$((16#${hdr:96:4}))
    options=$((16#${hdr:100:4}))
    
    case $roitype in
        0)  type="polygon";;
        1)  type="rect";;
        2)  type="oval";;
        3)  type="line";;
        4)  type="freeline";;
        5)  type="polyline";;
        6)  type="noRoi";;
        7)  type="freehand";;
        8)  type="traced";;
        9)  type="angle";;
        10)  type="point";;
    esac
    echo "type=$type  bounds=$top $left $bottom $right  ncoo=$ncoo"
    echo "subtype=$subtype  options=$options"
    
    # data, starting at byte 64
    #   x ncoo int16, y ncoo int16
    # if subpixel==1 (options 128) then additionally
    #   xf ncoo float32, xf ncoo float 32
}

# merge png into hotpixel text file (write to stdout)
merge_hotpix () {
    local newpng=$1
    local olddat=$2
    local tdir=${$AI_TMPDIR:-"/tmp"}
    local tmpdat1=$(mktemp $tdir/tmp_dat1_XXXXXX.dat)
    local tmpdat2=$(mktemp $tdir/tmp_dat2_XXXXXX.dat)
    local tmpnew=$(mktemp $tdir/tmp_new_XXXXXX.dat)
    
    test $# -ne 2 &&
        echo "usage: merge_hotpix <newpng> <oldhotpixdat>" >&2 && return 255
    
    AIval -a -c -1 $newpng | awk '{print $1" " $2}' | sort -n > $tmpdat1
    cat $olddat | awk '{print $1" " $2}' | sort -n > $tmpdat2
    comm -23 $tmpdat1 $tmpdat2 > $tmpnew
    cat $olddat
    cat $tmpnew | awk -v d=$day '{printf("%4d %4d 1 # %s\n", $1, $2, d)}'
}

# get telescope identifiers from iTelescope log files
get_itel_telid () {
    local showhelp
    local i
    for i in 1
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    done
    logfiles="$@"

    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: get_itel_telid file1 [file2] ..." >&2 &&
        return 1

    false && cat $logfiles | grep "Telescope .* ACP" | tr '\->' ' ' | \
        awk '{print $6}' | tr -d ',' | sort -u
    cat $logfiles | grep -E "Telescope is ACP|Image File Saved to|Imaging to" | tr '\->' ' ' | \
        awk '{
            if ($3=="Telescope") {
                if ($7~/^T[0-9][0-9]/) {id=$7} else if ($6~/^T[0-9][0-9]/) {id=$6}
            }
            if ($3=="Image" && $7!="p") id=$7
            sub(",","",id)
            if ($3=="Imaging" && $5~/^T/) id=$5
            if (id != lastid) print id
            lastid=id
        }' | sort -u
}

# convert observations log file from iTelescope.net into tabular observations
# data file or display commands for linking files from subdirectory zip
itel2obs () {
    local showhelp
    local loglevel=0    # 1 - add focus log info to output
                        # 2 - add even more log info to output
    local linkmode=0    # 1 - show commands for linking files from subdirectory zip
                        # 2 - use calibrated images for linking
    local use_filenames # if set the get file names from directory 'zip' instead
                        # of evaluating the log files
    local n=1           # start file numbering at n
    local pdir="$HOME/obsplan/itel" # directory with observations plan text files
    local i
    for i in 1 2 3 4 5 6
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-v" && loglevel=$((loglevel + 1)) && shift 1
        test "$1" == "-l" && linkmode=1 && shift 1
        test "$1" == "-c" && linkmode=2 && shift 1
        test "$1" == "-f" && use_filenames=1 && shift 1
        test "$1" == "-n" && n=$2 && shift 2
    done
    local logdir=${1:-$AI_RAWDIR}
    local filter
    local tellist
    local tel
    local logfiles
    local cadd=9000
    local tmp1=$(mktemp "/tmp/tmp_tmp1_$$.XXXXXX.txt")
    local d

    (test "$showhelp" || test $# -gt 1) &&
        echo -e "usage: itel2obs [-f|-a|-l|-c] [logdir|$logdir]" >&2 &&
        return 1
    test $linkmode -gt 0 && loglevel=0
    
    # date
    if [ $linkmode -eq 0 ]
    then
        d=$(basename $logdir | tr -d '[a-z]')
        echo
        echo "#" $d
    fi
    
    #tellist=$(cat $logdir/2* | grep -i "saved to" | awk '{print $NF}' |  \
    #    grep -i "^T" | cut -d "-" -f1 | sort -u)
    tellist=$(get_itel_telid $logdir/[2T]*{txt,log} 2>/dev/null)
    test -z "$tellist" &&
        echo "ERROR: no exposures in log files." >&2 && return 255

    filter="starting run|Telescope|script|autofocus|focus position|defocus|express"
    filter="$filter|temperature|hfd =|saved to"
    # workaround for T10/T68 which has no "saved to" log message
    filter="$filter|imaging to t10|imaging to t68"

    for tel in $tellist
    do
        #for logfile in $(grep -il "saved to $tel-" $logdir/2*)
        for logfile in $(ls $logdir/[2T]*{txt,log} 2>/dev/null)
        do
            test "$(get_itel_telid $logfile | lines 1)" != "$tel" && continue
            test $linkmode -ne 0 && echo "# $tel $logfile" >&2
            test $linkmode -eq 0 && echo "# $tel $logfile"
            grep -iE "$filter" $logfile | \
                grep -viE "slew|no focus|binning|exposure|p-Focus" | \
                grep -viE "Camera temperature in range" | \
                grep -viE "Focus position count is within typical range" | \
                grep -viE "Focus position count is out of typical focus range"
        done
    done > $tmp1
    test $linkmode -eq 0 && echo "#" $tellist
    
    # column header
    if [ $linkmode -eq 0 ]
    then
        echo
        echo "# LT"
        echo "# h:m set  target type texp n1 n2   nref dark flat tel"
    fi
    
    cat $tmp1 | tr -d '\r' | \
    awk -v loglevel=$loglevel -v linkmode=$linkmode -v n=$n -v cadd=$cadd \
    'BEGIN{num=n-1; nplan=-1; focusinfo=""}{
        if ($0~/Starting run for plan/) {nplan++}
        if (($0~/Image File Saved to [Tt]/) ||
            ($0~/Imaging to [Tt]/) ||
            ($0~/Dark\/Bias File Saved to [Tt]/)) {
            if (focusinfo != "") {printf("# %s\n", focusinfo); focusinfo=""}
            split($NF,a,/-/)
            ta=a[3]         # target
            if (tolower(a[4])~/^exp/) {
                # old calibs
                gsub(/[a-zA-Z]/,"",a[4])
                t=1*a[4]    # exposure time
                f=a[10]     # filter
                b=a[9]      # bin
                s=a[8]; gsub(/[a-zA-Z]/,"",s)   # LT start
                temp="-"a[6]    # temperatur
                ty="d"
                ta=tolower(ta)
                gsub(/[a-zA-Z]/,"",b)
            } else if (length(a[4])<=4) {
                # calibs
                t=1*a[4]    # exposure time
                f=""        # filter
                b=a[7]      # bin
                s=a[6]; gsub(/[a-zA-Z]/,"",s)   # LT start
                temp=""     # temperatur
                ty="d"
                ta=tolower(ta)
                gsub(/[a-zA-Z]/,"",b)
            } else {
                # lights
                t=1*a[9]    # exposure time
                f=a[6]      # filter
                b=a[7]      # bin
                s=a[5]      # LT start
                temp=""     # temperature unknown
                ty="o"
                if (tolower(ta)=="cal" || (tolower(ta)=="dark")) {
                    ty="d"
                    if (t==0) {ta="bias"} else {ta="dark"}
                } else {
                    if (t==0) {ty="d"; ta="sky"}
                }
                gsub(/[a-zA-Z]/,"",b)
            }
            # convert start time string to HH:MM
            if (substr(s,5,2)<30) {
                s=substr(s,1,2)":"substr(s,3,2)
            } else {
                s=sprintf("%s:%02d", substr(s,1,2), substr(s,3,2)+1)
            }
            if (loglevel>0) {
                if (loglevel>1) print $0
                s="# "s
                printf("%s %s %04d\n", s, ta, num+1)
            }
            if (linkmode < 1) {
                if (tel=="") {
                    firstnum=num+1; tel=a[1]; target=ta; type=ty; texp=t; filter=f; bin=b; start=s
                    if (type=="d") {
                        set="dkxx"; nref="-   "
                        txt="-    -    "tel
                    } else {
                        set="coxx"; nref=0
                        txt="doxx mgxx "tel
                    }
                    if ((temp!="") || (filter!="") || (bin!="1")) {txt=txt" #"}
                    if (temp!="")   {txt=txt" "temp}
                    if (filter!="") {txt=txt" "filter}
                    if (bin!="1")   {txt=txt" bin"bin}
                } else {
                    # check if this image file belongs to a new set
                    if (a[1]!=tel || ta!=target || t!=texp || f!=filter || b!=bin ||
                        nplan>0) {
                        # new set found
                        nplan=0
                        if (type=="o") nref=sprintf("%04.0f", (firstnum+num)/2)
                        printf("%s %s %-8s %s %3d %04d %04d %s %s\n",
                            start, set, target, type, texp, firstnum, num, nref, txt)
                        firstnum=num+1; tel=a[1]; target=ta; type=ty; texp=t; filter=f; bin=b; start=s
                        if (type=="d") {
                            set="dkxx"; nref="-   "
                            txt="-    -    "tel
                        } else {
                            set="coxx"; nref=0
                            txt="doxx mgxx "tel
                        }
                        if ((temp!="") || (filter!="") || (bin!="1")) {txt=txt" #"}
                        if (temp!="") {txt=txt" "temp}
                        if (filter!="") {txt=txt" "filter}
                        if (bin!="1")   {txt=txt" bin"bin}
                    }
                }
            } else {
                zname=tolower($NF)".zip"
                n=num+1
                if (linkmode==2 && ty=="o") {
                    zname="calibrated-"tolower($NF)".zip"
                    n=num+cadd+1
                }
                printf("ln -s zip/%s %04d.fitzip\n", zname, n)
            }
            num++
        } else {
            if (loglevel>1) {
                print $0
            }
            if (loglevel>0 && tolower($0)~/starting run|express|focus|temperature|hfd/) {
                print $0
            }
            if (loglevel==0 && tolower($0)~/focus position|temperature|mean hfd/) {
                gsub(/^[0-9: ]*/,"")
                if (focusinfo != "") focusinfo=focusinfo"; "
                focusinfo=focusinfo""$0
            }
        }
    }END{
        if (linkmode == 0) {
            if (type=="o") nref=sprintf("%04.0f", (firstnum+num)/2)
            printf("%s %s %-8s %s %3d %04d %04d %s %s\n",
                start, set, target, type, texp, firstnum, num, nref, txt)
        }
    }'
    if [ $loglevel -eq 0 ] && [ $linkmode -eq 0 ]
    then
        printf "\n(" >&2
        grep "Starting run for plan" $tmp1 | tr -d '\r' | \
            sed -e 's|\.*$||' | awk -v pdir=$pdir '{
            printf("echo; echo; echo \"#### %s\"; cat %s/%s\n", $NF, pdir, $NF)}' >&2
        printf ") >> %s/obs.txt\n" $logdir >&2
        echo "vi $logdir/obs.txt" >&2
    fi
    test "$AI_DEBUG" && echo $tmp1
    test ! "$AI_DEBUG" && rm $tmp1
}


raw2obs () {
    # create obs data file from rawfiles.dat
    local showhelp
    local tzoff=0   # LT-UT
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-t" && tzoff=$2 && shift 2
    done
    local telid=${1:-"TLSC"}
    
    test "$showhelp" &&
        echo "usage: raw2obs [-t tzoff] [telid]" >&2 && return 255

    test -s rawfiles.dat && cat rawfiles.dat | \
        awk -v day="$day" -v toff=$tzoff -v tel="$telid" 'BEGIN{count=0}{
        if ($1~/^#/) next
        count++
        if (count==1) {
            # determine observatory provider
            obs="local"
            if (tolower($2)~/^[0-9][0-9][0-9]*-/ && tolower($2)~/.fts$/) {
                obs="SkyGems"
            } else if (tolower($2)~/^t[0-9]/ || tolower($2)~/^raw-/ || tolower($2)~/^calibrated-/) {
                obs="iTelescope"
            } else {
                obs="local"
            }
            # print header lines
            if (day) printf("# %s\n", day)
            if (obs != "local") printf("# %s\n", obs)
            printf("\n")
            if (toff == 0) {
                printf("# UT\n")
            } else {
                printf("# LT\n")
            }
            printf("# h:m set  target type texp n1 n2   nref dark flat tel\n")
        }
        # determine target
        target=""
        if(tolower($2)~/dark/ || tolower($2)~/bias/) {
            target="dark"
        }
        if(tolower($2)~/flat/ || tolower($2)~/sky/ || tolower($2)~/poly/) {
            target="flat"
        }
        if (target=="") {
            if (obs=="local") {
                split($2, a, /_/)
            } else {
                split($2, a, /-/)
            }
            if (obs=="local")      target=a[1]
            if (obs=="SkyGems")   {target=a[3]; sub(/_.*/,"",target)}
            if (obs=="iTelescope") target=a[4]
        }
        if (target != last || (target=="dark" && $4 != lasttexp)) {
            if (last) {
                printf("%s %s %-8s %s %3.0f %04d %04d %04d %-4s %-4s %s\n",
                    utstart, sname, last, type, texp, n1, n2, (n1+n2)/2, dark, flat, tel)
            }
            n1=1*$1
            h=1*substr($3,1,2)+toff; m=1*substr($3,4,2); s=1*substr($3,7,2)
            if (s > 30) m=m+1
            if (m == 60) {h=h+1; m=0}
            if (h >= 24) h=h-24
            utstart=sprintf("%02d:%02d", h, m)
            texp=$4
            sname="coxx"
            type="o"
            dark="dkxx"
            flat="skxx"
            # determine image type
            if(tolower($2)~/dark/ || tolower($2)~/bias/) {
                sname="dkxx"; target="dark"; type="d"; dark="-   "; flat="-   "
            }
            if(tolower($2)~/flat/ || tolower($2)~/sky/ || tolower($2)~/poly/) {
                sname="skxx"; target="flat"; type="f"; flat="-   "
            }
        }
        n2=1*$1
        lasttexp=texp
        last=target
    }END{
                printf("%s %s %-8s %s %3.0f %04d %04d %04d %-4s %-4s %s\n",
                    utstart, sname, target, type, texp, n1, n2, (n1+n2)/2, dark, flat, tel)
    }'
}


map_rawfiles () {
    # create mapping of image number to file name for new raw (FITS) images
    #   note: spaces in file name are converted to "_"
    #   output to stdout: num fname tstart texp jd w h temp
    #   output might be written to rawfiles.dat
    local showhelp
    local time_from_log # extract start time from log file ("starting exposure")
    local verbose
    local skip_existing # if set, skip images which already have an entry in rdat
    local firstnum
    local i
    for i in 1 2 3 4 5
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-x" && skip_existing=1 && shift 1
        test "$1" == "-n" && firstnum=$2 && shift 2
        test "$1" == "-l" && time_from_log=1 && shift 1
        test "$1" == "-v" && verbose=1 && shift 1
    done
    local sdat=${AI_SETS:-"set.dat"}
    local rdat="rawfiles.dat"
    local edat="exif.dat"
    local x
    local cidx
    local nmax=0
    local tstart
    local texp
    local jd
    local w
    local h
    local f
    local b
    local d
    local temp
    local len=12
    local popts
    local tmpdat=$(mktemp "/tmp/tmp_data_XXXXXX.dat")
    
    local tmpsh=$(mktemp "/tmp/tmp_script_XXXXXX.sh")
    chmod u+x $tmpsh

    test "$showhelp" &&
        echo "usage: map_rawfiles [-v] [-n firstnum] [-l] [-x] file1 [file2] ..." >&2 &&
        return 1

    if [ "$firstnum" ]
    then
        nmax=$((firstnum - 1))
    else
        # get max number in use by $rdat, $edat and in $AI_RAWDIR
        if [ "$AI_RAWDIR" ] && [ -d $AI_RAWDIR ]
        then
            x=$(ls $AI_RAWDIR/[0-9][0-9][0-9][0-9].* 2>/dev/null | grep -v "^0000" | \
                sort | tail -1 | cut -d "." -f1)
            test "$x" && test "$x" \> "$nmax" && nmax=$x
            test "$verbose" && echo "# AI_RAWDIR: x=$x nmax=$nmax" >&2
        fi
        i=0
        for f in "$edat" "$rdat"
        do
            i=$((i+1))
            test "$verbose" && echo "# f=$f" >&2
            test ! -e $f && continue
            case $i in
                1)  cidx=2;;
                2)  cidx=1;;
            esac

            x=$(grep -v "^#" $f | awk -v i=$cidx '{if($i~/^[0-9]{4}$/) {printf("%s\n", $i)}}' | \
                sort | tail -1)
            test "$x" && test "$x" \> "$nmax" && nmax=$x
            test "$verbose" && echo "# $(basename $f): x=$x nmax=$nmax" >&2
        done
    fi

    # extract very basic file information: fname tstart texp jd w h temp
    #   sort images according to JD
    #   spaces in file name are replaced by "_"
    cat <<EOF > $tmpsh
#!/bin/bash
. airfun.sh > /dev/null
skip_existing=$skip_existing
time_from_log=$time_from_log
rdat=$rdat

_info_parallel \$@
EOF

    _info_parallel () {
        local f="$1"
        local tmphdr=$(mktemp "/tmp/tmp_header_XXXXXX.txt")

        test "$verbose" && echo "# $f" >&2
        test ! -e "$f" && return
        b=$(basename "$f" | tr ' ' '_')
        d=$(dirname "$f" | sed -e 's,^'$AI_RAWDIR',,' | sed -e 's,^/,,')
        test "$d" && d="$d/"
        test "$skip_existing" && test -e "$rdat" &&
            grep -q "^[0-9][0-9][0-9][0-9] $d$b " $rdat &&
            echo "# file $b exists" && return
        if is_fits "$f" || is_fitzip "$f" || is_fitsgz "$f"
        then
            get_header "$f" all > $tmphdr
        else
            echo "WARNING: $f has unsupported file type." >&2
            false
        fi
        test $? -ne 0 && return

        # get image size
        w=$(grep    "^NAXIS1  =" $tmphdr | lines 1 | cut -d "=" -f2 | awk '{printf("%d", $1)}')
        h=$(grep    "^NAXIS2  =" $tmphdr | lines 1 | cut -d "=" -f2 | awk '{printf("%d", $1)}')
        (test -z "$w" || test -z "$h") &&
            echo "ERROR: missing NAXIS[12]." >&2 && return

        # determine JD, tstart
        if [ "$time_from_log" ]
        then
            x=$(echo $f | tr '-' '\n' | tr -d '[A-Z]' | grep -E "[0-9]{8,8}")
            tstart=$(grep -iE "imaging to|starting exposure" \
                $AI_RAWDIR/[2T]*{log,txt} 2>/dev/null | \
                tr -d '\r' | sed -e 's,[[:alnum:]/_.\-]*:,,' | awk -v f=$f '{
                    if (f ~ $NF) {
                        found=1
                    } else {
                        if (found == 1) {
                            printf("%s", $1)
                            found=""
                        }
                    }
                }')
            test -z "$tstart" && tstart=$(grep -iE "image file saved to|starting exposure" \
                $AI_RAWDIR/[2T]*{log,txt} 2>/dev/null | \
                tr -d '\r' | sed -e 's,[[:alnum:]/_.\-]*:,,' | awk -v f=$f '{
                    if (f ~ $NF) printf("%s", last)
                    last=$1
                }')
            jd=$(ut2jd $tstart $x)
            #echo "$x $tstart" >&2
        else
            jd=$(get_jd -q "$f")
            test "$jd" && test ${jd%.*} -eq 2440587 &&
                echo "WARNING: implausible JD in $(basename "$f")" >&2 && jd=""
            if [ -z "$jd" ]
            then
                echo "WARNING: missing JD in $(basename "$f")" >&2
                # using file timestamp as fallback
                x=$(stat --format="%Y" "$f")
                jd=$(ut2jd $(date --date="@$x" -u +"%H:%M:%S %Y%m%d"))
            fi
            # determine tstart
            x=$(grep    "^DATE-OBS=" $tmphdr | lines 1 | cut -d "=" -f2 | cut -d "'" -f2)
            test "$x" && tstart=$(echo $x | cut -d "T" -f2 | sed -e 's,\..*,,')
            test -z "$x" && tstart="-"
        fi
        # get texp
        texp=$(grep "^EXPTIME =" $tmphdr | lines 1 | cut -d "=" -f2 | awk '{printf("%.1f", 1*$1)}')
        test -z "$texp" &&
            texp=$(grep "^EXPOSURE=" $tmphdr | lines 1 | cut -d "=" -f2 | awk '{printf("%.1f", 1*$1)}')
        test -z "$texp" && texp="-1"
        # get ccd temp
        temp=$(get_header -q $tmphdr CCD-TEMP | awk '{printf("%.0f", 1*$1)}')
        test -z "$temp" && temp="-"
        echo $d$b $tstart $texp $jd $w $h $temp
    }

    export -f _info_parallel
    popts=""; test "$AI_MAXPROCS" && popts="-P $AI_MAXPROCS"
    for f in "$@"
    do
        echo $f
    done | parallel $popts -k $tmpsh | sort -n -k4,4 > $tmpdat
    unset -f _info_parallel
    
    test "$AI_DEBUG" && echo "# tmpdat=$tmpdat" >&2
    test ! -s $tmpdat &&
        echo "ERROR: no raw images found." >&2 &&
        return 255
    ! grep -q -v "^#" $tmpdat &&
        echo "WARNING: no new raw images found." >&2 &&
        return 0
    
    # length of file name
    x=$(grep -v "^#" $tmpdat | awk '{print 1+length($1)}' | sort -n | tail -1)
    test $x -gt $len && len=$x

    # output image number and file info
    i=$((10#$nmax))
    while read
    do
        test "$verbose" && echo "# $REPLY" >&2
        test "${REPLY:0:1}" == "#" && continue
        i=$((i+1))
        # fields are: fname tstart texp jd w h temp
        printf "%04d %-"$len"s %8s %6.1f %.5f %4d %4d %s\n" $i $REPLY
    done < $tmpdat
    
    test "$AI_DEBUG" && echo $tmpdat $tmpsh
    test -z "$AI_DEBUG" && rm -f $tmpdat $tmpsh
    return 0
}


# starter function used for comet observations
AIstart () {
    # check headers of comet observations required by
    # airtools tasks psfextract,cometphot,photcal
    # TODO: AI_SITE should be read from image header
    local showhelp
    local accept_mjd    # accept keyword MJD_OBS if JD is missing
    local is_centered   # if set then comet locates near center
    local single_image  # if set then deal with missing costack
    local jd_data       # optional text file providing JD of all individual images
                        # (first field: image number, second field: JD)
    local do_flip       # flip images top-bottom
    local no_gui        # if set, interactive gui (AIexamine) is not started
    local keylist       # header keywords to add using set_header
    local i
    for i in $(seq 1 20)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-m" && accept_mjd=1 && shift 1
        test "$1" == "-c" && is_centered=1 && shift 1
        test "$1" == "-s" && single_image=1 && shift 1
        test "$1" == "-j" && jd_data=$2 && shift 2
        test "$1" == "-f" && do_flip=1 && shift 1
        test "$1" == "-n" && no_gui=1 && shift 1
        test "$1" == "-k" && keylist="$keylist $2" && echo "$2" >&2 && shift 2
    done
    local sname=$1
    local ststack=${2:-""}  # image name of star centered stack
    local costack=${3:-""}  # image name of comet centered stack
    local sdat=${AI_SETS:-"set.dat"}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpim=$(mktemp $tdir/tmp_im_$$.XXXXXX.pnm)
    local tmpfits=$(mktemp $tdir/tmp_im_$$.XXXXXX.fits)
    local tmpdat=$(mktemp $tdir/tmp_data_$$.XXXXXX.dat)
    local orighdr=$(mktemp $tdir/tmp_orig_$$.XXXXXX.head)
    local camdat="camera.dat"
    local sitesdat="sites.dat"
    local ext
    local hdr
    local whdr
    local x
    local str
    local line
    local err
    local object
    local texp
    local nexp
    local has_wcs
    local has_mpcephem
    local tlen
    local tpa
    local tref
    local ra
    local dec

    (test "$showhelp" || test $# -lt 1) &&
        echo -e "usage: AIstart [-c] [-f] [-s] [-j jd_datafile] [-k keylist] <setname> [starstack] [cometstack]" >&2 &&
        return 1
    
    # check set.dat
    test ! -e $sdat &&
        echo "ERROR: missing observations data file $sdat" >&2 && return 255
    ! is_setname $sname &&
        echo "ERROR: entry for set $sname in $sdat is missing (or incomplete)" >&2 && return 255
    # check files
    for x in $camdat $sitesdat $jd_data "$ststack" "$costack"
    do
        test -z "$x" && continue
        test ! -e "$x" && echo "ERROR: missing file \"$x\"" >&2 && return 255
    done
    

    # check for image files related to set
    if [ -e $sname.ppm ]
    then
        ext=ppm
        ststack=$sname.ppm
        echo "reusing star stack image $ststack" >&2
    else
        if [ -e $sname.pgm ]
        then
            ext=pgm
            ststack=$sname.pgm
            echo "reusing star stack image $ststack" >&2
        fi
    fi
    if [ "$ext" ]
    then
        test -e ${sname}_m.$ext && costack=${sname}_m.$ext &&
            echo "reusing comet stack image $costack" >&2
    else
        if [ -e ${sname}_m.ppm ]
        then
            costack=${sname}_m.ppm
            echo "reusing comet stack image $costack" >&2
        else
            test -e ${sname}_m.pgm && costack=${sname}_m.pgm &&
                echo "reusing comet stack image $costack" >&2
        fi
    fi
    test -z "$ststack" &&
        echo "ERROR: missing star stack (2nd parameter)" >&2 && return 255
    test -z "$costack" && test ! "$single_image" &&
        echo "ERROR: missing comet stack (3rd parameter)" >&2 && return 255


    # check input image format
    test "$ststack" && ! is_pnm "$ststack" && ! is_fits "$ststack" &&
        echo "ERROR: \"$ststack\" has unsupported image format" >&2 && return 255
    test "$costack" && ! is_pnm "$costack" && ! is_fits "$costack" &&
        echo "ERROR: \"$costack\" has unsupported image format" >&2 && return 255
    

    # check for identical image size
    if [ "$ststack" ] && [ "$costack" ] && [ "$ststack" != "$costack" ]
    then
        x=$(imsize "$ststack")
        test "$(imsize "$ststack")" != "$(imsize "$costack")" &&
            echo "ERROR: stacks have different dimensions" >&2 && return 255
    fi

    
    # convert stacked images if they are in FITS format
    hdr=$sname.head
    if ! is_pnm "$ststack"
    then
        echo "Converting \"$ststack\" ..." >&2
        x=$(datarange "$ststack")
        test $? -ne 0 &&
            echo "ERROR: cannot determine data range of \"$ststack\"" >&2 && return 255
        echo "# min/median/max: $x" >&2
        set - $(echo $x)
        test ${3%.*} -gt 70000 &&
            echo "WARNING: max. intensity exceeds 16bit range" >&2
        test ${3%.*} -lt 1000 &&
            echo "WARNING: dynamic range is very low" >&2
        test ${2%.*} -gt 60000 &&
            echo "ERROR: median intensity above limit" >&2 && return 255
        test ${2%.*} -le 2 &&
            echo "ERROR: median intensity below limit" >&2 && return 255
        test ${2%.*} -gt 30000 &&
            echo "WARNING: median intensity is surprisingly high" >&2

        test -z "$do_flip" && meftopnm "$ststack" > $tmpim
        test    "$do_flip" && meftopnm "$ststack" | pnmflip -tb > $tmpim
        ! is_pgm $tmpim && ! is_ppm $tmpim &&
            echo "ERROR: unable to convert \"$ststack\"" >&2 && return 255
        if [ -e $hdr ]
        then
            echo "reusing header file $hdr" >&2
        else
            meftopnm -a "$ststack" > $hdr
        fi
        is_pgm $tmpim && mv $tmpim $sname.pgm && ststack=$sname.pgm
        is_ppm $tmpim && mv $tmpim $sname.ppm && ststack=$sname.ppm
    fi
    test "$costack" && if ! is_pnm "$costack"
    then
        echo "Converting \"$costack\" ..." >&2
        x=$(datarange "$costack")
        test $? -ne 0 &&
            echo "ERROR: cannot determine data range of \"$costack\"" >&2 && return 255
        echo "# min/median/max: $x" >&2
        set - $(echo $x)
        test ${3%.*} -gt 70000 &&
            echo "WARNING: max. intensity exceeds 16bit range" >&2
        test ${3%.*} -lt 1000 &&
            echo "WARNING: dynamic range is very low" >&2
        test ${2%.*} -gt 60000 &&
            echo "ERROR: median intensity above limit" >&2 && return 255
        test ${2%.*} -le 2 &&
            echo "ERROR: median intensity below limit" >&2 && return 255
        test ${2%.*} -gt 30000 &&
            echo "WARNING: median intensity is surprisingly high" >&2

        test -z "$do_flip" && meftopnm "$costack" > $tmpim
        test    "$do_flip" && meftopnm "$costack" | pnmflip -tb > $tmpim
        ! is_pgm $tmpim && ! is_ppm $tmpim &&
            echo "ERROR: unable to convert \"$costack\"" >&2 && return 255
        is_pgm $tmpim && mv $tmpim ${sname}_m.pgm && costack=${sname}_m.pgm
        is_ppm $tmpim && mv $tmpim ${sname}_m.ppm && costack=${sname}_m.ppm
    fi
    test ! -e "$ststack" && echo "WARNING: no star stack" >&2
    test ! -e "$costack" && echo "WARNING: no comet stack" >&2
    test ! -e $hdr && echo "ERROR: missing header file $hdr" >&2 && return 255
    cp -p $hdr $orighdr
    test -e "$costack" && test ! -e ${sname}_m.head &&
        ln -s $hdr ${sname}_m.head
    whdr=$hdr
    test -e $sname.wcs.head && whdr=$sname.wcs.head


    #----------------------------
    # checking basic keywords
    #----------------------------
    # add header keywords if requested
    test "$keylist" && set_header $hdr $keylist

    # check mean JD (middle of exposures)
    if [ "$accept_mjd" ]
    then
        x=$(get_jd -q -k "JD,DATE-OBS,MJD_OBS" $hdr)
    else
        x=$(get_jd -q -k "JD,DATE-OBS" $hdr)
    fi
    if [ -z "$x" ]
    then
        # try to get mean JD from jd_data
        test "$jd_data" && test -e "$jd_data" && x=$(mean $jd_data 2)
        if [ -z "$x" ] && [ -e exif.dat ] && [ -e reg.dat ]
        then
            get_jd_dmag $sname > $tmpdat
            test $? -eq 0 && test -s $tmpdat && x=$(mean $tmpdat 2)
        fi
    fi
    test "$x" && set_header $hdr JD=$x
    test -z "$x" && err="$err JD" &&
        echo "ERROR: keyword JD (or DATE-OBS) is missing" >&2

    # use entry of the given set in set.dat for the following keywords
    line=$(grep -v "^#" $sdat | sed -e 's|#.*||' | \
        awk -v s=$sname '{if($2==s && $4=="o") {print $0}}')

    # number of images
    nexp=$(grep -v "^#" $sdat | awk -v s=$sname -v ex="$AI_EXCLUDE" '{
        if($2==s && ($4=="o" || $4=="a")) {
            for (i=$6; i<=$7; i++) {
                num=sprintf("%04d", i)
                if (index(ex, num) == 0) printf("%s\n", num)
            }}}' | sort -u | wc -l)
    set_header $hdr NEXP="$nexp/Number of exposures"
    
    # cumulative exposure time
    str=$(get_header -q $hdr EXPTIME | awk '{printf("%.2f", $1*1)}')
    x=$(echo $nexp $line | awk '{printf("%.2f", $1*$6)}')
    test "$str" && test "$str" != "$x" &&
        echo "# modifying EXPTIME from $str to $x" >&2
    set_header $hdr EXPTIME="$x/Total exposure time in seconds"

    # get object from entry in $sdat
    object=$(get_header -q $hdr OBJECT)
    x=$(echo $line | cut -d " " -f3)
    if [ "$object" != "$x" ]
    then
        test "$object" &&
            echo "# modifying OBJECT from $object to $x" >&2
        object=$x
        set_header $hdr OBJECT=$x
    fi
    
    # store AI_SITE
    x=$(get_header -q $hdr AI_SITE)
    test -z "$x" && x=$AI_SITE
    test -z "$x" && err="$err AI_SITE" &&
        echo "ERROR: AI_SITE is undefined" >&2
    set_header $hdr AI_SITE="$AI_SITE/Observatory site"

    # get telescope from entry in $sdat
    # TODO: maybe accept AI_TELESCOPE in first place
    x=$(echo $line | cut -d " " -f11)
    test "$x" && set_header $hdr AI_TELID="$x/Instrument identifier"
    test -z "$x" && x=$(get_header -q $hdr AI_TELID)
    if [ "$x" ]
    then
        ! grep -q -w "^$x" $camdat && err="$err AI_TELID" &&
            echo "ERROR: AI_TELID=$x does not exist in $camdat" >&2
    else
        err="$err AI_TELID"
        echo "ERROR: keyword AI_TELID is missing" >&2
    fi

    # add AI_COMST header keyword
    x=$(get_header -q $hdr AI_COMST)
    test -z "$x" && test "$costack" &&
        set_header $hdr AI_COMST="$costack/Comet stack image file name"

    # abort program if basic header information is missing
    test "$err" &&
        echo "ABORTING $FUNCNAME due to missing image header keywords." >&2 &&
        return 255
    
    
    #------------------------------
    # image center and orientation
    #------------------------------
    # adding comet ephemerides
    x=$(get_header -q $hdr AI_CORA,AI_CODEC,AI_OMOVE | wc -l)
    if [ $x -eq 3 ]
    then
        has_mpcephem=1
        echo "# Found comet ephemerides keywords (AI_CORA,AI_CODEC,AI_OMOVE)." >&2
    else
        get_mpcephem -w $sname > /dev/null
        if [ $? -eq 0 ]
        then
            has_mpcephem=1
            echo "# Comet ephemerides keywords added" >&2
            get_jplcoord -w $sname > /dev/null
        else
            echo "ABORTING $FUNCNAME due to failure in get_mpcephem $sname." >&2 &&
            return 255
        fi
    fi

    # check image coordinates
    ra=$(get_header -q $hdr RA)
    test -z "$ra" && ra=$(get_header -q $hdr OBJCTRA)
    test -z "$ra" && test "$is_centered" && ra=$(get_header -q $hdr AI_CORA)
    dec=$(get_header -q $hdr DEC)
    test -z "$dec" && dec=$(get_header -q $hdr OBJCTDEC)
    test -z "$dec" && test "$is_centered" && dec=$(get_header -q $hdr AI_CODEC)
    
    test -z "$ra" && err="$err RA"
    test -z "$dec" && err="$err DEC"
    (test -z "$ra" || test -z "$dec") &&
        echo "ERROR: missing approximate image center coordinates (RA, DEC)" >&2
    (test -z "$ra" || test -z "$dec") && ! test "$is_centered" &&
        echo "       (if comet is near image center then rerun AIstart using -c switch)" >&2

    # TODO: get image center from wcs calibrated images

    
    #----------------------------
    # comet position
    #----------------------------
    is_wcs $whdr && has_wcs=1
    x=$(get_header -q $hdr AI_OXY)
    if [ "$x" ]
    then
        # TODO: check correct format of AI_OXY
        echo "# Found image pixel coordinates of comet (AI_OXY)." >&2
    else
        # try to estimate AI_OXY
        test "$has_mpcephem" && test "$has_wcs" &&
            x=$(echo comet $(get_header -s $hdr AI_CORA,AI_CODEC) | \
                rade2xy - $whdr | awk '{printf("%.0f,%.0f", $2, $3)}')
        if [ -z "$x" ]
        then
            if [ "$has_wcs" ] || [ -z "$has_mpcephem" ]
            then
                err="$err AI_OXY"
                echo "ERROR: unable to determine image pixel coordinates of the comet (AI_OXY)." >&2
            fi
        fi                
    fi
    

    #----------------------------
    # comet trail information
    #----------------------------
    str=$(get_header -q $hdr AI_TRAIL)
    if [ "$str" ]
    then
        x=$(echo $str | tr ',' ' ' | wc -w)
        test $x -gt 0 && tlen=$(echo $str | cut -d "," -f1)
        test $x -gt 1 && tpa=$(echo $str | cut -d "," -f2)
        test $x -eq 3 && echo "# Using comet trail parameters (keyword AI_TRAIL)." >&2
        test $x -nq 3 && echo "# Using incomplete comet trail parameters (AI_TRAIL=$str)." >&2
    else
        if [ ! "$has_mpcephem" ]
        then
            err="$err AI_TRAIL"
            str="ERROR: unable to determine trail parameters.
                .    Please measure moving object trail length (in pixel) and angle
                .    (in degrees from right over top) and add keyword by using the
                .    command:   set_header $sname.head AI_TRAIL=length,angle"
            echo "$str" | sed -e 's|^[[:space:]]*\.||' >&2
        fi
    fi

    
    # restore file if contents has not changed
    echo ""
    if diff $orighdr $hdr > /dev/null
    then
        mv $orighdr $hdr
    else
        echo "Image header file $hdr has been modified." >&2
        test ! -e $sname.orig.head && mv $orighdr $sname.orig.head
    fi
    if [ "$err" ]
    then
        echo "Please fix errors by supplying missing header keywords." >&2
    else
        echo "All required keywords successfully validated." >&2
        if [ -z "$no_gui" ]
        then
            read -p "Do you want to start the AIRTOOLS graphical user interface now?  [Y/n]  " -r -n 1 answer
            echo
            answer=${answer,,}
            test -z "$answer" && answer=y
            if [ "$answer" == "y" ]
            then
                AIexamine $ststack $costack &
            else
                echo "To start the GUI later use: AIexamine $ststack $costack &" >&2
            fi
        fi
    fi
    echo
    
    rm -f $tmpim $tmpfits $tmpdat $orighdr
    echo $err
    test "$err" && return 255
    return 0
}


check_url () {
    # check if a given website is reachable
    local url=${1:-"http://www.google.com"}
    local tries=${2:-6}
    local delay=1
    local retval
    local i=1
    (test "$1" == "-h" || test $# -gt 2) &&
        echo "usage: check_url [url|$url] [trials|$tries]" >&2 &&
        return 1
    while [ $i -le $tries ]
    do
        if [ $i -gt 1 ]
        then
            test "$AI_DEBUG" && echo "# $i/$tries sleep $delay" >&2
            sleep $delay
            delay=$(echo $delay | awk '{
                x=1.5*$1; if(x>10){x=10}; printf("%.1f", x)}')
        fi
        wget -q --tries=2 --timeout=10 --spider $url
        retval=$?
        test $retval -eq 0 && break
        i=$((i+1))
    done
    test $retval -ne 0 && echo "ERROR: failed to connect to $url" >&2
    return $retval
}

click2mpcheck () {
    # convert click-position as given by jaicomp to data suitable for input
    # to MPChecker (http://scully.cfa.harvard.edu/cgi-bin/checkmp.cgi)
    local s=$1      # setname
    local rad=$2
    local ded=$3
    local nref
    local jd
    (test "$1" == "-h" || test $# -ne 3) &&
        echo "usage: click2mpcheck <setname> <rad> <ded>" >&2 &&
        return 1

    test -f $s.head &&
        jd=$(grep "^MJD_REF"  $s.head | awk '{printf("%.3f\n", $3)}')
    test -z "$jd" &&
        nref=$(grep "^[0-9].:.. $s " set.dat | awk '{printf("%s", $8)}') &&
        test -f $AI_RAWDIR/$nref.hdr &&
        jd=$(grep jdmid $AI_RAWDIR/$nref.hdr | cut -d '=' -f2)
    test -z "$jd" &&
        echo "ERROR: unknown jd." >&2 && return 255
    d=$(echo "scale=3; (${day:4} + 0.${jd#*.} + 0.5)/1" | bc -l)
    echo $jd $d
    ras=$(dec2sexa $rad 15 1 | tr ':' ' ')
    des=$(dec2sexa $ded 1 0 | tr ':' ' ')
    echo $ras " " $des
}

mpchecker () {
    local showhelp
    local ref=https://www.minorplanetcenter.net/cgi-bin/checkmp.cgi
    local url=https://www.minorplanetcenter.net/cgi-bin/mpcheck.cgi
    local utdate    # yyyy-mm-dd.dd
    local mlim
    local rad       # search radius in arcmin
    local do_outreg # if set than write objects to ds9 region file
    local i
    for i in 1 2 3 4
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-d" && utdate=$2 && shift 2
        test "$1" == "-m" && mlim=$2 && shift 2
        test "$1" == "-r" && rad=$2 && shift 2
        test "$1" == "-o" && do_outreg=1 && shift 1
    done
    
    local sname="$1"
    local ra="$2"
    local de="$3"

    local cameradat="camera.dat"
    local reg
    local ext
    local use_imgcenter
    local physical
    local jd
    local date
    local name
    local coord
    local x
    local n
    local str
    local args
    local args2
    local outreg
    local tmp1=$(mktemp "/tmp/tmp_tmp1_$$.XXXXXX.html")
    local tmp2=$(mktemp "/tmp/tmp_tmp2_$$.XXXXXX.dat")
    local tmpreg=$(mktemp "/tmp/tmp_reg_$$.XXXXXX.reg")
    local tmpxy=$(mktemp "/tmp/tmp_xy_$$.XXXXXX.dat")
    local tmprade=$(mktemp "/tmp/tmp_rade_$$.XXXXXX.dat")

    (test "$showhelp" || test $# -lt 1) &&
        echo -e "usage: mpchecker [-o] [-d yyyy-mm-dd.dd] [-m maglim] [-r rad_amin] <set> [<reg | ra de>]" >&2 &&
        return 1

    ! is_setname $sname &&
        echo "ERROR: $sname is not a valid set name" >&2 && return 255

    test "$do_outreg" && outreg=$sname.mpcast.reg
    if [ $# -lt 3 ]
    then
        ext=ppm
        test -s $sname.pgm && ext=pgm
        for x in $sname.$ext $sname.wcs.head
        do
            test ! -s $x && echo "ERROR: missing file $x." >&2 && return 255
        done
    else
        outreg=""
    fi
    
    # check for single argument (only set name)
    if [ -z "$ra" ]
    then
        use_imgcenter=1
        set - $(imcoord $sname)
        ra=$1; de=$2
    fi
     
    # check for region file (second parameter)
    test -f "$ra" && reg="$ra"
    test -z "$reg" && test -z "$de" &&
        echo -e "usage: mpchecker [-o] [-d yyyy-mm-dd.dd] [-m maglim] [-r rad_amin] <set> <reg | ra de>" >&2 &&
        return 1
    
    # number ob objects
    n=100
    test -s "$reg" && test $(grep "^circle(" $reg | wc -l) -gt 1 && n=1

    # date parameters
    if [ "$utdate" ]
    then
        date=$(echo $utdate | awk -F '-' '{printf("year=%d&month=%02d&day=%06.3f", $1,$2,$3)}')
    else
        jd=$(AIsetinfo -l $sname | awk '{printf("%s", $7)}')
        date=$(jd2ut $jd | awk -F '-' '{printf("year=%d&month=%02d&day=%06.3f", $1,$2,$3)}')
    fi
    
    # coordinates parameter
    if [ -z "$reg" ]
    then
        ra=$(dec2sexa $(sexa2dec $ra 1 7) 1 2 | tr -d "+-")
        de=$(dec2sexa $(sexa2dec $de 1 7) 1 1)
        test "$AI_DEBUG" && echo "# circle($ra,$de,10) # text={X}" >&2
        echo "circle($ra,$de,10) # text={X}" > $tmpreg
        reg=$tmpreg
    fi
    
    # determine maglim and search radius
    if [ -z "$mlim" ]
    then
        x=$(get_param camera.dat aperture $sname)
        mlim=15
        test $x -gt 15 && mlim=16
        test $x -gt 30 && mlim=17
        test $x -gt 50 && mlim=18
        test $x -gt 70 && mlim=19
        test $x -gt 100 && mlim=20
        test $x -gt 180 && mlim=21
        test $x -gt 280 && mlim=22
        str="maglim=$mlim"
    fi
    if [ -z "$rad" ]
    then
        if [ "$use_imgcenter" ]
        then
            rad=$(imsize -d $sname | awk '{printf("%.0f", 30*sqrt($1*$1+$2*$2))}')
        else
            x=$(exp10 $(echo "$mlim/10" | bc -l))
            rad=$(echo $x | awk '{
                x=500/$1
                if (x > 5) {
                    printf("%.0f", x)
                } else {
                    x=int(2*x+0.5)/2
                    printf("%.1f", x)
                }
            }')
        fi
        str="$str rad=$rad"
    fi
    test "$str" && echo "# using" $str >&2

    i=0
    grep -q "^physical" $reg && physical=1
    while read
    do
        #echo "# $REPLY"
        test "${REPLY:0:6}" != "circle" && continue
        if [ "$physical" ]
        then
            # image coordinates
            # convert from FITS coord to RA/DEC
            set - $(echo $REPLY | reg2xy $sname.$ext -)
            name="$1"
            set - $(echo $1 $2 $3 | xy2rade - $sname.wcs.head)
            echo "$@" >&2
            ra="$1"; de="$2"
            ra=$(dec2sexa $ra 15 2 | tr -d "+-")
            de=$(dec2sexa $de 1 1)
        else
            # wcs coordinates
            set - $(echo $REPLY | tr '(,){}' ' ')
            ra="$2"; de="$3"; name="$7"
            ra=$(dec2sexa $(sexa2dec $ra 1 7) 1 2 | tr -d "+-")
            de=$(dec2sexa $(sexa2dec $de 1 7) 1 1)
        fi
        coord="ra=${ra//:/+}&decl=${de//:/+}"
        #coord="ra=${ra}&decl=${de}"
        test "$AI_DEBUG" &&
            echo "date=$date   coord=$coord" >&2
        
        #POST /cgi-bin/cmtcheck.cgi year=2014&month=11&day=22.91&ra=03+49+01.6&decl=%2B21+50+10
        #&which=obs&TextArea=&radius=5&limit=18.0&oc=500&sort=d&mot=h&tmot=s&pdes=u&needed=f&ps=n&type=p

        args="${date}&which=pos&${coord}&TextArea=&radius=$rad&limit=$mlim"
        args2="oc=500&sort=d&mot=h&tmot=s&pdes=u&needed=f&ps=n&type=p"
        test "$AI_DEBUG" && echo "curl -s --referer $ref --data \"$args&${args2}\" $url" >&2
        
        curl -s --referer $ref --data "${args}&${args2}" -o $tmp1 $url
        test $? -ne 0 &&
            echo "ERROR: curl error."  && return 255
        grep -q "Incorrect Form Entry" $tmp1 &&
            echo "ERROR: incorrect web form entry, see $tmp1" >&2 && return 255
        grep -qi "Error" $tmp1 &&
            echo "ERROR: cgi error, see $tmp1" >&2 && return 255

        w3m -dump $tmp1 | awk '{
            if($0~/ Object designation /) {show=1; print "#" $0; next}
            if($0~/Explanatory Notes/) show=0
            if(show==1 && $0~/[0-9][0-9]/) {
                mag=substr($0,48,4)
                gsub(/^[ ]*/,"",mag)
                if (mag=="") mag=0
                print mag":"$0
            }}'
    done < $reg > $tmp2

    # sort by mag
    grep -v "^#" $tmp2 | LANG=C sort -n -t ':' -k1,1 -u | lines $n | \
            cut -d ':' -f2- > $tmp1

    if [ "$outreg" ]
    then
        cat $tmp1 | awk '{
            id=substr($0,1,24)
            ra=substr($0,26,10)
            de=substr($0,37,9)
            mag=substr($0,48,4) # not cmt
            sub(/^[ ]*/,"",id); sub(/[ ]*$/,"",id)
            if ($0~/ cmt /) sub(/[ ]*\(.*$/,"",id)
            if (id~/^\([0-9]*\) /) sub(/ .*$/,"",id)
            gsub(/ /,".",id)
            gsub(/ /,":",ra)
            gsub(/ /,":",de)
            gsub(/^[ ]*/,"",mag)
            printf("%s %s %s\n", id, ra, de)
            }' > $tmprade
        rade2xy $tmprade $sname.wcs.head > $tmpxy
        xy2reg $sname.$ext $tmpxy "" "" 15 > $outreg
        grep -i "Object designation" $tmp2 | lines 1
        while read id x
        do
            grep "^[ ]*${id//./ } " $tmp1 | sed -e 's/[ ]*None needed.*//'
        done < $tmpxy
    else
        # TODO: limit to frame size by using id from $tmpxy
        grep -i "Object designation" $tmp2 | lines 1
        cat $tmp1 | sed -e 's/[ ]*None needed.*//'        
    fi

    test "$outreg" && test -s "$outreg" &&
        echo "#" $(grep "^circle" $outreg | wc -l) "objects written to $outreg" >&2
    test "$AI_DEBUG" && echo $tmpreg $tmp1 $tmp2 $tmpxy $tmprade
    test ! "$AI_DEBUG" && rm -f $tmpreg $tmp1 $tmp2 $tmpxy $tmprade
}

get_cobs_old () {
    # get observations from COBS database
    # output is written to stdout
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1

    local comet="$1"    # comet ID (1074 = 2014Q2) or name
    local start=${2:-"$(date +"%F" -d 'now - 1 year')"}
    local cdat=${3:-"../cobs.cometid.csv"}  # ID data file with lines:
                                            # cometid,name,fullname
    local prog=http://www.cobs.si/analysis2
    #local interval="start_date=2015/07/01%2000:00&end_date=2015/12/31%2000:00"
    local interval
    #local url="${prog}?plot_type=0&comet_id=${cid}&${interval}&obs_type=0"
    local url=""
    local cid
    local cname
    local end
    local tmp1=$(mktemp "/tmp/tmp_tmp1_$$.XXXXXX.html")

    (test "$showhelp" || test $# -lt 1) &&
        echo -e "usage: get_cobs <comet> [start_yyyy-mm-dd|$start] [cobs_id_file|$cdat]" >&2 &&
        return 1

    test ! -f $cdat &&
        echo "ERROR: COBS cometID data file $cdat not found." >&2 && return 255
    is_integer "$comet" && cid=$comet
    # TODO: do exact query of second field in $cdat
    test -z "$cid" && cid=$(grep -w "$comet" $cdat | cut -d "," -f1)
    test -z "$cid" && if is_integer "${comet:0:4}" && [ ${#comet} -ge 6 ]
    then
        test "${comet:4:1}" != " " && cname="C/${comet:0:4} ${comet:4}"
        test "${comet:4:1}" == " " && cname="C/$comet"
        cid=$(grep -w "$cname" $cdat | cut -d "," -f1)
    fi
    test -z "$cid" &&
        echo "ERROR: no comet ID for $comet in $cdat" >&2 && return 255
    
    end=$(date +"%F" -d 'now + 1 day')
    interval="start_date=${start//-/\/}%2000:00&end_date=${end//-/\/}%2000:00"
    url="${prog}?plot_type=0&obs_type=0&comet_id=${cid}&${interval}"
    # analysis2 arguments:
    #   plot_type (0-magnitude , ...)
    #   obs_type (0 - all)

    echo "url=$url" >&2
    wget -O $tmp1 "$url"
    w3m -dump $tmp1
    rm -f $tmp1
    return
}


cometname () {
    # expand short comet name
    #   numbered (period.) comet: <num>P
    #   numbered asteroid: (<num>)
    #   unnumbered asteroid: <year> <aa>...
    #   unnumbered and non-periodic comet: <pre>/<year> <a><n>
    # comet fragments should be referenced by suffix "-A" or similar
    local str="${1// /}"
    local s
    local cname
    
    # check for numbered periodic comet
    s=$(echo $str | sed -e 's,^[0-9]\+P,,')
    test "$s" != "$str" && echo $str && return
    
    # check for numbered asteroid
    s=$(echo $str | sed -e 's,^([0-9]\+)$,,')
    test "$s" != "$str" && echo $str && return
    s=$(echo $str | sed -e 's,^[0-9]\+$,,')
    test -z "$s" && echo "($str)" && return

    # check for un-numbered asteroid YYYYAA...
    s=$(echo $str | awk '{
        if($0~/^[1-2][0-9][0-9][0-9][A-Z][A-Z]/) {
            printf("%s %s", substr($0,1,4), substr($0,5))
        }}')
    if [ "$s" ]
    then
        # check if it is known as a comet
        get_mpcephem -l "C/$s" > /dev/null 2>&1
        test $? -eq 0 && echo "C/$s" && return
        echo $s && return
    fi

    # convert comet name [ACP]YYYYXX to [ACP]/YYYY XX
    cname=$(echo $str | awk '{
        if($0~/^[ACP][1-2][0-9][0-9][0-9][A-Z][A-Z]*[0-9]/) {
            printf("%s/%s %s", substr($0,1,1), substr($0,2,4), substr($0,6))
        }}')
    # convert comet name YYYYAN to C/YYYY AN
    test -z "$cname" && cname=$(echo $str | awk '{
        if($0~/^[1-2][0-9][0-9][0-9][A-Z][0-9]/) {
            printf("C/%s %s", substr($0,1,4), substr($0,5))
        }}')
    test -z "$cname" && echo "WARNING: no name conversion applied" >&2 && cname=$str
    echo $cname
    return
}


get_cobs () {
    # get observations from COBS database
    # output is written to stdout
    local showhelp
    local all   # if set then get all available data
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-a" && all=1 && shift 1
    done
    
    local comet="$1"    # comet name, e.g. "2016 R2"
    local start=${2:-""}
    local end=$(date +"%F" -d 'now + 1 day')
    local interval
    local prog=http://www.cobs.si/analysis
    local x
    local n
    local fullname
    local par1
    local par2
    local url
    local cname         # full comet name
    local tmp1=$(mktemp "/tmp/tmp_tmp1_$$.XXXXXX.html")
    local tmpcdb=$(mktemp "/tmp/tmp_cdb_$$.XXXXXX.dat") # comet name database

    (test "$showhelp" || test $# -lt 1) &&
        echo -e "usage: get_cobs <comet> [start_yyyy-mm-dd|$start]" >&2 &&
        return 1

    # workaround for buggy date in Ubuntu 20.04
    #test "$all" && start=$(date +"%F" -d 'now - 300 years')
    test "$all" && start=$(date +"%F" | awk -F "-" '{printf("%d-%02d-%02d\n", $1-300, $2, $3)}')
    test -z "$start" && start=$(date +"%F" -d 'now - 3 years')
    
    # get comet names database
    wget -O $tmp1 "$prog"
    cat $tmp1 | awk '{
        if ($0~/Select comet/) {getline; ok=1}
        if ($0~/\/select/) {ok=0}
        if (ok==1) {print $0}
        }' | tr '<>' '\n' | grep "[a-zA-Z0-9]" | grep -v "option" > $tmpcdb
    x=$(cometname $comet)
    # search in $tmpcdb and convert to fullname
    n=$(grep "^$x[/ ]" $tmpcdb | wc -l)
    test $n -eq 0 &&
        echo "ERROR: comet $x unknown to database $tmpcdb" >&2 &&
        return 255
    test $n -gt 1 &&
        echo "ERROR: comet $x has multiple matches in database $tmpcdb" >&2 &&
        return 255
    fullname=$(grep "^$x[/ ]" $tmpcdb)
    echo "fullname=$fullname" >&2
    
    # example
    # comet="C/2016 R2 (PANSTARRS)"
    par1="required_fields=COMET_FULLNAME&COMET_FULLNAME=${fullname}"
    par2="COMET_MPC=&PERIHELION_DATE=&PLOT_TYPE=Magnitude&OBSERVER=0&ASSOCIATION=0&SUBMIT=Get+Obs&COUNTRY=0"
    #interval="START_DATE=YYYY%2FMM%2FDD+hh%3Amm&H0=&N=&END_DATE=YYYY%2FMM%2FDD+hh%3Amm"
    interval="START_DATE=${start//-/\/}+00:00&END_DATE=${end//-/\/}+00:00"
    
    url="${prog}?${par1}&${par2}&${interval}"
    test "$AI_DEBUG" && echo "url=$url" >&2
    wget -O $tmp1 "$url"
    
    grep "obs_visual" $tmp1 | sed 's,<br>,\n,g' | \
        sed 's,</span>,,; s,<span class="obs_visual">,,; s,</pre>,,' | grep "[0-9]"
    
    test "$AI_DEBUG" && echo $tmp1 $tmpcdb >&2 && return
    rm -f $tmp1 $tmpcdb
    return
}

get_jplcoord () {
    # TODO: add -w to write AI_CORA AI_CODEC
    # ref:  ftp://ssd.jpl.nasa.gov/pub/ssd/horizons_batch_example.long
    #       https://ssd.jpl.nasa.gov/?horizons_doc
    local showhelp
    local do_write_header   # if set write coordinates to image header keywords
    local verbose
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-w" && do_write_header=1 && shift 1
        test "$1" == "-v" && verbose=1 && shift 1
    done
    local sname="$1"        # set name or header file or object name
    local day=${2:-""}      # JD or UT day string "YYYY-MM-DD"
    local uttime=${3:-""}   # HH:MM
    local sdat=${AI_SETS:-"set.dat"}
    local sitesdat="sites.dat"
    local cgi=https://ssd.jpl.nasa.gov/horizons_batch.cgi
    local hdr
    local objects
    local long
    local lat
    local alt
    local jd
    local start
    local stop          # cgi form requires stop>start
    local site
    local step=1
    local fields="1"    # only RA DEC coordinates
    local arg1
    local arg2
    local arg3
    local str
    local cap
    local tmpdat=$(mktemp "/tmp/tmp_tmp2_$$.XXXXXX.dat")
    
    (test "$showhelp" || test $# -lt 1) &&
        echo -e "usage: get_jplcoord <set|object> [utday_yyyy-mm-dd] [uttime_hh:mm]" >&2 &&
        return 1

    test "$AI_DEBUG" && verbose=1
    
    # set name or header file or objects
    if [ -e "$sdat" ] && is_setname "$sname"
    then
        test -f $sname.head && hdr=$sname.head
    else
        if is_ahead "$sname"
        then
            hdr="$sname" && sname=""
        else
            objects="$sname" && sname=""
        fi
    fi
    test "$do_write_header" && (test -z "$hdr" || test ! -e "$hdr") &&
        echo "ERROR: header file $hdr is missing (required by option -w)" >&2 && return 255
    
    # get object name(s)
    test -z "$objects" && test "$hdr" &&
        objects=$(get_header -q $hdr OBJECT | sed -e 's,^[ ]*,,; s,[ ]*$,,')
    test -z "$objects" && if [ "$sname" ]
    then
        # read target name from $sdat
        set - $(grep -v "^#" $sdat | awk -v s=$sname '{if($2==s){print $0}}')
        test -z "$objects" && objects="$3"
        test -z "$objects" && echo "ERROR: no matching $sname in $sdat." >&2 && return 255
    fi
    test -z "$objects" &&
        echo "ERROR: missing object name(s)." >&2 && return 255
    objects=$(cometname "$objects")


    # get site: long/deg (east is >0), lat/deg, height/km
    test "$hdr" && test -e "$hdr" && str=$(get_header -q $hdr AI_SITE)
    test -z "$str" && str=${AI_SITE}
    test -z "$str" &&
        echo "ERROR: AI_SITE undefined" >&2 && return 255
    
    long=$(get_param -k location $sitesdat long $str AI_LONGITUDE)
    lat=$(get_param -k location $sitesdat lat $str AI_LATITUDE)
    alt=$(get_param -k location $sitesdat alt $str "" 500 | awk '{printf("%.3f", $1/1000)}')
    test "$long" && test "$lat" && test "$alt" && site="$long,$lat,$alt"
    test -z "$site" &&
        echo "ERROR: no match of site $str in $sitesdat" >&2 && return 255

    # get jd
    test "$day" && test "${day/-/}" == "$day" && test "${day/ /}" == "$day" && jd=$day
    if [ -z "$jd" ]
    then
        if [ "${day}${uttime}" ]
        then
            test -z "$utday"  && utday=$(date -u +"%Y-%m-%d")
            test -z "$uttime" && uttime="00:00"
            jd=$(ut2jd "$uttime" "$day")
        else
            test "$hdr" && jd=$(get_jd $hdr)
            # current time
            test -z "$jd" && jd=$(ut2jd $(date -u +"%H:%M:%S") $(date -u +"%Y-%m-%d"))
        fi
    fi
    test -z "$jd" &&
        echo "ERROR: unable to determine JD" >&2 && return 255
    test "$verbose" && echo "# object=$objects  jd=$jd  site=$site" >&2

    # convert jd to start / stop
    start=$(jd2ut -t $jd)
    stop=$(jd2ut -t $(echo "$jd + 1" | bc))

    # for short period comets choose elements of latest apparition
    if [ "${objects:0:1}" == "P" ] || [ "${objects: -1:1}" == "P" ]
    then
        cap="%3B%20NOFRAG%3B%20CAP"
    fi
    
    arg1="&COMMAND='NAME=$objects$cap'&MAKE_EPHEM='YES'&TABLE_TYPE='OBSERVER'&QUANTITIES='$fields'"
    #arg1="&COMMAND='?!'&MAKE_EPHEM='YES'&TABLE_TYPE='OBSERVER'&QUANTITIES='$fields'"
    arg2="&CENTER='coord'&SITE_COORD='$site'"
    arg3="&START_TIME='$start'&STOP_TIME='$stop'&STEP_SIZE='$step'"
    wget -O $tmpdat $cgi?batch=1"$arg1$arg2$arg3" 2>/dev/null
    str=$(grep -A1 "^\$\$SOE" $tmpdat | tail -1)
    test -z "$str" &&
        echo "ERROR: JPL web query failed, see $tmpdat" >&2 && return 255

    test "$verbose" && echo "# line=$str" >&2
    set - $(echo "$str" | awk '{
        ra=substr($0,31,11)
        dec=substr($0,43,11)
        gsub(" ",":",ra)
        gsub(" ",":",dec)
        printf("%s %s\n", ra, dec)}')
    test $# -ne 2 &&
        echo "ERROR: unable to get coordinates" >&2 && return 255
    
    echo $1 $2
    test "$do_write_header" &&
        set_header AI_ELREF="JPL" $hdr AI_CORA="$1" AI_CODEC="$2"


    test "$AI_DEBUG" && echo $tmpdat >&2
    test -z "$AI_DEBUG" && rm -f $tmpdat
    return
}

get_mpcephem () {
    local showhelp
    local do_write_header   # if set write some results to image header keywords
    local do_aladin_commands # if set show aladin commands for plotting positions
    local has_long_name     # if set then do not convert object name
    local n=1   # number of ephemerides entries per object
    local dhr="120:00"   # interval in HH:MM:SS
    local i
    for i in 1 2 3 4 5
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-w" && do_write_header=1 && shift 1
        test "$1" == "-a" && do_aladin_commands=1 && shift 1
        test "$1" == "-l" && has_long_name=1 && shift 1
        test "$1" == "-n" && n=$2 && shift 2
        test "$1" == "-i" && dhr=$2 && shift 2
    done
    
    local sname="$1"    # set name or header file or object name
    # TODO: allow for multiple objects (separated by comma)
    # objects="C%2F2012+K1%2CC%2F2010+S1%2C154P%2C2P%2CC%2F2012+S1%2CC%2F2013+R1"
    local utday="$2"    # e.g. "2013-09-29"
    local uttime="$3"   # HH:MM
    local hdr
    local objects       # e.g. "C/2012 K1,154P"
    local sdat=${AI_SETS:-"set.dat"}
    local ref=https://www.minorplanetcenter.net/iau/MPEph/MPEph.html
    local url=https://cgi.minorplanetcenter.net/cgi-bin/mpeph2.cgi
    local sitesdat="sites.dat"
    local jd
    local dateobs
    local dmin
    local interval
    local long
    local lat
    local alt
    local args
    local args2
    local tmp1=$(mktemp "/tmp/tmp_tmp1_$$.XXXXXX.html")
    local tmp2=$(mktemp "/tmp/tmp_tmp2_$$.XXXXXX.dat")
    local ra
    local de
    local dr
    local pa
    local mphase
    local mdist
    local malt
    local str
    local nval
    local y
    local m
    local d
    local u
    local rah
    local ram
    local ras
    local ded
    local dem
    local des
    local elref
    local x
    
    (test "$showhelp" || test $# -lt 1) &&
        echo -e "usage: get_mpcephem [-w] [-l] [-n num] [-i interval_hh:mm] <set|objects> [utday_yyyy-mm-dd] [uttime_hh:mm]" >&2 &&
        return 1

    # set name or header file or objects
    if [ -e "$sdat" ] && is_setname "$sname"
    then
        test -f $sname.head && hdr=$sname.head
    else
        if is_ahead "$sname"
        then
            hdr="$sname" && sname=""
        else
            objects="$sname" && sname=""
        fi
    fi
    test "$do_write_header" && (test -z "$hdr" || test ! -e "$hdr") &&
        echo "ERROR: header file $hdr is missing (required by option -w)" >&2 && return 255
    
    # get object name(s)
    test -z "$objects" && test "$hdr" &&
        objects=$(get_header -q $hdr OBJECT | sed -e 's,^[ ]*,,; s,[ ]*$,,')
    test -z "$objects" && if [ "$sname" ]
    then
        # read target name from $sdat
        set - $(grep   -v "^#" $sdat | awk -v s="$sname" '{if($2==s){print $0}}')
        test -z "$objects" && objects="$3"
        test -z "$objects" && echo "ERROR: no matching $sname in $sdat." >&2 && return 255
    fi
    test -z "$objects" &&
        echo "ERROR: missing object name(s)." >&2 && return 255
    test -z "$has_long_name" && objects=$(cometname "$objects")

    # get lat/long
    if [ "$AI_SITE" ]
    then
        test -f "$hdr" &&
            long=$(get_header -q $hdr SITELONG | cut -d ':' -f1-3)
        test "$long" || long=$(get_param -k location $sitesdat long "$AI_SITE" AI_LONGITUDE)
        test $? -ne 0 && return 255
        test "${long/:/}" != "$long" && long=$(sexa2dec $long)
        test -f "$hdr" &&
            lat=$(get_header -q $hdr SITELAT | cut -d ':' -f1-3)
        test "$lat"  || lat=$(get_param  -k location $sitesdat lat  "$AI_SITE" AI_LATITUDE)
        test $? -ne 0 && return 255
        test "${lat/:/}" != "$lat" && lat=$(sexa2dec $lat)
        alt=$(get_param  -k location $sitesdat alt  "$AI_SITE" "" 500)
    else
        test "$do_write_header" &&
            echo "ERROR: AI_SITE is not set (required by option -w)" >&2 && return 255
        echo "WARNING: AI_SITE is not set." >&2
        long=0
        lat=0
        alt=0
    fi
    test "$AI_DEBUG" && echo "# long=$long  lat=$lat" >&2
    test "$do_write_header" && test $n -ne 1 &&
        echo "WARNING: changing n from $n to 1 (required by option -w)" >&2 && n=1
    
    # convert and check interval
    dmin=$(echo "$dhr" | awk -F ":" '{printf("%.0f", $1*60+$2)}')
    dhr=$(echo "$dhr" | awk -F ":" '{printf("%.0f", $1+$2/60)}')
    #test $dhr -gt 480 &&
    #    echo "ERROR: interval is bejond limit of 480 hours." >&2 && return 255

    # determine utday and uttime
    if [ -z "$hdr" ] && [ -z "$sname" ]
    then
        # use current date/time if not set by command line
        test -z "$utday"  && test -z "$uttime" &&
            utday=$(date -u +"%Y-%m-%d") && uttime=$(date -u +"%H:%M")
        test -z "$utday"  && utday=$(date -u +"%Y-%m-%d")
        test -z "$uttime" && uttime="00:00"
    fi
    
    # check correct format of uttime, add leading zero if necessary
    x=${uttime%:*}
    test ${#x} -eq 1 && uttime=0$uttime
    
    # convert from yyyymmdd to yyyy-mm-dd
    test "$utday" && test ${#utday} -eq 8 &&
        utday=${utday:0:4}"-"${utday:4:2}"-"${utday:6:2}
    
    # evaluate jd if both ut day and time are missing
    if [ -z "$utday" ] || [ -z "$uttime" ]
    then
        test "$hdr" && jd=$(get_jd -k "JD,JD_OBS,DATE-OBS" $hdr)
        # try header of nref
        test -z "$jd" && if [ "$sname" ]
        then
            set - $(AIsetinfo -b $sname | grep -w o | lines 1)
            nref=$8
            test -f measure/$nref.src.head &&
                jd=$(get_jd -q -k "JD,JD_OBS,MJD_OBS,DATE-OBS" measure/$nref.src.head)
            test -z "$jd" &&
                jd=$(get_jd_dmag $sname | grep "^$nref " | awk '{printf("%s", $2)}')
        fi
        test -z "$jd" &&
            echo "ERROR: cannot get jd to calculate missing utday/uttime." >&2 && return 255
        
        test -z "$utday" && utday=$(jd2ut -t $jd | cut -d " " -f1)
        test -z "$uttime" && uttime=$(jd2ut -t $jd | cut -d " " -f2)
    fi
    test "$AI_DEBUG" && echo "# objects=\"$objects\" ut=\"$utday $uttime\""
    
    # check internet connection
    ! check_url && echo "ERROR: no internet connection." >&2 && return 1
    ! check_url $url && echo "ERROR: no access to $url" >&2 && return 2
    
    # set interval
    interval=""
    test $n -eq 1 && interval="1&u=s"
    test -z "$interval" && test $dmin -le 240 && interval=$dmin"&u=m"
    test -z "$interval" && test $dhr  -le 240 && interval=$dhr"&u=h"
    

    args="l=$n&i=$interval&uto=0&c=&long=$long&lat=$lat&alt=$alt"
    args2="raty=a&s=t&m=h&adir=N&oed=&e=-2&resoc=&tit=&bu=&ch=c&ce=f&js=f"
    test "$AI_DEBUG" && echo "args=\"$args\"" >&2 && echo "args2=\"$args2\"" >&2
    
    test "$AI_DEBUG" && echo "curl -s --referer $ref --data" \
        "\"ty=e&TextArea=$objects&d=$utday+${uttime//:/}&$args&$args2\" -o $tmp1 $url" >&2
    curl -s --referer $ref --data "ty=e&TextArea=$objects&d=$utday+${uttime//:/}&$args&$args2" \
        -o $tmp1 $url
    #w3m -dump -T text/html $tmp1
    test $? -ne 0 &&
        echo "ERROR: get_mpcephem: curl failed" >&2 && return 255
    cat $tmp1 | awk 'BEGIN{sectionnum=0; objectline=0; data=0; drow=0}{
        if ($0~/<hr>/) {
            sectionnum++
            i=0
            while (objectline == 0 && i<10) {
                getline
                if ($0~/No current elements/) objectline=-1
                if ($0~/<b>/) objectline=1
                i++
            }
            gsub(/[ ]*<[\/]*b>[ ]*/,"")
            if (sectionnum==1) {
                if (objectline==1) print "# "$0
                if (objectline==-1) {gsub(/\. .*/,""); print "# "$0}
            }
        }
        if (objectline == 1) {
            if ($0~/<i>MPC<\/i>/ || $0~/<i>MPO<\/i>/ || $0~/<i>MPEC<\/i>/) {
                gsub(/<a href.*>MPEC/,"MPEC")
                gsub(/<[\/]*[ia]>/,"")
                gsub(/\.[ ]*/,"")
                print "#"$0
            }
            if ($0~/<pre>/) {data=1; getline}
            if ($0~/<\/pre>/) {data=0; drow=0}
            if (data == 1) {
                drow+=1
                if (drow==2 || drow==3) print "#"$0
                if (drow>3) print $0
            }
        }
        }' > $tmp2
    grep "^#" $tmp2
    grep -v "^#" $tmp2 | sed -e 's|/.*||'
    if [ $? -ne 0 ]
    then
        test "$AI_DEBUG" && echo $tmp1 $tmp2 >&2
        test "$AI_DEBUG" || rm $tmp1 $tmp2
        echo "ERROR: No current elements found for $objects." >&2
        return 3
    fi
    
    set - $(grep -v "^#" $tmp2 | sed -e 's|/.*||' | lines 1) xx
    nval=$#
    (test $nval -lt 23 || test $nval -gt 26) &&
        echo "WARNING: $objects: wrong number of values ($nval)" >&2 &&
        echo $tmp1 $tmp2 >&2 &&
        return 255

    # reference of elements
    elref=$(grep "^#" $tmp2 | lines 2 | tail -1 | tr -d '#')
    
    # save to header keywords
    if [ "$do_write_header" ] && grep -q -v "^#" $tmp2
    then
        shift 4
        ra="$1:$2:$3"; de="$4:$5:$6"
        set_header $hdr AI_ELREF="$elref"
        set_header $hdr AI_CORA="$ra" AI_CODEC="$de"
        set_header $hdr AI_CODEL="$7/Distance from observer"
        set_header $hdr AI_COR="$8/Distance from Sun"
        set_header $hdr AI_COEL="$9/Solar elongation"
        set_header $hdr AI_COPH="$10/Phase angle of comet"
        test $nval -eq 23 && shift 10
        test $nval -eq 24 && shift 11
        test $nval -eq 25 && shift 11
        test $nval -eq 26 && shift 11
        dr=$1; pa=$2; mphase=$6; mdist=$7; malt=$8
        set_header $hdr AI_COAZI=$3 AI_COALT=$4
        set_header $hdr AI_OMOVE="$(printf "%.1f@%.1f" $dr $pa)/Object motion on sky per hour"
        set_header $hdr AI_MOP="$mphase/Moon phase" AI_MOD="${mdist##+(0)}/Moon distance angle" AI_MOALT="$malt/Moon altitude"
        #str=$(printf "%s %s %s %s  %.1f@%.1f  %.2f %3g %s\n" \
        #    $hdr $ra $de $alt  $dr $pa  $mphase $mdist $malt)
        #AIsetkeys "$str" AI_CORA AI_CODEC AI_COALT AI_OMOVE AI_MOP AI_MOD AI_MOALT
    fi

    if [ "$do_aladin_commands" ] && grep -q -v "^#" $tmp2
    then
        grep -v "^#" $tmp2 | while read y m d u rah ram ras ded dem des x
        do
            str=$u
            echo "draw red tag($rah:$ram:$ras,$ded:$dem:$des,\"$str\",0,0,circle,10);"
        done
    fi
    test "$AI_DEBUG" && echo $tmp1 $tmp2 >&2
    test "$AI_DEBUG" || rm $tmp1 $tmp2
}

mkrefcat () {
    # download objects from vizier database (CDS) and create
    # astrometric or photometric reference catalog
    # ref.: http://vizier.u-strasbg.fr/doc/asu-summary.htx
    local showhelp
    local server
    local wcshdr
    local nmax=1000
    local catdef=refcat.dat   # catalog column description
    local outfmt="tsv"      # output table format, tsv - tab separated ASCII,
                            # fits - FITS LDAC table
    local all_columns       # if set then all columns are queried
    local add_r             # if set then add _r column
    local i
    for i in 1 2 3 4 5 6 7
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-s" && server="$2" && shift 2
        test "$1" == "-w" && wcshdr="$2" && shift 2
        test "$1" == "-n" && nmax="$2" && shift 2
        test "$1" == "-f" && outfmt="fits" && shift 1
        test "$1" == "-a" && all_columns=1 && shift 1
        test "$1" == "-r" && add_r=1 && shift 1
    done
    local catalog=$1
    local ra=$2     # center coordinates
    local de=$3
    local radius=$4 # search radius in degrees
    local serverlist
    local url
    local vid
    local sortcol
    local addcol
    local rad
    local ded
    local center
    local args
    local opts
    local pscale
    local w
    local x
    local tmp1=$(mktemp "/tmp/tmp_tmp1_$$.XXXXXX.dat")
    local tmp2=$(mktemp "/tmp/tmp_tmp2_$$.XXXXXX.dat")
    local ahead=$(mktemp "/tmp/tmp_ahead_$$.XXXXXX.head")
    local tmpldac=$(mktemp "/tmp/tmp_ldac_$$.XXXXXX.dat")
    
    (test "$showhelp" || test $# -lt 4) &&
        echo -e "usage: mkrefcat [-h] [-f] [-a] [-s server] [-w wcshdr] [-n nmax|$nmax]" \
            "<catalog> <ra> <de> <radius>" >&2 &&
        return 1

    # list of vizier servers to check
    serverlist="
        vizier.u-strasbg.fr \
        vizier.hia.nrc.ca \
        vizier.china-vo.org \
        vizier.ast.cam.ac.uk \
        vizier.nao.ac.jp \
        vizier.cfa.harvard.edu \
        www.ukirt.jach.hawaii.edu \
        vizier.iucaa.ernet.in \
        "
    test "$server" && serverlist="$server"

    # get vizier catalog identifier
    vid=$(get_param $catdef vid $catalog)
    test -z "$vid" && echo "ERROR: unknown catalog." >&2 && return 255
    
    # get sort column (brightest sources)
    sortcol=$(get_param $catdef msort $catalog)
    test "$outfmt" != "tsv" && test -z "$sortcol" &&
        echo "ERROR: mag sort column (msort) undefined." >&2 && return 255

    # add columns to standard columns defined by vizier query
    case "$catalog" in
        gaia2)  addcol="DR2Name,RAJ2000,DEJ2000";;
        gaia3e) addcol="EDR3Name";;
        *)      addcol="";;
    esac
    test "$add_r" && test "$addcol"    && addcol="_r,$addcol"
    test "$add_r" && test -z "$addcol" && addcol="_r"
    
    # TODO: evaluate wcs header to determine center coordinates and search radius
    # convert center coordinates to degrees unit
    test "${ra/:/}" != "$ra" && rad=$(sexa2dec $ra 15)
    test -z "$rad" && rad=$ra
    test "${de/:/}" != "$de" && ded=$(sexa2dec $de)
    test -z "$ded" && ded=$de
    # TODO: replace "+" by "%2b"
    center="${rad}%20${ded/+/%2b}"
    #args="-mime=%7c&-source=${vid}&-out.max=${nmax}&-c.rd=${radius}"
    #args="-source=${vid}&-sort=*phot.mag&-out.max=${nmax}&-c.rd=${radius}"
    #args="-source=${vid}&-sort=$sortcol&-out.max=${nmax}&-c.rd=${radius}"
    args="-source=${vid}&-sort=$sortcol&$sortcol=!=&-out.max=${nmax}&-c.rd=${radius}"
    test "$addcol" && args="$args&-out.add=$addcol"
    if [ "$outfmt" == "tsv" ]
    then
        args="$args&-mime=%7c"   # delimiter |
    else
        test "$all_columns" && args="$args&-out.all"
        test ! "$all_columns" && args="$args&-out.add=$sortcol"
    fi
    
    # check connection
    for server in $serverlist
    do
        echo "# connecting to $server ..." >&2
        check_url http://$server 2 || continue
        url=http://$server/viz-bin/asu-$outfmt
        # run database query
        test "$AI_DEBUG" &&
            echo "wget -O $tmp1 \"${url}?${args}${opts}&-c=${center}\"" >&2
        wget -O $tmp1 "${url}?${args}${opts}&-c=${center}"
        test $? -ne 0 && echo "ERROR: wget failed" >&2 && continue
        
        # check for valid object entries
        x=$(grep -v "^#" $tmp1 | grep "[0-9]" | wc -l)
        test $x -eq 0 && echo "ERROR: empty catalog" >&2 && continue

        test "$url" && break
    done
    test -z "$url" && echo "ERROR: no suitable vizier server found." >&2 && return 255
    x=$(grep -v "^#" $tmp1 | grep "[0-9]" | wc -l)
    test $x -eq 0 && return 255
    
    if [ "$outfmt" == "tsv" ]
    then
        cat $tmp1
    else
        # create global ahead file (using arbitrary pixscale)
        pscale=0.001
        w=$(echo $radius $pscale | awk '{printf("%d", 8*int(2.04*$1/$2/8+2))}')
        x=$(echo $w | awk '{printf("%.1f", $1/2+0.5)}')
        echo "\
SIMPLE  =                    T / This is a FITS file                            
BITPIX  =                    0 /                                                
NAXIS   =                    2 / 2D data                                        
NAXIS1  =                $w / Number of rows                                 
NAXIS2  =                $w / Number of columns                              
EXTEND  =                    T / This file may contain FITS extensions          
TELESCOP= 'Telescope'  / Observatory: Telescope
INSTRUME= 'Camera'     / Detector: Camera
FILTER  = 'FILTER'     / Detector: Filter
EXPTIME =      1       / Exposure time in seconds
EPOCH   =      2000.0  / Epoch
EQUINOX =      2000.0  / Mean equinox
RADESYS = 'ICRS    '   / Astrometric system
CTYPE1  = 'RA---TAN'   / WCS projection type for this axis
CUNIT1  = 'deg     '   / Axis unit
CRVAL1  =      $rad    / World coordinate on this axis
CRPIX1  =      $x     / Reference pixel on this axis
CD1_1   =      -$pscale   / Linear projection matrix
CD1_2   =      0          / Linear projection matrix
CTYPE2  = 'DEC--TAN'   / WCS projection type for this axis
CUNIT2  = 'deg     '   / Axis unit
CRVAL2  =      $ded    / World coordinate on this axis
CRPIX2  =      $x     / Reference pixel on this axis
CD2_1   =      0          / Linear projection matrix
CD2_2   =      $pscale    / Linear projection matrix
PHOTFLAG=      F
END     " > $ahead

        # create LDAC_IMHEAD table
        echo '# "Field Header Card"' > $tmp2
        printf '"' >> $tmp2
        cat $ahead | awk '{printf("%-80s\n", $0)}' | tr -d '\n' >> $tmp2
        echo '"' >> $tmp2
        stilts tcopy ifmt=ascii ofmt=fits-basic $tmp2 $tmpldac
        sethead $tmpldac",1" EXTNAME=LDAC_IMHEAD
        sethead $tmpldac",1" TDIM1='(80,'$(wc -l $ahead | cut -d ' ' -f1)')'

        # combine LDAC_IMHEAD and LDAC_OBJECTS
        stilts tcopy ifmt=fits ofmt=fits-basic in=${tmp1}"#"1 out=$tmp2
        sethead $tmp2",1" EXTNAME=LDAC_OBJECTS
        stilts tmulti ifmt=fits ofmt=fits-basic in=$tmpldac in=$tmp2 out=$tmp1

        # add required columns for scamp reference catalog
        #   note: MAGERR and FLAGS are not strictly required
        #
        fitscopy "$tmp1[LDAC_OBJECTS][col \
            *;\
            X_WORLD=RAJ2000;\
            Y_WORLD=DEJ2000;\
            ERRA_WORLD=0.00001;\
            ERRB_WORLD=0.00001;\
            MAG=${sortcol//\./_};\
            MAGERR=0.2;\
            FLAGS=0;\
            OBSDATE=2000.0;\
            ]" - > $tmp2
        
        # listhead
        x=$(get_header -e 2 $tmp1 TFIELDS)
        sethead $tmp2",2" TUNIT$((x+1))='deg'
        sethead $tmp2",2" TUNIT$((x+2))='deg'
        sethead $tmp2",2" TUNIT$((x+3))='deg'
        sethead $tmp2",2" TUNIT$((x+4))='deg'
        sethead $tmp2",2" TUNIT$((x+5))='mag'
        sethead $tmp2",2" TUNIT$((x+6))='mag'
        sethead $tmp2",2" TUNIT$((x+8))='yr'

        cat $tmp2
    fi
    
    test "$AI_DEBUG" && echo "$tmp1 $tmp2 $ahead $tmpldac" >&2
    test ! "$AI_DEBUG" && rm -f $tmp1 $tmp2 $ahead $tmpldac
    return
}

photplot () {
    # plotting results from photometry data files
    local showhelp
    local color="V"     # color band name (V|B|R)
    local type="mag"    # type of residuals to plot mag|color
    local title         # plot title
    local gpcmd         # additional gnuplot commands
    local yrange        # yrange in the form y1:y2
    local outfile       # if set then print to given file
    local verbose
    local i
    for i in $(seq 1 10)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-B" && color="B" && shift 1
        test "$1" == "-V" && color="V" && shift 1
        test "$1" == "-R" && color="R" && shift 1
        test "$1" == "-c" && type="color" && shift 1
        test "$1" == "-t" && title="$2" && shift 2
        test "$1" == "-g" && gpcmd="$2" && shift 2
        test "$1" == "-y" && yrange="$2" && shift 2
        test "$1" == "-o" && outfile="$2" && shift 2
        test "$1" == "-v" && verbose="1" && shift 1
    done
    
    local set=$1
    local catalog=$2
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpdat=$(mktemp "$tdir/tmp_dat1.XXXXXX.dat")
    local hdr
    local xphot
    local f
    local x
    local xlist
    local magzero
    local data
    local aidx
    local apmzer
    local apmmag
    local aprmag
    local apslop
    local apcind
    local apcval
    local magdiff
    local cimd
    local colmag
    local colcat
    local colci1
    local colci2
    
    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: photplot [-v] [-c] [-B|-V|-R] <set> <refcat>" >&2 &&
        return 1
    
    ! is_setname "$set" &&
        echo "ERROR: unknown set $set." >&2 && return 255
        
    hdr=$set.head
    xphot=phot/$set.$catalog.xphot.dat
    for f in $hdr $xphot
    do
        ! test -s $f && echo "ERROR: file $f not found." >&2 && return 255
    done
    
    # read calibration data from header file
    magzero=$(get_header $hdr MAGZERO)
    test $? -ne 0 && echo "ERROR: no MAGZERO in $hdr" >&2 && continue
    xlist=$(get_header $hdr all | grep "^AP_AIDX[1-9]=" | cut -c8 | sort -nu)
    test -z "$xlist" &&
        echo "ERROR: no calibration data in $hdr." >&2 && continue
    for x in $xlist
    do
        set - $(get_header -q -s $hdr AP_PCAT$x,AP_PCOL$x,AP_CIND$i)
        test "${verbose}${AI_DEBUG}" && printf "# $x %-6s %s %s\n" $1 $2 $3
        test "$1" == "$catalog" && test "$2" == "$color" && aidx=$x
    done
    test -z "$aidx" &&
        echo "ERROR: no match found for given catalog and color." >&2 && return 255
    
    test "${verbose}${AI_DEBUG}" && echo "# aidx=$aidx"
    apmzer=$(get_header $hdr AP_MZER$aidx)
    apmmag=$(get_header $hdr AP_MMAG$aidx)
    aprmag=$(get_header $hdr AP_RMAG$aidx)
    apslop=$(get_header $hdr AP_SLOP$aidx)
    apcind=$(get_header $hdr AP_CIND$aidx)
    apcval=$(get_header $hdr AP_CVAL$aidx)
    #magdiff=$(echo $apmzer $magzero | awk '{printf("%f", $1-$2)}')
    magdiff=$(echo $aprmag $apmmag | awk '{printf("%f", $1-$2)}')
    echo "# mzer=$apmzer mdiff=$magdiff m=$color+$apcval*($apcind)"
    
    colmag=5
    colcat=8
    colci1=7
    colci2=8
    
    # determine median color index
    cimd=$(grep -v "^#" $xphot | awk -v cci1=$colci1 -v cci2=$colci2 '{
        printf("%.3f", $cci1-$cci2)}' | median)
    test "${verbose}${AI_DEBUG}" && echo "# cimd = $cimd"
    
    # create plot title and gnuplot labels
    if [ -z "$title" ]
    then
        case $type in
            mag)
                title="Photometric error, $set, m_{ref}=${color}_{$catalog}"
                test "${apcval:0:1}" != "-" && title="${title}+"
                title="$title$apcval*(${apcind})_{$catalog}"
                x="set grid lc rgb '#808080'"
                x="$x; set ylabel 'mag - m_{ref}'"
                x="$x; set xlabel 'mag'"
                ;;
            color)
                title="Color term, $set, slope=$apcval"
                x="set grid lc rgb '#808080'"
                x="$x; set ylabel 'mag - ${color}_{$catalog}'"
                x="$x; set xlabel '(${apcind})_{$catalog}'"
                ;;
        esac
    fi
    
    # additional gnuplot commands
    test "$yrange" && x="$x; set yrange [$yrange]"
    test "$gpcmd" && x="$x; $gpcmd"
    test "$AI_DEBUG" && echo "# gpcmd=$x"
    
    # create plot data
    echo "# mag mobs $color$catalog $apcind $color\' dmag dmcol" > $tmpdat
    grep -v "^#" $xphot | awk -v type=$type -v mdiff=$magdiff -v slop=$apslop \
        -v cval=$apcval -v cimd=$cimd \
        -v cmag=$colmag -v ccat=$colcat -v cci1=$colci1 -v cci2=$colci2 '{
        cind=$cci1-$cci2
        mref=$ccat - cval*(cind)
        mobs=$cmag+mdiff
        dm=mobs-mref
        dmc=mobs-$ccat + cval*cimd
        printf("%6.3f %6.3f %6.3f %6.3f %6.3f %6.3f %6.3f\n",
            $cmag, mobs, $ccat, cind, mref, dm, dmc)
    }' >> $tmpdat
    case $type in
        mag)
            test -z "$outfile" && AIplot -p -t "$title" -g "$x" $tmpdat 2 6
            test    "$outfile" && AIplot -p -o $outfile -t "$title" -g "$x" $tmpdat 2 6
            ;;
        color)
            test -z "$outfile" && AIplot -p -t "$title" -g "$x" $tmpdat 4 7
            test    "$outfile" && AIplot -p -o $outfile -t "$title" -g "$x" $tmpdat 4 7
            ;;
    esac
    
    test "$AI_DEBUG" && echo $tmpdat && return
    rm $tmpdat
    return
}

comet2icq () {
    # convert object name to icq notation
    local name=$1
    test "${name: -1}" == "P" && name=$(printf "%3d" ${name:0:-1})
    if is_integer $name
    then
        printf "%3d        " $name
    else
        if is_integer ${name:0:1}
        then
            printf "   %-8s" $name
        else
            printf "  %-9s" $name
        fi
    fi
}


phot2icq () {
    # convert photometry data (stored in header keywords) into icq format
    local showhelp
    local verbose   # show additional data
    local observer=${AI_OBSICQID:-""}
    local method="Z"
    local sfwkey="AIT"  # ICQ Photometry Software Key for AIRTOOLS
    local calib=5       # 1-bias 4-bias/dark 5-bias/dark/flat
    local ccdinfo       # if set then show additional CCD info in ICQ record
    local i
    for i in 1 2 3 4 5
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-v" && verbose=1 && shift 1
        test "$1" == "-o" && observer=$2 && shift 2
        test "$1" == "-m" && method=$2 && shift 2
        test "$1" == "-c" && ccdinfo=1 && shift 1
    done
    local setname=${1:-""}
    local catalog=${2:-""}
    local sdat=${AI_SETS:-"set.dat"}
    local sname
    local ltime
    local type
    local nref
    local x
    local hdr
    local whdr
    local object
    local mjd
    local ut
    local texp
    local nexp
    local magzero
    local pixscale
    local rot
    local flen
    local fratio
    local tel
    local inst
    local cam
    local csum
    local ccorr
    local cglim
    local cdia
    local dtlen
    local dtang
    local ptlen
    local ptang
    local papcorr
    local pcref
    local paref
    local moon
    
    local mag
    local cmag
    local dmag
    local alim
    local mlim
    local xlist
    local aidx
    local pcat
    local pcol
    local ptail
    local val
    local str
    local site
    local comment
    local camchip   # PDS/CAC-Pentax/APS-C CDS/CFC-Canon/FullFrame NDS-Nikon
                    # https://cobs.si/help?page=ccd_type https://cobs.si/help?page=ccd_chip
    
    test "$showhelp" &&
        echo -e "usage: phot2icq [-v] [-o observercode|$observer] [-m method|$method] " \
            "[-c] [setname] [catalog]" >&2 &&
        return 1

    
    test -z "$observer" && observer=${AI_OBSERVER:-"OBSxx"}

    while read ltime sname x type x x x nref x
    do
        (echo "$ltime" | grep -q "^#") && continue
        test "$type" != "o" && continue
        test "$setname" && test "$setname" != "$sname" && continue
        hdr=$sname.head
        test ! -e $hdr && echo "ERROR: header file $hdr not found." >&2 && continue
        whdr=$sname.wcs.head
        test ! -e $whdr && echo "ERROR: wcs header file $whdr not found." >&2 && continue

        # reading keywords
        object=$(get_header $hdr OBJECT | sed -e 's,^[ ]*,,; s,[ ]*$,,')
        test $? -ne 0 && echo "ERROR: no OBJECT in $hdr" >&2 && continue
        # check for AI_COMST which is indicative for a comet observation
        val=$(get_header -q $hdr AI_COMST)
        test -z "$val" &&
            (test "$setname" || test "$verbose") &&
            echo "# skipping $sname ($object), no AI_COMST keyword" >&2
        test -z "$val" && continue
        mjd=$(get_header -q $hdr JD_OBS)
        test -z "$mjd" && mjd=$(get_header -q $hdr MJD_OBS)
        test -z "$mjd" && mjd=$(get_header -q $hdr JD)
        test -z "$mjd" && echo "ERROR: no JD_OBS, MJD_OBS or JD in $hdr" >&2 && continue
        ut=$(jd2ut -p 2 $mjd)
        texp=$(get_header $hdr EXPTIME)
        test $? -ne 0 && echo "ERROR: no EXPTIME in $hdr" >&2 && continue
        nexp=$(get_header $hdr NEXP)
        test $? -ne 0 && echo "ERROR: no NEXP in $hdr" >&2 && continue
        magzero=$(get_header $hdr MAGZERO)
        test $? -ne 0 && echo "ERROR: no MAGZERO in $hdr" >&2 && continue

        # telescope, instrument, camera
        tel=$(get_header -q $hdr AI_TELID | sed -e 's,^[ ]*,,; s,[ ]*$,,')
        test $? -ne 0 && echo "ERROR: no AI_TELID in $hdr" >&2 && continue
        apert=$(AI_TELESCOPE=$tel  get_param camera.dat aperture xxx)
        fratio=$(AI_TELESCOPE=$tel get_param camera.dat fratio  xxx)
        ttype=$(AI_TELESCOPE=$tel  get_param camera.dat ttype   xxx)
        inst=$(echo $apert $ttype $fratio | awk '{printf("%04.1f%s %.0f", $1/10, $2, $3)}')
        
        # convert object name to icq notation
        object=$(comet2icq $object)

        pixscale=$(get_wcspscale $sname)
        rot=$(get_wcsrot $sname)
        #ticq=$(echo $texp | awk '{printf("%04.0f", $1)}' | sed -e 's/^0/a/' | sed -e \
        #    's/^1/A/; s/^2/B/; s/^3/C/; s/^4/D/; s/^5/E/; s/^6/F/; s/^7/G/')
        ticq=$(echo $texp | awk '{x=int(1*$1+0.5); sub(/...$/,"",x);
            s="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            if($1<1000){x=0; s="a"}
            printf("%s%03d\n", substr(s,x,1), $1-x*1000)}')
        #echo "texp=$texp  ticq=$ticq"

        
        # get comet photometry/tail keywords
        xlist=$(get_header $hdr all | grep "^AP_CMAG[1-9]=" | cut -c8 | sort -nu)
        if [ "$xlist" ]
        then
            for x in $xlist
            do
                mag=""; alim=""; mlim=""
                pcat=$(get_header $hdr AP_PCAT$x)
                pcol=$(get_header $hdr AP_PCOL$x)
                test "$catalog" && test "$pcat" != "$catalog" && continue
                case "$pcat" in
                    tycho2) refcat="TK";;
                    apass)  refcat="AQ"
                            test "$pcol" == "B" && refcat="AB"
                            test "$pcol" == "V" && refcat="AV"
                            test "$pcol" == "R" && refcat="AR"
                            ;;
                    gaia*)  refcat="GG"
                            test "$pcol" == "GB" && refcat="BG"
                            ;;
                    *)      refcat="--";;
                esac
                mag=$(get_header  $hdr AP_CMAG$x | awk '{printf("%4.1f", $1)}')

                aidx=$(get_header $hdr AP_AIDX$x)
                test -z "$aidx" &&
                    echo "ERROR: missing AP_AIDX$x, skipping $sname ($pcat)" >&2 &&
                    continue
                cdia=$(get_header $hdr AC_DIAM$aidx)
                
                dtlen=$(get_header -q $hdr AI_DLEN)
                dtang=$(get_header -q $hdr AI_DANG)
                ptlen=$(get_header -q $hdr AI_PLEN)
                ptang=$(get_header -q $hdr AI_PANG)
                
                # convert coma diameter and tail parameter
                coma="    "; tail="          "; pa="   "; ptail=""
                is_number "$cdia"  && coma=$(echo $cdia $pixscale | \
                    awk '{x=$1*$2/60; fmt="%4.1f"
                        if (x>10) {fmt="%2.0f  "}
                        printf(fmt, x)}')
                is_number "$dtlen" && tail=$(echo $dtlen $pixscale | tr -d '>' | \
                    awk '{if($1=="-") {print $1} else {
                        asec=$1*$2
                        if (asec>72000) {
                            printf("%7.0f    ", asec/3600)
                        } else if (asec>7200) {
                            printf("%8.1f  ", asec/3600)
                        } else if (asec>150) {
                            printf("%9.2f ", asec/3600)
                        } else {
                            printf("%8.1f m", asec/60)
                        }
                        }}')
                is_number "$dtang" && pa=$(echo $dtang $rot | \
                    awk '{if($1=="-") {print $1} else {printf("%3.0f", ($1-90+$2+720)%360)}}')
                is_number "$ptlen" && ptail=$(echo $ptlen $pixscale | tr -d '>' | \
                    awk '{if($1=="-") {print $1} else {
                        asec=$1*$2
                        if (asec>72000) {
                            printf("plasma tail %.0f deg", asec/3600)
                        } else if (asec>7200) {
                            printf("plasma tail %.1f deg", asec/3600)
                        } else {
                            printf("plasma tail %.2f deg", asec/3600)
                        }
                        }}')
                is_number "$ptang" && ptail=$(echo $ptang $rot | \
                    awk -v p="$ptail" '{printf("%s at pa=%.0f", p, ($1-90+$2+720)%360)}')

                # determine mlim
                alim=$(get_header $hdr AI_ALIM$aidx | grep "[0-9]" | awk '{printf("%.0f", $1)}')
                if [ "$alim" ]
                then
                    val=$(get_header -q $hdr AP_MZER$x)
                    mlim=$(i2mag $alim $(echo $texp $nexp | awk '{printf("%.1f", $1/$2)}') $val | awk '{printf("%.1f", $1)}')
                fi
                #mlim=$(get_header $hdr AP_MLIM$x | awk '{printf("%.1f", $1+$2)}')
                #test -z "$mlim" && mlim="    "

                # moon
                moon="$(echo $(get_header -q -s $hdr AI_MOP,AI_MOD,AI_MOALT) | \
                    awk '{if($3>0) {printf("moon %d%% dist %d deg", 100*$1, 1*$2)}}')"
                
                # filter
                filt=$(get_header -q $hdr FILTER)
                test "$filt" && case $filt in
                    Red)    filt="R";;
                    Green)  filt="G";;
                    Blue)   filt="B";;
                    Luminance)  filt="L";;
                    R|G|V|L|B) ;;
                    *)      filt="";;
                esac
                test -z "$filt" && filt=$(get_header $hdr AC_ICOL$aidx)

                # camera info
                cam=$(AI_TELESCOPE=$tel    get_param camera.dat ctype   xxx)
                if [ "$cam" == "DSLR" ]
                then
                    test "$filt" == "R" && cam="$cam red"
                    test "$filt" == "G" && cam="$cam green"
                    test "$filt" == "B" && cam="$cam blue"
                else
                    cam="$cam/"$filt
                fi
                
                # site info
                site=$(get_header $hdr AI_SITE)
                test "$site" &&
                    test "$(get_param -k location sites.dat comments $site 2>/dev/null)" == "iTelescope" &&
                    site="$site (remote)"

                
                if [ "$verbose" ]
                then
                    str="$pcat/$filt"
                    val=$(get_header -q $hdr AP_MZER$x)
                    test "$val" && str=$str" mzero=$val"
                    val=$(get_header -q $hdr AP_NFIT$x)
                    test "$val" && str=$str" nstar=$val"
                    val=$(get_header -q $hdr AP_MRMS$x)
                    test "$val" && str=$str" rms=$val"
                    val=$(get_header -q $hdr AI_MOALT | grep -v "^-")
                    test "$val" &&
                        val=$(echo $(get_header -q -s $hdr AI_MOP,AI_MOD,AI_MOALT) | tr ' ' '/') &&
                        str=$str" moon=$val"
                    val=$(get_header -q $hdr AI_COALT)
                    test "$val" && str=$str" alt=$val"
                    val=$(get_header -q $hdr AP_CMAG$x)
                    test "$val" && str=$str" m1=$val"
                    echo "# $str d=${coma// /}'"
                fi

                # create additional ccd information
                # ref.: https://cobs.si/help?page=icq_format
                _icqformatccd="
f InT APERTURcamchip SFW C ## u.uu xx.x PIXELSIZE       guideline
         9        10        11        12        13
123456789 123456789 123456789 123456789 123456789 123456789  
"
                if [ "${ccdinfo// /}" ]
                then
                    camchip=$(AI_TELESCOPE=$tel get_param camera.dat camchip xxx)
                    test "$camchip" == "-" && camchip=""
                    str=$(printf "%4.1fs%4.1f" $pixscale $pixscale)
                    ccdinfo=$(printf "I     C%5.2fm%-7s %-3s %1s %12s %9s" $coma "${camchip/[,_\/]/ }" $sfwkey $calib "" "$str")
                else
                    ccdinfo="      "
                fi

                # show results
                str=$(printf "%-5s%s" $observer "$ccdinfo")
                comment=""
                test "$cam$mlim$moon" && comment="; "
                test "$cam" && comment="${comment}$cam"
                test "$mlim" && test ${#comment} -gt 2 && comment="$comment, "
                test "$mlim" && comment="${comment}mlim=$mlim"
                test "$moon" && test ${#comment} -gt 2 && comment="$comment, "
                test "$moon" && comment="${comment}$moon"
                echo "$object${ut//-/ }  $method $mag $refcat $inst$ticq " \
                     "$coma $tail$pa        $str $site$comment" $ptail
            done
        else
            # old keywords, AI_VERSION<2.7
        
            # reference catalog abbreviation
            pcat=$(get_header $hdr AI_PCAT)
            test $? -ne 0 && echo "ERROR: no AI_PCAT in $hdr" >&2 && continue
            case $pcat in
                tycho2) refcat="TK";;
                apass)  refcat="AQ";;
                *)      refcat="--";;
            esac

            # photometry
            csum=$(get_header $hdr AI_CSUM)
            test $? -ne 0 && echo "ERROR: no AI_CSUM in $hdr" >&2 && continue
            ccorr=$(get_header $hdr AI_CCORR)
            test $? -ne 0 && echo "ERROR: no AI_CCORR in $hdr" >&2 && continue
            papcorr=$(get_header $hdr AI_PAPCO)
            test $? -ne 0 && echo "ERROR: no AI_PAPCO in $hdr" >&2 && continue
            pcref=$(get_header $hdr AI_PCREF)
            test $? -ne 0 && echo "ERROR: no AI_PCREF in $hdr" >&2 && continue
            paref=$(get_header $hdr AI_PAREF)
            test $? -ne 0 && echo "ERROR: no AI_PAREF in $hdr" >&2 && continue
            cglim=$(get_header $hdr AI_CGLIM)
            test $? -ne 0 && echo "ERROR: no AI_CGLIM in $hdr" >&2 && continue
        
            cmag=$(i2mag $(echo $csum $ccorr | awk '{print $1+$2}') $texp $magzero)
            dmag=$(echo $pcref $paref $papcorr | awk '{printf("%.2f", $1-$2-$3)}')
            mag=$(echo $cmag $dmag | awk '{printf("%4.1f", $1+$2)}')
            cmag=$(echo $cmag  $dmag | awk '{printf("%5.2f", $1+$2)}')
            mlim=$(i2mag $cglim $texp $magzero | awk -v dm=$dmag '{printf("%.1f", $1+dm)}')
            echo "# $sname:  mlim=$mlim  dmag=$dmag  mag=$cmag" >&2
        
            # coma diameter and tail parameter
            cdia=$(get_header $hdr AI_CDIA)
            test $? -ne 0 && echo "ERROR: no AI_CDIA in $hdr" >&2 && continue
            dtlen=$(get_header $hdr AI_CTLEN)
            test $? -ne 0 && echo "ERROR: no AI_CTLEN in $hdr" >&2 && continue
            dtang=$(get_header $hdr AI_CTANG)
            test $? -ne 0 && echo "ERROR: no AI_CTANG in $hdr" >&2 && continue

            # convert coma diameter and tail parameter
            coma="    "; tail="         "; pa="   "
            is_number "$cdia"  && coma=$(echo $cdia $pixscale | \
                awk '{x=$1*$2/60; fmt="%4.1f"
                    if (x> 2 && x<= 4) {x=sprintf("%.0f", 5*x);   x=x/5} 
                    if (x> 4 && x<=10) {x=sprintf("%.0f", 2*x);
                                      if(x%2==0) {fmt="%2.0f  "}; x=x/2} 
                    if (x>10) {fmt="%2.0f  "}
                    if (x>20 && x<=40) {x=sprintf("%.0f", 0.5*x); x=x/0.5} 
                    if (x>40)          {x=sprintf("%.0f", 0.2*x); x=x/0.2} 
                    printf(fmt, x)}')
            is_number "$dtlen" && tail=$(echo $dtlen $pixscale | tr -d '>' | \
                awk '{if($1=="-") {print $1} else {printf("%9.2f", $1*$2/3600)}}')
            is_number "$dtang" && pa=$(echo $dtang $rot | \
                awk '{if($1=="-") {print $1} else {printf("%3.0f", ($1-90+$2+720)%360)}}')
            
            # show results
            str=$(printf "%-8s" $observer)
            echo "$object${ut//-/ }  C $mag $refcat $inst$ticq " \
                 "$coma $tail $pa        $str    $mlim  $cam"
        fi
    done < $sdat
}

icqlist () {
    # list icq records by parsing imred*.txt
    local showhelp
    local ndays=14
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-n" && ndays="$2" && shift 2
    done
    local adir="$1"
    local tchars="12-24"  # characters defining date and time
    local start
    local dir
    local b
    local first
    local last
    local tmpdat=$(mktemp "/tmp/tmp_dat_$$.XXXXXX.dat")
    
    (test "$showhelp" || test $# -gt 1) &&
        echo -e "usage: icqlist [-h] [-n ndays|$ndays] <basedir>" >&2 &&
        return 1
    
    if [ -z "$adir" ]
    then
        for dir in \
            $(dirname $(pwd))
        do
            test -d "$dir" && adir=$(echo $adir $dir)
        done
        test "$adir" && echo "# assuming airtools basedir=$adir" >&2
    fi
    test -z "$adir" &&
        echo "ERROR: missing airtools basedir" >&2
    test ! -d "$adir" &&
        echo "ERROR: directory $adir does not exist." >&2 && return 255
    
    start=$(date -d "now - $ndays days" +"%y%m%d")
    
    find $adir -maxdepth 1 -type d | sort | while read dir
    do
        test "$AI_DEBUG" && echo "# dir=$dir" >&2
        b=$(basename $dir)
        echo ${b:0:6} | grep -qE "^[0-9]{6}$" || continue
        test ${b:0:6} -lt $start && continue
        test ! -e $dir/imred_$b.txt && test "$AI_DEBUG" &&
            echo "WARNING: file $dir/imred_$b.txt is missing." >&2
        test ! -e $dir/imred_$b.txt && continue
        line=$(grep -nE "^[0-9][0-9]*__.*()" $dir/imred_$b.txt | tr ':' ' ' | awk '{
            if (found==1) {b=$1; found=0}
            if ($2~/__icq_data/) {a=$1; found=1}
            }END{printf("%s %s", a, b)}')
        test -z "$(echo $line)" &&
            echo "ERROR: $b: icq_data not found." >&2 && continue
        test "$AI_DEBUG" && echo "# line: $line" >&2
        first=${line%% *}
        last=${line##* }
        test "$AI_DEBUG" && echo "# $b $first $last $start" >&2
        cat $dir/imred_$b.txt | sed "1,${first}d; ${last},\$d" | \
            grep "^[ ]*[0-9]" | awk -v s=$start '{
            x=substr($0,14,8); y=x
            gsub(" ","",x)
            if (x!=y && x>s) print $0
            }'
    done > $tmpdat
    sort -t "#" -k1.12,1.24 $tmpdat | \
        awk '{if ($0!=last) printf("%s\n", $0); last=$0}'
    
    test "$AI_DEBUG" && echo $tmpdat
    test -z "$AI_DEBUG" && rm -f $tmpdat
    return
}

icqsort () {
    # sort observations in icq format for submission to FGK
    local showhelp
    local sortopts
    local type="by_comet"   # sort type: by_comet or by_date
    local i
    for i in 1 2 3
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-r" && sortopts="-r" && shift 1
        test "$1" == "-d" && type="by_date" && shift 1
    done
    local dat=$1
    local tchars=12-24  # characters defining date and time
    local tmpdat=$(mktemp "/tmp/tmp_dat_$$.XXXXXX.dat")
    local tmpkey=$(mktemp "/tmp/tmp_key_$$.XXXXXX.dat")
    local tmpdsort=$(mktemp "/tmp/tmp_dsort_$$.XXXXXX.dat")
    
    (test "$showhelp" || test $# -ne 1) &&
        echo -e "usage: icqsort [-h] [-r] [-d] <fullicqfile>" >&2 &&
        return 1
    local lnum
    
    test "$dat" == "-" && dat=/dev/stdin
    grep "[0-9]" $dat | grep -v "^#" | grep -n "." > $tmpdat
    cut -d ":" -f2- $tmpdat | cut -c $tchars | grep -n "." > $tmpkey
    # sort everything by date
    cat $tmpkey | sort $sortopts -t ":" -k2,99 | cut -d ":" -f1 | while read lnum
    do
        grep "^$lnum:" $tmpdat | cut -d ":" -f2-
    done > $tmpdsort
    
    if [ "$type" == "by_date" ]
    then
        cat $tmpdsort
    else
        # extract periodic comets
        cat $tmpdsort | awk '{if ($0~/^[0-9 ][0-9 ][0-9]/) print $0}' | \
            sort -s -n -k1
        # extract non-periodic comets
        cat $tmpdsort | awk '{if ($0!~/^[0-9 ][0-9 ][0-9]/) print $0}' | \
            sort -s -k1
    fi
    test "$AI_DEBUG" && echo $tmpdat $tmpkey $tmpdsort >&2
    test -z "$AI_DEBUG" && rm -f $tmpdat $tmpkey $tmpdsort
}

fullicq2web () {
    # convert from full icq data format to short web format
    # short: UT to 0.01 day, chronolog. order
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1

    local dat=$1  # data file containing full format icq data
    local obs="T. Lehmann, Weimar, Germany"
    local clist
    local c
    local cc
    
    (test "$showhelp" || test $# -ne 1) &&
        echo -e "usage: fullicq2web [-h] <fullicqfile>" >&2 &&
        return 1
    
    test ! -f "$dat" && echo "ERROR: data file $dat not found." && return 255

    # get list of comets
    clist=$(grep -v "^#" $dat | cut -c 1-11 | sort -u | sort -n)
    for c in $clist
    do
        test ${#c} -gt 3 && cc="C/${c:0:4} ${c:4:4}" && cs="   $c"
        test ${#c} -le 3 && cc="$c"P && cs=$(printf "%3d " $c)
        echo "COMET $cc"
        grep -v unpublished $dat | grep "^$cs" | awk -v o="$obs" 'BEGIN{
            split("Jan._Feb._Mar._Apr._May_June_July_Aug._Sep._Oct._Nov._Dec.", ma, "_")}{
            y=substr($0,12,4)
            m=substr($0,17,2)
            d=substr($0,20,5)
            mag=substr($0,28,6); gsub(/^[ \t]+/, "", mag); gsub(/[ \t]+$/, "", mag)
            co=substr($0,49,6);  gsub(/^[ \t]+/, "", co); gsub(/[ \t]+$/, "", co)
            if (length(co) == 0) {
                co="--"
            } else {
                if (index(co, ".") > 0) {
                    gsub(/\./, "\047.", co)
                } else {
                    co=co"\047"; gsub(/:\047/, "\047:", co)
                }
            }
            aa=substr($0,36,5)
            t=substr($0,41,1)
            inst="#### UNKNOWN INSTRUMENT ####"
            if (t == "L") inst=sprintf("%.2f-m reflector", aa/100)
            if (t == "A") inst=sprintf("%.0f-cm telephoto lens", aa)
            if (t == "R") inst=sprintf("%.0f-cm refractor", aa)
            if (t == "B") inst=sprintf("%.0f-cm binoculars", aa)
            notes=substr($0,94,100); gsub(/^[ \t]+/, "", notes); gsub(/[ \t]+$/, "", notes)
            if (length(notes) > 0) {
                sub("DSLR green", "CCD via DSLR green", notes)
                sub("CCD/V", "CCD + V filter", notes)
                sub("CCD/G", "CCD + G filter", notes)
                sub(/ remote .Mayhill./, ", remotely from Mayhill, NM, USA", notes)
                sub(/ remote .SSO./,     ", remotely from Siding Spring Obs., Australia", notes)
                sub(/ remote .Nerpio./,  ", remotely from Nerpio, Spain", notes)
                sub(/ remote .Bathurst./,", remotely from Bathurst, Australia", notes)
                notes=" + "notes
            }
            if (y != lasty) print y
            printf("%4s %5.2f, %s, %s (%s, %s%s);\n", ma[1*m], d, mag, co, o, inst, notes)
            lasty=y
        }'
        echo ""
    done
}

comet_lightcurve () {
    # create comet lightcurve from icq formatted observations data file
    # format of photometric data records: <utday>,<mag>,<coma>
    #   e.g. 20140910.75,13.8,1.6
    local showhelp
    local i
    local title     # plot title, e.g. "C/2014 Q2 (Lovejoy)  2014 - 2015"
    local fsizeadd=0    # additive correction to default font size
    local mpcparam  # use this set of model parameters for MPC curve, format: <g>,<k> e.g. 8.5,4
    local newparam  # if set, plot additional model curve, format: <g>,<k>
    local keypos="top left reverse Left invert" # e.g. "bottom right"
    local kwidthadd=0   # additive correction to key area width
    local do_big    # if set create large plot
    local size="6.5,4.5"  # w,h page size of output file (inches)
    local do_update # if set download new elements (MPCORB), ICQ and FGK observations
    local xrange    # date range
    local yrange    # mag range
    local do_all_data   # plot all data, do not limit to interval from obsdat
    local visdb="cobs"  # comma separated list of visual observations databases
                        # known databases are cobs, icq, fgk
    local do_plot_distance  # overplot solar distance
    local otherdat  # additional photometry data file: yyyymmdd.dd,mag
    local otherdesc
    local obs="mag"
    local color
    local ptsize
    local days
    local peri
    local startymd
    local x
    for i in $(seq 1 18)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-t" && title="$2"     && shift 2
        test "$1" == "-f" && fsizeadd="$2"  && shift 2
        test "$1" == "-m" && mpcparam="$2"  && shift 2
        test "$1" == "-n" && newparam="$2"  && shift 2
        test "$1" == "-k" && keypos="$2"    && shift 2
        test "$1" == "-w" && kwidthadd="$2" && shift 2
        test "$1" == "-x" && xrange="$2"    && shift 2
        test "$1" == "-y" && yrange="$2"    && shift 2
        test "$1" == "-b" && do_big=1       && shift 1
        test "$1" == "-l" && size="$2"      && shift 2
        test "$1" == "-u" && do_update=1    && shift 1
        test "$1" == "-p" && obs="pa"       && shift 1
        test "$1" == "-c" && obs="coma"     && shift 1
        test "$1" == "-a" && do_all_data=1  && shift 1
        test "$1" == "-v" && visdb="$2"     && shift 2
        test "$1" == "-d" && do_plot_distance=1 && shift 1
        test "$1" == "-o" && otherdat=${2/,*/} && otherdesc=${2#*,} && shift 2
    done
    
    local comet=$1
    local obsdat=$2     # containing records in ICQ data format
    local dslrdesc=${3:-"DSLR/G (T. Lehmann)"}
    local ccddesc=${4:-"CCD/G (T. Lehmann)"}
    local visdesc
    local mpcorburl="http://www.minorplanetcenter.net/iau/MPCORB/CometEls.txt"
    local icqobsurl="http://www.icq.eps.harvard.edu/CometMags.html"
    local fgkobsurl="http://kometen.fg-vds.de/fgicq.zip"
    local fgkobsurl2="http://kometen.fg-vds.de/older_fgicq.zip"
    local outfile
    local cname
    local n
    local latest
    local dhr=0
    local mpcorb
    local date
    local endymd
    local d
    local r
    local mag
    local coma
    local retval
    local size
    local fsize
    local plotcmd
    local incr
    local xticsfmt
    local drange
    local dinter
    local docviewer
    local ocol
    local interval
    
    local tmp1=$(mktemp "/tmp/tmp_tmp1_$$.XXXXXX.dat")
    local tmpcobs=$(mktemp "/tmp/tmp_cobs_$$.XXXXXX.dat")
    local tmpobs=$(mktemp "/tmp/tmp_obs_$$.XXXXXX.dat")
    local tmpmpc=$(mktemp "/tmp/tmp_mpc_$$.XXXXXX.dat")
    local tmpgp=$(mktemp "/tmp/tmp_gp_$$.XXXXXX.gp")


    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: comet_lightcurve [-h] [-u] [-b | -l w,h|$size] [-v visdb|$visdb] [-d] [-a] [-t <plottitle>] [-m <mpc_g,k,desc>]" \
            "[-n <new_g,k,desc>] [-f <fontsize-add>] [-k <keypos>] [-w <keywidth-add>]" \
            "[-x start_YYYYMMDD:end_YYYYMMDD] [-y ymin:ymax] <comet> <obsdat>" \
            "[dslrlabel|$dslrdesc] [ccdlabel|$ccddesc]" >&2 &&
        return 1
    
    test ! -f "$obsdat" && echo "ERROR: observations data file $obsdat not found." >&2 && return 255
    test "$obs" != "mag" && mpcparam=0 && newparam=""
    test "$xrange" && test "$xrange" == "${xrange/:/}" && xrange=$xrange":"


    # -------------------------
    # process own observations
    # -------------------------
    cname=${comet%P}
    grep "^[ ]*$cname[ ]*[0-9][0-9][0-9][0-9] " $obsdat | awk -v o=$obs '{
        date=substr($0,12,4)""substr($0,17,2)""substr($0,20,5); gsub(/ /,"0",date)
        method=substr($0,27,1)
        #if (method == "Z") next
        if (substr($0,28,1) == "[") next
        mag=substr($0,29,5);  gsub(/ /,"",mag)
        coma=substr($0,49,6); gsub(/ /,"",coma); if (coma=="") coma=-1
        pa=substr($0,65,3); gsub(/ /,"",pa);    if (pa=="") pa=-1
        obs=substr($0,76,10); gsub(/ /,"",obs)
        if (substr($0,88) ~ /CCD/) {
            printf("ccd,%s,%s,%s,%s,%s,%s\n", method, date, mag, coma, pa, obs)
        } else {
            printf("dslr,%s,%s,%s,%s,%s,%s\n", method, date, mag, coma, pa, obs)
        }
    }' > $tmpobs
    if [ ! -s $tmpobs ]
    then
        echo "WARNING: no observation records found for comet $cname." >&2
    else
        n=$(grep "^dslr," $tmpobs | wc -l)
        test $n -gt 0 && printf "# %4s %4d\n" "DSLR" $n
        n=$(grep "^ccd," $tmpobs | wc -l)
        test $n -gt 0 && printf "# %4s %4d\n" "CCD" $n
    fi


    # --------------------------------------------------
    # retrieve data from visual observations databases
    # --------------------------------------------------
    cname=${comet%P}
    is_number "$cname" && cname="${cname}P"
    latest="latest.$cname.dat"
    test -f "$latest" &&
        dhr=$(echo $(date +'%s') $(stat -c '%Y' $latest) | \
            awk '{printf("%.0f", ($1-$2)/3600)}')
     
    
    # process observations from COBS (ICQ format)
    if echo $visdb | grep -qw cobs
    then
        n=0
        if [ -f "$latest" ] && [ $dhr -lt 24 ]
        then
            grep "^cobs," $latest > $tmp1
            n=$(cat $tmp1 | wc -l)
            test $n -gt 0 && printf "# %4s %4d  %s\n" "COBS" $n "($latest)"
        fi
        if [ $n -eq 0 ]
        then
            get_cobs $cname > $tmpcobs
            if [ ! -s $tmpcobs ]
            then
                echo "WARNING: no COBS observations." >&2
            else
                cname=${comet%P}
                grep "^[ ]*$cname[ ]*[0-9][0-9][0-9][0-9] " $tmpcobs | awk -v o=$obs '{
                    date=substr($0,12,4)""substr($0,17,2)""substr($0,20,5); gsub(/ /,"0",date)
                    method=substr($0,27,1)
                    if (method == "Z") next
                    if (substr($0,28,1) == "[") next
                    mag=substr($0,29,5);  gsub(/ /,"",mag)
                    coma=substr($0,49,6); gsub(/ /,"",coma); if (coma=="") coma=-1
                    pa=substr($0,65,3); gsub(/ /,"",pa);    if (pa=="") pa=-1
                    obs=substr($0,76,10); gsub(/ /,"",obs)
                    
                    printf("cobs,%s,%s,%s,%s,%s,%s\n", method, date, mag, coma, pa, obs)
                }' > $tmp1
                n=$(cat $tmp1 | wc -l)
                printf "# %4s %4d\n" "COBS" $n
            fi
        fi
        test $n -gt 0 && cat $tmp1 >> $tmpobs
    fi


    # download latest ICQ comet magnitudes (web data)
    cname="$comet"
    is_number ${comet%P} && cname=$(printf "%04gP" ${comet%P})
    if echo $visdb | grep -qw icq
    then
        n=0
        if [ -f "$latest" ] && [ $dhr -lt 120 ]
        then
            grep "^icq," $latest > $tmp1
            n=$(cat $tmp1 | wc -l)
            test $n -gt 0 && printf "# %4s %4d  %s\n" "ICQ" $n "($latest)"
        fi
        if [ $n -eq 0 ]
        then
            (test ! -f CometMags.html || test "$do_update") &&
                rm -f CometMags.html &&
                wget -nH $icqobsurl
            cat CometMags.html | awk -v c="$cname" -v o=$obs 'BEGIN{
                cpat="^<a name=\""c"\""
            }{
                if ($0~cpat) {found=1; y=0; m=0; d=0; next}
                if (found==1 && $0~/^<a name=/) found=0
                if (found==1) {
                    if ($1~/^Total/) next
                    if ($1~/<b>[0-9][0-9][0-9][0-9]<\/b>/) {
                        gsub(/[^0-9]/,"",$1); y=$1; next
                    }
                    if ($1 ~ /^[A-Z]/) {
                        ismonth=0
                        if ($1 == "Jan.") {m=1; ismonth=1}
                        if ($1 == "Feb.") {m=2; ismonth=1}
                        if ($1 == "Mar.") {m=3; ismonth=1}
                        if ($1 == "Apr.") {m=4; ismonth=1}
                        if ($1 == "May")  {m=5; ismonth=1}
                        if ($1 == "June") {m=6; ismonth=1}
                        if ($1 == "July") {m=7; ismonth=1}
                        if ($1 == "Aug.") {m=8; ismonth=1}
                        if ($1 == "Sep.") {m=9; ismonth=1}
                        if ($1 == "Oct.") {m=10; ismonth=1}
                        if ($1 == "Nov.") {m=11; ismonth=1}
                        if ($1 == "Dec.") {m=12; ismonth=1}
                        if (ismonth==0) {
                            printf("# %s\n", $0); next
                        } else {
                            d=$2; sub(/,$/,"",d)
                        }
                    } else {
                        d=$1; sub(/,$/,"",d)
                    }
                    split($0,a,",")
                    mag=a[2];  gsub(/ /,"",mag)
                    coma=a[3]; gsub(/[\047 ]/,"",coma); gsub(/\(.*/,"",coma)
                    method="S"
                    if ($0 ~ /CCD/) method="C"
                    if (o=="mag" && substr(mag,1,1) ~ /\[/) next
                    if (NF>=3) {
                        printf("icq,%s,%4d%02d%05.2f,%s,%s,-1 # %s\n", method, y, m, d, mag, coma, $0)
                    }
                }
            }' > $tmp1
            #'
            n=$(cat $tmp1 | wc -l)
            printf "# %4s %4d\n" "ICQ" $n
        fi
        test $n -gt 0 && cat $tmp1 >> $tmpobs
    fi


    # download observations from FG Kometen (ICQ format)
    cname=${comet%P}
    if echo $visdb | grep -qw fgk
    then
        if [ "$do_update" ]
        then
            rm -f fgk.icq
            wget $fgkobsurl -O $tmp1
            unzip -p $tmp1 > fgk.icq
            wget $fgkobsurl2 -O $tmp1
            unzip -p $tmp1 >> fgk.icq
        fi
        if [ -s fgk.icq ]
        then
            grep "^[ ]*$cname[ ]*[0-9][0-9][0-9][0-9] " fgk.icq | awk '{
                date=substr($0,12,4)""substr($0,17,2)""substr($0,20,5); gsub(/ /,"0",date)
                method=substr($0,27,1); sub(/[ -]/,"S",method)
                if (method == "Z") next
                if (substr($0,28,1) == "[") next
                mag=substr($0,29,5);  gsub(/ /,"",mag)
                coma=substr($0,49,6); gsub(/ /,"",coma); if (coma=="") coma=-1
                pa=substr($0,65,3); gsub(/ /,"",pa);    if (pa=="") pa=-1
                obs=substr($0,76,10); gsub(/ /,"",obs)

                printf("fgk,%s,%s,%s,%s,%s,%s\n", method, date, mag, coma, pa, obs)
            }' > $tmp1
            n=$(cat $tmp1 | wc -l)
            printf "# %4s %4d\n" "FGK" $n
            cat $tmp1 >> $tmpobs
        fi
    fi
    
    # save all observations
    cp $tmpobs $latest
    
    # select observations according to type
    cat $latest | 
    grep -v "^#" $latest | awk -F ',' -v o=$obs '{
        if (o=="mag"  && $4>=0) print $0
        if (o=="coma" && $5>=0) print $0
        if (o=="pa"   && $6>=0) print $0
    }' > $tmpobs
    
    
    # ------------------------------
    # determine time range for plot
    # ------------------------------
    
    # determine startymd, endymd and number of days
    if [ "$do_all_data" ]
    then
        startymd=$(grep -v "^#" $tmpobs | \
            sort -t ',' -k3,3 | lines 1 | awk -F ',' '{printf("%d", int($3))}')
        endymd=$(grep -v "^#" $tmpobs | \
            sort -t ',' -k3,3 | tail -1 | awk -F ',' '{printf("%d", int($3)+1)}')
    else
        startymd=$(grep -E "^dslr,|^ccd," $tmpobs | \
            sort -t ',' -k3,3 | lines 1 | awk -F ',' '{printf("%d", int($3))}')
        endymd=$(grep -E "^dslr,|^ccd," $tmpobs | \
            sort -t ',' -k3,3 | tail -1 | awk -F ',' '{printf("%d", int($3)+1)}')
    fi
    if [ -z "$startymd" ]
    then
        echo "WARNING: no observations data to plot." >&2
        startymd=$(date -d 'now - 2 month' '+%Y%m%d')
        endymd=$(date -d 'now + 4 month' '+%Y%m%d')
    fi
    days=$(echo "$(ut2jd 12 ${endymd}) - $(ut2jd 12 ${startymd}) + 1" | bc | cut -d "." -f1)
    echo "# start=$startymd  end=$endymd  days=$days" >&2
    
    # apply x-axis range
    if [ "$xrange" ]
    then
        test "${xrange%:*}" && startymd=${xrange%:*}
        test "${xrange#*:}" && endymd=${xrange#*:}
        days=$(echo "$(ut2jd 12 ${endymd}) - $(ut2jd 12 ${startymd}) + 1" | bc | cut -d "." -f1)
        # add some margin around xrange
        xrange=$(echo $xrange | awk -v d=$days '{
            split($1,a,/:/)
            if (a[1]!="") {
                str=substr(a[1],1,4)" "substr(a[1],5,2)" "substr(a[1],7,2)" 0 0 0"
                x=strftime("\"%Y%m%d\"", mktime(str)-d/20*24*3600)
            }
            if (a[2]!="") {
                str=substr(a[2],1,4)" "substr(a[2],5,2)" "substr(a[2],7,2)" 0 0 0"
                y=strftime("\"%Y%m%d\"", mktime(str)+d/20*24*3600)
            }
            printf("%s:%s", x, y)
        }')
        echo "# using xrange:  start=$startymd  end=$endymd  days=$days" >&2
        echo "# xrange: $xrange" >&2
    fi

    # code source of observation and apply time range
    grep -v "^#" $latest | awk -F ',' -v a=$startymd -v b=$endymd '{
            src=0
            if ($1=="dslr") src=1
            if ($1=="ccd")  src=2
            if ($1=="cobs") src=3
            if ($1=="icq")  src=4
            if ($1=="fgk")  src=5
            if (src>2 && $2!~/^[BEIMOSZ-]$/) src=src+10  # CCD observation, not vis. equivalent
            # limit time range
            if ($3>=a && $3<=b) printf("%s,%s,%s,%s,%s,%s\n", $1, src, $2, $3, $4, $5)
        }' > $tmpobs
    n=$(cat $tmpobs | wc -l)
    echo "# using $n/$(grep -v "^#" $latest | wc -l) observations of type $obs" >&2


    # ---------------------------------
    # create ephemerides from MPC data
    # ---------------------------------
    
    # download MPCORB data
    cname=${comet%P}
    (test ! -f CometEls.txt || test "$do_update") &&
        rm -f CometEls.txt &&
        wget -nH $mpcorburl
    mpcorb=$(cat CometEls.txt | awk -v c="$cname" 'BEGIN{
        if (c~/^[0-9]{4}[A-Z]/) {
            cpat="^C/"substr(c,1,4)" "substr(c,5)" "
        } else {
            cpat="^"c"P/"
        }
        }{
        cname=substr($0,103,57)
        if (cname ~ cpat) {
            sub(/[ ]*$/,"",cname)
            peri=substr($0,15,14); gsub(/ /,"",peri)
            m0=substr($0,92,4)
            slope=substr($0,97,4)
            ref=substr($0,160); sub(/[ ]*$/,"",ref)
            printf("%s,%s,%.1f,%.1f,%s\n", cname, peri, m0, slope, ref)
        }
        }')
    test -z "$mpcorb" &&
        echo "ERROR: comet not found in CometEls.txt (try -u switch?)." >&2 && return 255
    test "$AI_DEBUG" && echo "mpcorb=$mpcorb" >&2

    # set title if empty
    test "$comet" == "${comet//[A-Z]/}" && comet=$comet"P"
    if [ ! "$title" ]
    then
        title=${mpcorb%%,*}"  - "
        test "$obs" == "mag"  && title="$title Light Curve"
        test "$obs" == "coma" && title="$title Coma Diameter"
        test "$obs" == "pa"   && title="$title Tail PA"
        title="$title ${startymd:0:4}"
        test ${startymd:0:4} -ne ${endymd:0:4} && title="$title - ${endymd:0:4}"
    fi
    # set parameters of model curves
    test -z "$mpcparam" &&
        mpcparam=$(echo $mpcorb | awk -F "," '{print $3","$4",Model ("$5")"}')
    test "$newparam" &&
        test -z "$(echo $newparam | cut -d ',' -f3)" &&
        newparam="$newparam,m = ${newparam%,*} + 5log(D) + ${newparam#*,} x 2.5log(r)"
    echo "# title=$title" >&2
    echo "# mpcparam=$mpcparam" >&2
    test "$newparam" && echo "# newparam=$newparam" >&2
    # get time of perihel
    peri=$(echo $mpcorb | awk -F "," '{print $2}')
    
    # download and process MPC ephemerides
    cname="$comet"
    is_number ${comet%P} && cname="${comet%P}P"
    interval=24
    test $days -gt 1000 && interval=48
    test $days -gt 2000 && interval=96
    test $days -gt 5000 && interval=240
    echo "# running: get_mpcephem -n $((days*24/interval+1)) -i $interval $cname $startymd 0" >&2
    AI_SITE="" get_mpcephem -n $((days*24/interval+1)) -i $interval $cname $startymd 0 > $tmp1 2>/dev/null
    test $? -ne 0 &&
        echo "ERROR during get_mpcephem" >&2 &&
        return 255

    grep -v "^#" $tmp1 | while read
    do
        test "${REPLY:0:1}" == "#" && continue
        date="${REPLY:0:4}${REPLY:5:2}${REPLY:8:2}"
        d="${REPLY:40:6}"
        r="${REPLY:48:6}"
        mag="${REPLY:69:4}"
        echo "$date,$d,$r,$mag"
    done > $tmpmpc
    test "$AI_DEBUG" && wc -l $tmpmpc >&2
    # determine distance range
    drange=$(sort -n -t ',' $tmpmpc -k3,3 | awk -F ',' '{
        if(NR==1) x=$3} END {y=$3; m=(y-x)/10; printf("%f:%f", x-m, y+m)}')
    dinter=$(echo $drange | awk -F ':' '{dr=$2-$1; x=0.1
        if(dr>0.6)  x=0.2
        if (dr>1.5) x=0.5
        if (dr>3)   x=1
        print x}')
    echo "# drange=$drange  dinter=$dinter" >&2
    
    
    # -----------------------------
    # plotting
    # -----------------------------
    
    # gnuplot
    # pngcairo:
    #outfile=$comet.$obs.$(date +'%y%m%d').png
    #size="700,480"; fsize=11
    #test "$do_big" && size="900,600"; fsize=12
    # postscript:
    outfile=$comet.$obs.$(date +'%y%m%d').eps
    #test "$do_big" && size="7,4.9"
    #size="6.5,4.5"
    fsize=$(echo ${size#,*} $fsizeadd | awk '{printf("%.0f", $1*1.6+10+$2)}')
    cat <<EOF > $tmpgp
#set term pngcairo size $size font "Arial,$fsize" enhanced
set term postscript size $size font ",$fsize" enhanced eps color blacktext dashlength 2.5
set output "$outfile"
set border lw 1
set xtics nomirror
set ytics nomirror
set grid lc rgb '#808080'
#set key $keypos samplen 1 spacing 1.0 font "Arial,$((fsize-2))"
set key ${keypos//_/ } height +0.5 width ${kwidthadd//_/ } samplen 1 spacing 1.2 font ",$((fsize-2))"

set datafile separator ","
set xdata time
set timefmt "%Y%m%d"
set title '${title//_/ }' font ",$((fsize+4))"
set xlabel 'Date'
set arrow from '$peri', graph 0.98 to '$peri', graph 1 nohead
set label "P" at '$peri', graph 0.95 center
EOF

    # set xrange
    test "$xrange" && echo "set xrange [$xrange]" >> $tmpgp

    # set yrange, obscolumn
    case $obs in
        mag)    ocol=5
                echo "set yrange [$yrange] reverse" >> $tmpgp
                echo "set ylabel 'mag' offset 1" >> $tmpgp
                ;;
        pa)     ocol=5
                echo "set yrange [$yrange]" >> $tmpgp
                echo "set ylabel 'degrees' offset 1" >> $tmpgp
                ;;
        coma)   ocol=6
                echo "set yrange [$yrange]" >> $tmpgp
                echo "set ylabel 'arcmin' offset 1" >> $tmpgp
                ;;
    esac
    
    # set xtics "20110105", 1209600, "20110430"  # interval in seconds
    # 1 month = 365.2425/12 days
    incr=$(echo $days | awk -v y=365.2425 '{
        x=$1/5; d=0
        if (x<450) d=y
        if (x<250) d=y/2
        if (x<150) d=4*y/12
        if (x<100) d=3*y/12
        if (x<75)  d=2*y/12
        if (x<45)  d=y/12
        if (x<22)  d=14
        if (x<11)  d=7
        if (x<6.0) d=5
        if (x<3.5) d=2
        if (x<1.5) d=1
        if (d>0) printf("%.1f", d)}')
    xticsfmt="%Y"
    if [ "$incr" ]
    then
        echo "# incr=$incr" >&2
        test ${incr%.*} -lt 300 && xticsfmt="%b \'%y"
        #'
        test ${incr%.*} -lt  70 && xticsfmt="%b"
        test ${incr%.*} -lt  20 && xticsfmt="%b %d"
        if [ ${incr%.*} -lt 150 ] && [ ${incr%.*} -gt 20 ]
        then
            # start tics at beginning of month
            incr=$(echo $incr | awk -v s=$startymd '{
                a=int(s/100)*100+1
                printf("\"%d\",%d", a, $1*24*3600)}')
        else 
            incr=$(echo $incr | awk '{
                printf("%d", $1*24*3600)}')
        fi
    fi
    echo "# set xtics $incr format \"$xticsfmt\"" >&2
    echo "set xtics $incr format \"$xticsfmt\"" >> $tmpgp
    
    test "$mpcparam" && test "$mpcparam" != "0" && (cat <<EOF >> $tmpgp
gmpc='$(echo $mpcparam | cut -d ',' -f1)'
kmpc='$(echo $mpcparam | cut -d ',' -f2)'
tmpc='$(echo $mpcparam | cut -d ',' -f3-)'
EOF
)
    test "$newparam" && (cat <<EOF >> $tmpgp
gnew='$(echo $newparam | cut -d ',' -f1)'
knew='$(echo $newparam | cut -d ',' -f2)'
tnew='$(echo $newparam | cut -d ',' -f3-)'
EOF
)

    # plotting solar distance
    plotcmd="plot"
    test "$do_plot_distance" && (cat << EOF >> $tmpgp
set y2range [$drange]
set y2label 'r_{sun} / AU' offset -1
set y2tics $dinter
$plotcmd '$tmpmpc'  using 1:(\$1>$startymd && \$1<=$endymd ? \$3 : 1/0) \\
        title 'Heliocentric Distance' lw 2 lc rgb '#D07010' lt 3 with lines axes x1y2 \\
EOF
) && plotcmd="    ,"

    
    # MPC model data
    if [ "$mpcparam" ] && [ "$mpcparam" != "0" ]
    then
        cat <<EOF >> $tmpgp
$plotcmd '$tmpmpc'  using 1:(\$1>$startymd && \$1<=$endymd ? gmpc + 5*log10(\$2) + 2.5*kmpc*log10(\$3) : 1/0) \\
        title tmpc  lw 2 lc rgb '#B0D0F0' lt 1 with lines \\
EOF
        plotcmd="    ,"
    fi
    if [ ! "$mpcparam" ]
    then
        cat <<EOF >> $tmpgp
$plotcmd '$tmpmpc'  using 1:(\$1>=$startymd && \$1<=$endymd ? \$4 : 1/0) \\
        title 'MPC model' pt 7 ps 0.5 lw 2 lc rgb '#B0D0F0' lt 1 \\
EOF
        plotcmd="    ,"
    fi

    # new model data
    if [ "$newparam" ]
    then
        cat <<EOF >> $tmpgp
$plotcmd '$tmpmpc' using 1:(\$1>=$startymd && \$1<=$endymd ? gnew + 5*log10(\$2) + 2.5*knew*log10(\$3) : 1/0) \\
        title tnew lw 2 lc rgb '#80E870' lt 1 with lines \\
EOF
        plotcmd="    ,"
    fi


    # determine point size
    ptsize=1.4
    n=$(cat $tmpobs | wc -l)
    test $n -gt 20 && ptsize=1.3
    test $n -gt 100 && ptsize=1.2

    # observations from COBS,ICQ,FGK
    # CCD: src=13,14,15
    visdesc=""
    grep -q "^cobs," $tmpobs && visdesc="COBS"
    grep -q "^icq,"  $tmpobs && visdesc="$visdesc,ICQ"
    grep -q "^fgk,"  $tmpobs && visdesc="$visdesc,FGK"
    n=$(grep -E "^cobs,1[345],|^icq,1[345],|^fgk,1[345]," $tmpobs | wc -l)
    if [ $n -gt 0 ]
    then
        color="#90B0C8"  # #90B0C8 #D0B040 #60C840
        test $n -lt 25 && color="#6295BA"
        cat <<EOF >> $tmpgp
$plotcmd '$tmpobs'  using 4:(\$2>=10 ? \$$ocol : 1/0) \\
        title 'CCD (${visdesc##,})' pt 6 ps $ptsize lc rgb '$color' \\
EOF
        plotcmd="    ,"
    fi

    # vis. or CCD vis. equivalent: src=3,4,5
    visdesc=""
    grep -q "^cobs," $tmpobs && visdesc="COBS"
    grep -q "^icq,"  $tmpobs && visdesc="$visdesc,ICQ"
    grep -q "^fgk,"  $tmpobs && visdesc="$visdesc,FGK"
    n=$(grep -E "^cobs,[345],|^icq,[345],|^fgk,[345]," $tmpobs | wc -l)
    if [ $n -gt 0 ]
    then
        color="#E6C886"  # #90B0C8 #D0B040 #60C840
        test $n -lt 25 && color="#DBAE4B"
        cat <<EOF >> $tmpgp
$plotcmd '$tmpobs'  using 4:((\$2==3 || \$2==4 || \$2==5) ? \$$ocol : 1/0) \\
        title 'vis. (${visdesc##,})' pt 6 ps $ptsize lc rgb '$color' \\
EOF
        plotcmd="    ,"
    fi


    # intern (own) observations
    # CCD observations, src=2
    if grep -q "^ccd,2," $tmpobs
    then
        cat <<EOF >> $tmpgp
$plotcmd '$tmpobs'  using 4:(\$2==2 ? \$$ocol : 1/0) \\
        title '$ccddesc' pt 7 ps $ptsize lc rgb '#0000F0' \\
EOF
        plotcmd="    ,"
    fi

    # DSLR or visual observations, src=1
    if grep -q "^dslr,1," $tmpobs
    then
        cat <<EOF >> $tmpgp
$plotcmd '$tmpobs'  using 4:(\$2==1 ? \$$ocol : 1/0) \\
        title '$dslrdesc' pt 7 ps $ptsize lc rgb '#D03000' \\
EOF
        plotcmd="    ,"
    fi

    # other extern observations (obs data in column 2)
    if [ -f "$otherdat" ]
    then
        color="#91D8FF"  # #FCD974 #39B92E #F05020
        x=$(echo $ptsize | awk '{print $1*0.7}')
        cat <<EOF >> $tmpgp
$plotcmd '$otherdat'  using 1:(\$1>=$startymd && \$1<=$endymd ? \$2 : 1/0) \\
        title '$otherdesc' pt 7 ps $ptsize lc rgb '$color' \\
EOF
        plotcmd="    ,"
    fi
    

    # run gnuplot
    cat $tmpgp | gnuplot -p
    retval=$?
    if [ $retval -eq 0 ]
    then
        # show plot
        #docviewer="evinve"
        docviewer="xdg-open"
        ps uxaw | grep -vw grep | grep -q "$USER .* $docviewer $outfile" || \
            (echo "# displaying $outfile ..." >&2; $docviewer $outfile 2>/dev/null &)
    fi

    if [ "$AI_DEBUG" ] || [ $retval -ne 0 ]
    then
        echo "obs:     $tmpobs"
        echo "mpc:     $tmpmpc"
        echo "gnuplot: $tmpgp"
    else
        rm $tmp1 $tmpcobs $tmpobs $tmpmpc $tmpgp
    fi
    return $retval
}

# get ids from ds9 region file
regid () {
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    local reg=$1

    (test "$showhelp" || test $# -ne 1) &&
        echo "usage: regid <reg>" >&2 &&
        return 1
    
    cat $reg | grep "# text={" | tr '}' ' ' | cut -d '{' -f2 | cut -d ' ' -f1
}

get_xephemdb () {
    # download comets ephemeris database
    local showhelp
    local i
    local source=mpc
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-v" && source=vanbuitenen && shift 1
    done
    
    local db=Soft03Cmt.edb
    local ts
 
    (test "$showhelp" || test $# -gt 0) &&
        echo "usage: get_xephemdb [-v]" >&2 &&
        return 1
   
    case $source in
        mpc)
            url="http://www.minorplanetcenter.net/iau/Ephemerides/Comets/Soft03Cmt.txt"
            ;;
        vanbuitenen)
            echo "# unofficial database provided by http://astro.vanbuitenen.nl" >&2
            url="http://astro.vanbuitenen.nl/cometelements?format=xephem"
            ;;
        *)  echo "ERROR: source url is not defined." >&2 && return 255
            ;;
    esac
    if [ -f $db ]
    then
        ts=$(date +"%Y%m%d" -d "@$(stat -c "%Y" $db)")
        mv $db ${db%.*}_$ts.${db##*.}
    fi
    wget -N -nH -O $db $url
}


gplinfit () {
    # linear fit on data by using gnuplot
    # note: x,y values are subtracted by mean
    local showhelp
    local quiet
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-q" && quiet=1 && shift 1
    done
    local dat=$1
    local xc=${2:-1}
    local yc=${3:-2}
    local tmpdat=$(mktemp "/tmp/tmp_data_$$.XXXXXX.dat")
    local xm
    local ym
    local sd
    local maxslope
    local retval

    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: gplinfit [-q] <dat> [xcol|$xc] [ycol|$yc]" >&2 &&
        return 255

    cat $dat > $tmpdat
    xm=$(mean $tmpdat $xc)
    ym=$(mean $tmpdat $yc)
    sd=$(stddev $tmpdat $yc)
    
    # determine maximal slope of data points
    maxslope=$(echo $(minmax $tmpdat $xc) $(minmax $tmpdat $yc) | awk '{
        print ($4-$3)/($2-$1)}')
    
    test -z "$quiet" && echo "# xm=$xm ym=$ym sd=$sd maxslope=$maxslope" >&2
    echo "$(test "$quiet" && echo set fit quiet)
        set fit errorvariables
        set fit limit 1e-13
        a = $ym; a0_err=$sd
        if (a == 0) a=$sd/10
        b = $maxslope/10; a1_err=$maxslope/2
        f(x) = a + b*(x-$xm)
        fit f(x) '$tmpdat' using $xc:$yc via a, b
        
        # write coefficients to stdout
        set print '/dev/stdout'
        print FIT_NDF, FIT_STDFIT
        print \"a \", a-b*$xm, a_err
        print \"b \", b, b_err
        " | gnuplot -p
    retval=$?
    rm -f $tmpdat
    return $retval
}

plot2d () {
    # input data file with columns x y z
    local showhelp
    local outfile='x.plot2d.png' # output PNG file
    local title         # plot title
    local crange        # range of data values, either dz or z1:z2
    local log           # if set then apply log scaling to z
    local bounds        # bounding box x1:x2,y1:y2
    local i
    for i in $(seq 1 6)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-o" && outfile="$2" && shift 2
        test "$1" == "-t" && title="$2" && shift 2
        test "$1" == "-r" && crange="$2" && shift 2
        test "$1" == "-l" && log=1 && shift 1
        test "$1" == "-b" && bounds="$2" && shift 2
    done
    local dat=$1
    local gpversion
    local zmin
    local zmax
    local zm
    local retval
    local tmpgp=$(mktemp "/tmp/tmp_gp_$$.XXXXXX.gp")

    (test "$showhelp" || test $# -ne 1) &&
        echo "usage: plot2d [-o outfile|$outfile] [-l] [-r z1:z2] [-b x1:x2,y1:y2] [-t title] <data>" >&2 &&
        return 255

    gpversion=$(gnuplot -V | awk '{printf("%s", $2)}')
    case "$gpversion" in
        4*) ;;
        5*) ;;
        *)  echo "ERROR: unsupported gnuplot version $gpversion." >&2
            return 255
    esac

    # range in z
    set - $(minmax $dat 3)
    zmin=$1
    zmax=$2
    zm=$(median $dat 3)

    # plot settings
    echo "\
    # plot settings
    set terminal pngcairo enhanced font 'sans,10' size 630,460
    set output '$outfile'
    set size ratio -1
    set nokey" >> $tmpgp
    test "$title" && echo "    set title '$title'" >> $tmpgp
    if [ "$bounds" ]
    then
        echo "    set xrange [${bounds%,*}]" >> $tmpgp
        echo "    set yrange [${bounds#*,}]" >> $tmpgp
    fi
    if [ "$log" ]
    then
        echo "    set logscale cb" >> $tmpgp
        # TODO: get reasonable estimate of tic labels spacing (multiplicative)
        #echo "    set cbtics 2" >> $tmpgp
    fi
    if [ "$crange" ]
    then
        if [ "${crange/:/ }" != "$crange" ]
        then
            echo "    set cbrange [$crange]" >> $tmpgp
        else
            zmin=$(echo $zm $crange | awk '{printf("%f",$1-$2/2)}')
            zmax=$(echo $zm $crange | awk '{printf("%f",$1+$2/2)}')
            echo "    set cbrange [$zmin:$zmax]" >> $tmpgp
        fi
    fi
    echo "\
    plot '$dat' with image
    #show variables all
    " >> $tmpgp
    gnuplot -p $tmpgp
    retval=$?
    (test "$AI_DEBUG" || test $retval -ne 0) &&
        echo "# $tmpgp" >&2 && return $retval
        
    rm -f $tmpgp
    return
}

gpsurfit () {
    # surface fit on 2D data by using gnuplot
    # note: x,y values are subtracted by mean
    # input data: x y z
    local showhelp
    local mode="poly2"      # fitting function type
    local outfile="x.surfit.dat" # file to store fitted data grid x y z
    local samples="50:30"   # sampling points of fitted data (nx:ny)
    local quiet
    local i
    for i in $(seq 1 6)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-q" && quiet=1 && shift 1
        test "$1" == "-p" && mode="plane" && shift 1
        test "$1" == "-p2" && mode="poly2" && shift 1
        test "$1" == "-p3" && mode="poly3" && shift 1
        test "$1" == "-p4" && mode="poly4" && shift 1
        test "$1" == "-o" && outfile="$2" && shift 2
        test "$1" == "-s" && samples="$2" && shift 2
    done
    
    local dat=$1
    local ndig=2
    local fitfun
    local fitvars
    local xm    # mean x value from input data
    local ym
    local xmin  # min value
    local ymin
    local xmax  # max value
    local ymax
    local gpversion
    local tmp1=$(mktemp "/tmp/tmp_tmp1_$$.XXXXXX.dat")
    local tmpgp=$(mktemp "/tmp/tmp_gp_$$.XXXXXX.gp")
    local tmplog=$(mktemp "/tmp/tmp_gpout_$$.XXXXXX.log")
    
    (test "$showhelp" || test $# -ne 1) &&
        echo "usage: gpsurfit [-q] [-p|-p3|-p4] [-o outfile|$outfile] [-s samples|$samples] <data>" >&2 &&
        return 255

    gpversion=$(gnuplot -V | awk '{printf("%s", $2)}')
    case "$gpversion" in
        4*) ;;
        5*) ;;
        *)  echo "ERROR: unsupported gnuplot version $gpversion." >&2
            return 255
    esac

    cat $dat > $tmp1
    # range in x,y
    xm=$(mean $tmp1 1)
    set - $(minmax $tmp1 1)
    xmin=$1
    xmax=$2
    ym=$(mean $tmp1 2)
    set - $(minmax $tmp1 2)
    ymin=$1
    ymax=$2

    # mean value
    set - $(kappasigma $tmp1 3)
    # determine number of useful digits from uncertainty
    # echo "l($2)/l(10)" | bc -l
    test -z "$quiet" && printf "# mean: %.${ndig}f +-%.${ndig}f\n" $1 $2 >&2
    
    # plane
    test "$mode" == "plane" &&
        fitfun="a + b1*(x-$xm) + b2*(y-$ym); c1=0; c2=0; c3=0; xoff=0; yoff=0" &&
        fitvars="a, b1, b2"
    # centered bi-quadratic
    test "$mode" == "center" &&
        fitfun="a + b1*(x-$xm) + b2*(y-$ym) \
        + c1*(x-$xm+xoff)*(x-$xm+xoff) + c2*(y-$ym+yoff)*(y-$ym+yoff) + c3*(x-$xm+xoff)*(y-$ym+yoff)" &&
        fitvars="a, b1, b2, c1, c2, c3, xoff, yoff"
    # bi-quadratic
    test "$mode" == "poly2" &&
        fitfun="a + b1*(x-$xm) + b2*(y-$ym) \
        + c1*(x-$xm)*(x-$xm) + c2*(y-$ym)*(y-$ym) + c3*(x-$xm)*(y-$ym)"
    fitvars="a, b1, b2, c1, c2, c3"
    # polynome of 3. degree
    fitfun="a + b1*(x-$xm) + b2*(y-$ym) \
        + c1*(x-$xm)*(x-$xm) + c2*(y-$ym)*(y-$ym) + c3*(x-$xm)*(y-$ym) \
        + d1*(x-$xm)**3 + d2*(x-$xm)**2*(y-$ym) + d3*(x-$xm)*(y-$ym)**2 + d4*(y-$ym)**3"
    fitvars="a, b1, b2, c1, c2, c3, d1, d2, d3, d4"
    # polynome of 4. degree
    fitfun="a + b1*(x-$xm) + b2*(y-$ym) \
        + c1*(x-$xm)*(x-$xm) + c2*(y-$ym)*(y-$ym) + c3*(x-$xm)*(y-$ym) \
        + d1*(x-$xm)**3 + d2*(x-$xm)**2*(y-$ym) + d3*(x-$xm)*(y-$ym)**2 + d4*(y-$ym)**3 \
        + e1*(x-$xm)**4 + e2*(x-$xm)**3*(y-$ym) + e3*(x-$xm)**2*(y-$ym)**2 + e4*(x-$xm)*(y-$ym)**3 + e5*(y-$ym)**4"
    fitvars="a, b1, b2, c1, c2, c3, d1, d2, d3, d4, e1, e2, e3, e4, e5"

    echo "\
    # gather statistics
    stats '$tmp1' using 3 noout
    a=STATS_mean
    # data fitting" > $tmpgp
    test -z "$AI_DEBUG" && echo "        set fit quiet" >> $tmpgp
    echo "\
    # until 171228: b1=0.1; b2=0.1; c1=0.1; c2=0.1; c3=0.1
    b1=100; b2=100; c1=100; c2=100; c3=100
    d1=10; d2=10; d3=10; d4=10
    e1=1; e2=1; e3=1; e4=1; e5=1
    xoff=1; yoff=1
    f(x,y) = $fitfun" >> $tmpgp
    test ${mode:0:4} == "poly" && echo "xoff=0; yoff=0" >> $tmpgp
    case "$gpversion" in
        4*)
            echo "       " \
            "fit f(x,y) '$tmp1' using 1:2:3:(1) via $fitvars" >> $tmpgp
            ;;
        5*) echo "       " \
            "fit f(x,y) '$tmp1' using 1:2:3 via $fitvars" >> $tmpgp
            ;;
    esac
    test -z "$quiet" && echo "
    out=sprintf(\"%d %6.3f %8.3f %7.3f %7.3f %6.3f %6.3f %6.3f %5.1f %5.1f\", \
        FIT_NDF, FIT_STDFIT, a, b1, b2, c1, c2, c3, xoff, yoff)
    print out" >> $tmpgp
    echo "\
    # create fitted data points
    set samples ${samples%:*}
    set isosamples ${samples#*:}
    set table '$outfile'
    splot [$xmin:$xmax] [$ymin:$ymax] f(x,y)
    unset table" >> $tmpgp
        
    gnuplot -p $tmpgp > $tmplog 2>&1
    test $? -ne 0 &&
        echo "ERROR: unable to fit data (check $tmpgp and $tmplog)." >&2 && return 255
    test -z "$quiet" && echo "$(grep -v "number of data points scaled up to" $tmplog)" >&2
    
    test "$AI_DEBUG" &&
        echo "# $tmp1 $tmpgp $tmpout $tmplog" >&2 && return
    rm $tmp1 $tmpgp $tmpout $tmplog
    return
}


mktics () {
    # create list of tic mark positions with geometric spacing
    # note: if max/min < 2 nothing is returned
    local clip
    test "$1" == "-c" && clip=1 && shift 1
    local min=$1    # min data value
    local max=$2
    local r100
    local skip=0
    local x

    r100=$(echo $min $max | awk '{printf("%.0f", 100*$2/$1)}')
    test $r100 -lt   200 && return 255
    
    test $r100 -ge   200 && test $r100 -lt  1000 && x="
        0.1   0.15  0.2  0.25  0.3  0.4  0.5  0.7
        1     1.5   2    2.5   3    4    5    7
       10    15    20   25    30   40   50   70
      100   150   200  250   300  400  500  700"
    test $r100 -ge  1000 && test $r100 -lt  3000 && x="
        0.1   0.2  0.3  0.5
        1     2    3    5
       10    20   30   50
      100   200  300  500"
    test $r100 -ge  3000 && test $r100 -lt 18000 && x="
        0.1   0.2  0.5
        1     2    5
       10    20   50
      100   200  500"
    test $r100 -ge 18000 && test $r100 -lt 100000 && x="
        0.1   0.3
        1     3
       10    30
      100   300
     1000  3000"
    
    echo $(echo $x | tr ' ' '\n' | awk -v a=$min -v b=$max -v c="$clip" 'BEGIN{
            # x scaling
            mult=10^int(log(a)/log(10))
            #printf("mult=%d\n", mult)
        }{
        val=$1*mult
        if (c == "1") {
            if(val>=a && val<=b) {printf("%s\n", val)}
        } else {
            if(val>=a/5 && val<=5*b) {printf("%s\n", val)}
        }}')
}


icqplot () {
# plotting data from ICQ formatted data files
    local showhelp
    local i
    local title         # plot title, e.g. "C/2014 Q2 (Lovejoy)  2014 - 2015"
    local newmodel      # if set, plot additional model curve, format: <g>,<k>,<label>
    local keypos="top left reverse Left invert" # e.g. "bottom right"
    local kwidthadd     # additive correction to key area width
    local size="5.3,3.9 " # w,h page size of output file (inches)
    local wider=1       # enlarge plot width by this factor
    local xrange        # date range: YYYYMMDD:YYYYMMDD
    local yrange        # mag range: min:max
    local obslist       # list of observer id's with individual colored points
    local rmobslist     # list of observer id's to remove from plot
    local do_plot_distance  # overplot solar distance
    local do_mpcmodel   # if set then plot MPC model curve
    local fittype="none" # fittype for magnitude model curve m=M + 5*log(De) + 2.5*n*log(rs)
    local ephemdb       # comets ephemeris database (XEphem format)
    local npoints       # number of points of mag model curve
    local do_cobsobs    # if set include cobs observations
    local do_localobs   # if set include local observations (using AIlist)
    local do_update     # if set update ephemdb and cobsobs
    local outfile       # if set the plot is saved to the given file name
    local outext="png"  # png|eps plot file extension (if outfile is not given) 
    local verbose       # if set print additional messages and keep gnuplot files

    for i in $(seq 1 20)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-f"  && fittype="all"     && shift 1
        test "$1" == "-ff" && fittype="obslist" && shift 1
        test "$1" == "-m" && do_mpcmodel=1  && shift 1
        test "$1" == "-n" && newmodel="$2"  && shift 2
        test "$1" == "-d" && do_plot_distance=1 && shift 1
        test "$1" == "-o" && outfile="$2"   && shift 2
        test "$1" == "-ext" && outext="$2"   && shift 2
        test "$1" == "-s" && size="$2"      && shift 2
        (test "$1" == "-w" || test "$1" == "-wide") &&
            wider=$(echo $wider | awk '{print 1.25*$1}') && shift 1
        test "$1" == "-t" && title="$2"     && shift 2
        test "$1" == "-k" && keypos="$2"    && shift 2
        test "$1" == "-kw" && kwidthadd="$2" && shift 2
        test "$1" == "-x" && xrange="$2"    && shift 2
        test "$1" == "-y" && yrange="$2"    && shift 2
        test "$1" == "-e" && ephemdb="$2"   && shift 2
        test "$1" == "-i" && obslist="$2"   && shift 2
        test "$1" == "-r" && rmobslist="$2"   && shift 2
        test "$1" == "-p" && npoints="$2"   && shift 2
        test "$1" == "-c" && do_cobsobs=1   && shift 1
        test "$1" == "-l" && do_localobs=1  && shift 1
        test "$1" == "-u" && do_update=1    && shift 1
        test "$1" == "-v" && verbose=1      && shift 1
    done
    
    local comet=$1
    local icqdat=$2         # data file containing records in ICQ data format
    local type=${3:-"mag"}  # type of plot: mag, hmag, coma, lcoma
    
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpobs=$(mktemp "$tdir/tmp_obs_$$.XXXXXX.dat")
    local tmpdat1=$(mktemp "$tdir/tmp_dat1_$$.XXXXXX.dat")
    local tmpdat2=$(mktemp "$tdir/tmp_dat2_$$.XXXXXX.dat")
    local tmpmpc=$(mktemp "$tdir/tmp_mpc_$$.XXXXXX.dat")
    local tmpmodel=$(mktemp "$tdir/tmp_model_$$.XXXXXX.dat")
    local tmpfit=$(mktemp "$tdir/tmp_fit_$$.XXXXXX.dat")
    local tmpgp=$(mktemp "$tdir/tmp_gp_$$.XXXXXX.gp")
    local obsdata=$(mktemp "$tdir/tmp_obsdata_$$.XXXXXX.dat")
    local edburl="http://www.minorplanetcenter.net/iau/Ephemerides/Comets/Soft03Cmt.txt"
    local tmpedb=$tdir/tmp_soft03cmt.edb
    local tmplocalobs=$tdir/tmp_myobs.$comet.icq
    local tmpcobsobs=$tdir/tmp_cobs.$comet.icq
    local cname
    local cephem
    local observer
    local maxdays=60    # max days to use in AIlist
    local xp    # time of perihel (yyyymmdd.dd)
    local up	# time of perihel (unix time)
    local rp    # perihel distance from sun
    local jdp   # time of perihel (JD)
    local tperiod   # orbital period (in years)
    local f
    local flist
    local fields
    local source
    local n
    local umin
    local umax
    local dmin
    local dmax
    local span
    local xcol  # column in observations data file
    local ycol
    local mxcol # column in model data file
    local mycol
    local idcol
    local lcol
    local term
    local termopts
    local font
    local fsize
    local bwidth
    local gridparam
    local docviewer
    local incr
    local xticsfmt
    local xtics
    local ytics
    local ptsize
    local trange
    local drange
    local dinterval
    local plotcmd
    local color
    local lcolor
    local colors=('#E00000' '#3050FF' '#D0B040' '#60C840' '#90B0C8')
    #local colors=('#A22700' '#3465A4' '#BD8B06' '#3E7C04' '#6A496F' '#018587')  # dark
    local colors=('#E33434' '#5580D0' '#F3AB1D' '#6CC52C' '#AD7FA8' '#28D1D1' '#A0A0A0')  # bright
    # #A22700 #3E7C04 #BD8B06 #3465A4 #6A496F #018587  # dark
    # #F13D3D #7DCE2F #ECCD2A #739FCF #AD7FA8 #28D1D1  # bright
    local ncol
    local softlist
    local multiplot
    local lmargin=0.1
    local rmargin=0.9
    local xrange2
    local plotnum
    local datefilter
    local retval
    local rms
    local afit
    local bfit
    local str
    local tunix
    local tcal
    local src
    local mpclabel
    local fitlabel
    local newlabel
    local g
    local k
    local x
    local num
    local nskip
    local pid
    local pyprog    # full path to airfun.py

    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: icqplot [-h] [-v] [-c] [-l] [-u] [-f|-ff] [-m] [-n <g,k,desc>] [-d]" \
            "[-o outfile | -ext outext|$outext] [-w|-s w,h|$size] [-t <plottitle>] [-k <keypos>] [-kw <keywidth-add>]" \
            "[-x YYYYMMDDstart:YYYYMMDDend] [-y ymin:ymax] [-p npoints] [-e ephemdb] [-i obsidlist]" \
            "<comet> [icqdat] [plottype|$type]" >&2 &&
        return 1
    
    test "$icqdat" && test ! -f "$icqdat" &&
        echo "ERROR: ICQ observations data file $icqdat not found." >&2 && return 255
    test "$ephemdb" && test ! -f "$ephemdb" &&
        echo "ERROR: file $ephemdb not found." >&2 && return 255
    test "$xrange" && test "$xrange" == "${xrange/:/}" && xrange=$xrange":"

    # check for required python scripts
    pyprog=$(which airfun.py)
    test $? -ne 0 &&
        echo "ERROR: missing python module airfun.py." >&2 && return 255
    
    # ICQ id of local observer
    observer=$AI_OBSICQID
    test -z "$observer" && observer=${AI_OBSERVER:-"OBSxx"}

    # download $ephemdb if required
    if [ -z "$ephemdb" ]
    then
        touch -d 'now - 7 days' $tmpobs
        if [ -z "$do_update" ] && [ -s $tmpedb ] && [ $tmpedb -nt $tmpobs ]
        then
            # reuse tmpedb if not older than 7 days
            echo "# reusing $tmpedb" >&2
        else
            wget -nH -O $tmpedb $edburl
            test $? -ne 0 &&
                echo "ERROR: download of ephemdb failed." >&2 && return 255
        fi
        ephemdb=$tmpedb
    fi
    
    # ignore some options on certain plot types
    case "$type" in
        hmag)   do_plot_distance=""
                ;;
        coma)   do_mpcmodel=""
                fittype="none"
                newmodel=""
                ;;
        lcoma)  do_plot_distance=""
                do_mpcmodel=""
                fittype="none"
                newmodel=""
                ;;
    esac
    

    #-----------------------------------
    #   collect observations
    #-----------------------------------

    # create icqdat if not specified on command line
    test -z "$icqdat" && test -z "$do_localobs" && do_cobsobs=1
    touch -d 'now - 1 days' $tmpobs
    if [ "$do_localobs" ]
    then
        if [ "$do_update" ] || [ ! -s $tmplocalobs ] || [ $tmpobs -nt $tmplocalobs ]
        then
            echo "# get data from local AIRTOOLS projects (last $maxdays days)" >&2
            echo "comet = $comet" >&2
            AIlist -i -n $maxdays $comet > $tmplocalobs
        fi
    else
        # parse results of current project
        AIlist -i -c $comet > $tmplocalobs
    fi
    test "$do_cobsobs" &&
        if [ "$do_update" ] || [ ! -s $tmpcobsobs ] || [ $tmpobs -nt $tmpcobsobs ]
        then
            echo "# get data from COBS" >&2
            get_cobs -a $comet > $tmpcobsobs
        fi
    
    # get comet ephemerides, orbital period, perihel time (xp is utdate,
    #   up is unix time) and distance
    false && if [ "${comet%P}" != "${comet}" ] || [ "${comet%I}" != "${comet}" ]
    then
        cephem=$(grep "^$comet/" $ephemdb | lines 1)
    else
        cephem=$(grep "^./${comet:0:4} ${comet:4}[ ,/]" $ephemdb | lines 1)
    fi
    cephem=$(grep "^$(cometname $comet)[ ,/]" $ephemdb | lines 1)
    if [ -z "$cephem" ]
    then
        echo "ERROR: comet $comet not found in $ephemdb" >&2
        # return 255
    else
        test "$AI_DEBUG" && echo "# cephem=$cephem" >&2
        tperiod=$(echo "$cephem" | awk -F "," '{
                P=sqrt($6*$6*$6)
                if ($2=="e") printf("%.1f", P)}')
        rp=$(echo "$cephem" | awk -F "," '{
            if($2=="e") {a=$6; e=$8; q=a*(1-e)}
            if($2=="h") {q=$8}
            if($2=="p") {q=$6}
            print q
            }')
        if [ "$(echo "$cephem" | cut -d ',' -f2)" == "e" ]
        then
            jdp=$(echo "$cephem" | awk -F "," '{
                P=sqrt($6*$6*$6)
                M=$9
                ep=$10
                # convert epoch_of_M to jd
                split($10,x,"/")
                y=x[3]; m=x[1]; d=x[2]
                if (1*m<=2) {y=y-1; m=m+12}
                a=int(y/100); b=2-a+int(a/4)
                jd=int(365.25*(y+4716)) + int(30.6001*(m+1)) + d + h/24 + b - 1524.5
                # print jd of perihelion
                jdper=jd-M*P/0.9856076686
                if (M>170) jdper=jdper+P*365.2422
                printf("%.3f", jdper)}')
            # TODO: compute max jdp within plot range
            xp=$(jd2ut -p 1 $jdp | tr -d '-')
        else
            xp=$(echo "$cephem" | awk -F "," '{
                day=$3
                split(day,a,"/")
                printf("%s%s%s", a[3], a[1], a[2])
                }')
        fi
        up=$(echo $(ut2jd 0 ${xp%.*}) "0."${xp#*.} | awk '{printf("%.0f", ($1+$2-2440587.5)*86400)}')
        echo "# perihel: T=$xp utime=$up r=$rp" >&2
    fi
    
    # check file extension of outfile
    test -z "$outfile" && outfile=$comet.$type.$(date +'%y%m%d').$outext
    str=${outfile##*.}
    outext=${str,,}
        case "$outext" in
            png|eps|ps) ;;
            *)  echo "ERROR: filetype of outfile is not supported." >&2 && return 255;;
        esac

    
    # convert ICQ data files into CSV format
    # fields: unixtime, date, source, obsid, mag, coma, method, filter, soft
    # TODO: take type (plottype) into account
    flist=""    # list of ICQ data files
    test -s "$icqdat" && flist="$flist $icqdat"
    test -s $tmplocalobs && flist="$flist $tmplocalobs"
    test "$do_cobsobs"  && test -s $tmpcobsobs  && flist="$flist $tmpcobsobs"
    
    fields="utime,date,source,obsid,mag,coma,method,filter,soft"
    echo "$fields" > $tmpobs
    cname=${comet%P}
    
    for f in $flist
    do
        case $f in
            $tmplocalobs)   source="local";;
            $tmpcobsobs)    source="cobs";;
            *)              source="file";;
        esac
        test "$AI_DEBUG" && echo "# $f  src=$source" \
            "dstart=\"${xrange%:*}\" dend=\"${xrange#*:}\"" >&2
        grep "^[ ]*$cname[ ]*[0-9][0-9][0-9][0-9] " $f | \
        awk -v t=$type -v src=$source -v dstart="${xrange%:*}" -v dend="${xrange#*:}" '{
            date=substr($0,12,4)""substr($0,17,2)""substr($0,20,2)"."substr($0,23,2)
            gsub(/ /,"0",date)
            if (dstart!="" && date<dstart) next
            if (dend!=""   && date>dend)   next

            # convert ut date to jd and unix timestamp (seconds)
            y=substr($0,12,4)
            m=substr($0,17,2)
            d=substr($0,20,2)
            hr=substr($0,22,3)*24
            if (1*m<=2) {y=y-1; m=m+12}
            a=int(y/100); b=2-a+int(a/4)
            jd=int(365.25*(y+4716)) + int(30.6001*(m+1)) + d + hr/24 + b - 1524.5
            utime=(jd - 2440587.5)*24*3600

            method=substr($0,27,1)
            if (substr($0,28,1) == "[") next
            mag=substr($0,29,5);  gsub(/ /,"",mag)
            if (t~/mag/ && mag=="") next
            if (t~/mag/ && mag=="-") next
            if (t~/mag/ && mag=="-:") next
            if (mag=="") mag=-99        
            if (mag=="-") mag=-99        
            if (mag=="-:") mag=-99        
            coma=substr($0,50,5); gsub(/ /,"",coma);
            if (t~/coma/ && coma=="") next
            if (coma=="") coma=-99

            # obsid might have more than 5 characters but if char 6 is I than a CCD record is present
            obsid=substr($0,76,10)
            gsub(/ .*/,"",obsid)
            if (substr(obsid,6,1) == "I") obsid=substr(obsid,1,5)
            if (obsid=="") obsid="unknown"
            
            # software (use flag V to indicate visual observation)
            if (substr($0,81,1) == "I" || method ~ /[CZ]/) {
                soft=substr($0,102,3); gsub(/ /,"",soft); if (soft=="") {soft="?"}
            } else {
                soft="V"
            }
            
            # TODO: guess filter
            filter="X"
            
            if (obsid=="unknown") printf("#")
            printf("%.0f,%s,%s,%s,%s,%s,%s,%s,%s\n", utime, date, src, obsid, mag, coma, method, filter, soft)
        }' >> $tmpobs
    done
    test "$do_localobs" || rm -f $tmplocalobs
    
    # identify and remove local obs if cobs obs exist
    grep ",local,$observer," $tmpobs | tr ',' ' ' | while read tunix tcal src x
    do
        grep -q "^$tunix,$tcal,cobs,$observer," $tmpobs &&
            sed -i "/^$tunix,$tcal,local,$observer,/d" $tmpobs
    done

    n=$(cat $tmpobs | grep -v "^#" | sed -e '1d' | wc -l)
    test $n -eq 0 &&
        echo "WARNING: no observation records found for comet $cname." >&2 &&
        return 255
    echo "# $n observations" >&2
    
    # list most used software (COBS only)
    # obs id in col 4, software key in col 9 (last col)
    if grep -q "^[0-9].*,cobs," $tmpobs
    then
        echo "# most used software (COBS):"
        grep "^[0-9].*,cobs," $tmpobs | cut -d "," -f9 | sort | awk '{
            if (NR>1 && $0 != last) {
                printf("%d %s\n", n, last)
                n=1
            } else {
                n++
            }
            last=$0
        }END{printf("%d %s\n", n, last)}' | sort -nr -k1,1 | lines 10 | \
            sed -e 's|$|, |' | tr -d '\n' | sed -e 's|, $|\n|'
    fi
    
    # list most active observers (COBS only)
    # obs id in col 4, software key in col 9 (last col)
    if grep -q "^[0-9].*,cobs," $tmpobs
    then
        echo "# most active observers (COBS):"
        grep "^[0-9].*,cobs," $tmpobs | cut -d "," -f4 | sort | awk '{
            if (NR>1 && $0 != last) {
                printf("%d %s\n", n, last)
                n=1
            } else {
                n++
            }
            last=$0
        }END{printf("%d %s\n", n, last)}' | sort -nr -k1,1 | lines 10 | \
            sed -e 's|$|, |' | tr -d '\n' | sed -e 's|, $|\n|'
    fi

    
    # compute additional values (e.g. hmag, lcoma) using ephemerides
    # position 1     2    3      4     5   6    7    8     9      10     11   12         13    14
    # fields:  utime date source obsid mag hmag coma lcoma method filter soft log(r_sun) r_sun d_earth
    if [ "$cephem" ]
    then
        python3 $pyprog addephem $tmpobs "$cephem" > $tmpdat1
        test "$verbose" && echo "# addephem: returns $?" >&2
    else
        echo "WARNING: cannot compute comet ephemerides because elements are not known" >&2
        cat $tmpobs | grep "^[0-9]" | tr ',' ' ' | awk '{
            printf("%s %s %s %s %s %s %s %s %s %s %s\n", $1, $2, $3, $4, $5, 1, $6, 1, $7, $8, $9)}' > $tmpdat1
    fi
    
    #-----------------------------------
    #   ranges and tics
    #-----------------------------------

    # time range of data
    # determine start, end and number of days
    cat $tmpdat1 | awk '{printf("%s\n", $1)}' | sort -n > $tmpdat2
    umin=$(head -1 $tmpdat2) # unix time in seconds
    umax=$(tail -1 $tmpdat2)
    cat $tmpdat1 | awk '{printf("%s\n", $2)}' | sort -n > $tmpdat2
    dmin=$(head -1 $tmpdat2) # yyyymmdd.dd
    dmax=$(tail -1 $tmpdat2)
    span=$(echo $umax $umin | awk '{printf("%.1f", ($1-$2)/86400)}')
    echo "# data range: min=$dmin  max=$dmax  span=$span" >&2
    
    # apply user defined time range
    if [ "$xrange" ]
    then
        if [ "${xrange%:*}" ]
        then
            umin=$(ut2jd 0:01 ${xrange%:*} | awk '{
                printf("%.0f", ($1-2440587.5)*86400)}')
        fi
        if [ "${xrange#*:}" ]
        then
            umax=$(ut2jd 23:59 ${xrange#*:} | awk '{
                printf("%.0f", ($1-2440587.5)*86400)}')
        fi
        span=$(echo $umax $umin | awk '{printf("%.1f", ($1-$2)/86400)}')
    fi

    # add margin of 1% to model curves
    umin=$(echo $umin $span | awk '{printf("%.0f", $1-0.01*$2*86400)}')
    umax=$(echo $umax $span | awk '{printf("%.0f", $1+0.01*$2*86400)}')
    test "$verbose" && echo "# umin=$umin umax=$umax" >&2

    # time range of plot, saved to xrange (unix time)
	# add margins (4% + 1day)
    xrange=$(echo $umin $umax $span | awk '{
        dx=(0.04*$3+1)*86400
        printf("%.0f:%.0f", $1-dx, $2+dx)}')
    span=$(echo $span | awk '{printf("%.1f", 1.1*$1+2)}')
    test "$verbose" && echo "# plot range: xrange=$xrange span=$span" >&2


    # set xtics
    if [ "$type" == "mag" ] || [ "$type" == "coma" ]
    then
        # x axis is date/time
        xcol=1; mxcol=1

        # set xtics "20110105", 1209600, "20110430"  # interval in seconds
        # 1 month = 365.2425/12 days
        incr=$(echo $span | awk -v y=365.2425 '{
            x=$1/5; d=0
            if (x<450) d=y
            if (x<250) d=y/2
            if (x<150) d=4*y/12
            if (x<100) d=3*y/12
            if (x<75)  d=2*y/12
            if (x<45)  d=y/12
            if (x<22)  d=14
            if (x<11)  d=7
            if (x<6.0) d=5
            if (x<3.5) d=2
            if (x<1.5) d=1
            if (d>0) printf("%.1f", d)}')
        xticsfmt="%Y"
        if [ "$incr" ]
        then
            test "$verbose" && echo "# incr=$incr" >&2
            test ${incr%.*} -lt 300 && xticsfmt="%b '%y"
            #'
            test ${incr%.*} -lt  70 && xticsfmt="%b"
            test ${incr%.*} -lt  20 && xticsfmt="%b %d"
            if false && [ ${incr%.*} -lt 150 ] && [ ${incr%.*} -gt 20 ]
            then
                # note: not longer valid, it was used when xrange was given in yyyymmdd

                # start tics at beginning of month
                incr=$(echo $incr | awk -v s=${xrange%:*} '{
                    a=int(s/100)*100+1
                    #a=int(s/3600/24)*3600*24
                    printf("\"%d\",%d", a, $1*24*3600)}')
            else 
                incr=$(echo $incr | awk '{
                    printf("%d", $1*24*3600)}')
            fi
        fi
    else
    	# heliocentric plots, x axis is solar distance (using logscale)
        # TODO: deal with user provided xrange
        xcol=13 # dist from sun
        lcol=12 # log dist from sun
        mxcol=6 # dist from sun in model data file
        xrange=""; span=0
        
        # pre-perihelion observations
        cat $tmpdat1 | awk -v t=$xp -v xcol=$xcol '{if($2<=t) printf("%s\n", $xcol)}' | \
            sort -n > $tmpdat2
        if [ -s $tmpdat2 ]
        then
            min=$(head -1 $tmpdat2)
            max=$(tail -1 $tmpdat2)
            test "$verbose" &&
                echo "# pre-perihelion:  n=$(cat $tmpdat2 | wc -l)  xrange=$min:$max" >&2
            span=$(echo $max $min | awk '{print $1/$2}')
            # add some margins (5% of ratio)
            min=$(echo $min $span | awk '{print $1/(exp(0.05*log($2)))}')
            max=$(echo $max $span | awk '{print $1*(exp(0.05*log($2)))}')
            xrange=$max":"$min
            span=$(echo $max $min | awk '{print $1/$2}')
        fi
              
        # post-perihelion observations
        cat $tmpdat1 | awk -v t=$xp -v xcol=$xcol '{if($2>t) printf("%s\n", $xcol)}' | \
            sort -n > $tmpdat2
        if [ -s $tmpdat2 ]
        then
            min=$(head -1 $tmpdat2)
            max=$(tail -1 $tmpdat2)
            test "$verbose" &&
                echo "# post-perihelion: n=$(cat $tmpdat2 | wc -l)  xrange=$max:$min" >&2
            span=$(echo $max $min | awk '{print $1/$2}')
            # add some margins (5% of ratio)
            min=$(echo $min $span | awk '{print $1/(exp(0.05*log($2)))}')
            max=$(echo $max $span | awk '{print $1*(exp(0.05*log($2)))}')
            if [ -z "$xrange" ]
            then
                xrange=$min":"$max
                span=$(echo $max $min | awk '{print $1/$2}')
            else
                xrange=${xrange%:*}":"$rp
                xrange2=$rp":"$max
                set - $(echo ${xrange/:/ } $max $min $rp $lmargin $rmargin | awk '{
                    a=$1; if($3>a) a=$3; b=$5
                    c=(log($1)-log($5))/(log($1)-log($5)+log($3)-log($5)) * ($7-$6) + $6
                    printf("%s %s %f %.3f\n", b, a, a/b, c)}')
                min=$1
                max=$2
                span=$3
                multiplot=$4
            fi
        fi
        printf "# r_sun: min=%.2f  max=%.2f  ratio=%.2f\n" $min $max $span >&2

        # set xtics
        incr=$(echo $span | awk '{print exp(1/5*log($1))}')
        #echo "# ~5 tics spaced by ratio $incr" >&2
        if [ ${span%.*} -lt 2 ]
        then
            # place tics using linear spacing
            xtics=$(echo $min $max | awk '{
            m=($1+$2)/2
            s=($2-$1)/4
            l10=sprintf("%.0f", (log(s)/log(10))-0.5)
            x=exp(l10*log(10))
            l=log(s/x)
            #printf("%f %f %f %f %.2f\n", m, s, l10, x, l)
            if (l<0.7) {s=1*x} else {
                if (l<1.4) {s=2*x} else {
                    s=5*x}}
            #printf("# %3d %3d  %s\n", $1, $2, s)
            
            i=0
            for (x=s*int($1/s+0.9999); x<=$2; x=x+s) {
                if (i>0) printf(", ")
                printf("%s", x)
                i++
            }
            printf("\n")
            }')
        else
            xtics=$(mktics $min $max | tr ' ' ', ') 
        fi
        xtics="("${xtics}")"
        test "$verbose" && echo "# xtics=$xtics" >&2
    fi
    
    # set ycol and title
    case $type in
        mag)
                ycol=5; mycol=3
                test -z "$title" && title="$comet - Magnitude"
                ;;
        hmag)
                ycol=6; mycol=4
                test -z "$title" && title="$comet - Heliocentric Magnitude"
                ;;
        coma)
                ycol=7
                test -z "$title" && title="$comet - Coma Diameter"
                ;;
        lcoma)
                ycol=8
                test -z "$title" && title="$comet - Linear Coma Diameter"
                ;;
    esac
    
    # set yrange if not provided and multiplot (heliozentric data)
    if [ -z "$yrange" ] && [ "$multiplot" ]
    then
        cat $tmpdat1 | awk -v col=$ycol '{printf("%s\n", $col)}' | \
            sort -n > $tmpdat2
        min=$(head -1 $tmpdat2)
        max=$(tail -1 $tmpdat2)
        case $type in
            hmag)   yrange=$(echo $min $max | awk '{
                        printf("%.0f:%.0f", int($2+0.7)+1, int($1-0.7))}')
                    ;;
            lcoma)  yrange=$(echo $min $max | awk '{
                        printf("%.0f:%.0f", int($1*0.5), int($2/0.5)+1)}')
                    ;;
        esac
    fi
    
    # determine ytics for coma size plots if necessary
    if [ "$type" == "coma" ] || [ "$type" == "lcoma" ]
    then
        # determine ytics for log scale
        if [ "$yrange" ]
        then
            set - $(echo ${yrange/:/ } | tr ' ' '\n' | sort -n)
            min=$1
            max=$2
        else
            cat $tmpdat1 | awk -v col=$ycol '{printf("%s\n", $col)}' | \
                sort -n > $tmpdat2
            min=$(head -1 $tmpdat2)
            max=$(tail -1 $tmpdat2)
        fi
        test "$type" == "coma"  && ytics="($(mktics    $min $max | tr ' ' ', '))"
        test "$type" == "lcoma" && ytics="($(mktics -c $min $max | tr ' ' ', '))"
        test "$verbose" && echo "# ytics=$ytics" >&2
    fi


    #-----------------------------------
    #   model curves
    #-----------------------------------
    # number of data points in model curves
    if [ -z "$npoints" ]
    then
        if [ "$tperiod" ]
        then
            npoints=$(echo $span $tperiod | awk '{norb=$1/$2/365.23
                np=100
                if (norb > 1.5) np=150
                if (norb > 2.5) np=200
                if (norb > 4) np=250
                if (norb > 6) np=300
                if (norb > 10) np=350
                if (norb > 20) np=floor(20*norb)
                print np
                }')
            echo "# npoints=$npoints  tperiod=$tperiod" >&2
        else
            npoints=100
            echo "# npoints=$npoints" >&2
        fi
    fi
    
    # create data for model light curves (in $umin:$umax)
    # note: y column to plot is ycol-2
    if [ "$newmodel" ]
    then
        g=$(echo $newmodel | cut -d ',' -f1)
        k=$(echo $newmodel | cut -d ',' -f2)
        newlabel=$(echo $newmodel | cut -d ',' -f3-)
        test -z "$newlabel" &&
            newlabel=$(echo $g $k | awk '{printf("Model: m_0=%s n=%s", $1, $2)}')
        #num=100; nskip=3 # note: skip first and last 3 point
        python3 $pyprog mkephem -s "$cephem" $umin $umax $g $k $npoints | \
            grep -v "^#" > $tmpmodel
    fi
    if [ "$do_mpcmodel" ] || [ "$do_plot_distance" ]
    then
        g=$(echo "$cephem" | awk -F ',' '{x=$(NF-1); sub(/^[a-z ]*/,"",x); printf("%s", x)}')
        k=$(echo "$cephem" | awk -F ',' '{x=$NF; sub(/^[a-z ]*/,"",x); printf("%s", x)}')
        mpclabel=$(echo $g $k | awk '{printf("MPC Model: m_0=%s n=%s", $1, $2)}')
        test "$verbose" && echo "# command: python3 $pyprog mkephem -s" \
            "\"$cephem\" $umin $umax $g $k $npoints" >&2
        python3 $pyprog mkephem -s "$cephem" $umin $umax $g $k $npoints | \
            grep -v "^#" > $tmpmpc
    fi
    
    
    #-----------------------------------
    #   fit brightness model
    #-----------------------------------
    # if rmobslist is set, remove records of given id's from obsdata
    # note: obs ID is in column 4, software ID in column 11
    softlist=$(echo $(cut -d ' ' -f 11 $tmpdat1 | sort -u))
    if [ "$rmobslist" ]
    then
        x=0 # 0 = skip, 1 = keep
        test "$obslist" && case "$rmobslist" in
            other|all) rmobslist=$obslist; x=1;;
        esac
        
        cat $tmpdat1 | awk -v idlist="$rmobslist" -v x=$x '{
            found=0
            if (idlist~$4 || idlist~$11) found=1
            if (found == x) print $0
            }' > $obsdata
    else
        cp $tmpdat1 $obsdata
    fi

    # fit model parameters
    if [ "$fittype" != "none" ] && ([ "$type" == "mag" ] || [ "$type" == "hmag" ])
    then
        # log(r_sun) at column 12
        # hmag at column 6
        case $fittype in
            all)
                grep -v GON05 $obsdata | \
                gplinfit - 12 6 2>/dev/null > $tmpdat2
                ;;
            obslist)
                # observations matching obslist (both obs ID and software ID)
                # force removing of GON05
                cat $obsdata | awk -v idlist="${obslist//,/ }" -v rmlist="GON05" '{
                    found=0
                    if (rmlist~$4) next
                    if (idlist~$4 || idlist~$11) found=1
                    if (found == 1) print $0
                    }' > $tmpdat1
                
                test "$AI_DEBUG" &&
                    echo "# fit obslist data (first 10 lines):" >&2 &&
                    head $tmpdat1 >&2
                gplinfit $tmpdat1 12 6 2>/dev/null > $tmpdat2
                ;;
        esac
        # get coefficients/errors from fit
        head -1  $tmpdat2 | awk '{if (NF>=2) printf("# model fit: nobs=%d, rms=%.3f\n", $1+2, $2)}'
        afit=$(grep "^a " $tmpdat2 | awk '{if (NF>=3) printf("%.3f,%.3f", $2, $3)}')
        bfit=$(grep "^b " $tmpdat2 | awk '{if (NF>=3) printf("%.3f,%.3f", $2, $3)}')
        grep "^a " $tmpdat2 | awk '{printf("  m0= %6.3f +- %.3f\n", $2, $3)}'
        grep "^b " $tmpdat2 | awk '{printf("  n= %7.3f +- %.3f\n", $2/2.5, $3/2.5)}'
    fi
    
    # model curve (if fit has converged)
    if [ "$afit" ]
    then
        g=$(echo $afit | awk -F ',' '{print $1}')
        k=$(echo $bfit | awk -F ',' '{print $1/2.5}')
        fitlabel=$(printf "Model Fit: m_0=%.1f n=%.1f" $g $k)
        test "$verbose" && echo "# command: python3 $pyprog mkephem -s" \
            "\"$cephem\" $umin $umax $g $k $npoints" >&2
        python3 $pyprog mkephem -s "$cephem" $umin $umax $g $k $npoints | \
            grep -v "^#" > $tmpfit
        test $? -ne 0 &&
            echo "# command: python3 $pyprog mkephem -s \"$cephem\" ${trange%:*} ${trange#*:} $g $k" >&2
    fi


    #-----------------------------------
    #   plotting
    #-----------------------------------
    
    # initialize plot
    test "$verbose" && echo "# plot size=$size" >&2
    str=${outfile##*.}
    case "$outext" in
        png)    term=pngcairo
                termopts="enhanced dashlength 2.2"
                font="sans"; fsize=12
                size=$(echo $size | awk -F ',' '{printf("%.0f,%.0f", $1*150, $2*150)}')
                bwidth=1.2
                gridparam="lt 3 dt (2,8)"
                docviewer="feh"
                ;;
        ps|eps) term=postscript
                termopts="enhanced eps color blacktext dashlength 2.0"
                font=""
                fsize=$(echo ${size#,*} | awk '{printf("%.0f", sqrt($1)*7)}')
                #docviewer="evince"
                bwidth=1
                docviewer="xdg-open"
                ;;
    esac
    test "$wider" != "1" && size=$(echo $size | \
        awk -F ',' -v mul=$wider '{printf("%.0f,%.0f", mul*$1, $2)}')

    # correct width of background behind key labels
    x=0
    (test "$do_mpcmodel" || test "$newmodel" || test "$afit") && x=-15
    kwidthadd=$((kwidthadd + x))
    
    # pngcairo:
    #outfile=$comet.$obs.$(date +'%y%m%d').png
    #size="700,480"; fsize=11
    #test "$do_big" && size="900,600"; fsize=12
    cat <<EOF > $tmpgp
#set term pngcairo size $size font "Arial,$fsize" enhanced
set term $term size $size font "$font,$fsize" $termopts
set output "$outfile"
#set offsets graph 0.02, graph 0.02, graph 0.03, graph 0.03
set border lw $bwidth
set xtics nomirror
set ytics nomirror
set grid lc rgb '#808080' $gridparam
set title '${title//_/ }' font ",$((fsize+3))"
#set datafile separator " "
EOF

    # key label position
    if [ "$keypos" == "off" ]
    then
        echo "set nokey" >> $tmpgp
    else
        cat <<EOF >> $tmpgp
#set key $keypos samplen 1 spacing 1.0 font "Arial,$((fsize-2))"
set key opaque ${keypos//_/ } height +0.5 width ${kwidthadd//_/ } samplen 2.5 spacing 1.2 font "$font,$((fsize-2))"
EOF
    fi
    
    # xrange, xtics according to $type
    test -z "$xticsfmt" && xticsfmt="%b %y"
    if [ "$type" == "mag" ] || [ "$type" == "coma" ]
    then
        echo "set xdata time
set timefmt '%s'
set xtics $incr format \"$xticsfmt\"" >> $tmpgp
        test "$xrange" && echo "set xrange ['${xrange%:*}':'${xrange#*:}']" >> $tmpgp
        echo "set xlabel 'Date'" >> $tmpgp
    else
        test "$xrange" && echo "set xrange [$xrange]" >> $tmpgp
        echo "set log x" >> $tmpgp
        echo "set xtics $xtics" >> $tmpgp
        echo "set xlabel 'r_{sun} / AU'" >> $tmpgp
    fi
    
    # add perihel marker
    if [ "$xp" ]
    then
        echo "Tperi = $xp" >> $tmpgp
        if [ "$type" == "mag" ] || [ "$type" == "coma" ]
        then
            test "$(echo $umin $umax $up | awk '{if($3>$1 && $3<$2){print 1}}')" &&
                echo "\
set arrow from '$up', graph 0.98 to '$up', graph 1 nohead
set label 'P' at '$up', graph 0.95 center" >> $tmpgp
        else
            color=${colors[ncol-1]}
            test "$multiplot" &&
                echo "\
set arrow from screen $multiplot, graph 0.92 to screen $multiplot, graph 0 \
    nohead lt 1 dt (20,10) lc rgb '$color'
set arrow from screen $multiplot, graph 0.98 to screen $multiplot, graph 1 \
    nohead lt 1 lc rgb '$color'
set label 'P' at screen $multiplot, graph 0.95 center" >> $tmpgp
        fi
    fi
    
    # add yrange, ytics according to $type
    case $type in
        mag)
                echo "set yrange [$yrange] reverse" >> $tmpgp
                echo "set ylabel 'mag' offset 1" >> $tmpgp
                ;;
        hmag)
                echo "set yrange [$yrange] reverse" >> $tmpgp
                echo "set ylabel 'mag' offset 1" >> $tmpgp
                ;;
        coma)
                echo "set yrange [$yrange]" >> $tmpgp
                echo "set log y" >> $tmpgp        
                echo "set ytics $ytics" >> $tmpgp
                echo "set ylabel 'arcmin' offset 1" >> $tmpgp
                ;;
        lcoma)
                echo "set yrange [$yrange]" >> $tmpgp
                echo "set log y" >> $tmpgp        
                echo "set ytics $ytics" >> $tmpgp
                echo "set ylabel 'km' offset 1" >> $tmpgp
                ;;
    esac
    if [ "$do_plot_distance" ]
    then
        # solor dist. at column 6
        drange=$(minmax $tmpmpc 6 | awk '{
            d=$2-$1
            low=$1-0.1*d-0.01*$1
            high=$2+0.1*d+0.01*$1
            printf("%f:%f", low, high)}') 
        dinter=$(echo $drange | awk -F ':' '{dr=$2-$1; x=0.05
            if(dr>0.3)  x=0.1
            if(dr>0.6)  x=0.2
            if (dr>1.5) x=0.5
            if (dr>3)   x=1
            if (dr>6)   x=2
            if (dr>15)  x=5
            print x}')
        test "$verbose" && echo "# drange=$drange dinter=$dinter" >&2
        echo "set y2range [$drange]" >> $tmpgp
        echo "set y2label 'r_{sun} / AU' offset -1" >> $tmpgp
        test "$dinter" && echo "set y2tics $dinter" >> $tmpgp
    else
        test "$type" == "mag" && echo "set rmargin 8" >> $tmpgp
    fi
    
    # check observers (or software key) for valid observations
    if [ "$obslist" ]
    then
        str=$obslist
        x=$(for str in $(echo $obslist | tr ',' '\n')
        do
            idcol=4 # column of observer id = 4, software = 11
            echo $softlist | grep -wq $str && idcol=11
            cut -d ' ' -f$idcol $obsdata | grep -qw $str
            if [ $? -eq 0 ]
            then
                echo $str
            else
                echo "# WARNING: no observations for $str" >&2
            fi
        done)
        obslist=$(echo $x | tr ' ' ',')
    fi
    
    # plotting of all data
    i=$(echo $obslist | tr ',' '\n' | wc -l)
    ncol=${#colors[@]}
    color=${colors[i%ncol]}
    
    # setting point size depending on number of points
    n=$(cat $obsdata | wc -l)
    ptsize=1.4
    test $n -gt 20 && ptsize=1.3
    test $n -gt 100 && ptsize=1.2
    test $n -gt 200 && ptsize=1.1
    test $n -gt 400 && ptsize=1.0
    test $n -gt 800 && ptsize=0.9

    # observations not matching obslist (both obs ID and software ID)
    cat $obsdata | awk -v idlist="${obslist//,/ }" '{
        found=0
        if (idlist~$4 || idlist~$11) found=1
        if (found == 0) print $0
        }' > $tmpdat2

    n=1 # number of plots
    test "$multiplot" && n=2
    for plotnum in $(seq 1 $n)
    do
        plotcmd="plot"
        datefilter="1 == 1"
        if [ "$multiplot" ]
        then
            case $plotnum in
                1)  # pre-perihelion (left plot)
                    datefilter="\$2 <= Tperi"
                    echo "
set multiplot layout 1,2 rowsfirst offset 0,-0.02 title '${title//_/ }' font ',$((fsize+3))'
set title ''
set lmargin at screen $lmargin; set rmargin at screen $multiplot
set border 7
" >> $tmpgp

                    ;;
                2)  # post-perihelion (right plot)
                    datefilter="\$2 > Tperi"
                    echo "
set lmargin at screen $multiplot; set rmargin at screen $rmargin
set border 13
set xrange [$xrange2]
set xlabel 'r_{sun} / AU' textcolor 'white'
set format y ''; unset ylabel; set ytics scale 0
set nokey" >> $tmpgp
                    ;;
            esac
        fi
        
        if [ "$obslist" ]
        then
            # plot all observations not matching obslist
            if [ -s $tmpdat2 ]
            then
                str="others"; x=6; color=${colors[ncol-1]}
                echo "\
$plotcmd '$tmpdat2'  using $xcol:($datefilter ? \$$ycol : 1/0) \\
        title '$str' pt $x ps $ptsize lc rgb '$color' \\" >> $tmpgp
                plotcmd="    ,"
            fi
        else
            # plot other CCD observations
            if cut -d ' ' -f 11 $tmpdat2 | grep -qwv V
            then
                str="CCD"; x=7; color=${colors[2]}; #color="#F06030"
                echo "\
$plotcmd '$tmpdat2'  using $xcol:($datefilter && stringcolumn(11) ne 'V' ? \$$ycol : 1/0) \\
        title '$str' pt $x ps $ptsize lc rgb '$color' \\" >> $tmpgp
                plotcmd="    ,"
            fi

            # plot other visual observations
            if cut -d ' ' -f 11 $tmpdat2 | grep -qw V
            then
                str="Vis."; x=7; color=${colors[6]}; #color="#60C060"
                echo "\
$plotcmd '$tmpdat2'  using $xcol:($datefilter && stringcolumn(11) eq 'V' ? \$$ycol : 1/0) \\
        title '$str' pt $x ps $ptsize lc rgb '$color' \\" >> $tmpgp
                plotcmd="    ,"
            fi
        fi

        # plotting of data from observers in obslist
        i=$(echo $obslist | tr ',' '\n' | wc -l)
        test "$obslist" && for str in $(echo $obslist | tr ',' '\n' | tac)
        do
            idcol=4 # column of observer id = 4, software = 11
            echo $softlist | grep -wq $str && idcol=11
            i=$((i-1))
            echo "\
$plotcmd '$obsdata'  using $xcol:($datefilter && stringcolumn($idcol) eq '$str' ? \$$ycol : 1/0) \\
        title '$str' pt 7 ps $ptsize lc rgb '${colors[i%ncol]}' \\" >> $tmpgp
            plotcmd="    ,"
        done

        # plotting heliocentric distance   
        if [ "$do_plot_distance" ]
        then
            lcolor="#00AA00"
            echo "\
$plotcmd '$tmpmpc'  using $xcol:6 \\
        title 'Distance' lw 1 lc rgb '$lcolor' dt '-' with lines axes x1y2 \\" >> $tmpgp
            plotcmd="    ,"
        fi

        # plotting model curves
        if [ "$mycol" ] && [ -s $tmpmodel ] # newmodel
        then
            lcolor="#90B0C8"
            echo "\
$plotcmd '$tmpmodel'  using $mxcol:($datefilter ? \$$mycol : 1/0) \\
        title '$newlabel' lw 1 lc rgb '$lcolor' dt '-' with lines \\" >> $tmpgp
            plotcmd="    ,"
        fi
        if [ "$mycol" ] && [ "$do_mpcmodel" ]
        then
            lcolor="#DBAE4B"
            echo "\
$plotcmd '$tmpmpc'  using $mxcol:($datefilter ? \$$mycol : 1/0) \\
        title '$mpclabel' lw 1 lc rgb '$lcolor' dt '-' with lines \\" >> $tmpgp
            plotcmd="    ,"
        fi
        if [ "$mycol" ] && [ -s $tmpfit ]
        then
            lcolor="#90B0C8"
            #test -z "$obslist" && lcolor=$color
            echo "\
$plotcmd '$tmpfit'  using $mxcol:($datefilter ? \$$mycol : 1/0) \\
        title '$fitlabel' lw 2 lc rgb '$lcolor' with lines \\" >> $tmpgp
            plotcmd="    ,"
        fi
    done

    # running gnuplot and displaying result plot
    echo "" >> $tmpgp
    cat $tmpgp | gnuplot -p
    retval=$?
    test $retval -eq 0 && AIdisplay $outfile &

    if [ "$verbose" ] || [ "$AI_DEBUG" ] || [ $retval -ne 0 ]
    then
        echo "obs:     $tmpobs" >&2
        echo "data:    $obsdata" >&2
        test -s $tmpfit   && echo "fit:     $tmpfit" >&2
        test -s $tmpmpc   && echo "mpc:     $tmpmpc" >&2
        test -s $tmpmodel && echo "model:   $tmpmodel" >&2
        echo "gnuplot: $tmpgp" >&2
    else
        rm -f $tmpobs $tmpdat1 $tmpdat2 $tmpfit $tmpmpc $tmpmodel $tmpgp $obsdata
    fi
    return $retval
}

# convert from ds9 circle regions to xy points
# e.g. for single object: echo "circle 2886.3 1247.4" | reg2xy - 3284
# circles with r=0 are ignored
# TODO: check for keyword "physical"
reg2xy () {
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    local img=$1    # image or number (height of image)
    local reg=$2
    local h

    (test "$showhelp" || test $# -ne 2) &&
        echo "usage: reg2xy <img|height> <reg>" >&2 &&
        return 1

    test "$reg" == "-" && reg="/dev/stdin"
    is_integer "$img" && h=$img
    test -z "$h" && test ! -f "$img" &&
        echo "ERROR: image $img not found." >&2 && return 255
    
    test -z "$h" && h=$(identify $img | cut -d " " -f3 | cut -d "x" -f2)
    test -z "$h" && return 255
    
    cat $reg | tr '(){},=' ' ' | awk -v h=$h 'BEGIN{newid=1}{
        if($1=="circle") {
            if ($4==0) {
                printf("# ignoring %s\n", $0)
                next
            }
            if($6=="text") {id=$7} else {id=sprintf("N%04d",newid); newid++}
            n=index($0,"#")
            if (n>0) {x=" "substr($0,n)} else {x=""}
            printf("%s %.3f %.3f%s\n", id, $2-0.5, h-$3+0.5, x)
        }
        if($1=="box") {
            if($8=="text") {id=$9} else {id=sprintf("N%04d",newid); newid++}
            printf("%s %.0fx%.0f+%.0f+%.0f\n", id, $4, $5, $2-0.5-$4/2, h-$3+0.5-$5/2)
        }
    }'
}

reg2svg () {
    # convert ds9 region file (circle/polygon/box) to svg
    # output is directed to stdout
    # TODO: deal with object rotation (e.g. for a box, rotation is 5th parameter)
    local showhelp
    local i
    for i in $(seq 1 2)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    done
    local img=$1
    local reg=$2
    local id=${3:-""}
    local w
    local h

    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: reg2svg <img> <reg> <text_id>" >&2 &&
        return 1

    test "$reg" == "-" && reg="/dev/stdin"
    test ! -f "$img" &&
        echo "ERROR: image $img not found." >&2 && return 255
    
    set - $(imsize $img)
    w=$1
    h=$2
    
    echo "<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<svg xmlns=\"http://www.w3.org/2000/svg\"
        version=\"1.1\" baseProfile=\"full\"
        width=\"${w}px\" height=\"${h}px\" fill=\"white\" viewBox=\"0 0 $w $h\">"

    # create svg (shift to left and up to get final mask image to match ds9 region)
    cat $reg | tr '()' ' ' | awk -v w=$w -v h=$h -v id="$id" 'BEGIN{t="text={"id"}"}{
        if(id!~/^$/ && $0!~t) next
        if($1=="circle") {
            na=split($2,a,/,/)
            if (a[3]==0) next
            printf("<circle cx=\"%.3f\" cy=\"%.3f\" r=\"%.3f\" />\n", a[1]-0.5, h-a[2]+0.5, a[3])
        }
        if($1=="box") {
            na=split($2,a,/,/)
            printf("<rect x=\"%.3f\" y=\"%.3f\" width=\"%.3f\" height=\"%.3f\" />\n",
                a[1]-0.5-a[3]/2, h-a[2]+0.5-a[4]/2, a[3], a[4])
        }
        if($1=="polygon") {
            na=split($2,a,/,/)
            printf("<polygon points=\"")
            for(i=1;i<=na/2;i++) {printf("%.3f %.3f ", a[2*i-1]-0.5, h-a[2*i]+0.5)}
            printf("\" />\n")
        }
    }'

    echo "</svg>"
    return
}

reg2pbm () {
    # convert ds9 region file (circle/polygon/box) to pbm
    # regions are interpreted as good pixel regions (white, value=0)
    # output is directed to stdout
    # notes for applying mask:
    #    pnmarith -mul image.ppm mask.pbm > objects_in_reg.ppm
    #    pnminvert mask.pbm | pnmarith -mul image.ppm - > objects_outside_reg.ppm
    # TODO: deal with object rotation (e.g. for a box, rotation is 5th parameter)
    local showhelp
    opts=""
    local i
    for i in $(seq 1 2)
    do
        test "$1" == "-n" && opts="-negate" && shift 1
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    done
    local img=$1
    local reg=$2
    local id=${3:-""}
    local w
    local h
    local tmpsvg=$(mktemp "/tmp/tmp1_$$_XXXXXX.svg")

    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: reg2pbm [-n] <img> <reg> <text_id>" >&2 &&
        return 1

    test ! -f "$img" &&
        echo "ERROR: image $img not found." >&2 && return 255
    
    reg2svg $img $reg $id > $tmpsvg

    # note: canvas size is not kept if libmagick++-6.q16-5 is installed
    #   convert $tmpsvg -negate pbm:
    rsvg-convert $tmpsvg | pngtopnm -alpha - | convert - -threshold 45% $opts pbm:-
    test $? -ne 0 &&
		echo "ERROR: rsvg-convert $tmpsvg failed" >&2 &&
		return 255
    test "$AI_DEBUG" && echo $tmpsvg >&2
    test -z "$AI_DEBUG" && rm -f $tmpsvg
    return 0
}

pbm2reg () {
    # output to stdout
    local showhelp
    local verbose
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-v" && verbose=1 && shift 1
    done
    local pbm=$1
    local angle=140
    local rad=3
    local h
    local svg=$(mktemp "/tmp/tmp_svg_$$_XXXXXX.svg")
    local tmp1=$(mktemp "/tmp/tmp_dat_$$_XXXXXX.dat")

    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: pbm2reg <pbmfile>" >&2 &&
        return 1
    
    echo "ERROR: program under construction (autotrace -> potrace transition)" >&2
    exit 255
    
    h=$(identify $pbm | cut -d " " -f3 | cut -d "x" -f2)
    # TODO: replace autotrace by potrace
    autotrace -output-format svg -corner-surround $rad -corner-threshold $angle $pbm > $svg
    cat $svg | awk '{
        if ($1~/<\/svg>/) ok=0
        if ($1~/<path/) {
            ok=0
            if ($2~/fill:#ffffff/) ok=1
        }
        if (ok==1) printf("%s ", $0)
    }' | sed -e 's/^.* d="//; s|z"/>[ ]*$||; s/L/\nL/g; s/C/\nC/g' > $tmp1
    n=$(grep -v "^[ML]" $tmp1 | wc -l)
    test $n -ne 0 &&
        echo "ERROR: pbm2reg has $n non-line segments (check $tmp1)." >&2 && return 255
    # TODO: maybe rerun auto-/potrace with increased angle
    test "$verbose" && echo "# creating $(cat $tmp1 | wc -l) points" >&2
    echo "# Region file format: DS9 version 4.1
global color=green dashlist=8 3 width=1 font=\"helvetica 10 normal roman\" \
select=1 highlite=1 dash=0 fixed=0 edit=1 move=1 delete=1 include=1 source=1
physical"
    #("
    cat $tmp1 | awk -v h=$h '{
        if ($1~/^M/) onum++
        if (onum>lastnum) {
            if (onum>1) {printf(")\n")}
            printf("polygon(")
            lastnum=onum
        }
        if ($1~/^L/) printf(",")
        sub(/[LM]/, "")
        printf("%s,%s", $1+0.5, h-$2+0.5)
    } END {
        printf(")\n")
    }'
    rm $tmp1 $svg
}


regshift () {
    # shift coordinates in ds9 region file (circle/point/polygon/box)
    # TODO: deal with rotation of coordinate system for polygon and box
    local showhelp
    local do_flip       # if set apply y-flip before coordinate transformation
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-f" && do_yflip=1 && shift 1
    done
    local reg=$1
    local dx=$2         # to the right
    local dy=$3         # to the top
    local da=${4:-"0"}  # rotation angle between coordinate systems in degrees
                        # (counting counter clockwise)
    local w=${5:-"0"}   # width of image where reg has been created from
    local h=${6:-"0"}   # height of image

    (test "$showhelp" || test $# -lt 3) &&
        echo "usage: regshift [-f] <reg> <dx> <dy> [da] [w] [h]" >&2 &&
        return 1

    test "$reg" == "-" && reg="/dev/stdin"
    test "$da" != "0" && test $(echo "$w * $h" | bc) -eq 0 &&
        echo "ERROR: both w and h are required (non-zero)." >&2 && return 255
    
    cat $reg | tr '()' ' ' | awk -v dx=$dx -v dy=$dy -v da=$da -v w=$w -v h=$h -v flip="$do_yflip" '{
        str=""
        for (i=3;i<=NF;i++) str=str" "$i
        if($1=="circle" || $1=="point") {
            na=split($2,a,/,/)
            r=da*3.1415926/180
            if (flip == "") {
                x=w/2+(a[1]-w/2)*cos(r)+(a[2]-h/2)*sin(r)+dx
                y=h/2-(a[1]-w/2)*sin(r)+(a[2]-h/2)*cos(r)+dy
            } else {
                x=w/2+(a[1]-w/2)*cos(r)+(h-a[2]-h/2)*sin(r)+dx
                y=h/2-(a[1]-w/2)*sin(r)+(h-a[2]-h/2)*cos(r)+dy
            }
            if ($1=="circle") printf("%s(%.3f,%.3f,%.2f)%s\n", $1, x, y, a[3], str)
            if ($1=="point")  printf("%s(%.3f,%.3f)%s\n", $1, x, y, str)
            next
        }
        if($1=="box") {
            na=split($2,a,/,/)
            if (flip == "") {
                printf("%s(%.3f,%.3f,%s,%s)%s\n", $1, a[1]+dx, a[2]+dy, a[3], a[4], str)
            } else {
                printf("%s(%.3f,%.3f,%s,%s)%s\n", $1, a[1]+dx, h-a[2]+dy, a[3], a[4], str)
            }
            next
        }
        if($1=="polygon") {
            na=split($2,a,/,/)
            printf("%s(", $1)
            for(i=1;i<=na/2;i++) {
                if (i>1) printf(",")
                if (flip == "") {
                    printf("%.3f,%.3f", a[2*i-1]+dx, a[2*i]+dy)
                } else {
                    printf("%.3f,%.3f", a[2*i-1]+dx, h-a[2*i]+dy)
                }}
            printf(")%s\n", str)
            next
        }
        print $0
    }'
}


# transform region file between large image and croped image
reg2reg () {
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    local reg="$1"
    local img1=$2       # image with corresponding region file
    local img2=$3       # image for which region file is transformed to
    local cropgeom=$4   # wxh+x+y, e.g. from comet/aicomet.dat
    local h1
    local h2
    local dx
    local dy

    (test "$showhelp" || test $# -ne 4) &&
        echo "usage: reg2reg <reg> <fromimg> <toimg> <cropgeom>" >&2 &&
        return 1

    test "$reg" != "-" && test ! -f "$reg" &&
        echo "ERROR: region file $reg does not exist." >&2 && return 255
    test ! -f "$img1" &&
        echo "ERROR: image $img1 does not exist." >&2 && return 255
    test ! -f "$img2" &&
        echo "ERROR: image $img2 does not exist." >&2 && return 255
        
    test "$reg" == "-" && reg="/dev/stdin"

    h1=$(identify $img1 | cut -d " " -f3 | cut -d "x" -f2)
    h2=$(identify $img2 | cut -d " " -f3 | cut -d "x" -f2)
    set - $(echo $cropgeom | tr 'x+' ' ')
    dx=$3
    if [ $h1 -ge $h2 ]
    then
        dy=$((h1-h2-$4))
        regshift $reg -$dx -$dy
    else
        dy=$((h2-h1-$4))
        regshift $reg $dx $dy
    fi
}

regcopy () {
    # copy region (physical coordinates) from one image to another
    # using wcs information
    # write resulting region file to stdout
    local showhelp
    local i
    for i in 1
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    done

    reg=$1
    fromimg=$2
    toimg=$3
    local rtype
    local coord
    local attrib
    local ncoo
    local fromwcs
    local towcs
    local fromps
    local tops
    local rad
    local newcoord
    local f
    local tmprade=$(mktemp "/tmp/tmp_rade_XXXXXX.dat")
    
    (test "$showhelp" || test $# -ne 3) &&
        echo "usage: regcopy <regfile> <fromimage> <toimage>" >&2 &&
        return 1

    fromwcs=${fromimg%.*}.wcs.head
    towcs=${toimg%.*}.wcs.head
    for f in $fromwcs $towcs
    do
        test ! -e $f && error "Header file $f is missing"
    done

    # determine scale factor
    fromps=$(get_wcspscale $fromwcs)
    tops=$(get_wcspscale $towcs)
    scale=$(echo $fromps $tops | awk '{print $2/$1}')
    echo -e "# Region file format: DS9 version 4.1
global color=green dashlist=8 3 width=1 font=\"helvetica 10 normal roman\" \
select=1 highlite=1 dash=0 fixed=0 edit=1 move=1 delete=1 include=1 source=1
physical"

    grep -iwE "^circle|^polygon|^box" $reg | tr '()' ' ' | while read rtype coord attrib
    do
        newcoord=""
        # ncoo=$(echo $coord | tr ',' ' ' | wc -w | awk '{print $1/2}')
        # echo $rtype $ncoo $attrib
        case $rtype in
            polygon)
                    echo $coord | sed -e 's/\(,[^,]*\),/\1\n/g' | \
                        sed -e 's/^/circle /; s/,/ /' | \
                        reg2xy $fromimg - | xy2rade - $fromwcs > $tmprade
                    newcoord=$(cat $tmprade | sed -e 's/^/XX /' | \
                        rade2xy - $towcs | xy2reg $toimg - | \
                        grep "^circle" | tr '()' ' ' | cut -d ' ' -f2 | \
                        cut -d ',' -f1,2 | tr '\n' ',' | sed -e 's/,$//')
                    ;;
            circle)
                    rad=$(echo $coord | tr ',' ' ' | awk -v s=$scale '{print s*$3}')
                    echo $coord | tr ',' ' ' | sed -e 's/^/circle /' | \
                        reg2xy $fromimg - | xy2rade - $fromwcs > $tmprade
                    newcoord=$(cat $tmprade | sed -e 's/^/XX /' | \
                        rade2xy - $towcs | xy2reg $toimg - | \
                        grep "^circle" | tr '()' ' ' | cut -d ' ' -f2 | \
                        cut -d ',' -f1,2)
                    newcoord="$newcoord,$rad"
                    ;;
            *)      echo "WARNING: unsupported region type $rtype" >&2 && continue
                    ;;
        esac
        echo "$rtype($newcoord)" $attrib
    done
    rm $tmprade
    return
}

regskip () {
    # skip small regions below given size
    # for circle,box it uses the area, for polygons it uses region extent
    local showhelp
    local i
    for i in 1
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    done
    local reg=$1
    local minsize=${2:-"5"}
    local x
    local rtype
    
    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: regskip <regfile> [minsize|$minsize]" >&2 &&
        return 1

    ! is_reg $reg &&
        echo "ERROR: file $reg is not a ds9 region file." >&2 && return 255
    
    while read
    do
        rtype=${REPLY%%(*}
        # check region extent
        x=""
        case "$rtype" in
            circle) x=$(echo $REPLY | tr '(,)' ' ' | awk '{
                        x=3.1416*$4*$4
                        printf("%.1f", x)}')
                    ;;
            box)    x=$(echo $REPLY | tr '(,)' ' ' | awk '{
                        x=$4*$5
                        printf("%.1f", x)}')
                    ;;
            polygon) x=$(echo $REPLY | cut -d ')' -f1 | cut -d '(' -f2 | \
                        tr ',' '\n' | awk '{
                        if (NR%2 == 1) {
                            if (NR==1 || $1<x1) x1=$1
                            if (NR==1 || $1>x2) x2=$1
                        } else {
                            if (NR==2 || $1<y1) y1=$1
                            if (NR==2 || $1>y2) y2=$1
                        }} END {
                        x=(x2-x1)*(y2-y1)
                        printf("%.1f", x)}')
                    ;;
        esac
        test -z "$x" && echo "$REPLY" && continue
        test "$AI_DEBUG" && echo $x ${REPLY%%,*} >&2
        if [ "$(echo $x $minsize | awk '{if($1>=$2) {print "ok"}}')" ]
        then
            echo "$REPLY"
        else
            echo "# size=$x $REPLY"
        fi
    done < $reg
    return
}


# create subset from ds9 region file by matching object ids (sep by ',')
# id is taken from first string in text attribute in <reg>
ds9match () {
    local showhelp
    local do_reject    # if set the given objects are rejected
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-n" && do_reject=1 && shift 1
    done
    local reg=$1
    local olist=$2      # separated by ','

    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: ds9match [-n] <reg> <idlist>" >&2 &&
        return 1

    test "$reg" == "-" && reg="/dev/stdin"
    cat $reg | awk -v olist="$olist" -v mode=${do_reject:-"0"} '{
        if ($1!~/^[a-z]*\(/) {
            print $0
        } else {
            n=index($0,"text={")
            id=substr($0,n+6)
            sub(/}.*/,"",id)
            sub(/ .*/,"",id)
            id=","id","
            if (match(","olist",", id) > 0) {
                if (mode==0) print $0
            } else {
                if (mode!=0) print $0
            }
        }
    }'
}


# convert from fits coordinates to image coordinates
fits2xy () {
    local showhelp
    local offset=0
    local i
    for i in 1 2 3
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-i" && offset=0.5 && shift 1
    done
    local img=$1    # image file name or height of image
    local x=$2
    local y=$3
    local h
    
    (test "$showhelp" || test $# -ne 3) &&
        echo "usage: fits2xy [-i] <img> <x> <y>" >&2 &&
        return 1
    
    is_number $img && h=$img
    if [ -z "$h" ]
    then
        test ! -e $img &&
            echo "ERROR: image file $img not found." >&2 && return 255
        h=$(identify $img | cut -d " " -f3 | cut -d "x" -f2)
    fi
    echo $x $y | awk -v h=$h -v o=$offset '{print $1-0.5-o" "h-$2+0.5-o}'
}


# convert from image coordinates to fits image coordinates
# use option -i if input is image pixel number (upper left: 0,0)
xy2fits () {
    local showhelp
    local offset=0
    local i
    for i in 1 2 3
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-i" && offset=0.5 && shift 1
    done
    local img=$1    # image file name or height of image
    local x=$2
    local y=$3
    local h
    
    (test "$showhelp" || test $# -ne 3) &&
        echo "usage: xy2fits [-i] <img> <x> <y>" >&2 &&
        return 1
    
    is_number $img && h=$img
    if [ -z "$h" ]
    then
        test ! -e $img &&
            echo "ERROR: image file $img not found." >&2 && return 255
        set - $(imsize $img)
        h=$2
    fi
    echo $x $y | awk -v h=$h -v o=$offset '{print $1+0.5+o" "h-$2+0.5-o}'
}


# convert from point (image coordinates) to ds9 circle region (fits coordinates)
xy2reg () {
    local showhelp
    local regtype=c
    local has_fitscoord # if set, then assume data is in fits coordinates
    local i
    for i in 1 2 3
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-p" && regtype=p && shift 1
        test "$1" == "-f" && has_fitscoord=1 && shift 1
    done
    local img=$1    # image to extract height
    local dat=$2
    local dx=${3:-"0"}      # additive correction to xy coordinates
    local dy=${4:-"0"}
    local rad=${5:-"5"}
    local idcol=${6:-1}
    local xcol=${7:-2}
    local ycol=${8:-3}
    local magcol=${9:-5}    # will be appended to id string
    local h

    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: xy2reg [-p] [-f] <img> <xydat> [dx|$dx] [dy|$dy] [rad|$rad]" \
            "[idcol|$idcol] [xcol|$xcol] [ycol|$ycol] [magcol|$magcol]" >&2 &&
        return 1

    test "$dat" == "-" && dat="/dev/stdin"
    (test -z "$idcol" || test $idcol -lt 1) && idcol=0
    test ! -f $img &&
        echo "ERROR: image $img does not exist." >&2 && return 255

    set - $(imsize $img)
    h=$2
    test "$has_fitscoord" && h=0
    
    echo -e "# Region file format: DS9 version 4.1
global color=green dashlist=8 3 width=1 font=\"helvetica 10 normal roman\" \
select=1 highlite=1 dash=0 fixed=0 edit=1 move=1 delete=1 include=1 source=1
physical"
    cat $dat | awk -v h=$h -v dx=$dx -v dy=$dy -v ic=$idcol \
        -v xc=$xcol -v yc=$ycol -v mc=$magcol -v t=$regtype -v r=$rad '{
        if ($1~/^#/) next
        if (h>0) { # input is image coord
            xx=$xc+dx+0.5
            yy=h-$yc-dy+0.5
        } else { # input is fits coord
            xx=$xc+dx
            yy=$yc-dy
        }
        if (t=="p") {
            printf("polygon(%.2f,%.2f", xx-r, yy-r)
            printf(",%.2f,%.2f",        xx+r, yy-r)
            printf(",%.2f,%.2f",        xx+r, yy+r)
            printf(",%.2f,%.2f)",       xx-r, yy+r)
        } else {
            printf("circle(%.2f,%.2f,%s)", xx, yy, r)
        }
        id=""
        if (ic>0) id=$ic
        #if ((mc>0) && (mc<=NF) && ($mc~/^[0-9.+-]*$/)) id=id" "$mc
        if ((mc>0) && (mc<=NF)) id=id" "$mc
        if (id != "") {printf(" # text={%s}\n", id)} else {printf("\n")}
    }'
}

xymatch () {
    # match objects between two lists (format: id x y ...)
    # output: idref xref yref xaff yaff dx dy d idxy
    local showhelp
    local showall   # if set list unmatched objects from xydat as will
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-a" && showall=1 && shift 1
    done
    local xydat="$1"        # columns: id x y (any more columns are ignored)
    local refdat="$2"       # columns: id x y (any more columns are ignored)
    local dmax=${3:-"3"}    # max. distance in pix
    local dx=${4:-"0"}      # xoff added to xydat
    local dy=${5:-"0"}      # yoff added to xydat (>0 mean downshift!)
    local da=${6:-""}       # rotation angle (degrees around center) added to xydat
    local w=${7:-""}
    local h=${8:-""}
    local jointype          # "1and2" show matches only, "all1" left outer join
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpxy=$(mktemp "$tdir/tmp_xy_$$.XXXXXX.dat")
    local tmpref=$(mktemp "$tdir/tmp_ref_$$.XXXXXX.dat")
    local tmpout=$(mktemp "$tdir/tmp_out_$$.XXXXXX.dat")
    
    
    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: xymatch [-a] <xydat> <refdat> [dmax|$dmax] [dx|$dx]"\
            "[dy|$dy] [rot|$da] [w|$w] [h|$h]" >&2 &&
        return 1

    test "$da" && (test -z "$w" || test -z "$h") &&
        echo "ERROR: parameter w and/or h missing (required to apply rotation)." >&2 &&
        return 255

    # apply coord transformation to xydat
    echo "# ID X Y" > $tmpxy
    grep -v "^#" $xydat | awk -v dx=$dx -v dy=$dy -v da="$da" -v w="$w" -v h="$h" '{
            if (da == 0) {
                printf("%s %.2f %.2f\n", $1, $2+dx, $3+dy)
            } else {
                pi=3.1415927
                r=sqrt((h/2-$3)^2 + ($2-w/2)^2)
                a=atan2($3-h/2, $2-w/2)*180/pi+da
                printf("%s %.2f %.2f\n", $1, w/2+r*cos(a*pi/180)+dx, h/2+r*sin(a*pi/180)+dy)
            }
        }' >> $tmpxy
    
    # extract columns id x y from refdat
    echo "# ID X Y" > $tmpref
    grep -v "^#" $refdat | awk '{printf("%s %s %s\n", $1, $2, $3)}' >> $tmpref
    
    # do xy matching
    jointype="1and2"
    test "$showall" && jointype="all1"

    stilts tmatch2 in1=$tmpxy in2=$tmpref ifmt1=ascii ifmt2=ascii \
        matcher=2d join=$jointype values1='X Y' values2='X Y' params=$dmax \
        ocmd='addcol XDIFF X_2-X_1; addcol YDIFF Y_2-Y_1' \
        ofmt=ascii out=$tmpout 2>/dev/null
    test $? -ne 0 &&
        echo "ERROR: failed command:" >&2 &&
        echo "    stilts tmatch2 in1=$tmpxy in2=$tmpref ifmt1=ascii ifmt2=ascii \
        matcher=2d values1='X Y' values2='X Y' params=$dmax \
        ocmd='addcol XDIFF X_2-X_1; addcol YDIFF Y_2-Y_1' \
        ofmt=ascii out=$tmpout" >&2 &&
        return 255
    
    # format output to resemble the old xymatch output
    echo "# id     xref     yref      x      y        dx   dy   d    idxy"
    grep -v "^#" $tmpout | awk '{
        if ($4 == "\"\"") {
            printf("# %-8s %7.2f %7.2f  not found\n", $1, $2, $3)
        } else {
            printf("%-8s %7.2f %7.2f  %7.2f %7.2f  %4.1f %4.1f %4.1f  %s\n",
                    $1, $5, $6, $2, $3, $8, $9, $7, $4)
        }}'

    test "$AI_DEBUG" && echo $tmpxy $tmpref $tmpout >&2
    test -z "$AI_DEBUG" && rm -f $tmpxy $tmpref $tmpout
    return
}

xymatch_old () {
    # match objects between two lists (format: id x y ...)
    # output: id xref yref xaff yaff dx dy d idref
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    local xydat="$1"
    local refdat="$2"
    local dmax=${3:-"3"}    # max. distance in pix
    local dx=${4:-"0"}      # xoff added to xydat
    local dy=${5:-"0"}      # yoff added to xydat (>0 mean downshift!)
    local da=${6:-""}       # rotation angle (degrees) added to xydat
    local w=${7:-""}
    local h=${8:-""}
    local idcol=${9:-1}     # currently unused!
    local xcol=${10:-2}
    local ycol=${11:-3}
    local id
    local x
    local y
    local z
    
    
    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: xymatch <xydat> <refdat> [dmax|$dmax] [dx|$dx]"\
            "[dy|$dy] [rot|$da] [w|$w] [h|$h]" >&2 &&
        return 1

    test "$da" && (test -z "$w" || test -z "$h") &&
        echo "ERROR: parameter w and/or h missing (required due to rotation)." >&2 &&
        return 255

    # TODO: for large catalogues it is advised to work in segments,
    #   e.g. cut xydat in smaller boxes and use those to work on
    #   subsets of refdat
    echo "# id     xref     yref      x      y        dx   dy   d    idref"
    while read id x y z
    do
        test "${id:0:1}" == "#" && continue
        # apply rotation with respect to image center and translation
        set - $(echo $x $y $dx $dy $w $h $da | awk '{
            if ($7 == 0) {
                printf("%s %s\n", $1+$3, $2+$4)
            } else {
                pi=3.1415927
                r=sqrt(($6/2-$2)^2 + ($1-$5/2)^2)
                a=atan2($2-$6/2, $1-$5/2)*180/pi+$7
                printf("%.2f %.2f\n", $5/2+r*cos(a*pi/180)+$3, $6/2+r*sin(a*pi/180)+$4)
            }}')
        #echo "circle($1,$2,5) # text={$id}" >&2
        grep -v "^#" $refdat | awk -v id=$id \
            -v x=$1 -v y=$2 -v z="$z" -v dlim=$dmax 'BEGIN{found=0}{
                dx=$2-x
                if ((dx>dlim) || (dx<-1.0*dlim)) next
                dy=$3-y
                if ((dy>dlim) || (dy<-1.0*dlim)) next
                d=sqrt(dx*dx+dy*dy)
                if (d>dlim) next
                found=1
                printf("%-8s %7.2f %7.2f  %7.2f %7.2f  %4.1f %4.1f %4.1f  %s\n",
                    id, $2, $3, x, y, dx, dy, d, $1)
            }END{
                if (found == 0)
                    printf("# %-8s %8s %8s  not found\n", id, x, y)
            }'
    done < $xydat
}


# get subset of region file based on object ids
regmatch () {
    local showhelp
    local i
    for i in 1
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    done
    local reg=$1
    local idlist=$2     # ids separated by space or comma
    local id

    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: regmatch <reg> <idlist>" \
            "[xcol|$xcol] [ycol|$ycol] [fwhmcol|$fwhmcol]" >&2 &&
        return 1

    grep -vE "^circle\(|^box\(|^polygon\(|^line\(|^ellipse\(" $reg
    for id in $idlist
    do
        grep "text={$id " $reg
    done
    return
}

regfilter () {
    # apply spatial filtering of a fits table using ds9 region file
    # output fits table to stdout
    local showhelp
    local maxfwhm     # if set limit to fwhm<=maxfwhm
    local verbose
    local i
    for i in 1 2 3
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-f" && maxfwhm=$2 && shift 2
        test "$1" == "-v" && verbose=1 && shift 1
    done
    local ftab=$1
    local reg=$2
    local xycol=${3:-"X.*_IMAGE|Y.*_IMAGE"}
    local xcol
    local ycol
    local fwhmcol="FWHM_IMAGE"
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmp1=$(mktemp "$tdir/tmp_tmp1_XXXXXX.fits")
    local tmp2=$(mktemp "$tdir/tmp_tmp1_XXXXXX.fits")
    local tmpftab=$(mktemp "$tdir/tmp_ftab_XXXXXX.fits")
    local tmpreg=$(mktemp "$tdir/tmp_reg_XXXXXX.reg")
    local filter
    local hlist
    local ncol
    local fext

    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: regfilter [-f maxfwhm] <fitstab> <regfile> <xycol>" >&2 &&
        return 1

    test "$ftab" != "-" && test ! -f "$ftab" &&
        echo "ERROR: FITS table file $ftab not found." >&2 && return 255
    test "$reg" != "-" && test ! -f "$reg" &&
        echo "ERROR: ds9 region file $reg not found." >&2 && return 255

    test "$ftab" == "-" && cat > $tmpftab && ftab=$tmpftab
    test "$reg" == "-" && cat > $tmpreg && reg=$tmpreg

    # find HDU's with given x,y columns
    filter="for HDU|$xycol"; ncol=2
    test "$maxfwhm" && filter="$filter|$fwhmcol" && ncol=3
    hlist=$(listhead $ftab | tr "'" '\n' | grep -wiE "$filter" | \
        awk '{if (NF>1) printf("\n"); printf("%s ", $NF)}' | \
        awk -v n=$ncol '{if (NF==n+1) printf("%s ", $1)}' | tr -d '#:')
    test -z "$hlist" &&
        echo "ERROR: no table extension having columns $xycol" >&2 && return 255
    test "$AI_DEBUG" && echo "# hlist=$hlist" >&2

    cp $ftab $tmp1
    for fext in $hlist
    do
        filter="${xycol%|*}"
        xcol=$(listhead ${ftab}"[$((fext-1))]" | tr "'" '\n' | grep -wiE "$filter")
        filter="${xycol#*|}"
        ycol=$(listhead ${ftab}"[$((fext-1))]" | tr "'" '\n' | grep -wiE "$filter")
        test "$AI_DEBUG" && echo "# regfilter xcol=$xcol ycol=$ycol" >&2
        if [ "$maxfwhm" ]
        then
            fitscopy $tmp1"[$((fext-1))][regfilter('$reg', $xcol, $ycol); $fwhmcol < $maxfwhm]" - > $tmp2
        else
            fitscopy $tmp1"[$((fext-1))][regfilter('$reg', $xcol, $ycol)]" - > $tmp2
            test $? -ne 0 && echo "ERROR in fitscopy." >&2 &&
                echo "fitscopy $tmp1\"[$((fext-1))][regfilter('$reg', $xcol, $ycol)]\" - > $tmp2" >&2 &&
                return 255
        fi
        mv $tmp2 $tmp1
    done
    
    cat $tmp1
    rm $tmp1 $tmpftab $tmpreg
}


# image statistics within region
regstat2 () {
    local showhelp
    local kappa=3.5
    local do_green_only
    local do_merge_all_regions  # if set then stats is for the combined region
    local do_quick              # skip kappa-sigma clipping
    local do_minmax             # if set then show min/max/mean instead of noise stats
    local verbose               # currently not used
    local i
    for i in 1 2 3 4 5 6 7
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-a" && do_merge_all_regions=1 && shift 1
        test "$1" == "-k" && kappa="$2" && shift 2
        test "$1" == "-g" && do_green_only=1 && shift 1
        test "$1" == "-q" && do_quick=1 && shift 1
        test "$1" == "-m" && do_minmax=1 && shift 1
        test "$1" == "-v" && verbose=1 && shift 1
    done
    local img=$1
    local reg=$2
    local badreg=${3:-""}
    local tmpreg1=$(mktemp /tmp/tmp_reg1_XXXXXX.reg)
    local tmpreg2=$(mktemp /tmp/tmp_reg2_XXXXXX.reg)
    local opts=""

    (test "$showhelp" || test $# -lt 2 || test $# -gt 3) &&
        echo "usage: regstat [-q] [-g] [-m] [-a] [-k kappa|$kappa] <image> <reg> [badreg]" >&2 &&
        return 1
    test "$reg" == "-" && cat /dev/stdin > $tmpreg1 && reg=$tmpreg1
    test ! -f "$img" &&
        echo "ERROR: image file $img not found." >&2 && return 255
    #! is_reg "$reg" &&
    #    echo "ERROR: $reg is not a valid region file." >&2 && return 255
    
    test "$do_quick" && opts="-q"
    test "$do_minmax" && opts="-m"
    if [ "$do_merge_all_regions" ]
    then
        _regstat2 $opts $img $reg $badreg
    else
        grep -iwE "^circle|^polygon|^box" $reg | while read
        do
            echo "$REPLY" > $tmpreg2
            _regstat2 $opts $img $tmpreg2 $badreg
        done
    fi
    rm $tmpreg1 $tmpreg2
}

regstat () {
    local showhelp
    local kappa=3.5
    local do_green_only
    local do_merge_all_regions  # if set then stats is for the combined region
    local do_quick              # skip kappa-sigma clipping
    local do_minmax             # if set then show min/max/mean instead of noise stats
    local verbose               # currently not used
    local i
    for i in 1 2 3 4 5 6 7
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-a" && do_merge_all_regions=1 && shift 1
        test "$1" == "-k" && kappa="$2" && shift 2
        test "$1" == "-g" && do_green_only=1 && shift 1
        test "$1" == "-q" && do_quick=1 && shift 1
        test "$1" == "-m" && do_minmax=1 && shift 1
        test "$1" == "-v" && verbose=1 && shift 1
    done
    local img=$1
    local reg=$2
    local badreg=${3:-""}
    local tmpreg1=$(mktemp /tmp/tmp_reg1_XXXXXX.reg)
    local tmpreg2=$(mktemp /tmp/tmp_reg2_XXXXXX.reg)
    local opts=""

    (test "$showhelp" || test $# -lt 2 || test $# -gt 3) &&
        echo "usage: regstat [-q] [-g] [-m] [-a] [-k kappa|$kappa] <image> <reg> [badreg]" >&2 &&
        return 1
    test "$reg" == "-" && cat /dev/stdin > $tmpreg1 && reg=$tmpreg1
    test ! -f "$img" &&
        echo "ERROR: image file $img not found." >&2 && return 255
    #! is_reg "$reg" &&
    #    echo "ERROR: $reg is not a valid region file." >&2 && return 255
    
    test "$do_quick" && opts="-q"
    test "$do_minmax" && opts="-m"
    if [ "$do_merge_all_regions" ]
    then
        _regstat $opts $img $reg $badreg
    else
        grep -iwE "^circle|^polygon|^box" $reg | while read
        do
            echo "$REPLY" > $tmpreg2
            _regstat $opts $img $tmpreg2 $badreg
        done
    fi
    rm $tmpreg1 $tmpreg2
}

_regstat2 () {
    # note: show only limited stats, this is NOT a replacement for _regstat
    local do_minmax
    test "$1" == "-q" && shift 1    # ignored
    test "$1" == "-m" && do_minmax=1 && shift 1
    local img=$1
    local reg=$2
    local badreg=${3:-""}
    local area
    local mean
    local sd
    local min
    local max
    local tmpregmask=$(mktemp /tmp/tmp_regmask_XXXXXX.svg)
    local tmpbadmask=$(mktemp /tmp/tmp_badmask_XXXXXX.svg)
    local pyprog
    
    # check for required python scripts
    pyprog=$(which airfun.py)
    test $? -ne 0 &&
        echo "ERROR: missing python module airfun.py." >&2 && return 255

    # convert mask regions to svg
    reg2svg $img $reg > $tmpregmask
    if [ "$badreg" ]
    then
        reg2svg $img $badreg > $tmpbadmask
    else
        rm $tmpbadmask
        tmpbadmask=""
    fi
    
    # do limited stats
    if [ ! "$do_minmax" ]
    then
        stats=$(python3 $pyprog regstat $img $tmpregmask $tmpbadmask)
    else
        stats=$(python3 $pyprog regstat -m $img $tmpregmask $tmpbadmask)
    fi
    
    # get region text
    id=$(grep "^[a-z]*(.*).* # text={" $reg | cut -d '{' -f2 | tr -d '}')
    n=$(echo "$id" | wc -l)
    test $n -gt 1 && id="${n}_regions"
    echo $stats $id
    
    test "$AI_DEBUG" || rm $tmpregmask $tmpbadmask
    return
}

_regstat () {
    local do_quick
    local do_minmax
    test "$1" == "-q" && do_quick=1 && shift 1
    test "$1" == "-m" && do_minmax=1 && shift 1
    local img=$1
    local reg=$2
    local badreg=$3
    local tmpreg1=$(mktemp /tmp/tmp_reg1_XXXXXX.reg)
    local tmp1=$(mktemp /tmp/tmp_tmp1_XXXXXX.dat)
    local tmpmask=$(mktemp /tmp/tmp_mask_XXXXXX.pbm)
    local tmpmask2=$(mktemp /tmp/tmp_mask2_XXXXXX.pbm)
    local tmpim1=$(mktemp /tmp/tmp_img_XXXXXX.pnm)
    local w
    local h
    local xmin
    local xmax
    local ymin
    local ymax
    local dx
    local dy
    local area
    local mean
    local sum
    local bgmean
    local sd
    local min
    local max
    local idx
    local n

    # determine region extent
    set - $(imsize $img)
    w=$1
    h=$2
    cat $reg | tr '()' ' ' | awk -v w=$w -v h=$h '{
        if($1=="circle") {
            na=split($2,a,/,/)
            if (a[3]==0) next
            printf("%.3f %.3f\n", a[1]-a[3], a[2]-a[3])
            printf("%.3f %.3f\n", a[1]+a[3], a[2]+a[3])
        }
        if($1=="box") {
            na=split($2,a,/,/)
            printf("%.3f %.3f\n", a[1]-a[3]/2, a[2]-a[4]/2)
            printf("%.3f %.3f\n", a[1]+a[3]/2, a[2]+a[4]/2)
        }
        if($1=="polygon") {
            na=split($2,a,/,/)
            for(i=1;i<=na/2;i++) {printf("%.3f %.3f\n", a[2*i-1], a[2*i])}
        }
    }' > $tmp1
    # region boundary in image coordinates
    xmin=$(sort -n -k1,1 $tmp1  | lines 1 | awk -v w=$w '{
        x=$1-1.0; if(x<0) x=0; if(x>w) x=w; printf("%.0f",x)}')
    xmax=$(sort -nr -k1,1 $tmp1 | lines 1 | awk -v w=$w '{
        x=$1;     if(x<0) x=0; if(x>w) x=w; printf("%.0f",x)}')
    ymin=$(sort -nr -k2,2 $tmp1 | lines 1 | awk -v h=$h '{
        y=h-$2;     if(y<0) y=0; if(y>h) y=h; printf("%.0f",y)}')
    ymax=$(sort -n -k2,2 $tmp1  | lines 1 | awk -v h=$h '{
        y=h-$2+1.0; if(y<0) y=0; if(y>h) y=h; printf("%.0f",y)}')
    dx=$((xmax-xmin))
    dy=$((ymax-ymin))
    test "$AI_DEBUG" && echo "x: $xmin - $xmax   y: $ymin - $ymax" >&2
    
    (test $dx -eq 0 || test $dy -eq 0) &&
        echo "ERROR: region outside image." >&2 && return 255

    # create subimage, trim region file, create and apply mask image
    test "$AI_DEBUG" && echo "imcrop -1 <img> $dx $dy $xmin $ymin" >&2
    if is_pnm $img
    then
        imcrop -1 $img $dx $dy $xmin $ymin > $tmpim1
    else
        if is_fits $img
        then
            meftopnm $img | imcrop -1 - $dx $dy $xmin $ymin > $tmpim1
        else
            echo "ERROR: $img is not a valid image file." >&2 && return 255
        fi
    fi
    reg2reg $reg $img $tmpim1 ${dx}x${dy}+${xmin}+${ymin} > $tmpreg1
    reg2pbm $tmpim1 $tmpreg1 > $tmpmask
    if [ "$badreg" ]
    then
        mv $tmpmask $tmpmask2
        reg2reg $badreg $img $tmpim1 ${dx}x${dy}+${xmin}+${ymin} > $tmpreg1
        reg2pbm $tmpim1 $tmpreg1 | pnmarith -sub $tmpmask2 - > $tmpmask
    fi
    test "$AI_DEBUG" && echo $tmpim1 $tmpreg1 $tmpmask >&2
    
    
    if [ "$do_quick" ] && [ ! "$do_minmax" ]
    then
        area=$(imcount $tmpmask)
        sum=$(pnmarith -mul $tmpim1 $tmpmask 2>/dev/null | imcount -)
        mean=$(echo $sum $area | tr ',' ' ' | awk '{
            if($NF>0) {
                printf("%.1f", $1/$NF)
                if(NF==4) printf(",%.1f,%.1f", $2/$NF, $3/$NF)
            } else {
                printf("0")
                if(NF==4) printf(",0,0")
            }}')
        bgmean=$mean
        sd=0
    else
        # list data values shifted by +1
        is_pgm $tmpim1 && pnmccdred -a 1 $tmpim1 - | pnmarith -mul - $tmpmask 2>/dev/null | \
            pnmnoraw | grep -v "^#" | sed '1,3d;s/ /\n/g'  | grep "[0-9]" | grep -v "^0$" > $tmp1
        is_ppm $tmpim1 && pnmccdred -a 1 $tmpim1 - | pnmarith -mul - $tmpmask 2>/dev/null | \
            pnmnoraw | grep -v "^#" | sed '1,3d;s/  /\n/g' | grep "[0-9]" | grep -v "^0 0 0$" > $tmp1
        test "$AI_DEBUG" && echo $tmp1 >&2

        # get statistics
        clist=1
        is_ppm $tmpim1 && clist="1 2 3"
        test "$do_green_only" && is_ppm $tmpim1 && clist=2
        area=$(wc -l $tmp1 | cut -d ' ' -f1)
        test $area -eq 0 && echo "ERROR: no data points, no stats" && return 255
        for idx in $clist
        do
            test "$mean" && mean=$mean"," && sum=$sum"," &&
                bgmean=$bgmean"," && sd=$sd"," &&
                min=$min"," && max=$max","
            mean="$mean"$(mean $tmp1 $idx | awk '{printf("%.1f", $1-1)}')
            sum="$sum"$(sum $tmp1 $idx | awk -v a=$area '{printf("%.0f", $1-a)}')
            if [ "$do_minmax" ]
            then
                set - $(minmax $tmp1 $idx | awk '{printf("%.1f %.1f", $1-1, $2-1)}')
                min="$min"$1; max="$max"$2
            fi
            if [ $area -lt 5 ]
            then
                bgmean=$mean
                sd=0
            else
                set - $(kappasigma $tmp1 $idx $kappa)
                bgmean="$bgmean"$(echo $1 | awk '{printf("%.1f", $1-1)}')
                sd="$sd"$(echo $2| awk '{printf("%.1f", $1)}')
            fi
        done
    fi
    
    # get region text
    id=$(grep "^[a-z]*(.*).* # text={" $reg | cut -d '{' -f2 | tr -d '}')
    n=$(echo "$id" | wc -l)
    test $n -gt 1 && id="${n}_regions"
    test ! "$do_minmax" && echo $bgmean $sd $area $sum $mean $id
    test   "$do_minmax" && echo $min $max $mean $area $id
    
    test "$AI_DEBUG" || rm $tmp1 $tmpreg1 $tmpim1 $tmpmask $tmpmask2
    return
}

# get region extent (fits coord: xmin xmax ymin ymax)
get_extent () {
    local reg=$1
    local tmp1=$(mktemp /tmp/tmp_tmp1_XXXXXX.dat)

    cat $reg | tr '()' ' ' | awk '{
        if($1=="circle") {
            na=split($2,a,/,/)
            if (a[3]==0) next
            printf("%.3f %.3f\n", a[1]-a[3], a[2]-a[3])
            printf("%.3f %.3f\n", a[1]+a[3], a[2]+a[3])
        }
        if($1=="box") {
            na=split($2,a,/,/)
            printf("%.3f %.3f\n", a[1]-a[3]/2, a[2]-a[4]/2)
            printf("%.3f %.3f\n", a[1]+a[3]/2, a[2]+a[4]/2)
        }
        if($1=="polygon") {
            na=split($2,a,/,/)
            for(i=1;i<=na/2;i++) {printf("%.3f %.3f\n", a[2*i-1], a[2*i])}
        }
    }' > $tmp1
    # region boundary in image coordinates
    xmin=$(sort -n -k1,1 $tmp1  | lines 1 | awk '{printf("%s", $1)}')
    xmax=$(sort -nr -k1,1 $tmp1 | lines 1 | awk '{printf("%s", $1)}')
    ymin=$(sort -n -k2,2 $tmp1  | lines 1 | awk '{printf("%s", $2)}')
    ymax=$(sort -nr -k2,2 $tmp1 | lines 1 | awk '{printf("%s", $2)}')
    echo "$xmin $xmax $ymin $ymax"
}

findgain () {
    # determine gain from noise statistics of a pair of images
    local showhelp
    local kappa=5
    local dkvalue
    local dknoise
    local i
    for i in 1 2 3 4
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-a" && do_merge_all_regions=1 && shift 1
        test "$1" == "-k" && kappa="$2" && shift 2
        test "$1" == "-d" && dkvalue="$2" && dknoise="$3" && shift 3
    done
    local img1=$1
    local img2=$2
    local reg=${3:-""}
    local noise
    local sd
    local mean
    local str
    local tmpimg=$(mktemp /tmp/tmp_img_XXXXXX.pnm)
    local tmpreg=$(mktemp /tmp/tmp_reg_XXXXXX.reg)
    local tmpdat=$(mktemp /tmp/tmp_dat_XXXXXX.dat)

    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: findgain [-a] [-k kappa|$kappa] [-d dkvalue dknoise]" \
            "<image1> <image2> [regfile]" >&2 &&
        return 1
    
    ! is_pnm $img1 &&
        echo "ERROR: $img1 is not a valid image (ppm, pgm)." >&2 &&
        return 255
    ! is_pnm $img2 &&
        echo "ERROR: $img2 is not a valid image (ppm, pgm)." >&2 &&
        return 255

    pnmccdred -a 1000 -d $img2 $img1 $tmpimg
    if [ -z "$reg" ] || [ ! -s "$reg" ]
    then
        touch x.findgain.reg
        reg=x.findgain.reg
        echo "# Please define bg regions and save as $reg ..." >&2
        AIexamine -n findgain -l $tmpimg
    fi 
    
    test ! -s "$reg" &&
        echo "ERROR: file $reg is empty." >&2 && return 255
    regstat -k $kappa $tmpimg $reg > $tmpdat
    # cat $tmpdat
    set - $(kappasigma $tmpdat 2 99 | awk -v n=$(cat $tmpdat | wc -l) '{
        printf("%.3f %.3f", $1/sqrt(2), $2/sqrt(2)/sqrt(n-1))}')
    noise=$1
    sd=$2
    if [ "$dknoise" ]
    then
        pnmcombine $img2 $img1 $tmpimg 2>/dev/null
        regstat -k $kappa $tmpimg $reg > $tmpdat
        mean=$(kappasigma $tmpdat 1 99 | awk -v dk=$dkvalue '{printf("%.1f", $1-dk)}') 
        str="$(echo $noise $sd $mean $dknoise | awk '{
            x=$1*$1-$4*$4
            l=($1+$2)*($1+$2)-$4*$4
            h=($1-$2)*($1-$2)-$4*$4
            g=sqrt($3/x)
            dg=(sqrt($3/h)-sqrt($3/l))/2
            printf("%.3f %.3f", g, dg)}')"
    fi
    echo $noise $sd $mean $str
    
    rm $tmpimg $tmpdat1 $tmpreg
}

# show subset of an object list (id x y) located within given regions
xyinreg () {
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    local xydat="$1"    # x, y in FITS coordinates
    local reg="$2"
    local colnames=${3:-"ID XWIN_IMAGE YWIN_IMAGE"}
    local ndat
    local ncolnames
    local tmpin=$(mktemp "/tmp/tmp1_in_XXXXXX.dat")
    local tmpxy=$(mktemp "/tmp/tmp1_xy_XXXXXX.dat")
    local ftab=$(mktemp "/tmp/tmp1_tab_XXXXXX.fits")
    local ftab2=$(mktemp "/tmp/tmp1_tab2_XXXXXX.fits")

    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: xyinreg <xydat> <reg> [colnames|$colnames]" >&2 &&
        return 1

    test "$xydat" == "-" && cat > $tmpin && xydat=$tmpin
    test ! -f "$reg" &&
        echo "ERROR: ds9 region file $reg not found." >&2 && return 255

    # check for matching number of columns
    # note: ignore "sat" flag at end of line of photometry data files
    ndat=$(grep -v "^#" $xydat | lines 1 | sed -e 's, sat$,,' | wc -w)
    ncolnames=$(echo $colnames | wc -w)
    test $ndat -lt $ncolnames &&
        echo "ERROR: number of column names ($ncolnames) is larger than" \
            "number of data columns ($ndat) in $xydat." >&2 && return 255

    # convert xydat to fits table (skipping excess columns)
    echo "# $colnames" > $tmpxy
    grep -v "^#" $xydat | awk -v nc=$ncolnames '{
        for(i=1;i<=nc;i++){printf(" %s", $i)}; printf("\n")}' >> $tmpxy
    stilts tcopy ifmt=ascii ofmt=fits $tmpxy $ftab
    test $? -ne 0 && echo "ERROR: stilts failed" >&2 &&
        echo $tmpxy $ftab >&2 && return 255
    regfilter $ftab $reg > $ftab2
    test $? -ne 0 && echo "ERROR: regfilter failed" >&2 &&
        echo $tmpxy $ftab >&2 && return 255
    stilts tcopy ifmt=fits ofmt=ascii $ftab2
    
    rm -f $tmpin $tmpxy $ftab $ftab2
    return
}


# convert ra/de to x/y image coordinates (wrapper around sky2xy)
rade2xy () {
    # convert ra, de to x, y (image coordinates) using wcs header information
    # and program sky2xy
    # output: id x y
    # supports input coordinates in either decimal degrees or sexagesimal format
    # using colon separator (like h:m:s deg:amin:asec)
    local showhelp
    local i
    for i in 1
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    done
    local radedat=$1    # datafile
    local wcshdr=$2
    local catorcolnums=${3:-"1,2,3"}   # either star catalog name or idcol,racol,decol
    local delim=${4:-" "}
    local drad=${5:-"0"}    # correction to be added to catalog ra, in degrees
    local dded=${6:-"0"}    # correction to be added to catalog de, in degrees
    local catdef=refcat.dat
    local idcol
    local racol
    local decol
    local fits=$(mktemp /tmp/tmp_img_XXXXXX.fits)
    local tmp1=$(mktemp /tmp/tmp_tmp1_XXXXXX.dat)
    local tmp2=$(mktemp /tmp/tmp_tmp2_XXXXXX.dat)
    local tmp3=$(mktemp /tmp/tmp_tmp3_XXXXXX.dat)

    (test "$showhelp" || test $# -lt 2) &&
        echo -e "usage: rade2xy <radedat> <wcshdr> [catname_or_idcol,racol,decol|$catorcolnums]" \
            "[delim|\"$delim\"] [drad|$drad] [dded|$dded]" >&2 &&
        return 1

    test "$radedat" != "-" && test ! -f "$radedat" &&
        echo "ERROR: datafile $radedat not found." >&2 && return 255
    test ! -f "$wcshdr" &&
        echo "ERROR: wcs header file $wcshdr not found." >&2 && return 255
    ! grep -q "^CRPIX1" $wcshdr &&
        echo "ERROR: missing wcs keywords in $wcshdr." >&2 && return 255
    test "$radedat" == "-" && radedat=/dev/stdin

    if [ "${catorcolnums//,/ }" == "$catorcolnums" ]
    then
        # read column numbers from refcat.dat
        idcol=$(get_param $catdef cid $catorcolnums)
        test -z "$idcol" &&
            echo "ERROR: unknown catalog $catorcolnums." >&2 &&
            return 255
        racol=$(get_param $catdef cra $catorcolnums)
        decol=$(get_param $catdef cde $catorcolnums)
    else
        set - ${catorcolnums//,/ }
        test $# -ne 3 &&
            echo "ERROR: unknown catalog/column specification." >&2 &&
            return 255
        idcol=$1; racol=$2; decol=$3
    fi
    
    # get original image size
    w=$(grep "^CRPIX1" $wcshdr | tr '=' ' ' | awk '{printf("%d", $2*2)}')
    h=$(grep "^CRPIX2" $wcshdr | tr '=' ' ' | awk '{printf("%d", $2*2)}')
    
    # create image-less fits file
    rm -f $fits
    newfits -o 8 -s $w $h $fits
    keys=$(grep -Ev "^BITPIX|^HISTORY|^COMMENT|^END" $wcshdr | \
        cut -d "/" -f1 | tr "'" ' ' | sed -e 's|[ ]*=[ ]*|=|' | tr '\n' ' ')
    sethead $fits $keys
    
    # conversion to: rad ded id
    cat $radedat | grep -v -E -- "^--|^#|^$" | awk -F "$delim" -v cid=$idcol \
        -v cx=$racol -v cy=$decol -v dx=$drad -v dy=$dded '{
            if ($1~/^#/) next
            if ($cx~/[[:alpha:]]/ || $cx~/^[[:space:]]*$/) next
            if ($cy~/[[:alpha:]]/ || $cy~/^[[:space:]]*$/) next
            id=""
            if (cid == "0") {
                id=sprintf("S%05d", NR)
            } else {
                ncid=split(cid,a,",")
                for (i=1; i<=ncid; i++ ) {
                    sub(/^[[:space:]]*/,"",$a[i])
                    sub(/[[:space:]]*$/,"",$a[i])
                    id=id""$a[i]
                }
            }
            gsub(/ /,".",id)
            
            # strip leading/trailing spaces, replace remaining spaces by a colon
            sub(/^[[:space:]]*/,"",$cx)
            sub(/[[:space:]]*$/,"",$cx)
            gsub(/[[:space:]]+/,":",$cx)
            sub(/^[[:space:]]*/,"",$cy)
            sub(/[[:space:]]*$/,"",$cy)
            gsub(/[[:space:]]+/,":",$cy)
            #printf("### %s %s\n", $cx, $cy)

            na=split($cx,a,":")
            if (na>1) {rad=15*(a[1]+a[2]/60+a[3]/3600)} else {rad=$cx}
            na=split($cy,a,":")
            if (na>1) {
                if($cy~/^-/) {ded=a[1]-a[2]/60-a[3]/3600} else {ded=a[1]+a[2]/60+a[3]/3600}
            } else {ded=$cy}
            printf("%.5f %.5f _%s_\n", rad+dx, ded+dy, id)
        }' > $tmp1
    
    # coordinates only
    cat $tmp1 | awk '{printf("%s %s\n", $1, $2)}' > $tmp2

    # create lines with: rad ded x y off
    sky2xy $fits @$tmp2 | awk -v h=$h '{
            if ($0~/off image/) {off=1} else {off=0}
            printf("%s %s %.2f %.2f %d\n", $1, $2, $5-0.5, h-$6+0.5, off)
        }' > $tmp3

    # output: id x y
    test $(cat $tmp1 | wc -l) -ne $(cat $tmp3 | wc -l) &&
        echo "ERROR: unterschiedliche Anzahl von Zeilen (in tmp1 und tmp3)." >&2 &&
        echo $fits $tmp1 $tmp2 $tmp3 >&2 &&
        return 255
    paste -d ' ' $tmp1 $tmp3 | awk '{
        gsub("_","",$3);
        if ($8==0) printf("%s %s %s\n", $3, $6, $7)}'
    # print warning if single object is outside image
    test $(cat $tmp3 | wc -l) -eq 1 && grep -q " 1$" $tmp3 &&
        echo "WARNING: single object outside image" >&2

    test "$AI_DEBUG"    && echo $fits $tmp1 $tmp2 $tmp3 >&2
    test -z "$AI_DEBUG" && rm $fits $tmp1 $tmp2 $tmp3
    return 0
}


# convert x/y image coordinates to ra/de (wrapper around xy2sky)
xy2rade () {
    # convert from x,y image coordinates to ra (degrees), de (degrees) using wcs
    # header information
    # TODO: implement idcol,racol,decol
    local showhelp
    local has_fitscoord # if set then xydat contains FITS coordinates
    local do_out_sexa   # if set then output in sexagesimal units
    local prec=2        # number of decimal places in output RA seconds
    for i in 1 2 3 4
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-f" && has_fitscoord=1 && shift 1
        test "$1" == "-s" && do_out_sexa=1 && shift 1
        test "$1" == "-p" && prec=$2 && shift 2
    done
    local xydat=$1
    local wcshdr=$2
    local colnums=${3:-"1,2,3"} # column numbers for id,x,y
    local idcol
    local xcol
    local ycol
    local keys
    local opts="-d"
    local fits=$(mktemp /tmp/tmp_img_XXXXXX.fits)
    local tmpxy=$(mktemp /tmp/tmp_xy_XXXXXX.dat)
    local tmp1=$(mktemp /tmp/tmp_tmp1_XXXXXX.dat)
    
    (test "$showhelp" || test $# -lt 2) &&
        echo -e "usage: xy2rade [-f] [-s] <xydat> <wcshdr> [idcol,xcol,ycol|$colnums]" >&2 &&
        return 1

    test "$xydat" != "-" && test ! -f "$xydat" &&
        echo "ERROR: datafile $xydat not found." >&2 && return 255
    test ! -f "$wcshdr" &&
        echo "ERROR: wcs header file $wcshdr not found." >&2 && return 255
    ! grep -q "^CRPIX1" $wcshdr &&
        echo "ERROR: missing wcs keywords in $wcshdr." >&2 && return 255
    if [ "$xydat" == "-" ]
    then
        cat > $tmpxy
        test ! -s $tmpxy && rm -f $tmpxy &&
            echo "ERROR: no xy data to process" >&2 && return 255
        xydat=$tmpxy
    fi
    test "$do_out_sexa" && opts=""
    set - ${colnums//,/ }
    test $# -ne 3 &&
        echo "ERROR: unknown column specification." >&2 &&
        return 255
    idcol=$1; xcol=$2; ycol=$3

    # get original image size
    w=$(grep "^CRPIX1" $wcshdr | tr '=' ' ' | awk '{printf("%d", $2*2)}')
    h=$(grep "^CRPIX2" $wcshdr | tr '=' ' ' | awk '{printf("%d", $2*2)}')
    
    # create image-less fits file
    rm -f $fits
    newfits -o 8 -s $w $h $fits
    keys=$(grep -Ev "^BITPIX|^HISTORY|^COMMENT|^END" $wcshdr | \
        cut -d "/" -f1 | tr "'" ' ' | sed -e 's|[ ]*=[ ]*|=|' | tr '\n' ' ')
    sethead $fits $keys

    # conversion
    if [ "$has_fitscoord" ]
    then
        grep -v "^#" $xydat | awk -v cid=$idcol -v cx=$xcol -v cy=$ycol '{
            if ($1~/^#/) next
            printf("%.5f %.5f _%s_\n", $cx, $cy, id)
        }' > $tmp1
    else
        grep -v "^#" $xydat | awk -v h=$h -v cid=$idcol -v cx=$xcol -v cy=$ycol '{
            if ($1~/^#/) next
            printf("%.5f %.5f _%s_\n", $cx+0.5, h-$cy+0.5, id)
        }' > $tmp1
    fi
    xy2sky -n $prec $opts $fits @$tmp1
   
    rm $fits $tmpxy $tmp1
}


rade2altaz () {
    # for coord. trans ref.: http://star-www.st-and.ac.uk/~fv/webnotes/chapter7.htm
    # sidereal time ref.: http://aa.usno.navy.mil/faq/docs/GAST.php
    # parallactic angle ref.: https://books.google.de/books?id=e7gGCAAAQBAJ&pg=PA30
    local showhelp
    local use_image_center  # if set then use image center instead of radedat
    local use_jd_now        # if set use current date/time
    for i in 1 2 3 4
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-c" && use_image_center=1 && shift 1
        test "$1" == "-n" && use_jd_now=1 && shift 1
    done
    local sname=$1      # set name or JD
    local radedat=$2    # columns radeg dedeg
    local long
    local lat
    local jd
    local st
    local rade
    local pangle
    local tmp1=$(mktemp /tmp/tmp_tmp1_XXXXXX.dat)
    
    (test "$showhelp" || test $# -lt 1) &&
        echo -e "usage: rade2altaz [-c] <sname | jd> <radedat>" >&2 &&
        return 1

    is_number $sname && jd=$sname && sname=""
    
    if [ ! "$use_image_center" ]
    then
        test -z "$radedat" &&
            echo "ERROR: missing parameter for ra/de data file name." >&2 && return 255
        test "$radedat" != "-" && test ! -f "$radedat" &&
            echo "ERROR: datafile $radedat not found." >&2 && return 255
        test "$radedat" == "-" && radedat=/dev/stdin
    fi
    test -z "$jd" && test ! -e $sname.head &&
        echo "ERROR: missing header file $sname.head" >&2 && return 255
    test "$use_image_center" && test ! -e $sname.wcs.head &&
        echo "ERROR: missing wcs header file $sname.wcs.head" >&2 && return 255

    long=$(get_param -k location sites.dat long $AI_SITE)
    lat=$(get_param -k location sites.dat lat $AI_SITE)
    test -z "$jd" && if [ "$use_jd_now" ]
    then
        jd=$(ut2jd $(date -u +"%H:%M:%S %y%m%d"))
    else
        jd=$(get_header $sname.head MJD_OBS)
    fi
    # sidereal time in hr
    st=$(echo $jd $long | awk '{x=18.697374558+24.06570982441908*($1-2451545.0)+$2/15;
        x=x%24; if(x<0) x=x+24
        printf("%.4f", x)}')
    test "$AI_DEBUG" && echo "st=$st" >&2
    
    if [ "$use_image_center" ]
    then
        # image center in degrees
        echo $(get_header -s $sname.wcs.head CRVAL1,CRVAL2) > $tmp1
        # parallactic angle at image center (measured from north to zenith)
        #   tan(q) = sin(HA) / (tan(lat)*cos(de) - sin(de)*cos(HA))
        radedat=$tmp1
        pangle=$(echo $(cat $tmp1) $st $lat | awk 'BEGIN{r=3.14159/180}{
            x=sin($4*r)/cos($4*r)*cos($2*r)-sin($2*r)*cos(($3*15-$1)*r)
            x=sin(($3*15-$1)*r)/x
            printf("%5.2f\n", atan2(x,1)/r)
            }')
        echo "pangle=$pangle"
    fi
    
    # sin(h)  = sin(de) * sin(lat) + cos(de) * cos(lat) * cos(HA)
    # sin(az) = -sin(HA)*cos(lat)/cos(h)    #### maybe wrong ?
    # cos(az) = (sin(de)-sin(lat)*sin(h)) / (cos(lat)*cos(h))
    grep -v "^#" $radedat | awk -v l=$lat -v s=$st 'BEGIN{r=3.14159/180}
        {
            # hour angle
            ha=(s-$1/15+24)%24
            if(ha<0) ha=ha+24
            
            # altitude
            x=sin($2*r)*sin(l*r)+cos($2*r)*cos(l*r)*cos(ha*15*r)
            h=atan2(x,sqrt(1-x*x))/r    # asin
            
            # azimuth
            x=(sin($2*r)-sin(l*r)*sin(h*r)) / (cos(l*r)*cos(h*r))
            az=atan2(sqrt(1-x*x),x)/r   # acos
            if (ha>12 && az<0) az=-1*az
            if (ha<12 && az>0) az=-1*az
            if(az<0) az=az+360
            
            #y=-sin(ha*15*r)*cos(l*r)/cos(h*r)
            #az=atan2(y,x)/r
            
            # airmass
            zd=90-h;
            if (zd>89.9) {
                am=99
            } else {
                am=1/cos(zd*r)
            }
            if (am>99) am=99
            
            printf("%5.2f %5.2f %5.3f\n", az, h, am)
        }'
    
    rm -f $tmp1
    return
}


# get altitude, azimuth, moon illumination, distance and moon altitude
# for a given image set
pyaltaz () {
    local showhelp
    local site
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-s" && site="$2" && shift 2
    done
    local dir=$1
    local set=$2
    local hdr
    local whdr
    local f
    local jd
    local ra
    local de
    local lat
    local long
    local py=$(mktemp /tmp/tmp_prog_XXXXXX.py)
    local tmp1=$(mktemp /tmp/tmp_tmp1_XXXXXX.dat)
    
    (test "$showhelp" || test $# -lt 1) &&
        echo -e "usage: pyaltaz [-s site] [dir] <setname>" >&2 &&
        return 1
    
    test -z "$set" && set=$dir && dir="./"
    test ! -d "$dir" &&
        echo "ERROR: directory $dir not found." >&2 && return 255
    (cd $dir
    ! is_setname $set &&
        echo "ERROR: $set is not a valid image set." >&2 && return 255
    
    test -e .airtoolsrc && . .airtoolsrc
    test -z $site && site=$AI_SITE
    test -z $site &&
        echo "ERROR: AI_SITE is not defined." >&2 && return 255
    
    hdr=$set.head
    whdr=$set.wcs.head
    for f in $hdr $whdr
    do
        test ! -e $f &&
            echo "ERROR: file $f not found." >&2 && return 255
    done
    test "$dir" && f=$dir/$whdr
    echo "# $f  site=$site" >&2
    
    
    # get jd ra de
    jd=$(get_jd $hdr)
    test $? -ne 0 &&
        echo "ERROR: unable to determine JD from $hdr." >&2 && return 255
    set - $(imcoord $set) x
    test $# -ne 3 &&
        echo "ERROR: unable to determine image coordinates." >&2 && return 255
    ra=$1
    de=$2

    # get lat lon
    lon=$(get_param -k location sites.dat long $site)
    lat=$(get_param -k location sites.dat lat $site)
    (test -z "$lat" || test -z "$lon") &&
        echo "ERROR: unable to determine lat/long for site $site." >&2 && return 255
    lon=$(dec2sexa $lon)
    lat=$(dec2sexa $lat)
    
    cat << EOF > $py
import sys
import math
import ephem

# reading command line parameters
# note: all coordinates must be given in sexagesimal format
if len(sys.argv) != 6:
    print('usage: altaz.py jd lat long ra dec')
    exit(-1)
else:
    jd=float(sys.argv[1])
    lat=sys.argv[2]
    long=sys.argv[3]
    ra=sys.argv[4]
    dec=sys.argv[5]

# test case
def testparam ():
    jd=2458502.41062
    lat=50.98
    long=11.32
    ra='08:31:00.3'
    dec='+45:25:06'

# convert JD to date
def jd2date (jd):
    return ephem.Date(jd - ephem.julian_date(0))

# convert radians to degrees
def deg (rad):
    return 180*rad/math.pi

# convert degrees to radians
def rad (deg):
    return deg/180*math.pi

# a new object
line=','.join(['Object', 'f|S', ra, dec, '0', '2000'])
print('pos={}'.format(line))
pos = ephem.readdb(line)

# a new site
site=ephem.Observer()
site.lon = long
site.lat = lat
#site.elev = alt
#site.date = ephem.now()
#site=ephem.city('Berlin')
print(site)

# moon alt/az/illum
site.date = jd2date(jd)
moon = ephem.Moon()
moon.compute(site)
print(site.date)
print('moon:   RA={} DEC={}'.format(moon.ra, moon.dec))
#print('alt={} az={} illum={}'.format(moon.alt, moon.az, moon.moon_phase))
print('moon:   alt={:.2f} az={:.2f} illum={:.2f}'.format(deg(moon.alt), deg(moon.az), moon.moon_phase))

# object alt/az/moondist
pos.compute(site)
mdist=ephem.separation(pos, moon)  # distance angle from moon
print('object: alt={:.2f} az={:.2f} mdist={:.2f}'.format(deg(pos.alt), deg(pos.az), deg(mdist)))

# summary line: alt az moon_illum,dist,alt
print('{:.3f} {:.3f} {:.2f} {:.0f} {:.0f}'.format(deg(pos.alt), deg(pos.az), moon.moon_phase, deg(mdist), deg(moon.alt)))
EOF
    echo "# python3 $py $jd $lat $lon $ra $de" >&2
    python3 $py $jd $lat $lon $ra $de
    ) > $tmp1 2>&1
    
    if [ $? -eq 0 ]
    then
        tail -1 $tmp1
        test -z "$AI_DEBUG" && rm -f $py $tmp1
        return 0
    else
        cat $tmp1
        return 255
    fi

}


# affine transformation of image coordinates
# apply translation first, rotation is measured anti-clockwise
# note: origin of new system is at -dx,-dy of old system
#   y-axis in new system goes from origin downwards
#   new coords (or altitude) is appended to each input line
xytrans () {
    local showhelp
    local pscale=-1 # if set use this pixel scale to compute altitude
                    # difference in degrees and output altitude instead of
                    # xy image coordinates
    #local do_out_sexa   # if set then output in sexagesimal units
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-p" && pscale="$2" && shift 2
    done
    local xydat=$1
    local dx=$2
    local dy=$3
    local rot=${4:-0}
    local xcol=2
    local ycol=3
    local tmp1=$(mktemp /tmp/tmp_tmp1_XXXXXX.dat)
    
    (test "$showhelp" || test $# -lt 3) &&
        echo -e "usage: xytrans <xydat> <dx> <dy> [rot]" >&2 &&
        return 1

    test "$xydat" != "-" && test ! -f "$xydat" &&
        echo "ERROR: datafile $xydat not found." >&2 && return 255
    test "$xydat" == "-" && xydat=/dev/stdin

    cat $xydat | awk -v dx=$dx -v dy=$dy -v a=$rot -v xcol=$xcol -v ycol=$ycol -v p=$pscale \
    'BEGIN{arad=a*3.141596/180}{
        # translation
        x=$xcol+dx
        y=$ycol+dy
        # rotation, 
        xx=x*cos(arad)+y*sin(arad)
        yy=-x*sin(arad)+y*cos(arad)
        if (p>0) {
            printf("%s  %.3f\n", $0, yy*p/-3600.)
        } else {
            printf("%s  %.3f %.3f\n", $0, xx, yy)
        }
    }'
}


# TODO: deal with multiple extensions
# NOTE: this function is used by sexselect only
ahead2ldac () {
    # convert sextractor output catalog from ASCII_HEAD format to FITS_LDAC
    # optionally selecting a single extension number
    # output: to stdout
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    local acat=$1
    local w=${2:-"65536"}
    local h=${3:-"65536"}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpin=$(mktemp "$tdir/tmp_infile_XXXXXX.dat")
    local out=$(mktemp "$tdir/tmp_out_XXXXXX.fits")
    local tmp1=$(mktemp "$tdir/tmp_tmp1_XXXXXX.dat")
    local tmp2=$(mktemp "$tdir/tmp_tmp2_XXXXXX.dat")
    local tmp3=$(mktemp "$tdir/tmp_tmp3_XXXXXX.dat")
    
    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: ahead2ldac <infile> [w|$w] [h|$h]" >&2 &&
        return 1
    
    if [ "$acat" == "-" ]
    then
        cat > $tmpin
    else
        cp $acat $tmpin
    fi
    #echo "ERROR: not implemented yet." >&2 && return 255
    
    # TODO: determine number of extensions in $acat
    #grep "^#" $acat | grep EXTENSION 
    
    # create LDAC_IMHEAD table
    echo "# 'Field Header Card'                                                                                                                                             
        'SIMPLE  =                    T / This is a FITS file'" > $tmp1
    cat <<EOF > $tmp1
# "Field Header Card"                                                                                                                                             
"\
SIMPLE  =                    T                                                  \
BITPIX  =                    0                                                  \
NAXIS   =                    2                                                  \
NAXIS1  =               $w                                                  \
NAXIS2  =               $h                                                  \
END                                                                             \
"
EOF
    stilts tcopy ifmt=ascii ofmt=fits-basic $tmp1 $tmp2
    sethead $tmp2",1" EXTNAME=LDAC_IMHEAD

    # extract column names
    grep "^#" $tmpin | awk '{if($2~/^[0-9]+$/) x=x" "$3}END{print "#"x}' > $tmp1
    grep -v "^#" $tmpin >> $tmp1
    stilts tcopy ifmt=ascii ofmt=fits-basic $tmp1 $tmp3
    sethead $tmp3",1" EXTNAME=LDAC_OBJECTS
    stilts tmulti ifmt=fits ofmt=fits-basic in=$tmp2 in=$tmp3 out=$out
    
    # modify EXTNAME for tables
    sethead $out",1" TDIM1='(80,0)'
    
    cat $out
    rm $tmpin $tmp1 $tmp2 $tmp3 $out
}


addldacwcs () {
    # add simple wcs to LDAC_IMHEAD
    # note: only first 3 HDU's of input FITS file are used
    local scat=$1
    local wcshead=$2
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpcat=$(mktemp "$tdir/tmp_incat_XXXXXX.fits")
    local tmpdat=$(mktemp "$tdir/tmp_imhead_XXXXXX.dat")
    local tmptab=$(mktemp "$tdir/tmp_tab_XXXXXX.dat")
    local tmp1=$(mktemp "$tdir/tmp_tmp1_XXXXXX.fits")
    local tmp2=$(mktemp "$tdir/tmp_tmp2_XXXXXX.fits")
    
    test "$scat" == "-" && scat="/dev/stdin"
    cp $scat $tmpcat
    stilts tpipe in=$tmpcat"#"1 ofmt=csv | fold | \
        grep -vwE "^Field Header Card|^END" | \
        grep -vE "^FITS|^SEX" | \
        sed -e '/^BITPIX /s/16/ 0/' > $tmpdat
    grep -vw "^END" $wcshead | while read
    do
        printf "%-80s\n" "$REPLY"
    done >> $tmpdat
    printf "%-80s\n" "END" >> $tmpdat

    # create LDAC_IMHEAD table
    echo '# "Field Header Card"' > $tmptab
    printf '"' >> $tmptab
    cat $tmpdat | tr -d '\n' >> $tmptab
    echo '"' >> $tmptab
    stilts tcopy ifmt=ascii ofmt=fits-basic $tmptab $tmp1
    sethead $tmp1",1" EXTNAME=LDAC_IMHEAD
    sethead $tmp1",1" TDIM1='(80,0)'

    stilts tcopy ifmt=fits ofmt=fits-basic in=${tmpcat}"#"2 out=$tmp2
    stilts tmulti ifmt=fits ofmt=fits-basic in=$tmp1 in=$tmp2
    
    
    rm -f $tmpcat $tmpdat $tmptab $tmp1 $tmp2
}


# create RGB photometry data file (to stdout) from sextractor output catalog as
# produced by AIsource, for 3-color input images a crossmatching of sources
# is performed
# TODO: optionally keep crossmatched FITS table (includes all data from R/B channels
#   in columns which have _R or _B appended to the name)
sex2rgbdat () {
    local showhelp
    local fwhmmax=999   # max allowed FWHM in pixels
    local i
    for i in $(seq 1 2)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-f" && fwhmmax=$2 && shift 2
    done
    
    local scat=$1
    local rad=$2        # match radius between colors in pixels
    local reg=${3:-""}  # ds9 region file to filter data
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmptab1=$(mktemp "$tdir/tmp_tab1_XXXXXX.fits")
    local tmptab2=$(mktemp "$tdir/tmp_tab2_XXXXXX.fits")
    local colnames
    local xcol
    local ycol
    local cmd
    local str
    local w
    local h

    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: sex2rgbdat [-f fwhmmax] <srccat> <rmax> [region]" >&2 &&
        return 1
    
    test ! -e "$scat" &&
        echo "ERROR: input catalog $scat not found." >&2 && return 255
    ! is_fits "$scat" &&
        echo "ERROR: input catalog $scat not in FITS format." >&2 && return 255
    #! is_sexcat $scat &&
    #    echo "ERROR: $scat is not a sextractor output catalog." >&2 && return 255
    
    # get original image height from LDAC_IMHEAD in scat
    w=$(stilts tpipe in=$scat"#"1 ofmt=fits-basic | fold | grep "[[:alnum:]]" | \
        grep -A 100000 "EXTNAME .*LDAC_IMHEAD" | \
        grep NAXIS1 | lines 1 | awk '{print $3}')
    h=$(stilts tpipe in=$scat"#"1 ofmt=fits-basic | fold | grep "[[:alnum:]]" | \
        grep -A 100000 "EXTNAME .*LDAC_IMHEAD" | \
        grep NAXIS2 | lines 1 | awk '{print $3}')

    # determine x,y column names
    colnames=$(stilts tpipe omode=meta in=$scat"#"4 | grep "^[ ]* [0-9]" | \
        sed -e 's/(.*//' | tr ' ' '\n' | grep -vE "^$|^[0-9]") #)
    xcol=$(echo "$colnames" | grep "^X" | lines 1)
    ycol=$(echo "$colnames" | grep "^Y" | lines 1)
    
    # matching R with respect to G
    stilts tskymatch2 in1=$scat"#"4 in2=$scat"#"2 ra1=$xcol/3600 ra2=$xcol/3600 \
        dec1=$ycol/3600 dec2=$ycol/3600 error=$rad find=best1 ofmt=fits-basic > $tmptab1
    # rename columns
    colnames=$(stilts tpipe omode=meta in=$tmptab1 | grep "^[ ]* [0-9]" | \
        sed -e 's/(.*//' | tr ' ' '\n' | grep -vE "^$|^[0-9]") #)
    cmd=$(echo "$colnames" | awk '{
        x=$1; sub(/_[12]/,"",x)
        if ($1~/^Separation$/) printf("colmeta -name %s_R %s;", x, $1)
        if ($1~/_1$/) printf("colmeta -name %s   %s;", x, $1)
        if ($1~/_2$/) printf("colmeta -name %s_R %s;", x, $1)}')
    stilts tpipe in=$tmptab1 ifmt=fits cmd="$cmd" ofmt=fits-basic > $tmptab2
    
    # matching B with respect to G
    stilts tskymatch2 in1=$tmptab2  in2=$scat"#"6 ra1=$xcol/3600 ra2=$xcol/3600 \
        dec1=$ycol/3600 dec2=$ycol/3600 error=$rad find=best1 ofmt=fits-basic > $tmptab1
    # rename columns
    colnames=$(stilts tpipe omode=meta in=$tmptab1 | grep "^[ ]* [0-9]" | \
        sed -e 's/(.*//' | tr ' ' '\n' | grep -vE "^$|^[0-9]") #)
    cmd=$(echo "$colnames" | awk '{
        x=$1; sub(/_[12]/,"",x)
        if ($1~/^Separation$/) printf("colmeta -name %s_B %s;", x, $1)
        if ($1~/_1$/) printf("colmeta -name %s   %s;", x, $1)
        if ($1~/_2$/) printf("colmeta -name %s_B %s;", x, $1)}')
    stilts tpipe in=$tmptab1 ifmt=fits cmd="$cmd" ofmt=fits-basic > $tmptab2

    # write photometry data file
    test "$reg" && regfilter $tmptab2 $reg > $tmptab1 && mv $tmptab1 $tmptab2
    # col 5         6        7           8     9          10     11         12
    str="FWHM_IMAGE,MAG_AUTO,MAGERR_AUTO,FLAGS,MAG_AUTO_R,Sep*_R,MAG_AUTO_B,Sep*_B"
    stilts tpipe in=$tmptab2 ifmt=fits \
        cmd="keepcols \"NUMBER X*IMAGE Y*IMAGE A*IMAGE ${str//,/ }\"" \
        ofmt=ascii | awk -v h=$h -v fmax=$fwhmmax '{
            if ($1~/^#/) next
            if ($5 > fmax) next
            printf("%-10s  %7.2f %7.2f  %6.3f %6.3f %6.3f  %3d %3d  %4d %3d %.3f",
                $1, $2-0.5, h-$3+0.5, $9, $6, $11, 0, 0, 0, 0, $7)
            if($8>=4) printf(" sat")
            printf("\n")
        }'

    rm -f $tmptab1 $tmptab2
    return
}


sdensity () {
    # determine source density in a star stack (per square degree)
    local showhelp
    local quiet # suppress output from AIsource
    local all   # if set show additional values: nsrc area
    local i
    for i in $(seq 1 2 3)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-a" && all=1  && shift 1
        test "$1" == "-q" && quiet=1 && shift 1
    done
    local set=$1
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpim=$(mktemp "$tdir/tmp_im1_$$.XXXXXX.pnm")
    local tmpcat=$(mktemp "$tdir/tmp_src_$$.XXXXXX.dat")
    local ststack
    local binning
    local pixscale
    local magzero
    local sopt
    local nsrc
    local area
    local dens

    (test "$showhelp" || test $# -ne 1) &&
        echo "usage: sdensity [-a] <set>" >&2 &&
        return 1
        
    # check for ststack and header file
    ststack=""
    test -f $set.pgm && ststack=$set.pgm
    test -f $set.ppm && ststack=$set.ppm
    test -z "$ststack" &&
        echo "ERROR: missing star stack $set.p[gp]m" >&2 && return 255
    ! test -e $set.head &&
        echo "ERROR: missing header file $set.head" >&2 && return 255
    
    # determine pixscale
    pixscale=""
    binning=""
    test -z "$binning" && binning=$(get_header -q $set.head BINNING)
    test -z "$binning" && binning=$(get_header -q $set.head XBINNING)
    test -z "$binning" && binning=1
    pixscale=$(get_param camera.dat pixscale $set | \
        awk -v b=$binning '{print $1*b}')
    test -z "$pixscale" &&
        error "unknown pixscale in $set"

    magzero=$(get_header -q $set.head MAGZERO)
    test -z $magzero && magzero=25
    imcrop $ststack 50 > $tmpim
    test "$quiet" && sopt="-q"
    AI_MAGZERO=$magzero AIsource $sopt -2 -o $tmpcat $tmpim "" 30
    nsrc=$(sexselect -s $tmpcat | tail -1 | awk '{print $7*4}')
    area=$(echo $pixscale $(imsize $tmpim) | \
        awk '{a=4*$1*$1*$2*$3/3600/3600; fmt="%.3f"
            if (a > 0.7) fmt="%.2f"
            if (a > 7) fmt="%.1f"
            printf(fmt, a)}')
    dens=$(echo $nsrc $area | awk '{printf("%.0f", $1/$2)}')
    
    test -z "$all" && echo $dens
    test    "$all" && echo $dens $nsrc $area
    rm -f $tmpim $tmpcat
    return 0
}


# select subset from sextractor catalog file to stdout
sexselect () {
    # TODO: deal with tables where NUMBER is missing
    local showhelp
    local color         # set color channel to use (1 or 2 or 3) if
                        # source catalog contains multiple ext_numbers
                        # default: 2
    local outstats      # instead of listing object show some statistics
    local outregion     # change output format to ds9 region file
    local outfits       # change output format to FITS_LDAC table
    local outxy         # change coordinate system to image pixel in output
    local verbose
    local i
    for i in $(seq 1 7)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-s" && outstats=1  && shift 1
        test "$1" == "-r" && outregion=1 && shift 1
        test "$1" == "-f" && outfits=1   && shift 1
        test "$1" == "-x" && outxy=1     && shift 1
        (test "$1" == "-1" || test "$1" == "-2" || test "$1" == "-3") &&
            color=${1#-} && shift 1
        test "$1" == "-a" && color="all" && shift 1
        test "$1" == "-v" && verbose=1 && shift 1
    done
    local scat=$1
    local maglim=${2:-""}
    local magerrlim=${3:-""}
    local rrange=${4:-""}    # rmin,rmax or rmax
    local center=${5:-""}    # xc,yc in FITS coordinates
    local columns=${6:-""}
    local flagsmax=${7:-"3"}
    local w
    local h
    local filter
    local rmin
    local rmax
    local xc
    local yc
    local idcol
    local xcol
    local ycol
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmp1=$(mktemp "$tdir/tmp_tmp1_XXXXXX.fits")
    local tmp2=$(mktemp "$tdir/tmp_tmp2_XXXXXX.dat")
    local tmp3=$(mktemp "$tdir/tmp_tmp3_XXXXXX.fits")
    local tmp4=$(mktemp "$tdir/tmp_tmp4_XXXXXX.fits")
    local cmds=$(mktemp "$tdir/tmp_cmds_XXXXXX.txt")
    local tmpcat=$(mktemp "$tdir/tmp_stdin_XXXXXX.dat")

    # set default columns
    test -z "$columns" &&
        columns="NUM*,X*,Y*,A*,ELONGATION,FWHM_IMAGE,MAG_AUTO,MAGERR_AUTO,FLAGS"
    test "$outregion" && columns="NUMBER,X*,Y*,FWHM*,MAG_AUTO"
    test "$outstats"  && columns="AWIN*,BWIN*,FWHM*,MAG_AUTO"

    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: sexselect [-s|-r|-f|-x] [-1|2|3] <scat> [maglim|$maglim]"\
            "[magerrlim|$magerrlim] [rrange] [fcenter] [columns|$columns]"\
            "[flagsmax|$flagsmax]" >&2 &&
        return 1

    # handle reading scat from stdin
    if [ "$scat" == "-" ]
    then
        cat > $tmpcat
        scat=$tmpcat
    fi
    test ! -f "$scat" &&
        echo "ERROR: input catalog $scat not found." >&2 && return 255
    
    # checkings
    test "$maglim" &&    ! is_integer ${maglim%.*} &&
        echo "ERROR: maglim=$maglim is not a number." >&2 && return 255
    test "$magerrlim" && ! is_integer ${magerrlim%.*} &&
        echo "ERROR: magerrlim=$magerrlim is not a number." >&2 && return 255
    test "$rrange" &&    ! is_integer ${rrange%,*} &&
        echo "ERROR: rrange=$rrange does not start with an integer." >&2 && return 255
    test "$center" &&    ! is_integer ${center%,*} &&
        echo "ERROR: center=$center does not start with an integer." >&2 && return 255

    # get original image height from LDAC_IMHEAD in scat
    w=$(stilts tpipe in=$scat"#"1 ofmt=fits-basic | fold | grep "[[:alnum:]]" | \
        grep -A 100000 "EXTNAME .*LDAC_IMHEAD" | \
        grep NAXIS1 | lines 1 | awk '{print $3}')
    h=$(stilts tpipe in=$scat"#"1 ofmt=fits-basic | fold | grep "[[:alnum:]]" | \
        grep -A 100000 "EXTNAME .*LDAC_IMHEAD" | \
        grep NAXIS2 | lines 1 | awk '{print $3}')

    # convert input catalog
    if is_fits $scat
    then
        cp $scat $tmp1
    else
        echo "ERROR: not implemented yet." >&2 && return 255
        ahead2ldac -$color $scat > $tmp1
        test "$color" && color=1
    fi

    # determine extension number going to be used
    test -z "$color" &&
        test $(listhead $tmp1 | grep "EXTNAME = 'LDAC_OBJECTS'" | wc -l) -gt 1 &&
        color=2
    test -z "$color" && color=1
    
    # determine center and rrange
    if is_number $flagsmax
    then
        filter="flags<=$flagsmax"
    else
        filter="flags$flagsmax"
    fi
    if [ -z "$center" ]
    then
        center=$((w/2))","$((h/2))
    fi
    if [ -z "$rrange" ]
    then
        rrange=$(echo $w $h | awk '{
            rmax=sqrt($1*$1+$2*$2)
            printf("0,%.2f", rmax)
        }')
    fi
    xc=${center%,*}
    yc=${center#*,}
    rmin=${rrange%,*}
    rmax=${rrange#*,}
    rmin=$(echo $rmin $rmax | awk '{if($1>=$2) {print 0} else {print $1}}')
    
    # get X,Y column names
    # determine hdu of LDAC_OBJECTS table matching color (start counting from 0)
    hdu=$(listhead $tmp1 | grep -wE "HDU|XTENSION|EXTNAME" | tr "='" " " | awk -v c=$color '
        BEGIN{hnum=0; tab=0; if(c=="all") c=1}{
        if ($0~/Header listing for HDU/) hnum++
        if ($1=="EXTNAME" && $2=="LDAC_OBJECTS") tab++
        if (tab==c) {printf("%d", hnum-1); nextfile} 
        }')
    xcol=$(listhead $tmp1[$hdu] | awk -F "'" '{print $2}' | grep "^X.*_IMAGE$" | lines 1)
    ycol=$(listhead $tmp1[$hdu] | awk -F "'" '{print $2}' | grep "^Y.*_IMAGE$" | lines 1)
    test "$verbose" && echo "# color=$color hdu=$hdu center=$center xc=$xc yc=$yc" >&2
    
    # construct filter string
    if is_number $flagsmax
    then
        filter="flags<=$flagsmax"
    else
        filter="flags$flagsmax"
    fi
    test "$magerrlim" && filter="$filter && magerr_auto<$magerrlim"
    test "$maglim"    && filter="$filter && mag_auto<$maglim"
    test "$verbose" && echo "# $filter && r<$rmax && r>=$rmin" >&2
    
    echo 'select "'"$filter"'"
        addcol DX "'$xcol'-'$xc'"
        addcol DY "'$ycol'-'$yc'"
        addcol R "sqrt(DX*DX+DY*DY)"
        select "R<'$rmax' && R>='$rmin'"
        keepcols "'"${columns//,/ }"'"' > $cmds
    test "$verbose" && cat $cmds >&2
    if [ "$outstats" ]
    then
        echo 'stats name q.4 mean stdev minimum maximum ngood' >> $cmds
    fi
    # cat $cmds >&2
    
    if [ "$outfits" ]
    then
        # note: in stilts extension 1 refers to first table extension
        if [ "$color" == "all" ]
        then
            # TODO: cycle over all extensions
            # first color
            stilts tcopy ifmt=fits ofmt=fits-basic in=${tmp1}"#1" out=$tmp2
            stilts tpipe ofmt=fits cmd="@$cmds" in=${tmp1}"#2" out=$tmp3
            stilts tmulti multi=true ifmt=fits ofmt=fits-basic in=$tmp2 in=$tmp3 out=$tmp4
            
            if [ $(listhead $tmp1 | grep "EXTNAME = 'LDAC_OBJECTS'" | wc -l) -eq 1 ]
            then
                cat $tmp4
            else        
                # second color
                stilts tmulti multi=true ifmt=fits ofmt=fits-basic in=$tmp4 in=${tmp1}"#3" out=$tmp2
                stilts tpipe ofmt=fits cmd="@$cmds" in=${tmp1}"#4" out=$tmp3
                stilts tmulti multi=true ifmt=fits ofmt=fits-basic in=$tmp2 in=$tmp3 out=$tmp4

                # third color
                stilts tmulti multi=true ifmt=fits ofmt=fits-basic in=$tmp4 in=${tmp1}"#5" out=$tmp2
                stilts tpipe ofmt=fits cmd="@$cmds" in=${tmp1}"#6" out=$tmp3
                stilts tmulti multi=true ifmt=fits ofmt=fits-basic in=$tmp2 in=$tmp3
            fi
        else
            stilts tcopy ifmt=fits ofmt=fits-basic in=${tmp1}"#"$((color*2-1)) out=$tmp3
            stilts tpipe ofmt=fits cmd="@$cmds" in=${tmp1}"#"$((color*2)) out=$tmp2
            stilts tmulti ifmt=fits ofmt=fits-basic in=$tmp3 in=$tmp2
        fi
    else
        if [ "$color" == "all" ]
        then
            echo "ERROR: color=all only supports FITS output." >&2 && return 255
            stilts tpipe ofmt=ascii cmd="@$cmds" in=${tmp1} out=$tmp2
        else
            stilts tpipe ofmt=ascii cmd="@$cmds" in=${tmp1}"#"$((color*2)) out=$tmp2
        fi
        head -1 $tmp2 | tr ' ' '\n' | grep -i "[a-z]" > $tmp3
        idcol=$(grep -n "^NUMBER" $tmp3 | cut -d ":" -f1 | head -1)
        xcol=$(grep -n  "^X"      $tmp3 | cut -d ":" -f1 | head -1)
        ycol=$(grep -n  "^Y"      $tmp3 | cut -d ":" -f1 | head -1)
        if [ "$outregion" ]
        then
            echo -e "# Region file format: DS9 version 4.1\nglobal " \
                "color=green dashlist=8 3 width=1" \
                "font=\"helvetica 10 normal roman\" select=1 highlite=1" \
                "dash=0 fixed=1 edit=0 move=0 delete=1 include=1" \
                "source=1\nphysical"
            cat $tmp2 | awk '{
                if ($1~/^#/) next
                printf("circle(%.2f,%.2f,%.2f)", $2, $3, 2*$4)
                printf(" # text={%s %.1f}\n", $1, $5)
            }'
        else
            if [ "$outxy" ]
            then
                cat $tmp2 | awk -v w=$w -v h=$h -v xcol=$xcol -v ycol=$ycol '{
                    if ($0 ~ /^#/) {print $0; next}
                    for (i=1; i<=NF; i++) {
                        if (i==xcol) {
                            printf(" %9.3f", $xcol-0.5)
                        } else {
                            if (i==ycol) {
                                printf(" %9.3f", h-$ycol+0.5)
                            } else {
                                printf(" %s", $i)
                            }
                        }
                    }
                    printf("\n")
                }'
            else
                cat $tmp2
            fi
        fi
    fi
    rm $tmp1 $tmp2 $tmp3 $tmp4 $cmds $tmpcat
    return
}


# convert objects data file containing id, x, y to sextractor ASCII_HEAD
# format
xy2ahead () {
    local showhelp
    for i in 1
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    done
    local xydat=$1
    local img=$2
    local colnums=${3:-"1,2,3"}
    local fwhm=${4:-"3.0"}
    local idcol
    local xcol
    local ycol
    local h
    local fits=$(mktemp /tmp/tmp_img_XXXXXX.fits)
    local tmp1=$(mktemp /tmp/tmp_tmp1_XXXXXX.dat)
    
    (test "$showhelp" || test $# -lt 2) &&
        echo -e "usage: xy2ahead <xydat> <img> [idcol,xcol,ycol|$colnums] [fwhm|$fwhm]" >&2 &&
        return 1

    test "$xydat" != "-" && test ! -f "$xydat" &&
        echo "ERROR: datafile $xydat not found." >&2 && return 255
    test ! -f "$img" &&
        echo "ERROR: input image $img not found." >&2 && return 255
    test "$xydat" == "-" && xydat=/dev/stdin
    set - ${colnums//,/ }
    test $# -ne 3 &&
        echo "ERROR: unknown column specification." >&2 &&
        return 255
    idcol=$1; xcol=$2; ycol=$3
    h=$(identify $img | cut -d " " -f3 | cut -d "x" -f2)

    echo "#  1 NUMBER
#  2 EXT_NUMBER
#  3 XWIN_IMAGE
#  4 YWIN_IMAGE
#  5 AWIN_IMAGE
#  6 ELONGATION
#  7 FWHM_IMAGE
#  8 MAG_AUTO
#  9 MAGERR_AUTO
# 10 FLAGS"
    cat $xydat | awk -v h=$h -v cid=$idcol -v cx=$xcol -v cy=$ycol \
        -v a=2.0 -v e=1.0 -v f=$fwhm -v m=10.0 -v me=0.02 '{
            if ($1~/^#/) next
            printf("%12s 1 %8.3f %8.3f %s %s %s %s %s 0\n",
                $cid, $cx+0.5, h-$cy+0.5, a, e, f, m, me)
        }'
}

mkwcs () {
    # create simple wcs header file (assuming binning=1)
    local showhelp
    local distort   # it set, add cubic distortion keywords to wcs header
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-d" && distort="$2" && shift 2
    done
    local setname=$1
    local rahms=$2  # center coordinates
    local dedms=$3
    local north=${4:-"0"}
    local pscale=${5:-""}
    
    local tmphdr=$(mktemp "/tmp/tmp_wcs_XXXXXX.head")
    local img
    local size
    local line
    
    (test "$showhelp" || test $# -lt 3) &&
        echo -e "usage: mkwcs <setname|wxh> <ra> <de> [north] [pscale]" >&2 &&
        return 1

    echo $setname | grep -q "^[0-9][0-9]*x[0-9][0-9]*$"
    if [ $? -eq 0 ]
    then
        size=$setname
    else
        test -z "$img" && test -f $setname.ppm && img=$setname.ppm
        test -z "$img" && test -f $setname.pgm && img=$setname.pgm
        test -z "$img" && test -f $setname     && img=$setname
        test -z "$img" && echo "ERROR: cannot find image for $setname." >&2 && return 255
        size=$(identify $img | cut -d ' ' -f3)
        test -z "$pscale" && pscale=$(get_param camera.dat pixscale $setname)
    fi
    test -z "$pscale" && echo "ERROR: unknown pixscale." >&2 && return 255
    
    # initial header
    echo "\
EQUINOX =        2000.00000000 / Mean equinox                                  
RADESYS = 'ICRS    '           / Astrometric system                            
CTYPE1  = 'RA---TAN'           / WCS projection type for this axis             
CTYPE2  = 'DEC--TAN'           / WCS projection type for this axis             
CUNIT1  = 'deg     '           / Axis unit                                     
CUNIT2  = 'deg     '           / Axis unit                                     " > $tmphdr
    
    # center coordinates
    set_header $tmphdr CRVAL1=$(sexa2dec $rahms 15) CRVAL2=$(sexa2dec $dedms)
    set_header $tmphdr CRPIX1=$(echo $size | awk -F "x" '{printf("%.1f", $1/2+0.5)}')
    set_header $tmphdr CRPIX2=$(echo $size | awk -F "x" '{printf("%.1f", $2/2+0.5)}')
    
    # wcs matrix
    line=$(echo $pscale $north | awk '{
        r=$1/3600; y=r*sin($2*3.1416/180); x=r*cos($2*3.1416/180);
        printf("%.8f %.8f %.8f %.8f\n", -1*x, -1*y, -1*y, x)
    }')
    set - $line
    set_header $tmphdr CD1_1=$1 CD1_2=$2 CD2_1=$3 CD2_2=$4
    
    # cubic distortion
    # x'= x * r' / r
    #   = x * r * (1 + distort3 * r) / r
    #   = x + distort3 * x * (x + y)
    #   = x + distort3 * x + distort3 * x * y
    if [ "$distort" ]
    then
        set_header $tmphdr PV1_0=0          # 1
        set_header $tmphdr PV1_1=1          # x
        set_header $tmphdr PV1_2=0          # y
        set_header $tmphdr PV1_4=0          # x
        set_header $tmphdr PV1_5=0          # xy
        set_header $tmphdr PV1_6=0          # y
        set_header $tmphdr PV1_7=${distort} # x
        set_header $tmphdr PV1_8=0          # xy
        set_header $tmphdr PV1_9=${distort} # xy
        set_header $tmphdr PV1_10=0         # y
        set_header $tmphdr PV2_0=0          # 1
        set_header $tmphdr PV2_1=1          # y
        set_header $tmphdr PV2_2=0          # x
        set_header $tmphdr PV2_4=0          # y
        set_header $tmphdr PV2_5=0          # xy
        set_header $tmphdr PV2_6=0          # x
        set_header $tmphdr PV2_7=${distort} # y
        set_header $tmphdr PV2_8=0          # yx
        set_header $tmphdr PV2_9=${distort} # yx
        set_header $tmphdr PV2_10=0         # x
        #set_header $tmphdr FGROUPNO=                    1 / SCAMP field group label
        #set_header $tmphdr ASTINST =                    1 / SCAMP astrometric instrument label
        #set_header $tmphdr FLSCALE =   1.000000000000E+00 / SCAMP relative flux scale
        #set_header $tmphdr MAGZEROP=           0.00000000 / SCAMP zero-point
        #set_header $tmphdr PHOTINST=                    1 / SCAMP photometric instrument label
        #set_header $tmphdr PHOTLINK=                    F / True if linked to a photometric field
    fi
    cat $tmphdr
    rm -f $tmphdr
    
}

mkregheader () {
    # create artificial header files for stacking without x-y-shift
    local setname=$1
    local object
    local nref
    local img
    local w
    local h
    local cx
    local cy
    local pscale
    local num
    local texp
    local jd
    
    set - $(AIsetinfo $setname)
    object=$2
    nref=$4
    img=$AI_TMPDIR/$nref.ppm
    test ! -e $img && img=$AI_TMPDIR/$nref.pgm
    test ! -e $img &&
        echo "ERROR: missing reference image $img (run AIccd first)." >&2 &&
        return 255
    test -z "$day" &&
        echo "ERROR: day is undefined." >&2 && return 255
    
    w=$(identify $img | cut -d " " -f3 | cut -d "x" -f1)
    h=$(identify $img | cut -d " " -f3 | cut -d "x" -f2)
    cx=$(echo $w | awk '{printf("%.3f", $1/2+0.5)}')
    cy=$(echo $h | awk '{printf("%.3f", $1/2+0.5)}')
    pscale=0.0003
    
    test ! -d measure && mkdir measure
    for num in $(AIimlist -n $setname)
    do
        test -e measure/$num.src.head &&
            echo "WARNING: skipping $num, measure/$num.src.head exists." >&2 &&
            continue
        set - $(grep "^$num." exif.dat)
        texp=$4
        jd=$(ut2jd $3 $day)
        echo "OBJECT  = '$object'
EXPTIME =    $texp       / Exposure time in seconds
MJD_OBS =      $jd  / Time of observation in julian days
EPOCH   =      2000.0  / Epoch
EQUINOX =      2000.0  / Mean equinox
RADESYS = 'ICRS    '           / Astrometric system                            
CTYPE1  = 'RA---TAN'   / WCS projection type for this axis
CUNIT1  = 'deg     '   / Axis unit
CRVAL1  =      10.0    / World coordinate on this axis
CRPIX1  =      $cx     / Reference pixel on this axis
CD1_1   =      -$pscale   / Linear projection matrix
CD1_2   =      0          / Linear projection matrix
CTYPE2  = 'DEC--TAN'   / WCS projection type for this axis
CUNIT2  = 'deg     '   / Axis unit
CRVAL2  =      0.0     / World coordinate on this axis
CRPIX2  =      $cy     / Reference pixel on this axis
CD2_1   =      0          / Linear projection matrix
CD2_2   =      $pscale    / Linear projection matrix
PHOTFLAG=      F
END     " > measure/$num.src.head
    done
    return
}



#-------------------------------
#   low level image operations
#-------------------------------

mkpgm () {
    # create gray image with given intensity
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    local val=$1
    local w=$2
    local h=$3
    local oname=${4:-"-"}

    (test "$showhelp" || test $# -lt 3) &&
        echo "usage: mkpgm <val> <w> <h> [outname]" >&2 &&
        return 1
    ppmmake "black" $w $h | pnmdepth 65535 - | ppmtopgm | \
        pnmccdred -a $val - $oname
}

mkppm () {
    # create gray image with given intensity
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    local val=$1
    local w=$2
    local h=$3
    local oname=${4:-"-"}

    (test "$showhelp" || test $# -lt 3) &&
        echo "usage: mkppm <val> <w> <h> [outname]" >&2 &&
        return 1
    ppmmake "black" $w $h | pnmdepth 65535 - | \
        pnmccdred -a $val - $oname
}

pnmccdred2 () {
    # out = mult * (in-dark)/flat + add
    # TODO: allow piping output to next command
    local showhelp
    local premult
    local preadd
    local dark
    local flat
    local mult
    local add
    local do_fits   # if set write FITS (plane or cube) instead of PNM file
    local do_gray   # convert rgb to gray image
    local do_flip   # if set flip image top-bottom
    local do_rot    # if set rotate image by 180 degrees
    local i
    for i in $(seq 1 9)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-d" && dark=$2 && shift 2
        test "$1" == "-s" && flat=$2 && shift 2
        test "$1" == "-m" && mult=$2 && shift 2
        test "$1" == "-a" && add=$2  && shift 2
        test "$1" == "-premult" && premult=$2   && shift 2
        test "$1" == "-preadd"  && preadd=$2    && shift 2
        test "$1" == "-f"       && do_fits=1    && shift 1
        test "$1" == "-g"       && do_gray=1    && shift 1
        test "$1" == "-tb"      && do_flip=1    && shift 1
        test "$1" == "-r180"    && do_rot=1     && shift 1
    done
    local img=$1
    local out=${2:-"-"}
    local f
    local pyopts
    local pyprog
    local retval

    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: pnmccdred2 [-f] [-g] [-tb] [-d dark] [-s flat] [-m mult] [-a add] <img> [out|$out]" >&2 &&
        return 1

    # check for valid images
    # TODO: handle fitsgz, fitszip
    test "$img" != "-" && ! is_pnm $img && ! is_fits $img && ! is_fitsgz $img &&
        echo "ERROR: $img is not a valid PNM/FITS file." >&2 &&
            return 255

    test "$dark$flat" && for f in $dark $flat
    do
        test "$f" && test "$f" != "-" && ! is_pnm $f &&
            echo "ERROR: $f is not a valid PPM/PGM/PBM file." >&2 &&
            return 255
    done

    # check for required python scripts
    pyprog=$(which airfun.py)
    test $? -ne 0 &&
        echo "ERROR: missing python module airfun.py." >&2 && return 255

    test "$do_fits" && pyopts="$pyopts -f"
    test "$do_gray" && pyopts="$pyopts -g"
    test "$preadd"  && pyopts="$pyopts -preadd $preadd"
    test "$premult" && pyopts="$pyopts -premult $premult"
    test "$do_flip" && pyopts="$pyopts -tb"
    test "$do_rot"  && pyopts="$pyopts -r180"
    test "$AI_DEBUG" &&
        echo python3 $pyprog pnmccdred $pyopts "$img $out \"$dark\" \"$flat\" \"$mult\" \"$add\"" >&2
    python3 $pyprog pnmccdred $pyopts $img $out "$dark" "$flat" "$mult" "$add"
    retval=$?
    
    test $retval -ne 0 &&
        echo "ERROR: pnmccdred2 failed" >&2 && sleep 20

    return $retval
}

pnmcombine2 () {
    local showhelp
    local mode="mean"
    local i
    for i in $(seq 1 5)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-d" && mode="median" && shift 1
        test "$1" == "-s" && mode="stddev" && shift 1
    done
    local img=$1
    local out=${@: -1}  # last argument
    local pyprog

    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: pnmcombine2 [-d|-s] <img1> [img2 ...] <out>" >&2 &&
        return 1

    # check for required python scripts
    pyprog=$(which airfun.py)
    test $? -ne 0 &&
        echo "ERROR: missing python module airfun.py." >&2 && return 255

    test "$AI_DEBUG" &&
        echo "python3 $pyprog pnmcombine -m $mode $@" >&2
    python3 $pyprog pnmcombine -m $mode $@
    return $?
}


ppm2gray () {
    # convert from ppm to gray image, result goes to stdout
    # using a specific set of color ratios (other than ppmtopgm!)
    # this function replaces ppmtograyfits as of 130614
    local outfits    # if set create FITS format output file instead of PGM
    local quiet      # do not report warning upon writing keywords containing umlauts
    local showhelp
    local cboxsize   # if set then keep data in center box of given size
    local wcshead
    local rgb_ratios="0.26,0.40,0.34"
    for i in $(seq 1 6)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-f" && outfits=1 && shift 1
        test "$1" == "-q" && quiet=1 && shift 1
        test "$1" == "-c" && cboxsize=$2 && shift 2
        test "$1" == "-w" && wcshead=$2 && shift 2
        test "$1" == "-r" && rgb_ratios="$2" && shift 2
    done
    local ppm=${1:-"-"}
    local head=${2:-""}     # ascii header file containing FITS keywords
    local line
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpim=$(mktemp "$tdir/tmp_im_XXXXXX.img")
    local tmp1=$(mktemp "$tdir/tmp1_XXXXXX.img")
    local tmpmask=$(mktemp "$tdir/tmp_mask_XXXXXX.pgm")
    local tmpppm=$(mktemp "$tdir/tmp_in_XXXXXX.pnm")
    local tmpkeys=$(mktemp "$tdir/tmp_keys_XXXXXX.head")
    local wdir=$(mktemp -d "$tdir/tmp_ppm2gray_XXXXXX")
    local str1
    local str2
    local w
    local h
    local key
    local pyprog

    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: ppm2gray [-f] [-w wcshead] [-r rgbratio|$rgb_ratios] <ppm> [fitshdr]" >&2 &&
        return 1
    test "$ppm" != "-" && test ! -f "$ppm" &&
        echo "ERROR: ppm file $ppm not found." >&2 &&
        return 255
    test "$outfits" && test "$head" && test ! -f "$head" &&
        echo "ERROR: ascii FITS header file $head not found." >&2 &&
        return 255
    test "$outfits" && test "$wcshead" && test ! -f "$wcshead" &&
        echo "ERROR: ascii FITS header file $wcshead not found." >&2 &&
        return 255

    # check for required python scripts
    pyprog=$(which airfun.py)
    test $? -ne 0 &&
        echo "ERROR: missing python module airfun.py." >&2 && return 255

    # handle input from stdin
    test "$ppm" == "-" &&
        cat > $tmpim && ppm=$tmpim

    # check format of $rgb_ratios
    str1=$(echo $rgb_ratios | awk -F ',' '{print NF" "1*$1","1*$2","1*$3}')
    # strip zeros from end of decimal numbers
    str2="3 "$(echo $rgb_ratios | tr ',' '\n' | \
        sed -e '/\./s|[0]*$||; s|\.$||' | tr '\n' ',' | sed -e 's|,$||')
    test "$str1" != "$str2" &&
        echo "ERROR: rgb_ratios in unsupported format (use: r,g,b)." >&2 &&
        echo "DEBUG:  $str1  $str2" >&2 &&
        return 255
    
    # blank any data outside of the given center box
    if [ "$cboxsize" ]
    then
        w=$(identify $ppm | cut -d " " -f3 | cut -d "x" -f1)
        h=$(identify $ppm | cut -d " " -f3 | cut -d "x" -f2)
        mkpgm 65535 $cboxsize $cboxsize | pnmpad -width $w -height $h - > $tmpmask
        pnmarith -mul $ppm $tmpmask 2>/dev/null > $tmpppm
        ppm=$tmpppm
    fi
    
    set - ${rgb_ratios//,/ }
    if [ "$outfits" ]
    then
        #convert "$setname" -channel G -separate - | ppmtopgm - | pnmtomef - > $sfits
        if is_ppm $ppm
        then
            # old:
            false && convert $ppm \
                -channel R  -evaluate multiply $1 \
                -channel G  -evaluate multiply $2 \
                -channel B  -evaluate multiply $3 \
                +channel -separate \
                -background black -compose plus -flatten - | \
                ppmtopgm - | pnmtomef - > $tmp1
            # new:
            false && gm convert $ppm -operator Red multiply $1 \
                -operator Green multiply $2 \
                -operator Blue  multiply $3 - | \
            (cd $wdir; ppmtorgb3 &&
                pnmarith -add noname.red noname.grn | pnmarith -add - noname.blu | \
                pnmtomef - > $tmp1)
            # newer:
            false && gm convert $ppm -operator Red multiply $1 \
                -operator Green multiply $2 \
                -operator Blue  multiply $3 - | \
                convert - -separate -background black -compose plus -flatten pgm:- | \
                pnmtomef - > $tmp1
            python3 $pyprog ppmtogray -f $ppm $tmp1 $1,$2,$3
        else
            pnmccdred2 -f $ppm $tmp1
        fi
        # note: workaround for libvips/fitssave which always creates cube
        set_header $tmp1 NAXIS=2
        delhead $tmp1 NAXIS3
        
        # strip off COMMENT keywords
        listhead $tmp1 | grep -w "^COMMENT" | cut -c 1-8 | \
            while read key; do delhead $tmp1 $key; done

        if [ -f "$head" ]
        then
            # skip some keywords and replace umlauts
            grep -Ev "^BITPIX|^NAXIS |^NAXIS[1-9] " $head | \
                grep -Ev "^BSCALE |^BZERO |^HISTORY|^COMMENT|^END" | \
                grep -Ev "^RADESYS |^CUNIT[0-9] " | \
                grep -Ev "^FILE[0-9][0-9]|^WGHT[0-9][0-9]|^WGTT[0-9][0-9]|^INTF[0-9][0-9]|^SUBF[0-9][0-9]|^BCKT[0-9][0-9]|^BCKS[0-9][0-9]|^BKFS[0-9][0-9]" | \
                sed -e 's|[ ]*=[ ]*|=|' | tr '' '?' | awk -F "'" '{
                    #if(NF>1) {gsub("/"," ",$2)}
                    printf("%s", $1)
                    if(NF>1) {
                        printf("\047%s", $2)
                        if (length($2)>18) {
                            # skip comment
                            printf("\047")
                        } else {
                            for (i=3;i<=NF;i++) {printf("\047%s", $i)}
                        }
                    }
                    printf("\n")}' > $tmpkeys
            test "$AI_DEBUG" && echo "# keys: $tmpkeys" >&2
            sethead $tmp1 @$tmpkeys
            # workaround: delete malformed string keywords (truncated long strings)
            # note: should be handled already by last awk command
            listhead $tmp1 | grep "'" | awk -F "'" '{if(NF==2){print $0}}' | cut -c 1-8 | \
            while read key
            do
                # grep "^${key}=" $tmpkeys
                echo "WARNING: deleting key: $key" >&2
                delhead $tmp1 $key
            done
            #delwcs $tmp1
        fi
        if [ -f "$wcshead" ]
        then
            grep -Ev "^BITPIX|^NAXIS |^NAXIS[1-9] " $wcshead | \
                grep -Ev "^BSCALE |^BZERO |^HISTORY|^COMMENT|^END" | \
                sed -e 's|[ ]*=[ ]*|=|' | tr '' '?' | awk -F "'" '{
                    #if(NF>1) {gsub("/"," ",$2)}
                    printf("%s", $1)
                    if(NF>1) {
                        printf("\047%s", $2)
                        if (length($2)>18) {
                            # skip comment
                            printf("\047")
                        } else {
                            for (i=3;i<=NF;i++) {printf("\047%s", $i)}
                        }
                    }
                    printf("\n")}' > $tmpkeys
            test "$AI_DEBUG" && echo "# keys: $tmpkeys" >&2
            sethead $tmp1 @$tmpkeys
            # workaround: delete malformed string keywords (truncated long strings)
            listhead $tmp1 | grep "'" | awk -F "'" '{if(NF==2){print $0}}' | cut -c 1-8 | \
            while read key
            do
                # grep "^${key}=" $tmpkeys
                echo "WARNING: deleting key: $key" >&2
                delhead $tmp1 $key
            done
        fi
        cat $tmp1
    else
        if is_ppm $ppm
        then
            # old:
            false && convert $ppm \
                -channel R  -evaluate multiply $1 \
                -channel G  -evaluate multiply $2 \
                -channel B  -evaluate multiply $3 \
                +channel -separate \
                -background black -compose plus -flatten - | \
                ppmtopgm -
            # new:
            false && gm convert $ppm -operator Red multiply $1 \
                -operator Green multiply $2 \
                -operator Blue  multiply $3 - | \
            (cd $wdir; ppmtorgb3 &&
                pnmarith -add noname.red noname.grn | pnmarith -add - noname.blu)
            # newer:
            false && gm convert $ppm -operator Red multiply $1 \
                -operator Green multiply $2 \
                -operator Blue  multiply $3 - | \
                convert - -separate -background black -compose plus -flatten pgm:-
            #pnmccdred2 -g -m $1,$2,$3 $ppm -
            python3 $pyprog ppmtogray $ppm - $1,$2,$3
        else
            cat $ppm
        fi
    fi
    test ! "$AI_DEBUG" && rm $tmpkeys
    rm -f $tmp1 $tmpim $tmpmask $tmpppm
    rm -rf $wdir
    return
}


pnmtomef2 () {
    local pnm=$1
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpcube=$(mktemp "$tdir/tmp_cube_XXXXXX.fits")

    # check for required python scripts
    pyprog=$(which airfun.py)
    test $? -ne 0 &&
        echo "ERROR: missing python module airfun.py." >&2 && return 255
    
    python3 $pyprog pnmtofits $pnm $tmpcube
    test $? -ne 1 &&
        echo "ERROR: failed command was: python3 $pyprog pnmtofits $pnm $tfits" >&2 &&
        return 255
    
    # convert cube to MEF fits
    # TODO: process $tmpcube by missfits
    return
}


ppm2mef () {
    # convert RGB PPM to Multi-Extension FITS (output to stdout)
    #   first HDU: red channel and all FITS keywords
    #   second HDU: green channel, third HDU: blue channel
    local showhelp
    local quiet      # do not report warning upon writing keywords containing umlauts
    local wcshead
    for i in $(seq 1 6)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-q" && quiet=1 && shift 1
        test "$1" == "-w" && wcshead=$2 && shift 2
    done
    local ppm=${1:-"-"}
    local head=${2:-""}     # ascii header file containing FITS keywords
    local line
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpim=$(mktemp "$tdir/tmp_im_XXXXXX.img")
    local tmpfits=$(mktemp "$tdir/tmp_fits_XXXXXX.fits")
    local tmphead=$(mktemp "$tdir/tmp_ahead_XXXXXX.head")

    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: ppm2mef [-q] [-w wcshead] <ppm> [asciihdr]" >&2 &&
        return 1
    test "$ppm" != "-" && test ! -f "$ppm" &&
        echo "ERROR: ppm file $ppm not found." >&2 &&
        return 255
    test "$head" && test ! -f "$head" &&
        echo "ERROR: header file $head not found." >&2 &&
        return 255
    test "$wcshead" && test ! -f "$wcshead" &&
        echo "ERROR: wcs header file $wcshead not found." >&2 &&
        return 255

    # handle input from stdin
    test "$ppm" == "-" &&
        cat > $tmpim && ppm=$tmpim
    
    if [ "$head$wcshead" ]
    then
        pnmtomef $ppm > $tmpfits
        # add header keywords
        cat $head $wcshead > $tmphead
        ahead2fits $tmpfits $tmphead
    else
        pnmtomef $ppm
    fi

    rm -f $tmpim $tmpfits $tmphead
}
    

ahead2fits () {
    # add ascii header to first HDU of FITS file
    # output to stdout
    local fits=$1
    local ahead=$2
    local key
    local nhdu
    local phdu  # primary (image) HDU
    local off
    local nk
    local nb
    local opts=""
    local tdir=${AI_TMPDIR:-"/tmp"}
    local wdir=$(mktemp -d "$tdir/tmp_ahead_XXXXXX")
    local conf=$wdir/miss.conf
    local keys=$wdir/keys.head
    
    test "$#" -ne 2 && echo "usage: ahead2fits <fits> <asciihead>" >&2 && return 255

    # slicing extensions
    nhdu=$(listhead $fits | grep -w "^Header listing for HDU" | wc -l)
    phdu=$wdir/ext0.fits
    imslice $fits 0 > $phdu
    
    # determine offset for start of second HDU
    nk=0
    while true
    do
        dd if=$fits bs=80c skip=$nk count=1 2>/dev/null | grep -w "^END" >/dev/null &&
        break
        nk=$((nk+1))
    done
    nb=$(echo $(get_header -s -q $phdu BITPIX,NAXIS1,NAXIS2,NAXIS3) | awk '{
            x=$1*$2/8
            if (NF>2) x=x*$3
            if (NF>3) x=x*$4
            printf("%d", x)
        }')
    test -z "$nb"  && echo "ERROR: first HDU is not an image" >&2 && return 255
    test $nb -lt 0 && echo "ERROR: unsupported FITS image (float)" >&2 && return 255
    off=$(echo $nk $nb | awk '{
        h=($1+1)*80
        a=int(h/2880)
        if (h%2880 > 0) a=a+1
        b=int($2/2880)
        if ($2%2880 > 0) b=b+1
        printf("%d", a+b)
        }')
    test "$AI_DEBUG" && echo "# off=$off cards ($nk keywords, $nb bytes of image data)" >&2
    
    # skip some keywords and replace umlauts
    grep -Ev "^SIMPLE |^XTENSION|^EXTEND |^BITPIX |^NAXIS |^NAXIS[1-9] " $ahead | \
        grep -Ev "^BSCALE |^BZERO |^HISTORY|^COMMENT|^END" | \
        grep -Ev "^RADESYS |^CUNIT[0-9] " | \
        grep -Ev "^FILE[0-9][0-9]|^WGHT[0-9][0-9]|^WGTT[0-9][0-9]|^INTF[0-9][0-9]|^SUBF[0-9][0-9]|^BCKT[0-9][0-9]|^BCKS[0-9][0-9]|^BKFS[0-9][0-9]" | \
        sed -e 's|right=0|right: 0|' | \
        sed -e 's|[ ]*=[ ]*|=|' | tr '' '?' | awk -F "'" '{
            #if(NF>1) {gsub("/"," ",$2)}
            printf("%s", $1)
            if(NF>1) {
                #gsub("/",",",$2)  # replace "/" by ","
                sub(/^[[:space:]]*/,"",$2)
                sub(/[[:space:]]*$/,"",$2)
                #printf("\047%s\047", $2)
                printf("\"%s\"", $2)
                if (length($2) <= 18 && NF>2) {
                    # print comment
                    printf("%s", $3)
                    for (i=4;i<=NF;i++) {printf("\047%s", $i)}
                }
            }
            printf("\n")}' > $keys
    
    # add kewwords to first HDU (does not work if NAXIS=0)
    sethead $opts $phdu @$keys
    if ! fitsverify -q $phdu > /dev/null
    then
        echo "ERROR: FITS file contains errors, check with" >&2
        echo "    fitsverify $phdu" >&2
        return 255
    fi

    # combine fits files
    cat $phdu
    test $nhdu -gt 1 && dd if=$fits bs=2880c skip=$off 2>/dev/null
    
    false && (
    # note: missfits adds a data-less image HDU before any other HDU's
    missfits -d > $conf
    (cd $wdir; missfits -c $conf -split_suffix %1d.fits -outfile_type multi -verbose_type quiet \
        -new_suffix .miss -save_type new ext) > /dev/null
    if ! fitsverify -q $wdir/ext.miss.fits > /dev/null
    then
        echo "ERROR: FITS file contains errors, check with" >&2
        echo "    fitsverify $wdir/ext.miss.fits" >&2
        return 255
    fi
    cat $wdir/ext.miss.fits
    )
    
    test "$AI_DEBUG"    && echo "# $wdir" >&2
    test -z "$AI_DEBUG" && rm -rf $wdir
    return 0
}

whead2fits () {
    # add wcs header keywords to FITS file
    # TODO: optionally remove any WCS header from original FITS file
    local fits=$1
    local wcshead=$2
    local key
    local tmpkeys=$(mktemp "/tmp/tmp_keys_XXXXXX.head")

    # skip some keywords and replace umlauts
    grep -Ev "^BITPIX|^NAXIS |^NAXIS[1-9] " $wcshead | \
        grep -Ev "^BSCALE |^BZERO |^HISTORY|^COMMENT|^END" | \
        sed -e 's|[ ]*=[ ]*|=|' | tr '' '?' | awk -F "'" '{
            #if(NF>1) {gsub("/"," ",$2)}
            printf("%s", $1)
            if(NF>1) {
                printf("\047%s", $2)
                if (length($2)>18) {
                    # skip comment
                    printf("\047")
                } else {
                    for (i=3;i<=NF;i++) {printf("\047%s", $i)}
                }
            }
            printf("\n")}' > $tmpkeys
    test "$AI_DEBUG" && echo "# keys: $tmpkeys" >&2
    sethead $fits @$tmpkeys
    # workaround: delete malformed string keywords (truncated long strings)
    listhead $fits | grep "'" | awk -F "'" '{if(NF==2){print $0}}' | cut -c 1-8 | \
    while read key
    do
        # grep "^${key}=" $tmpkeys
        echo "WARNING: deleting key: $key" >&2
        delhead $fits $key
    done
    
    rm -f $tmpkeys
}


meftopnm () {
    # convert from FITS to 16bit PNM image, result goes to stdout
    # note: automatic scaling of data values is applied according to
    #   physical value = BSCALE * (storage value) + BZERO
    local showhelp
    local do_ascii_header   # if set, also create ASCII header
                            # requires command line parameter outimage
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-a" && do_ascii_header=1 && shift 1
    done
    local fits="$1"
    #local pnm=$2
    local bitpix
    local imgtype
    local pyprog
    local nx
    local retval
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpfits=$(mktemp "$tdir/tmp_img_XXXXXX.fits")
    local tmpppm=$(mktemp "$tdir/tmp_img_XXXXXX.ppm")

    (test "$showhelp" || test $# -ne 1) &&
        echo "usage: meftopnm [-a] <fits>" >&2 &&
        return 1
    test ! -e "$fits" &&
        echo "ERROR: fits file $fits not found." >&2 &&
        return 255
    ! is_fits "$fits" &&
        echo "ERROR: $fits is not a supported FITS file." >&2 &&
        return 255
    bitpix=$(listhead "$fits" | grep BITPIX | lines 1 | awk '{print $3}')
    test -z "$imgtype" && is_fitsrgb "$fits"  && imgtype="rgbmef"  && nx=3
    test -z "$imgtype" && is_fitscube "$fits" && imgtype="rgbcube" && nx=3
    test -z "$imgtype" && imgtype="plane" && nx=1
    test "$AI_DEBUG" &&
        echo "# imgtype=$imgtype  bitpix=$bitpix" >&2

    if [ "$do_ascii_header" ]
    then
        # replace non-ASCII characters
        listhead "$fits" | tr '' '?' | grep -aE "^........=" | \
            grep -vwE "^SIMPLE|^BITPIX|^NAXIS[0-9 ]|^EXTEND|^XTENSION"
        echo "END"
        # cleanup
        test "$AI_DEBUG" && echo $wdir >&2
        test -z "$AI_DEBUG" && rm -rf $wdir
        return
    fi
    
    # check for required python scripts
    pyprog=$(which airfun.py)
    test $? -ne 0 &&
        echo "ERROR: missing python module airfun.py." >&2 && return 255


    case $imgtype in
        rgbmef) meftocube "$fits" > $tmpfits
                python3 $pyprog fitscubetoppm $tmpfits $tmpppm
                retval=$?
                ;;
        plane|rgbcube)
                python3 $pyprog fitscubetoppm "$fits" $tmpppm
                retval=$?
                ;;
    esac
    cat $tmpppm
    test "$AI_DEBUG" && echo $tmpfits $tmpppm >&2
    test -z "$AI_DEBUG" && rm -f $tmpfits $tmpppm
    return $retval
}

meftopnm_old () {
    # convert from FITS to 16bit PNM image, result goes to stdout
    # note: automatic scaling of data values is applied according to
    #   physical value = BSCALE * (storage value) + BZERO
    local showhelp
    local do_ascii_header   # if set, also create ASCII header
                            # requires command line parameter outimage
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-a" && do_ascii_header=1 && shift 1
    done
    local fits="$1"
    local bitpix
    local imgtype
    local nx
    local tfits
    local tdir=${AI_TMPDIR:-"/tmp"}
    local wdir=$(mktemp -d "$tdir/tmp_meftopnm_XXXXXX")
    local tmpdat=$(mktemp "$wdir/tmp_dat_XXXXXX.dat")
    local tmptif=$(mktemp "$wdir/tmp_im1_XXXXXX.tif")
    local tmpfits=$(mktemp "$wdir/tmp_XXXXXX.fits")
    local tmp=$(mktemp "$wdir/tmp_im2_XXXXXX")
    local mconf=$(mktemp "$wdir/tmp_missfits_XXXXXX.conf")
    local sconf=$(mktemp "$wdir/tmp_stiff_XXXXXX.conf")

    (test "$showhelp" || test $# -ne 1) &&
        echo "usage: meftopnm [-a] <fits>" >&2 &&
        return 1
    test ! -e "$fits" &&
        echo "ERROR: fits file $fits not found." >&2 &&
        return 255
    ! is_fits "$fits" &&
        echo "ERROR: $fits is not a supported FITS file." >&2 &&
        return 255
    bitpix=$(listhead "$fits" | grep BITPIX | lines 1 | awk '{print $3}')
    test -z "$imgtype" && is_fitsrgb "$fits"  && imgtype="rgbmef"  && nx=3
    test -z "$imgtype" && is_fitscube "$fits" && imgtype="rgbcube" && nx=3
    test -z "$imgtype" && imgtype="plane" && nx=1
    test "$AI_DEBUG" &&
        echo "# imgtype=$imgtype  bitpix=$bitpix" >&2

    if [ "$do_ascii_header" ]
    then
        # replace non-ASCII characters
        listhead "$fits" | tr '' '?' | grep -aE "^........=" | \
            grep -vwE "^SIMPLE|^BITPIX|^NAXIS[0-9 ]|^EXTEND|^XTENSION"
        echo "END"
        # cleanup
        test "$AI_DEBUG" && echo $wdir >&2
        test -z "$AI_DEBUG" && rm -rf $wdir
        return
    fi

    if [ $bitpix -eq 16 ]
    then
        # note: fitstopnm does not handle 32bit FITS images
        case $imgtype in
            rgbmef)
                meftocube "$fits" | \
                fitstopnm -min 0 -max 65535 -       2>/dev/null | gm convert -flip - -
                ;;
            rgbcube)
                fitstopnm -min 0 -max 65535 "$fits" 2>/dev/null | gm convert -flip - -
                ;;
            plane)
                fitstopnm -min 0 -max 65535 "$fits" 2>/dev/null | gm convert -flip - -
                ;;
        esac
    else
        case $imgtype in
            rgbmef)
                cp "$fits" $tmpfits
                missfits -d > $mconf
                (cd $wdir;
                missfits -c $mconf -verbose_type quiet -write_xml N -save_type new -new_suffix ".miss" \
                    -outfile_type split -split_suffix ".%03d.fits" "$(basename $tmpfits)" >/dev/null)
                ;;
            rgbcube)
                imcopy "$fits[0]" - > $tmpfits
                missfits -d > $mconf
                (cd $wdir;
                missfits -c $mconf -verbose_type quiet -write_xml N -save_type new -new_suffix ".miss" \
                    -outfile_type slice -slice_suffix ".%03d.fits" "$(basename $tmpfits)" >/dev/null)
                ;;
            plane)
                cp "$fits" $wdir/"$(basename $tmpfits | sed -e 's/\.[^.]*$//').000.miss.fits"
                ;;
        esac
        
        stiff -d > $sconf
        for i in $(seq 0 $((nx-1)))
        do
            tfits=$wdir/"$(basename $tmpfits | sed -e 's/\.[^.]*$//').00$i.miss.fits"
            listhead "$tfits" | grep -q "^DATAMIN " || sethead "$tfits" datamin=0
            listhead "$tfits" | grep -q "^DATAMAX " || sethead "$tfits" datamax=65535
            # note: fitstopnm does not handle 32bit FITS images
            #test $nx -eq 1 && fitstopnm $tfits 2>/dev/null | pnmflip -tb
            #test $nx -ne 1 && fitstopnm $tfits 2>/dev/null | pnmflip -tb > $tmp.$i

            stiff -c $sconf -sky_type manual -min_type manual -min_level 0 \
                -max_type manual -max_level 65535 -satur_level 65535 \
                -gamma 1 -bits_per_channel 16 -write_xml N \
                -verbose_type quiet -outfile_name $tmptif $tfits
            test $? -ne 0 &&
                echo "ERROR: stiff failed." >&2 && return 255
            gm convert $tmptif pgm:- > $tmp.$i
        done
        if [ $nx -eq 3 ]
        then
            rgb3toppm $tmp.0 $tmp.1 $tmp.2
        else
            cat $tmp.0
        fi
    fi
    test "$AI_DEBUG" && echo $wdir >&2
    test -z "$AI_DEBUG" && rm -rf $wdir
    return
}


fits3toppm () {
    # combine 3 monochrome FITS images to RGB PPM
    local red=$1
    local green=$2
    local blue=$3
    local outfile=${4:-"-"}
    local pyprog
    
    (test "$1" == "-h" || test "$1" == "--help" || test $# -lt 3) &&
        echo "usage: fits3toppm <red> <green> <blue> [outppm]" >&2 &&
        return 1

    # check for required python scripts
    pyprog=$(which airfun.py)
    test $? -ne 0 &&
        echo "ERROR: missing python module airfun.py." >&2 && return 255

    python3 $pyprog fits3toppm $red $green $blue $outfile
    return $?
}


fits3tocube () {
    # combine 3 monochrome FITS images to FITS cube
    local red=$1
    local green=$2
    local blue=$3
    local outfile=${4:-"-"}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpvips=$(mktemp "$tdir/tmp_vips_XXXXXX.v")
    local tmpvips16=$(mktemp "$tdir/tmp_vips16_XXXXXX.v")
    
    (test "$1" == "-h" || test "$1" == "--help" || test $# -lt 3) &&
        echo "usage: fits3tocube <red> <green> <blue> [outfits]" >&2 &&
        return 1

    test "$outfile" == "-" && outfile=/dev/stdout
    vips bandjoin "$red $green $blue" $tmpvips
    vips cast $tmpvips $tmpvips16 ushort
    # TODO: check interpretation
    vips fitssave $tmpvips16 $outfile
    retval=$?
    
    rm -f $tmpvips $tmpvips16
    return $retval
}

meftocube () {
    # convert MEF to FITS image cube (output to stdout)
    # note: FILTER is set to RGB
    local mef=$1
    local tdir=${AI_TMPDIR:-"/tmp"}
    local wdir=$(mktemp -d "$tdir/tmp_meftocube_XXXXXX")
    local conf=$wdir/missfits.conf
    local lmef=$wdir/mef.fits
    local retval=0
    
    # TODO: replace imstack and imcopy by missfits
    ! is_fitsrgb $mef && echo "ERROR: input file is not RGB multi-extension FITS image" >&2 && return 255

    ln -s "$(realpath "$mef")" $lmef
    missfits -d > $conf
    (cd $wdir
    missfits -c $conf -outfile_type split -split_suffix %1d.fits -split_start 1 -new_suffix .miss \
        -verbose_type quiet \
        $lmef
    test $? -ne 0 && echo "ERROR: missfits (split) failed" >&2 && return 255
    missfits -c $conf -outfile_type cube  -slice_suffix %1d.fits -slice_start 0 -new_suffix .miss \
        -verbose_type quiet \
        -save_type new \
        mef
    test $? -ne 0 && echo "ERROR: missfits (combine) failed" >&2 && return 255
    ) > /dev/null
    
    if [ -s $wdir/mef.miss.fits ]
    then
        sethead $wdir/mef.miss.fits FILTER=RGB
        cat $wdir/mef.miss.fits
    else
        echo "ERROR: cube not created" >&2
        retval=255
    fi
    
    (test "$AI_DEBUG" || test $retval -ne 0)    && echo $wdir >&2
    (test -z "$AI_DEBUG" && test $retval -eq 0) && rm -rf $wdir
    return $retval
}


imslice () {
    # extract single slice from FITS cube or MEF to stdout
    local showhelp
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    done
    local img=$1
    local slicenum=$2
    local num
    local tfits
    local tdir=${AI_TMPDIR:-"/tmp"}
    local wdir=$(mktemp -d "$tdir/tmp_mef2cube_XXXXXX")
    local mconf=$(mktemp "$wdir/tmp_missfits_XXXXXX.conf")

    (test "$showhelp" || test $# -ne 2) &&
        echo "usage: imslice <image> <slice_number>" >&2 &&
        return 1
    test ! -e "$img" &&
        echo "ERROR: image file $img not found." >&2 &&
        return 255

    # note: checking disabled to work around libvips error (fitssave writes
    #   cube in case of single image plane)
    false && ! is_fitscube $img && ! is_fitsrgb $img &&
        echo "ERROR: unsupported image type (not FITS cube or MEF)." >&2 &&
        return 255

	if is_fitsrgb $img
	then
		# first extension has number 0
		imcopy "$img[$slicenum]" -
	else
        # fits cube
		imcopy "$img[0]" $wdir/"$(basename $img)"
		missfits -d > $mconf
		(cd $wdir;
		missfits -c $mconf -verbose_type quiet -write_xml N -save_type new -new_suffix ".miss" \
			-outfile_type slice -slice_suffix ".%03d.fits" $(basename $img) >/dev/null)
		test $? -ne 0 &&
			echo "ERROR: program missfits failed." >&2 &&
			return 255
		
		num=$(echo $slicenum | awk '{printf("%03d", $1)}')
		tfits=$wdir/$(basename $img | sed -e 's/\.[^.]*$//')".$num.miss.fits"
		#delhead $tfits CTYPE3
		cat $tfits
	fi
    
    rm -rf $wdir
    return
}


mkkernel () {
    # create rectangular b/w kernel (thick line)
    # output image to stdout
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    
    local len=$1    # box width (odd number)
    local width=$2  # line width
    local angle=$3  # position angle (0=right, 90=top)
    local x
    local w
    
    (test "$showhelp" || test $# -ne 3) &&
        echo "usage: mkkernel <length> <width> <angle>" >&2 &&
        return 1
    
    x=$((len*10+1))
    w=$(echo $width | awk '{printf("%.0f", 10*$1)}')
    gm convert -size ${x}x${x} xc:black -stroke white -strokewidth $w \
        -draw "line 0,$((x/2)) $((x-1)),$((x/2))" -rotate $((-1*angle)) \
        +repage -gravity center -crop ${x}x${x}+0+0 \
        -filter box -resize ${len}x${len}! pbm:-
}


imcrop () {
    # crop image, output goes to stdout
    # crop area values w,h,x,y are truncated to multiples of <mod>, default 2
    # old style: imcrop img refpix size, only used by AIval
    local mod=2
    local showhelp
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-1" && mod=1 && shift 1
    done
    
    local img=${1:-"-"}
    local cw=${2:-"20"}
    local ch=${3:-""}   # if empty then cw is percentage
    local cx=${4:-""}   # if empty use center, else used as offset from left 
    local cy=${5:-""}   # if empty use center, else used as offset from top
    local fname
    local tmp1=$(mktemp "/tmp/tmp_img_$$.XXXXXX")
    local tmpfits=$(mktemp "/tmp/tmp_img_$$.XXXXXX.fits")
    local outfmt="pnm"
    local w
    local h
    local ret
    local pyprog

    test "$showhelp" &&
        echo "usage: imcrop [-1] <img> [w|$cw] [h] [xoff] [yoff]> " >&2 &&
        return 1

    # check for required python scripts
    pyprog=$(which airfun.py)
    test $? -ne 0 &&
        echo "ERROR: missing python module airfun.py." >&2 && return 255
    
    if [ "$img" != "-" ]
    then
        fname=$(get_imfilename $img)
        test -z "$fname" && return 255
    else
        cat "$img" > $tmp1
        fname="$tmp1"
    fi
    test ! "$cw" && echo "ERROR: imcrop: cw is empty." >&2 && return 255
    for i in $cw $ch $cx $cy
    do
        ! is_integer $i &&
            echo "ERROR: w,h,xoff,yoff is not integer." >&2 && return 255
    done
    
    # get image width and height and outfmt
    if is_raw "$fname"
    then
        line=$(dcraw-tl -i -v "$fname" | grep "^Image size:")
        w=$(echo $line | cut -d " " -f3)
        h=$(echo $line | cut -d " " -f5)
    fi
    if [ -z "$w" ] && is_fitzip "$fname"
    then
        line=$(unzip -p "$fname" | gm identify - | cut -d " " -f3)
        w=$(echo $line | cut -d "x" -f1)
        h=$(echo $line | cut -d "x" -f2)
    fi
    if [ -z "$w" ]
    then
        set - $(imsize $fname)
        w=$1
        h=$2
        if is_ppm $fname
        then
            outfmt="ppm"
        else if is_pgm $fname
            then
                outfmt="pgm"
            else if is_pbm $fname
                then
                    outfmt="pbm"
                fi
            fi
        fi
    fi
    
    # determine crop area
    if [ "$ch" ]
    then
        test $mod -ne 1 && ch=$((ch/mod*mod)) && cw=$((cw/mod*mod))
    else
        if [ $mod -ne 1 ]
        then
            ch=$((h*cw/100/mod*mod))
            cw=$((w*cw/100/mod*mod))
        else
            ch=$((h*cw/100))
            cw=$((w*cw/100))
        fi
    fi
    if [ "$cx" ]
    then
        test $mod -ne 1 && cx=$((cx/mod*mod))
    else
        if [ $mod -ne 1 ]
        then
            cx=$(((w-cw)/2/mod*mod))
        else
            cx=$(((w-cw)/2))
        fi
    fi
    if [ "$cy" ]
    then
        test $mod -ne 1 && cy=$((cy/mod*mod))
    else
        if [ $mod -ne 1 ]
        then
            cy=$(((h-ch)/2/mod*mod))
        else
            cy=$(((h-ch)/2))
        fi
    fi
    
    test "$AI_DEBUG" && test $AI_DEBUG -gt 1 &&
        echo "DEBUG: imcrop: crop area: ${cw}x${ch}+${cx}+${cy}" >&2
    
    if is_raw "$fname"
    then
        AIraw2gray "$fname" - | \
            gm convert - -crop ${cw}x${ch}+${cx}+${cy} +repage pnm:-
    else
        if is_fits $fname
        then
            python3 $pyprog imcrop "$fname" - $cw $ch $cx $cy
        else
            if is_fitzip $fname
            then
                unzip -p "$fname" > $tmpfits
                python3 $pyprog imcrop $tmpfits - $cw $ch $cx $cy
            else
                #gm convert "$fname" -crop ${cw}x${ch}+${cx}+${cy} +repage ${outfmt}:-
                python3 $pyprog imcrop "$fname" - $cw $ch $cx $cy
            fi
        fi
    fi
    ret=$?
    rm -f $tmp1 $tmpfits
    return $ret
}

imcount_older () {
    local img=${1:-"-"}
    local tmp1=$(mktemp "/tmp/tmp_img_$$.XXXXXX")
    local fname

    if [ "$img" != "-" ]
    then
        fname=$(get_imfilename $img)
        test -z "$fname" && echo "ERROR: in imcount." >&2 && return 255
    else
        cat "$img" > $tmp1
        fname="$tmp1"
    fi
    identify -verbose $fname | grep -iE "geometry:|mean:" | tr 'x+:' ' ' | \
    awk '{
        if (NR==1) {s=$2*$3; next}
        if ($1!="mean" || NR>4) next
        if (NR>2) printf(",")
        printf("%.0f", $2*s)
    }END{printf("\n")}'
    rm -f $tmp1
}

imcount_old () {
    local img=${1:-"-"}
    local tmp1=$(mktemp "/tmp/tmp_img_$$.XXXXXX")
    local fname
    local neg=0

    if [ "$img" != "-" ]
    then
        fname=$(get_imfilename $img)
        test -z "$fname" && echo "ERROR: in imcount." >&2 && return 255
    else
        cat "$img" > $tmp1
        fname="$tmp1"
    fi
    is_pbm $fname && neg=1

    AIval -a $fname | awk -v neg=$neg '{
        if(NR==1) ncol=NF
        r=r+$1; g=g+$2; b=b+$3
    }END{
        if (neg==1) {
            r=NR-r; g=NR-g; b=NR-b
        }
        printf("%d",r)
        if(ncol==3) printf(",%d,%d",g,b)
        printf("\n")
    }'
}


# get sum of pixel values for each color (coma separated)
imcount () {
    local img=${1:-"-"}
    local tmp1=$(mktemp "/tmp/tmp_img_$$.XXXXXX")
    local tmpcsv=$(mktemp "/tmp/tmp_csv_$$.XXXXXX.csv")
    local fname
    local bw=0

    if [ "$img" != "-" ]
    then
        fname=$(get_imfilename $img)
        test -z "$fname" && echo "ERROR: in imcount." >&2 && return 255
    else
        cat "$img" > $tmp1
        fname="$tmp1"
    fi
    is_pbm $fname && bw=1

    vips stats $fname $tmpcsv
    cat $tmpcsv | awk -v bw=$bw '{
        if (NR>1) {
            if (NR>2) printf(",")
            if (bw==1) {
                printf("%.0f", $3/255)
            } else {
                printf("%.0f", $3)
            }
        }
    } END {printf("\n")}'
    
    rm -f $tmp1 $tmpcsv
}

imnumadd () {
    local showhelp
    local testonly
    local i
    for i in 1 2
    do
        test "$1" == "-h" && showhelp=1 && shift 1
        test "$1" == "-t" && testonly=1 && shift 1
    done
    local dir=$1
    local add=$2
    local f
    local nin
    local nout
    local tmpdat=$(mktemp /tmp/tmp_list_XXXXXX.dat)
    
    (test "$showhelp" || test $# -ne 2) &&
        echo "usage: imnumadd [-t] <dir> <add>" >&2 &&
        return 1
    
    ! test -d $dir &&
        echo "ERROR: directory $dir does not exist" >&2 && return 255
    ! is_number $add &&
        echo "ERROR: add=$add is not a number" >&2 && return 255
    
    (cd $dir &&
    ls -1 -r 2>/dev/null | \
        grep -E "[a-zA-Z]*[0-9][0-9][0-9][0-9].[a-zA-Z]*" > $tmpdat
    if [ -s $tmpdat ]
    then
        while read f
        do
            nin=$(echo $f | tr -d '[:alpha:][:punct:]')
            nout=$(echo $nin | awk -v a=$add '{printf("%04d", $1+a)}')
            if [ "$testonly" ]
            then
                echo mv -i $f ${f/$nin/$nout}
            else
                mv -i $f ${f/$nin/$nout}
            fi
        done < $tmpdat
    else
        echo "WARNING: no images found" >&2
    fi
    )
    rm -f $tmpdat
    return 0
}

imsize () {
    # get image dimension
    local showhelp
    local do_deg    # try to estimate fov in degrees
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-d" && do_deg=1 && shift 1
    done
    local img="$1"
    local sname
    local str
    local type
    local retval
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpfits=$(mktemp $tdir/tmp_im_XXXXXX.fits)

    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: imsize [-d] <img|setname>" >&2 &&
        return 1
    
    if [ -s "$img" ]
    then
        test -z "$type" && is_raw "$img" && type=RAW
        test -z "$type" && is_pnm "$img" && type=PNM
        test -z "$type" && is_fits "$img" && type=FITS
        test -z "$type" && is_fitsgz "$img" && type=FITSGZ
        test -z "$type" && is_fitzip "$img" && type=FITZIP
    else
        test -z "$type" && is_setname "$img" && sname=$img && img=""
    fi
    test -z "$img" && test -f $sname.ppm && img=$sname.ppm
    test -z "$img" && test -f $sname.pgm && img=$sname.pgm
    test -z "$img" &&
        echo "ERROR: no image found." >&2 && return 255

    case "$type" in
        RAW)    str=$(dcraw-tl -i -v "$img" | grep "^Image size:")
                retval=$?
                set - $(echo $str)
                str="$3 $5"
                ;;
        PNM)    set - $(pnmfile "$img" | cut -d ',' -f2)
                test $# -lt 3 && retval=255
                test $# -ge 3 && retval=0
                str="$1 $3"
                ;;
        FITS|FITSGZ)   #str=$(get_header -q -s "$img" NAXIS1,NAXIS2,NAXIS3)
                str=$(listhead "$img" | grep NAXIS[123] | awk '{print $3}')
                retval=$?
                ;;
        FITZIP) unzip -p "$img" > $tmpfits
                #str=$(get_header -q -s $tmpfits NAXIS1,NAXIS2,NAXIS3)
                str=$(listhead "$tmpfits" | grep NAXIS[123] | awk '{print $3}')
                retval=$?
                ;;
        *)      str=$(gm identify "$img")
                retval=$?
                test $retval -eq 0 &&
                    str=$(echo $str | cut -d ' ' -f3 | sed -e 's,+.*,,' | tr 'x' ' ')
                ;;
    esac
    if [ $retval -eq 0 ]
    then
        if [ "$do_deg" ]
        then
            if [ -e $sname.wcs.head ]
            then
                echo $str $(get_wcspscale $sname) | awk '{
                    printf("%.2f %.2f\n", $1*$3/3600, $2*$3/3600)}'
            else
                echo "ERROR: missing $sname.wcs.head" >&2
                retval=255
            fi
        else
            echo $str
        fi
    else
        test "$AI_DEBUG" && echo "# str=$str" >&2
    fi
    rm -f $tmpfits
    return $retval
}

imcoord () {
    # determine image coordinates
    local showhelp
    local sexagesimal=1 # default output sexagesimal values
    local kwralist="RA RATEL OBJCTRA"
    local kwdelist="DEC DETEL OBJCTDEC"
    local verbose
    local i
    for i in 1 2 3
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-c" && kwralist="$kwralist AI_CORA"  &&
                             kwdelist="$kwdelist AI_CODEC" && shift 1
        test "$1" == "-d" && sexagesimal="" && shift 1
        test "$1" == "-v" && verbose=1 && shift 1
    done
    local sname=$1       # set name
    #local x=${2:-""}    # image coordinate, if empty use CRPIXn
    local img
    local nref
    local hdr
    local whdr
    local rad
    local ded
    local kw
    local fname
    local usedkw
    local str
    
    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: imcoord [-v] [-c] [-d] <set>" >&2 &&
        return 1
    
    ! is_setname $sname && ! is_ahead $sname &&
        echo "ERROR: unsupported input file" >&2 && return 255
    
    is_setname $sname && whdr=$sname.wcs.head
    is_ahead $sname && whdr=$sname
    if [ "$whdr" ] && [ -e $whdr ]
    then
        # get coordinates from wcs header file
        test "$verbose" && echo "# reading CRVAL[12] from $whdr" >&2
        rad=$(dec2sexa $(grep "^CRVAL1 " $whdr | awk '{printf("%.4f", 1*$3)}') 15 1)
        ded=$(dec2sexa $(grep "^CRVAL2 " $whdr | awk '{printf("%.4f", 1*$3)}') 1 0)
        #echo $rad $ded >&2
    else
        nref=$(AIsetinfo -b $sname | lines 1 | awk '{printf("%s", $8)}')
        # get ra de from $sname.head or measure/$nref.src.head
        hdr=$sname.head
        #test "$singleimage" && hdr=${sname%.*}.head
        if [ -e $hdr ]
        then
            for kw in $kwralist
            do
                test -z "$rad" && test -f $sname.head &&
                    rad=$(get_header -q $sname.head $kw) &&
                    fname=$sname.head && usedkw=$kw
            done
            for kw in $kwralist
            do
                test -z "$rad" && test -f measure/$nref.src.head &&
                    rad=$(get_header -q measure/$nref.src.head $kw) &&
                    fname=measure/$nref.src.head && usedkw=$kw
            done
            test -z "$rad" && test -f $rdir/$nref.hdr &&
                rad=$(grep "^ra=" $rdir/$nref.hdr | cut -d '=' -f2) &&
                fname=$rdir/$nref.hdr && usedkw="ra"

            if [ "$fname" ]
            then
                test "${fname##*.}" == "head" && for kw in $kwdelist
                do
                    test -z "$ded" &&
                        ded=$(get_header -q $fname $kw) &&
                        usedkw="$usedkw, $kw"
                done
                test -z "$ded" &&
                    ded=$(grep "^de=" $fname | cut -d '=' -f2) &&
                        usedkw="$usedkw, $de"
            fi
        fi
        test -z "$rad" &&
            echo "ERROR: unknown ra center coordinate ($sname $nref)." >&2 &&
            return 255
        test -z "$ded" &&
            echo "ERROR: unknown de center coordinate ($sname $nref)." >&2 &&
            return 255
        test "$verbose" && echo "# reading $usedkw from $fname" >&2
    fi
    test -z "$rad" && str="RA"
    test -z "$ded" && test "$str" && str="$str and DEC"
    test -z "$ded" && test ! "$str" && str="DEC"
    test "$str" &&
        echo "$str coordinate is missing" >&2 && return 255
    
    # convert sexadecimal to decimal coordinates
    rad=$(echo $rad | tr ' ' ':')
    ded=$(echo $ded | tr ' ' ':')
    test "${rad/:/}" != "$rad" && rad=$(sexa2dec $(echo $rad | tr ' ' ':') 15)
    test "${ded/:/}" != "$ded" && ded=$(sexa2dec $(echo $ded | tr ' ' ':'))
    if [ "$sexagesimal" ]
    then
        echo $(dec2sexa $rad 15 1 | sed -e 's/^+//') $(dec2sexa $ded 1 0)
    else
        echo $rad $ded
    fi
    return
}


_imstat () {
    # get statistics for the given image (or stdin)
    local img=${1:-"-"}
    local fname
    local stat
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpin=$(mktemp "$tdir/tmp_stat_XXXXXX.img")
    local tmpgray=$(mktemp "$tdir/tmp_stat_XXXXXX.pgm")
    local tmpcsv=$(mktemp "$tdir/tmp_stat_XXXXXX.csv")

    if [ "$img" != "-" ]
    then
        fname=$(get_imfilename $img)
        test -z "$fname" && return 255
    else
        cat > $tmpin
        fname=$tmpin
    fi
    if is_raw "$fname"
    then
        AIraw2gray "$fname" $tmpgray
        vips stats $tmpgray $tmpcsv
        stat=$(cat $tmpcsv | awk '{
            if (NR>1) {
                if (NR>2) printf(" ")
                printf("%.0f %.0f %.1f (%.1f)", $1, $2, $5, $6)
            }
        } END {printf("\n")}')
    else
        vips stats "$fname" $tmpcsv
        stat=$(cat $tmpcsv | awk '{
            if (NR>1) {
                if (NR>2) printf(" ")
                printf("%.0f %.0f %.1f (%.1f)", $1, $2, $5, $6)
            }
        } END {printf("\n")}')
        is_ppm "$fname" && test $(echo $stat | wc -w) -eq 4 &&
            stat="$stat $stat $stat"
    fi
    echo $stat
    rm -f $tmpcsv $tmpgray
}


_imstat_old () {
    # get statistics for the given image (or stdin)
    local img=${1:-"-"}
    local fname
    local stat
    if [ "$img" != "-" ]
    then
        fname=$(get_imfilename $img)
        test -z "$fname" && return 255
    else
        fname="-"
    fi
    if is_raw "$fname"
    then
        stat=$(AIraw2gray "$fname" - | identify -verbose - | \
            grep -iE "min:|max:|mean:|deviation:" | \
            awk '{if ($2~/deviation/) {printf("(%.1f)\n", $3)}
                else {if ($1~/mean/) {printf("%.1f\n", $2)}
                else printf("%d\n", $2)}}')
    else
        stat=$(identify -verbose "$fname" | \
            grep -iE "min:|max:|mean:|deviation:" | \
            awk '{if ($2~/deviation/) {printf("(%.1f)\n", $3)}
                else {if ($1~/mean/) {printf("%.1f\n", $2)}
                else printf("%d\n", $2)}}' | lines 12)
        is_ppm "$fname" && test $(echo $stat | wc -w) -eq 4 &&
            stat="$stat $stat $stat"
    fi
    echo $stat
}

immedian () {
    # compute median in each color channel of the given image (or stdin)
    local do_bayer
    local showhelp
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-b" && do_bayer=1 && shift 1
    done
    
    local img=${1:-"-"}
    local fname
    local stat
    local tmp1=$(mktemp "/tmp/tmp_img_$$.XXXXXX")

    (test "$showhelp" || test $# -ne 1) &&
        echo "usage: immedian [-b] <img>" >&2 &&
        return 1

    if [ "$img" != "-" ]
    then
        fname=$(get_imfilename $img)
        test -z "$fname" && return 255
    else
        cat "$img" > $tmp1
        fname="$tmp1"
    fi

    if is_raw "$fname"
    then
        stat=$(AIraw2gray "$fname" - | \
            pgmhist "$fname" | grep "^[0-9]" | tr -d '%' | awk '{
                if ($3>=50) {print $1; nextfile}}')
    else
        type=$(pnmfile $fname | awk '{print $2}')
        case $type in
            PGM)    if [ "$do_bayer" ]
                    then
                        # old:
                        #c11=$(convert $fname -roll +0+0 -define sample:offset=75 -sample 50% - | \
                        #    pgmhist | grep "^[0-9]" | tr -d '%' | awk '{
                        #        if ($3>=50) {print $1; nextfile}}')
                        c00=$(gm convert $fname -roll +0+0 -filter point -resize 50% - | \
                            pgmhist | grep "^[0-9]" | tr -d '%' | awk '{
                                if ($3>=50) {print $1; nextfile}}')
                        c10=$(gm convert $fname -roll +0-1 -filter point -resize 50% - | \
                            pgmhist | grep "^[0-9]" | tr -d '%' | awk '{
                                if ($3>=50) {print $1; nextfile}}')
                        c01=$(gm convert $fname -roll -1+0 -filter point -resize 50% - | \
                            pgmhist | grep "^[0-9]" | tr -d '%' | awk '{
                                if ($3>=50) {print $1; nextfile}}')
                        c11=$(gm convert $fname -roll -1-1 -filter point -resize 50% - | \
                            pgmhist | grep "^[0-9]" | tr -d '%' | awk '{
                                if ($3>=50) {print $1; nextfile}}')
                        stat="$c00 $c01 $c10 $c11"
                    else
                        stat=$(pgmhist "$fname" | grep "^[0-9]" | tr -d '%' | awk '{
                            if ($3>=50) {print $1; nextfile}}')
                    fi
                    ;;
            PPM)    cat "$fname" | ppmtorgb3
                    r=$(pgmhist noname.red | grep "^[0-9]" | tr -d '%' | awk '{
                        if ($3>=50) {print $1; nextfile}}')
                    g=$(pgmhist noname.grn | grep "^[0-9]" | tr -d '%' | awk '{
                        if ($3>=50) {print $1; nextfile}}')
                    b=$(pgmhist noname.blu | grep "^[0-9]" | tr -d '%' | awk '{
                        if ($3>=50) {print $1; nextfile}}')
                    stat="$r $g $b"
                    rm noname.red noname.grn noname.blu
                    ;;
            *)      echo "ERROR: immedian(): unknown type." >&2 && return 255;;
        esac
    fi
    echo $stat
    rm -f $tmp1
}

datarange () {
    # check data range of FITS image, output: min median max
    local showhelp
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    done
    
    local fimg="$1"
    local min
    local max
    local md
    local x
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpdat=$(mktemp $tdir/tmp_data_$$.XXXXXX.dat)
    local tmpfits=$(mktemp $tdir/tmp_im_$$.XXXXXX.fits)
    local tmpfits2=$(mktemp $tdir/tmp_im2_$$.XXXXXX.fits)

    (test "$showhelp" || test $# -ne 1) &&
        echo "usage: datarange <fitsimage>" >&2 &&
        return 1

    test ! -e "$fimg" &&
        echo "ERROR: file $fimg not found" >&2 && return 255
    ! is_fits "$fimg" &&
        echo "ERROR: unsupported file format" >&2 && return 255

    if is_fitscube "$fimg"
    then
        # choose green channel only
        imslice "$fimg" 2 > $tmpfits2
        fitscopy "$tmpfits2[:5,:5]" - > $tmpfits
    else
        fitscopy "$fimg[:5,:5]" - > $tmpfits
    fi
    # determine center area (80%)
    x=$(imsize $tmpfits | awk '{
        dx=0.1*$1; dy=0.1*$2
        printf("%.0f:%.0f,%.0f:%.0f\n", dx, $1-dx, dy, $2-dy)}')
    imlist "$tmpfits[$x]" | sed -e 's/^[ ]*[0-9]*//' | sed -e '1,2d' | tr ' ' '\n' | \
        grep "[0-9]" > $tmpdat
    set - $(minmax $tmpdat)
    min=$1
    max=$2
    md=$(median $tmpdat)
    
    test "$AI_DEBUG" && echo $tmpfits $tmpdat
    test -z "$AI_DEBUG" && rm -f $tmpfits $tmpdat
    rm -f $tmpfits2
    #echo "# min/median/max:" >&2
    echo $min $md $max
    return 0
}


# subtract smoothed background(s) from image
# output goes to stdout
imbgsub () {
    local showhelp
    local outmult=1
    local do_fits       # if set create FITS output instead of PNM
    local i
    for i in 1 2 3
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-m" && outmult=$2 && shift 2
        test "$1" == "-f" && do_fits=1 && shift 1
    done
    local img=${1:-""}
    local bgimg=${2:-""}
    local bgres=${3:-""}
    local bgmult=${4:-10}       # intensity multiplier used in bgimg, bgres
    local bgmean=${5:-1000}     # mean bg value in bgres
    local bgval=${6:-1000}      # desired bg value of resulting bg-subtracted image
    local hdr
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpim1=$(mktemp "/tmp/tmp_im1_XXXXXX.pnm")
    local tmpim2=$(mktemp "/tmp/tmp_im2_XXXXXX.pnm")
    local tmpim3=$(mktemp "/tmp/tmp_im3_XXXXXX.pnm")
    local size
    local f
    local opts
    local retval
    local pyprog
    
    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: imbgsub [-f] [-o inbgoff] [-m outmult] <img> <bgimg> [bgres] [bgmult|$bgmult]" \
            "[bgresmean|$bgmean] [outbgval|$bgval]" >&2 &&
        return 1

    # check for required python scripts
    pyprog=$(which airfun.py)
    test $? -ne 0 &&
        echo "ERROR: missing python module airfun.py." >&2 && return 255

    for f in $img $bgimg $bgres
    do
        test ! -f "$f" &&
            echo "ERROR: image $f does not exist." >&2 && return 255
        ! is_pnm $f &&
            echo "ERROR: image $f has unsupported file format." >&2 && return 255
    done

    test "$do_fits" && opts="-f"

    false && (
    size=$(identify $img | cut -d ' ' -f3)
    gm convert $bgimg -resize $size\! $tmpim1
    test "$bgres" &&
        gm convert $bgres -resize $size\! - | pnmarith -add - $tmpim1 | \
            pnmccdred -a -$bgmean - $tmpim2 &&
        cp $tmpim2 $tmpim1

    # note: pyvips pipes are unreliable
    #pnmccdred2 -m $(echo $outmult/$bgmult | bc -l) $tmpim1 - | \
    #    pnmccdred2 -f -premult $outmult -a $bgval -d - $tmpim1 -
    pnmccdred2 -m $(echo $outmult/$bgmult | bc -l) $tmpim1 $tmpim2
    pnmccdred2 -a $((-1*inbgoff)) $img $tmpim3
    pnmccdred2 $opts -premult $outmult -a $bgval -d $tmpim2 $tmpim3 -
    )

    # TODO: add bgres
    test "$bgres" && echo "# ERROR: imbgsub bgres not supported" >&2 && return 255
    python3 $pyprog imbgsub $opts -bgm $bgmult -m $outmult -b $bgval $img $bgimg -
    retval=$?
    
    rm -f $tmpim1 $tmpim2 $tmpim3
    return $retval
}

# remove vertical gradient pattern from image
impatsub () {
    local plevel=50 # 0 lowest, 50 median, 100 highest
    local outfile   # if set then write result to outfile (default=infile)
    local do_keep   # keep gradient pattern (line)
    local quiet
    local showhelp
    local i
    for i in $(seq 1 5)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-p" && plevel="$2" && shift 2
        test "$1" == "-o" && outfile="$2" && shift 2
        test "$1" == "-k" && do_keep=1 && shift 1
        test "$1" == "-q" && quiet=1 && shift 1
    done
    local img=${1:-""}
    local w
    local h
    local pos
    local add
    local tmpsort=$(mktemp "/tmp/tmp_sort_XXXXXX.pnm")
    local tmppat=$(mktemp "/tmp/tmp_pat_XXXXXX.pnm")
    local tmppatsub=$(mktemp "/tmp/tmp_patsub_XXXXXX.pnm")
    local tmpline=$(mktemp "/tmp/tmp_line_XXXXXX.pnm")
    local tmpdat=$(mktemp "/tmp/tmp_data_XXXXXX.dat")

    (test "$showhelp" || test $# -ne 1) &&
        echo "usage: impatsub [-c] [-p plevel|$plevel] [-o outfile] <image>" >&2 &&
        return 1

    set - $(imsize $img)
    w=$1
    h=$2
    pos=$((w*plevel/100))

    pnmrowsort $img $tmpsort
    gm convert $tmpsort -crop 1x${h}+${pos}+0 $tmpline
    if is_ppm $tmpline
    then
        AIval -a $tmpline > $tmpdat
        add=$(median $tmpdat 1)","$(median $tmpdat 2)","$(median $tmpdat 3)
    else
        AIval -a $tmpline > $tmpdat
        add=$(median $tmpdat 1)
    fi
    # TODO: remove gradient from tmpline (skip lowest/highest 10%)
    gm convert $tmpline -resize ${w}x${h}\! $tmppat
    pnmccdred -a $add -d $tmppat $img $tmppatsub
    test -z "$outfile" && mv $tmppatsub $img
    test    "$outfile" && mv $tmppatsub $outfile
    test "$do_keep" && cp $tmpline x.pat.pnm && test -z "$quiet" &&
        echo "# gradient line: x.pat.pnm" >&2 &&
        echo "# expand line: gm convert x.pat.pnm -resize ${w}x${h}\! <bgimg>" >&2
    test "$AI_DEBUG"   && echo  $tmpsort $tmpline $tmpdat $tmppat >&2
    test ! "$AI_DEBUG" && rm -f $tmpsort $tmpline $tmpdat $tmppat $tmppatsub
    return 0
}


imblur () {
    # smooth image by downscaling, bluring and upscaling
    local showhelp
    local scale=2
    local blur=0.8
    local i
    for i in 1 2 3
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-s" && scale=$2 && shift 2
        test "$1" == "-b" && blur=$2 && shift 2
    done
    local img=$1
    local s
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpim=$(mktemp "$tdir/tmp_im_XXXXXX.pnm")
 
    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: imblur [-s downscale|$scale] [-b blur|$blur] <image>" >&2 &&
        return 1
   
    if [ "$img" == "-" ]
    then
        cat /dev/stdin > $tmpim
        img=$tmpim
    fi
    s=$(imsize $img | tr ' ' 'x')
    convert $img -scale $((100/scale))% -blur 0x$blur -resize ${s}\! -
    rm -f $tmpim
}

kmedian () {
    # compute median of image pixels within given kernel
    # output image to stdout
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    local img=$1
    local kernel=$2 # use this b/w image as kernel for computing median
                    # kernel pixels must be black , image must have
                    # odd number of pixels in both dimensions
    local tdir=${AI_TMPDIR:-"/tmp"}
    local wdir=$(mktemp -d "$tdir/tmp_median_XXXXXX")
    local xc
    local yc
    local roll

    (test "$showhelp" || test $# -ne 2) &&
        echo "usage: kmedian <image> <kernelimage>" >&2 &&
        return 1

    ! is_pbm $kernel &&
        echo "ERROR: kernel image must be in PBM format." >&2 &&
        return 255
    ! is_pnm $img &&
        echo "ERROR: only PNM images supported by kernel-median." >&2 &&
        return 255
    
    xc=$(identify $kernel | cut -d " " -f3 | awk -F "x" '{print ($1-1)/2}')
    yc=$(identify $kernel | cut -d " " -f3 | awk -F "x" '{print ($2-1)/2}')
    AIval -c -a -1 $kernel | while read x y z
    do
        roll=$(echo $((x-xc)) $((y-yc)) | awk '{
            if ($1<=0) {printf("+%d", -1*$1)} else {printf("%d", -1*$1)}
            if ($2<=0) {printf("+%d", -1*$2)} else {printf("%d", -1*$2)}
            }')
        #echo "$roll" >&2
        gm convert $img -roll $roll $wdir/roll.$roll.pnm
    done
    #pnmcombine -d $wdir/* - 2>/dev/null
    pnmcombine2 -d $wdir/* -
    rm -rf $wdir
    return

}


AIraw2fullgray () {
    # convert raw image to gray scale with linear scale up to 16bit range
    # and keeping overscan area
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1

    local img=$1
    local bad=${2:-""}
    local sat
    local mult=1
    local param="-4 -t 0 -k 0 -r 1 1 1 1 $AI_DCRAWPARAM"
    
    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: AIraw2fullgray <img> [bad]" >&2 &&
        return 1
    
    test "$AI_RAWBITS" && sat=$(echo "2^$AI_RAWBITS - 1" | bc) &&
        mult=$(echo "2^(16-$AI_RAWBITS)" | bc)
    test "$sat"  && param="$param -S $sat"

    test "$bad" && param="$param -P $bad"
    dcraw-tl -c $param -E $img | pnmccdred -m $mult - -
}

AIraw2gray () {
    # convert raw image to gray scale image, output to stdout
    # - optionally crop to AI_CCDREGION (image pixel coordinates measured from raw image)
    # - scale up from 12bit to 16bit
    # - optionally subtract scaled dark frame
    # - correct for overscan offset if text file $AI_OVERSCAN exists
    #   (containing lines with two fields: imnum overscan_value)
    # - if input image is FITS file then header keyword IMGROLL = 'Y' is
    #   accounted for
    local showhelp
    local add=0
    local doff=0    # offset of dark counts (FITS only)
    local scale=1   # only applied on FITS images
    local do_flip
    local do_ccdregion # if set then crop to AI_CCDREGION
    local i
    for i in 1 2 3 4 5 6
    do
        test "$1" == "-a" && add=$2 && shift 2
        test "$1" == "-o" && doff=$2 && shift 2
        test "$1" == "-s" && scale=$2 && shift 2
        test "$1" == "-c" && do_ccdregion=1 && shift 1
        test "$1" == "-f" && do_flip=1 && shift 1
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    done
    
    local img=$1
    local outimg=$2
    local dark=${3:-""}
    local bad=${4:-""}
    local flat=${5:-""}     # must be at average level 10000
    local sat
    local param="-4 -t 0 -k 0 -r 1 1 1 1 $AI_DCRAWPARAM"
    local i4
    local oscorr=""
    local oszero=8192
    local ped
    local imgroll=""
    local cmd
    local origname
    local fitsreg
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpfits=$(mktemp "$tdir/tmp_im_XXXXXX.fits")
    local tmpcrop=$(mktemp "$tdir/tmp_crop_XXXXXX.fits")

    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: AIraw2gray [-f] [-c] [-s scale|$scale] [-a add|$add] <inimg> <outimg> [dark] [bad] [flat]" >&2 &&
        return 1

    test "$dark" && test ! -f $dark &&
        echo "ERROR: dark image $dark not found." >&2 && return 255
    test "$bad" && test ! -f $bad &&
        echo "ERROR: badpixel file $bad not found." >&2 && return 255
    test "$flat" && test ! -f $flat &&
        echo "ERROR: flat field image $flat not found." >&2 && return 255
    
    test "$AI_RAWBITS" && sat=$(echo "2^$AI_RAWBITS - 1" | bc)
    test "$sat"  && param="$param -S $sat"

    origname=$img
    is_fitzip $img && unzip -p $img > $tmpfits && img=$tmpfits
    is_fitsgz $img && gunzip -c $img > $tmpfits && img=$tmpfits
    
    if is_fits $img
    then
        if [ "$do_ccdregion" ] && [ "$AI_CCDREGION" ]
        then
            fitsreg=$(echo $(imsize $img) $AI_CCDREGION | awk '{
                printf("[%d:%d,%d:%d]\n", $5+1, $3+$5, $2-($4+$6)+1, $2-$6)}')
            test "$AI_DEBUG" && echo "# crop to fitsreg $fitsreg" >&2
            fitscopy $img"$fitsreg" - > $tmpcrop && img=$tmpcrop
        fi
        imhead $img | grep "^IMGROLL " | tr -d "'" | grep -q -w Y &&
            imgroll="yes"
        test "$AI_DEBUG" && echo "$img  imgroll=$imgroll" >&2
        ped=$(listhead $img | grep "^PEDESTAL=" | awk '{print $2}')
        test -z "$ped" && ped=0
        ped=$((ped + doff))
        param=""
        test "$dark" && param="$param -d $dark"
        test "$flat" && param="$param -m 10000 -s $flat"
        test "$AI_DEBUG" && echo "param=$param" >&2 &&
            echo "add=$add  ped=$ped  imgroll=$imgroll" >&2

        test $ped -ne 0     && param="$param -preadd $ped"
        test "$scale" != "1" && param="$param -premult $scale"
        test "$do_flip"     && param="$param -tb"
        test "$imgroll"     && param="$param -r180"
        test $add -ne 0     && param="$param -a $add"
        cmd="pnmccdred2 $param $img $outimg"
        

        test "$AI_DEBUG" && echo pnmccdred2 $param $img $outimg >&2
        pnmccdred2 $param $img $outimg
        test -z "$AI_DEBUG" && rm $tmpfits $tmpcrop
        return
    fi
    
    if is_raw $img
    then
        test "$dark" && param="$param -K $dark"
        test "$bad" && param="$param -P $bad"
        test "$flat" && param="$param -F $flat"
        if [ -f "$AI_OVERSCAN" ]
        then
            i4=$(echo $(basename $img) | awk '{printf("%04d", 1*$1)}')
            is_integer $i4 &&
                oscorr=$(grep -w "^$i4" "$AI_OVERSCAN" | awk -v zero=$oszero '{
                    printf("%.1f", zero-$2)}')
            test -z "$oscorr" && echo "WARNING: no overscan value found for $i4" >&2
        fi
        test "$outimg" == "-" && outimg=/dev/stdout
        test "$AI_DEBUG" && param="$param -v"
        test "$AI_DEBUG" && echo dcraw-tl -c $param -d -l $img >&2
        test -z "$oscorr" && dcraw-tl -c $param -d -l $img > $outimg
        test    "$oscorr" && dcraw-tl -c $param -d -l $img | pnmccdred -a $oscorr - $outimg
        test -z "$AI_DEBUG" && rm $tmpfits $tmpcrop
        return
    fi
    
    echo "ERROR: input image has unsupported format." >&2
    test -z "$AI_DEBUG" && rm $tmpfits $tmpcrop
    return 255
}

AIraw2rgb () {
    # convert raw image to RGB image, output to stdout
    # - scale up from 12bit to 16bit
    # - optionally subtract dark frame (scaled to 16bit)
    # - optionally divide by normalized flat field (average level 10000)
    # - correct for overscan offset if text file $AI_OVERSCAN exists
    #   (containing lines with two fields: imnum overscan_value)
    # outputs RGB image (to stdout)
    # note about bayer pattern
    # - INDI ASI driver reports RGGB, corresponding to lower left corner = R
    # - bayer2rgb is using upper left corner which is GBRG, that means pattern
    #   rows have to be flipped
    local showhelp
    local quality=3         # 0=bilinear, 1=VNG, 2=PPG, 3=AHD
    local apply_color_mult  # if set dcraw then color channel multipliers
                            # are applied
    local add=0
    local scale=1           # intensity scaling, only applied on fitsbayer images
    local bayer_pattern     # Bayer matrix pattern (gray FITS)
    local doff=0            # offset of dark counts (FITS only)
    local do_ccdregion      # if set then crop to AI_CCDREGION
    local do_flip
    local i
    for i in $(seq 1 9)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-q" && quality=$2 && shift 2
        test "$1" == "-a" && add=$2 && shift 2
        test "$1" == "-s" && scale=$2 && shift 2
        test "$1" == "-c" && do_ccdregion=1 && shift 1
        test "$1" == "-f" && do_flip=1 && shift 1
        test "$1" == "-m" && apply_color_mult=1 && shift 1
        test "$1" == "-b" && bayer_pattern=$2 && shift 2
        test "$1" == "-o" && doff=$2 && shift 2
    done
    
    local img=$1
    local dark=${2:-""}
    local bad=${3:-""}
    local flat=${4:-""}     # must be at average level 10000
    local sat
    local param
    local i4
    local oscorr=""
    local oszero=8192
    local type  # either raw (is_raw) or fitsbayer
    local scale
    local flippat
    local method
    local opts
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpraw=$(mktemp "$tdir/tmp_gray_XXXXXX.raw")
    local tmptif=$(mktemp "$tdir/tmp_rgb_XXXXXX.tif")

    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: AIraw2rgb [-m] [-q quality|$quality] [-f] [-c] [-s scale|$scale]" \
            "[-b bayer_pattern] <img> [dark] [bad] [flat]" >&2 &&
        return 1

    
    is_raw $img && type="raw"
    test -z "$type" && test "$bayer_pattern" && type="fitsbayer"
    test -z "$type" &&
        echo "ERROR: image $img is not supported (neither DSLR-RAW nor FITS-Bayer)." >&2 &&
        return 255
    test "$dark" && test ! -f $dark &&
        echo "ERROR: dark image $dark not found." >&2 && return 255
    test "$bad" && test ! -f $bad &&
        echo "ERROR: badpixel file $bad not found." >&2 && return 255
    test "$flat" && test ! -f $flat &&
        echo "ERROR: flat field image $flat not found." >&2 && return 255
    
    test "$AI_RAWBITS" && sat=$(echo "2^$AI_RAWBITS - 1" | bc)
    
    if [ "$type" == "raw" ]
    then
        param="-q $quality -4 -t 0 -k 0 $AI_DCRAWPARAM"
        test "$apply_color_mult" || param="-r 1 1 1 1 $param"
        test "$sat"  && param="$param -S $sat"

        test "$dark" && param="$param -K $dark"
        test "$bad"  && param="$param -P $bad"
        test "$flat" && param="$param -F $flat"
        if [ -f "$AI_OVERSCAN" ]
        then
            i4=$(echo $(basename $img) | awk '{printf("%04d", 1*$1)}')
            is_integer $i4 &&
                oscorr=$(grep -w "^$i4" "$AI_OVERSCAN" | awk -v zero=$oszero '{
                    printf("%.0f", zero-$2)}')
            test -z "$oscorr" && echo "WARNING: no overscan value found for $i4" >&2
        fi
        test "$AI_DEBUG" && param="$param -v"
        test "$AI_DEBUG" && echo dcraw-tl -c $param -o 0 -l $img >&2
        test "$oscorr" && add=$((add + oscorr))
        if [ $add -eq 0 ]
        then
            dcraw-tl -c $param -o 0 -l $img
        else
            dcraw-tl -c $param -o 0 -l $img | pnmccdred -a $add - -
        fi
    else
        # flip, scale, dark, flat, debayer
        opts=""
        test "$do_ccdregion" && opts=$(echo $opts "-c")
        test "$do_flip" && opts=$(echo $opts "-f")
        AIraw2gray $opts -o $doff -s $scale $img - "$dark" "$bad" "$flat" | sed -e '1,3d' > $tmpraw
        set - $(imsize $img)
        case $quality in
            0)  method="BILINEAR";;
            1)  method="VNG";;
            3)  method="AHD";;
            *)  method="BILINEAR";;
        esac
        if [ "$do_flip" ]
        then
            flippat=${bayer_pattern}
        else
            flippat=${bayer_pattern:2:2}${bayer_pattern:0:2}
        fi
        #echo "# flippat=$flippat method=$method" >&2
        bayer2rgb -f $flippat -m $method -b 16 -s -t -w $1 -v $2 -i $tmpraw -o $tmptif
        if [ $add -eq 0 ]
        then
            convert $tmptif ppm:-
        else
            convert $tmptif ppm:- | pnmccdred -a $add - -
        fi
    fi
    rm -f $tmpraw $tmptif
}

AImedian () {
    # median of a set of images
    # output image: median.pnm (1 or 3 samples per pixel)
    # TODO: rework
    # - compute mean image: tmpmean
    # - normalize images using tmpmean
    # - create variation map
    # - create median image
    local outfile="median.pnm"
    local showhelp
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-o" && outfile="$2" && shift 2
    done
    
    local img
    local ext
    local fname
    local ilist=""
    local dlist=""
    local mean
    local mul
    local tdir=${AI_TMPDIR:-"/tmp"}
    local wdir=$(mktemp -d "$tdir/tmp_median_$$.XXXXXX")
    local tmpmean=$(mktemp "$wdir/tmp_mean_XXXXXX.pnm")

    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: AImedian [-o outfile|$outfile] <set1|image1> [set2|image2 ...]" >&2 &&
        return 1

    for img in "$@"
    do
        if is_setname $img
        then
            ilist="$ilist $(AIimlist -f $img)"
        else
            fname=$(get_imfilename $img)
            test -z "$fname" && continue
            if is_raw "$fname"
            then
                b=$(basename $fname)
                AIraw2gray "$fname" $tdir/${b%.*}.pnm
                dlist="$dlist $tdir/${b%.*}.pnm"
                ilist="$ilist $tdir/${b%.*}.pnm"
            else
                ilist="$ilist $fname"
            fi
        fi
    done
    test $(echo $ilist | wc -w) -eq 0 &&
        echo "ERROR: no input images" >&2 && return 255
    test "$AI_DEBUG" && echo $ilist
    pnmcombine2 $ilist $tmpmean
    mean=$(AImstat -c $tmpmean | awk '{printf("%.1f", $5)
        if(NF>9) printf(",%.1f,%.1f", $9, $13)}')
    echo "# mean=$mean" >&2
    
    # normalize images
    i=1
    for img in $ilist
    do
        mul=$(AImstat -c $img | awk -v mean=$mean '{
            n=split(mean,m,",")
            printf("%f", m[1]/$5)
            if(n>1) printf(",%f,%f", m[2]/$9, m[3]/$13)
            }')
        pnmccdred2 -m $mul $img $wdir/$i.norm.pnm
        i=$((i+1))
    done
    
    # median image
    pnmcombine2 -d $wdir/[0-9]*.norm.pnm $outfile
    test "$dlist" && rm $dlist
    
    rm $tmpmean
    if [ "$AI_DEBUG" ]
    then
        echo $wdir >&2
    else
        rm -rf $tmpmean $wdir/[0-9]*.norm.pnm
        rmdir $wdir
    fi
    return
}

AIbsplit () {
    # subtract dark and split bayer matrix into separate images for each color cell
    # create pgm output files into current directory
    # matrix geometry:  BGGR    GBRG
    #            A B    b1 g1   g1 b1
    #            C D    g2 r1   r1 g2
    #
    local showhelp
    local cell
    local matrix="BGGR"
    local i
    for i in 1 2 3
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-m" && matrix=$2 && shift 2
        (test "$1" == "-g1" || test "$1" == "-g2" || test "$1" == "-b1" || test "$1" == "-r1" ||
            test "$1" == "-g" || test "$1" == "-g" || test "$1" == "-r") &&
            cell=$(echo $1"1" | cut -c2-3) &&
            echo "# cell=$cell" >&2 &&
            shift 1
    done
    local img=$1
    local dark=${2:-""}
    local bad=${3:-""}
    local fname
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpim=$(mktemp "$tdir/tmp_im_XXXXXX.pgm")
    local a
    local b
    local c
    local d
    local gidx=1
    local f

    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: AIbsplit [-m matrix|$matrix] [-r|g1|g2|b] <img> [dark] [bad]" >&2 &&
        return 1

    matrix=${matrix,,}  # lower case
    a=${matrix:0:1}
    test "$a" != "g" && a=${a}1; test "$a" == "g" && a=${a}$gidx && gidx=2
    b=${matrix:1:1}
    test "$b" != "g" && b=${b}1; test "$b" == "g" && b=${b}$gidx && gidx=2
    c=${matrix:2:1}
    test "$c" != "g" && c=${c}1; test "$c" == "g" && c=${c}$gidx && gidx=2
    d=${matrix:3:1}
    test "$d" != "g" && d=${d}1; test "$d" == "g" && d=${d}$gidx && gidx=2
        
    fname=$(get_imfilename $img)
    test -z "$fname" && continue
    f=$(basename $fname)
    if is_raw "$fname"
    then
        if [ "$dark" ]
        then
            AIraw2gray "$fname" $tmpim $dark $bad
        else
            AIraw2gray "$fname" $tmpim ""    $bad
        fi
        fname=$tmpim
    fi
    # old:
    #convert $fname -roll +1+1 -define sample:offset=75 -sample 50% ${b%.*}.b1.pgm
    #convert $fname -roll +0+1 -define sample:offset=75 -sample 50% ${b%.*}.g1.pgm
    #convert $fname -roll +1+0 -define sample:offset=75 -sample 50% ${b%.*}.g2.pgm
    #convert $fname -roll +0+0 -define sample:offset=75 -sample 50% ${b%.*}.r1.pgm
    (test -z "$cell" || test "$cell" == $a) &&
        gm convert $fname -roll +0+0 -filter point -resize 50% ${f%.*}.$a.pgm
    (test -z "$cell" || test "$cell" == $b) &&
        gm convert $fname -roll -1+0 -filter point -resize 50% ${f%.*}.$b.pgm
    (test -z "$cell" || test "$cell" == $c) &&
        gm convert $fname -roll +0-1 -filter point -resize 50% ${f%.*}.$c.pgm
    (test -z "$cell" || test "$cell" == $d) &&
        gm convert $fname -roll -1-1 -filter point -resize 50% ${f%.*}.$d.pgm
    rm -f $tmpim
}

AIbmerge () {
    # combine 4 images each representing a single bayer matrix "color" into
    # BGGR 2x2 bayer grid
    # note: function is used in manual reduction steps only
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1

    local b1=$1
    local g1=$2
    local g2=$3
    local r1=$4
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpim1=$(mktemp "$tdir/tmp_im1_XXXXXX.pgm")
    local tmpim2=$(mktemp "$tdir/tmp_im2_XXXXXX.pgm")
    local tmpmask=$(mktemp "$tdir/tmp_mask_XXXXXX.pgm")
    local w
    local h

    (test "$showhelp" || test $# -ne 4) &&
        echo "usage: AIbmerge <b1> <g1> <g2> <r1>" >&2 &&
        return 1
        
    w=$(identify $b1 | cut -d " " -f3 | cut -d "x" -f1)
    h=$(identify $b1 | cut -d " " -f3 | cut -d "x" -f2)
    echo -e "P2\n2 2\n65535\n65535 0 0 0" | pnmtile $((w*2)) $((h*2)) - > $tmpmask
    
    # old:
    #convert $b1 -scale 200% - | pnmarith -mul - $tmpmask > $tmpim1
    #convert $g1 -scale 200% - | pnmarith -mul - $tmpmask | convert - -roll +1+0 - | \
    #    pnmarith -add - $tmpim1 > $tmpim2
    gm convert $b1 -scale 200% - | pnmarith -mul - $tmpmask > $tmpim1
    gm convert $g1 -scale 200% - | pnmarith -mul - $tmpmask | gm convert - -roll +1+0 - | \
        pnmarith -add - $tmpim1 > $tmpim2
    mv $tmpim2 $tmpim1
    #convert $g2 -scale 200% - | pnmarith -mul - $tmpmask | convert - -roll +0+1 - | \
    #    pnmarith -add - $tmpim1 > $tmpim2
    gm convert $g2 -scale 200% - | pnmarith -mul - $tmpmask | gm convert - -roll +0+1 - | \
        pnmarith -add - $tmpim1 > $tmpim2
    mv $tmpim2 $tmpim1
    #convert $r1 -scale 200% - | pnmarith -mul - $tmpmask | convert - -roll +1+1 - | \
    #    pnmarith -add - $tmpim1 > $tmpim2
    gm convert $r1 -scale 200% - | pnmarith -mul - $tmpmask | gm convert - -roll +1+1 - | \
        pnmarith -add - $tmpim1 > $tmpim2
    cat $tmpim2
    rm -f $tmpim1 $tmpim2 $tmpmask
}
    
AIbnorm () {
    # normalize gray bayer image by average value (or bg image) of each color
    # output PGM to stdout
    local showhelp
    local nval=10000            # level of normalized image
    local do_keep_brightness    # keep mean brightness instead of normalizing
                                # to nval
    local do_subtract           # do subtraction of mean value instead of division
    local do_bgimage            # do subtraction of bg image for each color
    local quiet
    local i
    for i in 1 2 3 4 5 6
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-n" && nval=$2 && shift 2
        test "$1" == "-k" && do_keep_brightness=1 && shift 1
        test "$1" == "-s" && do_subtract=1 && shift 1
        test "$1" == "-b" && do_bgimage=1 && shift 1
        test "$1" == "-q" && quiet=1 && shift 1
    done
    
    local img=$1
    local ext=pgm
    local pyprog
    local w
    local h
    local mxx
    local x
    local tdir=${AI_TMPDIR:-"/tmp"}

    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: AIbnorm [-q] [-k] [-s|-b] [-n newval|$nval] <img>" >&2 &&
        return 1

    # check for required python scripts
    pyprog=$(which airfun.py)
    test $? -ne 0 &&
        echo "ERROR: missing python module airfun.py." >&2 && return 255

    set - $(imsize $img)
    w=$1
    h=$2
    mxx=$(AImstat -b -c $img | awk '{
        printf("%.0f %.0f %.0f %.0f", $5, $9, $13, $17)}')
    test "$quiet" || echo "# mxx=$mxx" >&2
    test "$do_keep_brightness" && nval=$(echo $mxx | mean)
    if [ "$do_bgimage" ]
    then
        # remove (subtract) smoothed bg image for each bayer matrix cell
        x=$(basename $img | sed -e 's,.'$ext'$,,')
        AIbsplit $img
        for c in b1 g1 g2 r1
        do
            AIbgmap -q $x.$c.pgm 32 3
            pnmccdred2 -a $nval -d $x.$c.bg.pgm $x.$c.pgm $tdir/$x.$c.sub.pgm
            rm $x.$c.bg.pgm $x.$c.bgm1.pgm $x.$c.pgm
        done
        (cd $tdir
        python3 $pyprog bmerge $x.b1.sub.pgm $x.g1.sub.pgm $x.g2.sub.pgm $x.r1.sub.pgm
        rm $x.b1.sub.pgm $x.g1.sub.pgm $x.g2.sub.pgm $x.r1.sub.pgm)
    else
        if [ "$do_subtract" ]
        then
            echo -e "P2\n2 2\n65535\n$mxx" | pnmtile $w $h - | \
                pnmccdred -a $nval -d - $img -
        else
            echo -e "P2\n2 2\n65535\n$mxx" | pnmtile $w $h - | \
                pnmccdred -m $nval -s - $img -
        fi
    fi
}

#----------------------
#   utility functions
#----------------------

AIstat () {
    # statistics of an image
    # gray image:  min max mean stddev
    # rgb image:   Red-min max mean stddev Green-min ... Blue-min
    local showhelp
    local do_crop   # center only
    local do_bayer  # stats in each bayer cell
    local do_median # apply 3x3 median before statistics
    local imgtype
    local verbose
    local i
    for i in $(seq 1 9)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-b" && do_bayer=1 && shift 1
        test "$1" == "-c" && do_crop=1 && shift 1
        test "$1" == "-m" && do_median=1 && shift 1
        test "$1" == "-d" && imgtype="d" && shift 1
        test "$1" == "-f" && imgtype="f" && shift 1
        test "$1" == "-o" && imgtype="o" && shift 1
        test "$1" == "-v" && verbose=1 && shift 1
    done
    local img
    local stat
    local fname
    local sname
    local cmd
    local opts
    local sdat=${AI_SETS:-"set.dat"}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local imlist=$(mktemp "$tdir/tmp_imlist.XXXXXX.dat")
    local tmpdat=$(mktemp "$tdir/tmp_data.XXXXXX.dat")
    local tmp1=$(mktemp "$tdir/tmp_img1.XXXXXX")
    local tmp2=$(mktemp "$tdir/tmp_img2.XXXXXX")
    local tmpstdin=$(mktemp "$tdir/tmp_stdin.XXXXXX")
    local str
    local num
    local c00
    local c01
    local c10
    local c11
    local scale=1   # apply intensity scaling (FITS images only)
    local pyprog
    
    (test "$showhelp" || (test -z "$imgtype" && test $# -lt 1) ||
        (test "$imgtype" && test $# -ge 1)) &&
        echo "usage: AIstat [-m] [-b] [-c] -d|-f|-o" >&2 &&
        echo "   or: AIstat [-m] [-b] [-c] <image1|set1> [image2|set2 ...]" >&2 &&
        return 1
    
    # check for required python scripts
    pyprog=$(which airfun.py)
    test $? -ne 0 &&
        echo "ERROR: missing python module airfun.py." >&2 && return 255

    # create image list (fields: sname num fname ...)
    if [ "$imgtype" ]
    then
        AIimlist -q "" "" raw $imgtype > $imlist
    else
        for img in "$@"
        do
            if [ -e $sdat ] && is_setname $img
            then
                AIimlist -q $img 2>/dev/null > $tmpdat
                if [ -s $tmpdat ]
                then
                    cat $tmpdat >> $imlist
                else
                    AIimlist -q $img "" raw >> $imlist
                fi
            else
                if [ "$img" == "-" ]
                then
                    cat /dev/stdin > $tmpstdin
                    fname=$tmpstdin
                else
                    fname=$(get_imfilename $img)
                fi
                test -z "$fname" && continue
                num="-"
                str=$(basename ${fname%.*})
                #is_integer ${str:0:4} && num=${str:0:4}
                echo "-" $num $fname "- - -" >> $imlist
            fi
        done
    fi
    
    test "$do_median" && opts="-m"

    # statistics
    while read sname num fname x
    do
        test "$verbose" && echo "computing stats for $(basename $fname) ..." >&2

        # determine intensity scaling factor to stretch to full 16bit range
        # this is used in case of FITS images only
        if [ "$sname" == "-" ]
        then
            scale=1
        else
            scale=$(get_param camera.dat rawbits $sname | awk '{print 2^(16-$1)}')
        fi
        
        # apply raw conversion and cropping -> $tmp1
        cmd=""
        # TODO: apply scaling of FITS to final stats instead of scaling the image
        test -z "$cmd" && is_pnm "$fname"    && cmd="cat $fname"
        test -z "$cmd" && is_raw "$fname"    && cmd="AIraw2gray $fname -"
        test -z "$cmd" && is_fits "$fname"   && cmd="meftopnm $fname | pnmccdred -m $scale - -"
        test -z "$cmd" && is_fitzip "$fname" && cmd="unzip -p $fname > $tmp2 && meftopnm $tmp2 | pnmccdred -m $scale - -"
        if [ "$cmd" ]
        then
            test "$do_crop" && cmd="$cmd | imcrop"
            eval $cmd > $tmp1
        else
            if [ "$do_crop" ]
            then
                imcrop $fname > $tmp1
            else
                cp $fname > $tmp1
            fi
        fi
        test $? -ne 0 && return 255
        
        # statistics
        #cmd="cat"
        if [ "$do_bayer" ]
        then
            # old:
            #c00=$(convert $tmp1 -roll +1+1 -define sample:offset=75 -sample 50% - | \
            #    convert - -median 3 pnm:- | _imstat)
            #c01=$(convert $tmp1 -roll +0+1 -define sample:offset=75 -sample 50% - | \
            #    convert - -median 3 pnm:- | _imstat)
            #c10=$(convert $tmp1 -roll +1+0 -define sample:offset=75 -sample 50% - | \
            #    convert - -median 3 pnm:- | _imstat)
            #c11=$(convert $tmp1 -roll +0+0 -define sample:offset=75 -sample 50% - | \
            #    convert - -median 3 pnm:- | _imstat)
            gm convert $tmp1 -roll +0+0 -filter point -resize 50% $tmp2
            c00=$(python3 $pyprog imstat $opts $tmp2)
            gm convert $tmp1 -roll +0-1 -filter point -resize 50% $tmp2
            c10=$(python3 $pyprog imstat $opts $tmp2)
            gm convert $tmp1 -roll -1+0 -filter point -resize 50% $tmp2
            c01=$(python3 $pyprog imstat $opts $tmp2)
            gm convert $tmp1 -roll -1-1 -filter point -resize 50% $tmp2
            c11=$(python3 $pyprog imstat $opts $tmp2)
            stat="$c00 $c01 $c10 $c11"
        else
            # old:
            #stat=$(convert $tmp1 -median 3 pnm:- | _imstat)
            stat=$(python3 $pyprog imstat $opts $tmp1)
        fi
        echo "$(basename $fname) $num "$stat
    done < $imlist
    rm -f $tmp1 $tmp2 $tmpstdin $imlist $tmpdat
    return
}

AImstat () {
    # median statistics
    AIstat -m $@
}


AImstat_old () {
    # median statistics
    AIstat_old -m $@
}


AIsfit () {
    # fit surface to each channel of image ignoring any zero value intensities
    # default surface: plane + centered parabolic
    # output fitted image to stdout
    # output coefficients of fit to stderr
    local showhelp
    local do_plane  # planar fit (instead of quadratic fit)
    local do_center # parabolic fit including center
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-p" && do_plane=1 && shift 1
        test "$1" == "-c" && do_center=1 && shift 1
    done
    local img="$1"
    local rgbdat=$(mktemp "/tmp/tmp_rgbdat_$$.XXXXXX")
    local fitdat=$(mktemp "/tmp/tmp_fitdat_$$.XXXXXX")
    local tmp1=$(mktemp "/tmp/tmp_dat_$$.XXXXXX")
    local tmpgp=$(mktemp "/tmp/tmp_sfit_$$.XXXXXX.gp")
    local tmpout=$(mktemp "/tmp/tmp_out_$$.XXXXXX.txt")
    local w
    local h
    local xm
    local ym
    local c
    local fitfun
    local fitvars
    local out
    local retval
    local ncolors=3
    local gpversion
    
    (test "$showhelp" || test $# -ne 1) &&
        echo "usage: AIsfit [-p|-c] <img>" >&2 &&
        return 1

    is_pgm $img && ncolors=1
    
    # create rgb data file
    w=$(identify $img | cut -d " " -f3 | cut -d "x" -f1)
    h=$(identify $img | cut -d " " -f3 | cut -d "x" -f2)
    AIval -c $img $w $h > $rgbdat

    xm=$(echo $w | awk '{print $1/2}')
    ym=$(echo $h | awk '{print $1/2}')
    fitfun="a + b1*(x-$xm) + b2*(y-$ym) \
        + c1*(x-$xm)*(x-$xm) + c2*(y-$ym)*(y-$ym) + c3*(x-$xm)*(y-$ym); xoff=0; yoff=0"
    fitvars="a, b1, b2, c1, c2, c3"
    test "$do_plane" &&
        fitfun="a + b1*(x-$xm) + b2*(y-$ym); c1=0; c2=0; c3=0; xoff=0; yoff=0" &&
        fitvars="a, b1, b2"
    test "$do_center" &&
        fitfun="a + b1*(x-$xm) + b2*(y-$ym) \
        + c1*(x-$xm+xoff)*(x-$xm+xoff) + c2*(y-$ym+yoff)*(y-$ym+yoff) + c3*(x-$xm+xoff)*(y-$ym+yoff)" &&
        fitvars="a, b1, b2, c1, c2, c3, xoff, yoff"
    
    # check gnuplot version
    gpversion=$(gnuplot -V | awk '{printf("%s", $2)}')
    case "$gpversion" in
        4*) ;;
        5*) ;;
        *)  echo "ERROR: unsupported gnuplot version $gpversion." >&2
            return 255
    esac
    
    for c in $(seq 1 $ncolors)
    do
        # extract data >0
        grep -v "^#" $rgbdat | awk -v cid=$((c+2)) '{if ($cid>0) {print $0}}' > $tmp1
        test ! -s $tmp1 &&
            echo "ERROR: empty data file when extracting column $((c+2)) from $rgbdat" >&2 &&
            return 255

        # coefficients
        echo "# gather statistics
        stats '$tmp1' using $((c+2)) noout
        a=STATS_mean
        nx=$w
        ny=$h
        # data fitting" > $tmpgp
        test -z "$AI_DEBUG" && echo "        set fit quiet" >> $tmpgp
        echo "\
        # until 171228: b1=0.1; b2=0.1; c1=0.1; c2=0.1; c3=0.1
        b1=100; b2=100; c1=100; c2=100; c3=100; xoff=1; yoff=1
        f(x,y) = $fitfun" >> $tmpgp
        case "$gpversion" in
            4*)
                echo "       " \
                "fit f(x,y) '$tmp1' using 1:2:$((c+2)):(1) via $fitvars" >> $tmpgp
                ;;
            5*) echo "       " \
                "fit f(x,y) '$tmp1' using 1:2:$((c+2)) via $fitvars" >> $tmpgp
                ;;
        esac
        echo "
        out=sprintf(\"%d %6.3f %8.3f %7.3f %7.3f %6.3f %6.3f %6.3f %5.1f %5.1f\", \
            FIT_NDF, FIT_STDFIT, a, b1, b2, c1, c2, c3, xoff, yoff)
        print out
        # create fitted data points
        set samples nx
        set isosamples ny
        set table '$fitdat'
        splot [0:nx-1] [0:ny-1] f(x,y)
        unset table
        #plot '$fitdat' with image
        #show variables all
        " >> $tmpgp
        gnuplot -p $tmpgp > $tmpout 2>&1
        test $? -ne 0 &&
            echo "ERROR: unable to fit data (check $tmpgp)." >&2 && return 255
        echo "$c $(grep -v "number of data points scaled up to" $tmpout)" >&2
        
        # create fitted surface
        #grep -av "^#" $img | head -3 | sed -e 's,P.,P2,' > $fitdat.$c.pgm
        grep -av "^#" $img | sed -e '4,$d' | sed -e 's,P.,P2,' > $fitdat.$c.pgm
        grep -v "^#" $fitdat | grep "[0-9]" | awk '{
            if(($3>=0) && ($3<=2^16-1)) {printf("%d\n", $3)} else {print 0}
            }' >> $fitdat.$c.pgm
    done
    if [ $ncolors -eq 3 ]
    then
        rgb3toppm $fitdat.1.pgm $fitdat.2.pgm $fitdat.3.pgm
        retval=$?
        rm $fitdat.1.pgm $fitdat.2.pgm $fitdat.3.pgm
    else
        pnmccdred -a 0 $fitdat.1.pgm -
        retval=$?
        rm $fitdat.1.pgm
    fi
    rm -f $fitdat $tmpout
    test -z "$AI_DEBUG" && rm -f $rgbdat $tmp1 $tmpgp
    test "$AI_DEBUG" && echo $rgbdat $tmp1 $tmpgp >&2
    return $retval
}


bgresmodel () {
    # model background using low-resolution residual images as
    # created by bggradient
    # use minimum value after normalization
    local showhelp
    local bgmult=10
    local bgres=1000
    local scale=1.0
    local bgval
    local verbose=1
    local keepnorm      # if set keep normalized residual images
    local cdir=bgcorr   # base name of bgcorr directories to search for res image
    local checkonly     # if set, show normalized res images but do not compute model
    for i in $(seq 1 7)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-v" && verbose=1 && shift 1
        test "$1" == "-m" && bgmult=$2 && shift 2
        test "$1" == "-s" && scale=$2 && shift 2
        test "$1" == "-b" && bgval=$2 && shift 2
        test "$1" == "-c" && checkonly=1 && shift 1
        test "$1" == "-k" && keepnorm=1 && shift 1
    done
    local target=${1:-""}   # target set
    local reflist=${2:-""}  # bg references <day>/<set>:<suffix> separated by ,
    local tdir=${AI_TMPDIR:-"/tmp"}
    local wdir=$(mktemp -d "$tdir/tmp_bgres_$$.XXXXXX")
    local ext
    local refentry
    local refdir
    local suffix
    local ncol
    local sname
    local x
    local i
    local add
    local mult
    local resimg
    local bgimg
    local imlist
    
    (test "$showhelp" || test $# -ne 2) &&
        echo "usage: bgresmodel [-v] [-c] [-m bgmult|$bgmult] [-s scale|$scale] [-b setbgval]" \
            "<set> <refset1,refset2,...>" >&2 &&
        return 1

    # get extension from first reference image
    ext=""
    refentry=${reflist%%,*}
    if [ "${refentry/:/}" != "$refentry" ]
    then
        sname=$(basename ${refentry%%:*})
        suffix=${refentry##*:}
    else
        sname=$(basename $refentry)
        suffix=""
    fi
    for refdir in $(dirname $refentry)/$cdir$suffix \
                  $A/$(dirname $refentry)/$cdir$suffix \
                  $A/results/$(dirname $refentry)/$cdir$suffix
    do
        test "$ext" && break
        test -e $refdir/$sname.bgm${bgmult}res.pgm && ext="pgm"
        test -e $refdir/$sname.bgm${bgmult}res.ppm && ext="ppm"
    done
    test -z "$ext" &&
        echo "ERROR: missing image $cdir$suffix/$sname.bgm${bgmult}res.p[pg]m" >&2 &&
        return 255

    # measure bgvalue on target
    if [ -z "$bgval" ]
    then
        bgval=($(AImstat -c $target.$ext | awk '{
            printf("%s", $5); if(NF>13) {printf(" %s %s", $9, $13)}}'))
        test "$verbose" && echo "# bgval=${bgval[@]}" >&2
    fi
    ncol=${#bgval[@]}
    test "$ext" == "ppm" && test $ncol -eq 1 && bgval=$bgval" "$bgval" "$bgval
        
    # normalize bgres images in each color
    for refentry in ${reflist//,/ }
    do
        if [ "${refentry/:/}" != "$refentry" ]
        then
            sname=$(basename ${refentry%%:*})
            suffix=${refentry##*:}
        else
            sname=$(basename $refentry)
            suffix=""
        fi
        resimg=""
        bgimg=""
        for refdir in $(dirname $refentry)/$cdir$suffix \
                      $A/$(dirname $refentry)/$cdir$suffix \
                      $A/results/$(dirname $refentry)/$cdir$suffix
        do
            test "$resimg" && break
            test -e    $refdir/$sname.bgm${bgmult}res.$ext &&
                resimg=$refdir/$sname.bgm${bgmult}res.$ext &&
                bgimg=$refdir/$sname.bgm${bgmult}.$ext
        done
        test -z "$resimg" &&
            echo "ERROR: missing image $cdir$suffix/$sname.bgm${bgmult}res.p[pg]m" >&2 &&
            return 255
        
        x=($(AIstat -c $bgimg | awk -v m=$bgmult '{
            printf("%s", $5/m); if(NF>13) {printf(" %s %s", $9/m, $13/m)}}'))
        test "$verbose" && echo "# $bgimg: x=${x[@]}" >&2
        for i in $(seq 0 $((ncol-1)))
        do
            mult[$i]=$(echo ${x[i]} ${bgval[i]} | \
                awk -v s=$scale '{printf("%.4f", $2/$1*s)}')
            add[$i]=$(echo ${x[i]} ${bgval[i]} | \
                awk -v b=$bgres -v s=$scale '{printf("%.1f", b-$2/$1*s*b)}')
        done
        test "$verbose" && echo "mult=${mult[@]} add=${add[@]}" >&2
        x=$(basename $(dirname $refdir) | tr '/' '_')
        test "$x" == "." && x=""
        test "$x" && x=${x}"_"
        pnmccdred -m $(echo ${mult[@]} | tr ' ' ',') $resimg - | \
        pnmccdred -a $(echo ${add[@]} | tr ' ' ',') - $wdir/$x$sname.norm.$ext
        if [ "$checkonly" ]
        then
            if [ "$verbose" ]
            then
                rgbscale -v $wdir/$x$sname.norm.$ext > $wdir/x.$sname.res.$ext
            else
                rgbscale $wdir/$x$sname.norm.$ext > $wdir/x.$sname.res.$ext
            fi
            imlist="$imlist $wdir/x.$sname.res.$ext"
        fi
    done
    
    if [ "$checkonly" ]
    then
        montage -background '#202020' -fill '#D0D0D0' -label '%t' \
            $imlist -geometry +4+2 x.bgnorm.$ext
        display x.bgnorm.$ext &
    else
        # get min
        #convert $wdir/*.norm.$ext -evaluate-sequence min ${ext}:-
        convert $wdir/*.norm.$ext -evaluate-sequence min $wdir/min.$ext

        # shift average level to bgres
        x=$(AImstat $wdir/min.$ext | awk -v m=$bgres '{
            printf("%.0f", m-$5); if(NF>13) {printf(",%.0f,%.0f", m-$9, m-$13)}}')
        pnmccdred -a $x $wdir/min.$ext -    
    fi
    
    if [ "$AI_DEBUG" ] || [ "$keepnorm" ]
    then
        echo $wdir >&2
    else
        rm -rf $wdir
    fi
}


skygradient () {
    # remove gradient from sky flat
    local showhelp
    local flat=${1/.pgm/}
    local ref=${2/.pgm/}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local fdiv=$(mktemp $tdir/tmp_fdiv_XXXXXX.pgm)
    local tmpim=$(mktemp $tdir/tmp_im1_XXXXXX.pgm)
    local outflat
    
    (test "$showhelp" || test $# -ne 2) &&
        echo "usage: skygradient <flat> <ref>" >&2 &&
        return 1
    outflat=${flat/sk/sb}.pgm
    test -f $outflat &&
        echo "ERROR: overwriting $outflat is not allowed." >&2 && return 255
    test -d bgcorr || mkdir bgcorr

    AIbnorm $flat.pgm > $AI_TMPDIR/$flat.norm.pgm
    AIbnorm $ref.pgm > $AI_TMPDIR/$ref.norm.pgm
    pnmccdred2 -m 10000 -s $AI_TMPDIR/$ref.norm.pgm $AI_TMPDIR/$flat.norm.pgm $fdiv
    (cd $tdir; AIbgmap -p -d -m -x 75 -q $fdiv 64 1 "" 1)
    size=$(imsize $flat.pgm)
    mv ${fdiv/.pgm/.bgm1n.pgm} bgcorr/$flat.bgm1n.pgm
    gm convert bgcorr/$flat.bgm1n.pgm -resize ${size/ /x}\! $tmpim
    pnmccdred2 -m 10000 -s $tmpim $flat.pgm ${flat/sk/sb}.pgm
    rm -f ${fdiv/.pgm/}* $tmpim
    echo "# $outflat created" >&2
    return 0
}


AIval () {
    # list intensities for given pixels
    # old syntax: AIval [img] [refpix] [size] used by AIoverscan, AInoise
    local showcoords    # if set show image coordinates
    local showhelp
    local do_allpixels  # if set then all image pixel are printed
    local minmax        # if 0/1 then print pixel matching 0/maxval
    local low           # if set then print pixel with value >= low
    local high          # if set then print pixel with value <= high
    for i in $(seq 1 7)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-c" && showcoords=1 && shift 1
        test "$1" == "-a" && do_allpixels=1 && shift 1
        test "$1" == "-0" && minmax=0 && shift 1
        test "$1" == "-1" && minmax=1 && shift 1
        test "$1" == "-low" && low=$2 && shift 2
        test "$1" == "-high" && high=$2 && shift 2
    done
    
    local img=${1:-""}
    local cw=${2:-"1"}
    local ch=${3:-"1"}
    local cx=${4:-""}   # empty = center box
    local cy=${5:-""}   # empty = center box
    local opts
    local fname
    local line
    local w
    local h
    local cmd
    local retval
    local pyprog
    local tmp1=$(mktemp "/tmp/tmp_img_$$.XXXXXX")

    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: AIval [-a] [-c] [-0|-1] [-low <low>] [-high <high>] <img> [w] [h] [x_topleft] [y_topleft]" >&2 &&
        return 1

    # check for required python scripts
    pyprog=$(which airfun.py)
    test $? -ne 0 &&
        echo "ERROR: missing python module airfun.py." >&2 && return 255

    test "$showcoords" && opts="-c"
    test "$minmax" && opts="$opts -$minmax"
    test "$high" && test -z "$low" && low=0
    

    # handle image via stdin
    if [ "$img" != "-" ]
    then
        fname=$(get_imfilename $img)
        test -z "$fname" && return 255
    else
        cat "$img" > $tmp1
        fname="$tmp1"
    fi

    # check for supported image formats
    ! (is_pnm "$fname" || is_png "$fname" || is_fits "$fname") &&
        echo "ERROR: AIval: $fname has unsupported image format." >&2 &&
        return 255
    
    if [ "$do_allpixels" ]
    then
        if is_raw "$fname"
        then
            test "$AI_DEBUG" &&
                echo "AIraw2gray $fname | python3 $pyprog listpixels" $opts "-" 0 0 0 0 $low $high >&2
            AIraw2gray "$fname" | python3 $pyprog listpixels $opts - 0 0 0 0 $low $high
        else
            test "$AI_DEBUG" &&
                echo "python3 $pyprog listpixels" $opts $fname 0 0 0 0 $low $high >&2
            python3 $pyprog listpixels $opts $fname 0 0 0 0 $low $high
        fi
        retval=$?
    else
        # get image width and height
        set - $(imsize "$fname")
        w=$1
        h=$2
    
        # determine crop area
        test -z "$cx" && cx=$(((w-cw)/2))
        test -z "$cy" && cy=$(((h-ch)/2))
    
        # truncates cx and cy to integer
        cx=$(echo $cx | awk '{print int($1)}')
        cy=$(echo $cy | awk '{print int($1)}')
    
        # crop and show values
        if is_pnm "$fname" || is_png "$fname"
        then
            test "$AI_DEBUG" &&
                echo "python3 $pyprog listpixels" $opts $fname $cx $cy $cw $ch $low $high >&2
            python3 $pyprog listpixels $opts $fname $cx $cy $cw $ch $low $high
        else
            cmd="imcrop -1 \"$fname\" \"$cw\" \"$ch\" \"$cx\" \"$cy\""
            test "$AI_DEBUG" &&
                echo "eval $cmd | python3 $pyprog listpixels" $opts - $cx $cy $cw $ch $low $high >&2
            eval $cmd | python3 $pyprog listpixels $opts - $cx $cy $cw $ch $low $high
        fi
        retval=$?
    fi

    # cleanup
    rm -f $tmp1
    return $retval
}


AIvalold () {
    # list intensities for given pixels
    # old syntax: AIval [img] [refpix] [size] used by AIoverscan, AInoise
    local showcoords    # if set show image coordinates
    local showhelp
    local do_allpixels  # if set then all image pixel are printed
    local matchval=-1   # if >=0 then print pixel matching matchval
    local minval        # if set then print pixel with value >= minval
    local maxval        # if set then print pixel with value <= maxval
    for i in $(seq 1 7)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-c" && showcoords=1 && shift 1
        test "$1" == "-a" && do_allpixels=1 && shift 1
        test "$1" == "-0" && matchval=0 && shift 1
        test "$1" == "-1" && matchval=1 && shift 1
        test "$1" == "-min" && minval=$2 && shift 2
        test "$1" == "-max" && maxval=$2 && shift 2
    done
    
    local img=${1:-""}
    local cw=${2:-"1"}
    local ch=${3:-"1"}
    local cx=${4:-""}   # empty = center box
    local cy=${5:-""}   # empty = center box
    local sc
    local fname
    local line
    local w
    local h
    local cmd
    local tmp1=$(mktemp "/tmp/tmp_img_$$.XXXXXX")

    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: AIval [-a] [-c] [-0|-1|-t <minval>] <img> [w] [h] [x_topleft] [y_topleft]" >&2 &&
        return 1

    sc=0
    test "$showcoords" && sc=1
    #test $matchval -ge 0 && sc=1
    #test "$showcoords" || matchval=-1

    # handle image via stdin
    if [ "$img" != "-" ]
    then
        fname=$(get_imfilename $img)
        test -z "$fname" && return 255
    else
        cat "$img" > $tmp1
        fname="$tmp1"
    fi

    # get image width and height
    set - $(imsize "$fname")
    w=$1
    h=$2
    
    if [ "$do_allpixels" ]
    then
        cw=$w
        ch=$h
        cx=0
        cy=0
    else
        # determine crop area
        test -z "$cx" && cx=$(((w-cw)/2))
        test -z "$cy" && cy=$(((h-ch)/2))
    
        # truncates cx and cy to integer
        cx=$(echo $cx | awk '{print int($1)}')
        cy=$(echo $cy | awk '{print int($1)}')
    fi
    
    # crop and show values
    if is_pnm "$fname"
    then
        cmd="gm convert \"$fname\" -crop ${cw}x${ch}+${cx}+${cy} -"
    else
        cmd="imcrop -1 \"$fname\" \"$cw\" \"$ch\" \"$cx\" \"$cy\""
    fi
    test "$AI_DEBUG" && echo "$cmd" >&2

    # set minval, maxval if required
    test -z "$minval" && minval=0
    test -z "$maxval" && maxval=65536
    
    test "$AI_DEBUG" &&
        echo "$cmd | pnmnoraw - | awk -v sc=$sc -v cw=$cw -v ch=$ch -v cx=$cx -v cy=$cy" \
            "-v m=$matchval -v min=$minval -v max=$maxval ..." >&2    
    eval "$cmd" | pnmnoraw - | \
    awk -v sc=$sc -v cw=$cw -v ch=$ch -v cx=$cx -v cy=$cy \
        -v m=$matchval -v min=$minval -v max=$maxval 'BEGIN{
        row=1; col=1; pnmmaxval=1
    }{
        if (NR==1) {
            if ($0=="P1") {type=1; skip=2
                    # note: 0/1 represent white/black
                    if (m>=0) m=1-m
                }
            if ($0=="P2") {type=2; skip=3}
            if ($0=="P3") {type=3; skip=3}
        }
        if(type>1 && NR==3) pnmmaxval=$1 
        if(NR>skip) {
            if (type==3) np=split($0, p, "  ")
            if (type==2) np=split($0, p, " ")
            if (type==1) {
                if ((m==0) && ($0!~/0/)) {
                    col=col+length($0); np=0
                } else {
                    if ((m==1) && ($0!~/1/)) {
                        col=col+length($0); np=0
                    } else {
                        np=split($0, p, "")
                    }
                }
            }
            for(i=1;i<=np;i++) {
                if (sc==0) {
                    if ((m<0  && 1*p[i]>=min && 1*p[i]<=max) ||
                        (m>=0 && 1*p[i]==m*pnmmaxval))
                        printf("%s\n", p[i])
                } else {
                    if ((m<0  && 1*p[i]>=min && 1*p[i]<=max) ||
                        (m>=0 && 1*p[i]==m*pnmmaxval))
                        printf("%d %d %s\n", cx+col-1, cy+row-1, p[i])
                    col++
                }
            }
            if (col>cw) {row++; col=1}
        }
    }'
    
    # cleanup
    rm -f $tmp1
}


AIpeak () {
    # TODO: improve performance by running parallel processes
    local showhelp
    local channel=2     # prefer green color channel (PPM only)
    local merrlim=0.01  # max. photometric error of objects
    local nmax=100      # max. number of objects
    local bgval         # background ADU (green channel)
    local i
    for i in $(seq 1 5)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        (test "$1" == "-1" || test "$1" == "-2" || test "$1" == "-3") &&
            channel=${1#-} && shift 1
        test "$1" == "-m" && merrlim=$2 && shift 2
        test "$1" == "-n" && nmax=$2 && shift 2
        test "$1" == "-b" && bgval=$2 && shift 2
    done

    local img=$1        # image with objects to measure
    local sdat=${2:-""} # sextractor datafile containing object locations
    local dmax=3        # box size = 1+2*dmax
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmp1=$(mktemp "$tdir/tmp_dat1.XXXXXX.dat")
    local tmp2=$(mktemp "$tdir/tmp_dat2.XXXXXX.dat")
    local tmpimg=$(mktemp "$tdir/tmp_img.XXXXXX.pgm")
    local tmpgp=$(mktemp "$tdir/tmp_gp.XXXXXX.gp")
    local grayimg
    local rmax
    local n
    local bsize
    local x
    local y
    local a
    local e
    local f
    local m
    local z
    local xi
    local yi
    local max
    
    (test "$showhelp" || test $# -eq 0 || test $# -gt 2) &&
        echo -e "usage: AIpeak [-1|2|3] [-b bgval] [-m magerrlim|$merrlim]" \
            "[-n nmax|$nmax] <img> [sdat]" >&2 &&
        return 1
    
    test ! -f "$img" &&
        echo "ERROR: file $img does not exist." >&2 && return 255
    test -z "$sdat" && sdat=${img%.*}.src.dat
    test ! -e $sdat &&
        echo "ERROR: file $sdat does not exist." >&2 && return 255

    # extract single color channel from image
    if is_ppm $img
    then
        case $channel in
            1)  gm convert $img -channel red   $tmpimg && grayimg=$tmpimg;;
            2)  gm convert $img -channel green $tmpimg && grayimg=$tmpimg;;
            3)  gm convert $img -channel blue  $tmpimg && grayimg=$tmpimg;;
        esac
    fi
    is_pgm $img && channel=1 && grayimg=$img
    test -z "$grayimg" &&
        echo "ERROR: unsupported image type." >&2 && return 255
    
    # guess background if not provided on command line
    if [ -z "$bgval" ]
    then
        bgval=$(AIbg $grayimg | awk '{printf("%.0f", $1)}')
        echo "# bgval=$bgval" >&2
    fi
    
    # determine size of center circle with nmax objects
    rmax=$(imsize $grayimg | tr ' ' '\n' | sort -n | lines 1 | awk '{printf("%d", $1/3)}')
    sexselect -x -$channel $sdat "" $merrlim $rmax "" "" 99 > $tmp1
    n=$(grep -v "^#" $tmp1 | wc -l)
    echo "channel=$channel, magerrlim=$merrlim, r=$rmax, n=$n" >&2
    if [ $n -gt $((nmax*15/10)) ]
    then
        rmax=$(echo $rmax $n | awk -v nmax=$nmax '{printf("%d", $1*sqrt(nmax/$2))}')
        echo "reducing rmax to $rmax" >&2
        sexselect -x -$channel $sdat "" $merrlim $rmax "" "" 99 > $tmp1
    fi
    
    #echo "# id     peak  a    fwhm mag"
    bsize=$((1+2*dmax))
    grep -v "^#" $tmp1 | \
    while read id x y a e f m z
    do
        xi=$(echo $x $bsize | awk '{printf("%.0f", $1-0.5-($2-1)/2)}')
        yi=$(echo $y $bsize | awk '{printf("%.0f", $1-0.5-($2-1)/2)}')
        test "$AI_DEBUG" && echo "$id $x $y $xi $yi" >&2
        #max=$(AIval $grayimg $bsize $bsize $xi $yi | sort -n | tail -1)
        max=$(gm convert $grayimg -crop ${bsize}x${bsize}+${xi}+${yi} - | \
            pnmnoraw | sed '1,3d' | tr ' ' '\n' | sort -n | tail -1)
        printf "%-8s %5d %4.2f %4.2f %5.2f\n" $id $((max-bgval)) $a $f $m
    done > $tmp2
    mc=$(median $tmp2 5)
    ic=$(median $tmp2 2)
    echo "# median: $mc $ic" >&2
    echo "
        set terminal x11 font 'sans,12' size 630,460
        set title 'Peak Intensity of Objects in $img' font 'sans,14'
        set style line 11 lc rgb '#505050' lt 1
                set border lw 1.2
                set style line 1 lc rgb '#e00000' # --- red
                set style line 2 lc rgb '#00e000' # --- green
        set offsets graph 0.02, graph 0.02, graph 0.03, graph 0.03
        set grid
        set log y
        set yrange [100:65000]
        set xlabel 'mag'
        set ylabel 'peak / ADU'
        mc=$mc
        ic=$ic
        f(x)=ic*exp(0.4*(mc-x)*log(10))
        plot  '$tmp2' u 5:2 title 'objects' ls 1, \
        f(x) title 'linear model' ls 2
    " > $tmpgp
    cat $tmpgp | gnuplot -p
    echo $tmpgp
    rm -f $tmpimg $tmp1 #$tmp2 $tmpgp
}


AIimlist () {
    # get image list for sets of a certain type
    #   exclude images according to $AI_EXCLUDE
    #   checks if input image files exist in the following directories:
    #   . $AI_TMPDIR $AI_RAWDIR
    # splitted image sets: lines using the same set name and exposure time
    #   but type==a (nref,dark,bias are ignored but should be set to "-")
    #   TODO: match nref as well, use dark and flat as given in each line
    #         modify AIccd and AIfindbad accordingly
    #AIcheck_ok -q || return 255
    local showhelp
    local show_file_only
    local show_num_only
    local no_image_check
    local do_check_reg  # if set check for corresponding entry in reg.dat
    local do_check_size # if set check if image file is not empty
    local quiet
    local i
    for i in $(seq 1 7)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-f" && show_file_only=1 && shift 1
        test "$1" == "-n" && show_num_only=1 && shift 1
        test "$1" == "-r" && do_check_reg=1 && shift 1
        test "$1" == "-s" && do_check_size=1 && shift 1
        test "$1" == "-x" && no_image_check=1 && shift 1
        test "$1" == "-q" && quiet=1 && shift 1
    done

    local setname=${1:-""}
    local insuffix=${2:-""}     # filename part after number
    local inext=${3:-""}        # file extension, if empty search ppm/pgm/pnm
    local intype=${4:-""}
    local sdat=${AI_SETS:-"set.dat"}
    local ex=${AI_EXCLUDE:-""}  # space separated list of image numbers
    local tmp1=$(mktemp "/tmp/tmp_flist_$$.XXXXXX")
    local inpath=""
    local rawext="cr2 pef nef raf dng fit fits fitzip"
    local ltime
    local sname
    local target
    local type
    local texp
    local n1
    local n2
    local nref
    local dark
    local flat
    local ext
    local nlist
    local cmd
    local x
    local num
    local ext
    local extlist
    local f
    local use_rdat
    local df
    

    test "$showhelp" &&
        echo "usage: AIimlist [-q] [-f|-n] [-r|-x] [set] [insuffix] [inext|$inext] [intype|$intype]" >&2 &&
        return 1

    # allow uppercase extension in raw image file names
    rawext=$(echo $(for x in $rawext; do echo ${x,,} ${x^^}; done))

    while read ltime sname target type texp n1 n2 nref dark flat x
    do
        #(echo "$ltime" | grep -q "^#") && continue
        test "${ltime:0:1}" == "#" && continue
        test "$setname" && test "$sname" != "$setname" && continue
        test -z "$setname" && test "$intype" && test "$type" != "$intype" && continue
        test ${#type} -ne 1 && continue
        is_integer $n1 || continue
        is_integer $n2 || continue
        test "$type" == "a" && continue
        test $n2 -lt $n1 && n2=$((n2+10000))    # e.g. image number wrap on DSLRs
        nlist=$(seq $n1 $n2 | awk '{printf("%04d\n", $1)}')
        
        # try to find associated images of the same set (splitted sets)
        cmd=$(grep -v "^#" $sdat | awk -v s=$sname -v e=$texp -v n1=$n1 -v n2=$n2 '{
            if ($2==s && $4=="a" && $6!=n1 && $7!=n2) {
                printf("seq %s %s;", $6, $7)}}')
        test "$cmd" && nlist="$nlist $(eval "$cmd" | awk '{printf("%04d\n", $1)}')"
        test "$AI_DEBUG" && echo "nlist="$nlist >&2
        test -z "$setname" && test -z "$quiet" && echo "set $sname" >&2


        use_rdat=""
        inpath=""
        for num in $nlist
        do
            test $num -gt 9999 && num=$(echo $num | awk '{printf("%04d", $1-10000)}')
            echo $ex | grep -q -w $num - &&
                (test ! "$quiet" && echo "excluding image $num." >&2 || true) && continue
            test "$no_image_check"  && echo "$num" && continue
            test "$do_check_reg" && test -s reg.dat &&
                grep -q -w "^$num" reg.dat &&
                echo "$num" && continue
            
            # find inpath and set inext
            if [ -z "$inpath" ]
            then
                extlist=$inext
                test "$inext" == "raw" && extlist=$rawext
                test -z "$inext" && extlist="ppm pgm pnm"
                for ext in $extlist
                do
                    test -z "$inpath" && test -f "./$num$insuffix.$ext" &&
                        inpath="."
                    test -z "$inpath" && test -f "$AI_TMPDIR/$num$insuffix.$ext" &&
                        inpath="$AI_TMPDIR"
                    test -z "$inpath" && test -f "$AI_RAWDIR/$num$insuffix.$ext" &&
                        inpath="$AI_RAWDIR"
                    test "$inpath" && break
                done
                if [ -z "$inpath" ] && [ "$inext" == "raw" ]
                then
                    # try to read file name from exif.dat/rawfiles.dat
                    f=$(get_rawfile $num 2>/dev/null | lines 1)
                    test "$f" &&
                        ext=$(echo $f | sed -e 's,.*\.,,') &&
                        inpath=$(dirname $f) &&
                        use_rdat=1 &&
                        test "$AI_DEBUG" && echo "# ext=$ext" >&2
                fi
                if [ "$AI_DEBUG" ] && [ "$inpath" ]
                then
                    if [ "$use_rdat" ]
                    then
                        echo "found images in directory $inpath (using get_rawfile)" >&2
                    else
                        echo "found images in directory $inpath (ext=$ext)" >&2
                    fi
                fi
            fi
            
            test -z "$inpath" &&
                (test ! "$quiet" &&
                    echo "WARNING: no image dir found for $num$insuffix.$inext." >&2 || true) &&
                continue
            if [ "$use_rdat" ]
            then
                f=$(get_rawfile $num 2>/dev/null | lines 1)
            else
                f="$inpath/$num$insuffix.$ext"
            fi
            (test -z "$f" || test ! -f "$f") &&
                (test ! "$quiet" &&
                    echo "WARNING: $f not found." >&2 || true) &&
                continue
            
            test "$do_check_size" && test ! -s "$f" &&
                (test ! "$quiet" &&
                    echo "WARNING: $f is empty." >&2 || true) &&
                continue

            # output
            test "$show_file_only" && echo "$f" && continue
            test "$show_num_only"  && echo "$num" && continue
            # get corresponding dark and flat
            df=$(grep -v "^#" $sdat | awk -v s=$sname -v n=$num '{
                if($2==s && ($4=="o" || $4=="a") && $6<=n && $7>=n) print $9" "$10
                }')
            echo "$sname $num $f $nref $df"
        done
        if [ -z "$no_image_check" ] && [ -z "$do_check_reg" ] && [ -z "$inpath" ]
        then
            if [ "$setname" ]
            then
                test -z "$quiet" && echo "ERROR: no images found for set $sname." >&2
                return 255
            fi
            test ! "$quiet" && echo "WARNING: no images found for set $sname." >&2
        fi
    done < $sdat
    rm $tmp1
    return 0
}


AIexamine () {
    # interactively examine images using ds9 and analysis scripts
    # note:
    #   the name of the default ds9 instance is AIRTOOLS
    #   the name of newly started instance is written to env variable DS9NAME
    #   the analysis 
    local showhelp
    local wcshead
    local afile="airds9.ana"    # default ds9 analysis file
    local small=0               # if > 0 reduce window size
    local ds9opts               # xpaset commands to be added at the end
    local ds9name="AIRTOOLS"
    local do_linear
    local do_lock_colorbar
    local do_replace_image
    local verbose
    local i
    for i in 1 2 3 4 5 6 7 8 9 10
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-w" && wcshead=$2 && shift 2
        test "$1" == "-a" && afile=$2 && shift 2
        test "$1" == "-n" && ds9name=$2 && shift 2
        test "$1" == "-v" && verbose=1 && shift 1
        test "$1" == "-s" && small=$((small+1)) && shift 1
        test "$1" == "-p" && ds9opts="$2" && shift 2
        test "$1" == "-l" && do_linear=1 && shift 1
        test "$1" == "-c" && do_lock_colorbar=1 && shift 1
        test "$1" == "-r" && do_replace_image=1 && shift 1
    done
    local tdir=${AI_TMPDIR:-"/tmp"}
    #test ! -d "$tdir" && echo "WARNING: $AI_TMPDIR does not exist." >&2 && tdir="/tmp"
    local sdat=${AI_SETS:-"set.dat"}
    local tmpconv=$(mktemp "$tdir/tmp_conv_XXXXXX.dat")
    local pardir=$(mktemp -d "$tdir/tmp_par_XXXXXX")
    local add
    local ilist=""
    local tlist=""
    local slist=""
    local nimg=0
    local cx
    local cy
    local opts
    local fopts
    local xcmd
    local fxcmd
    local infile
    local zoom
    local pan
    local geom
    local has_wcs=1
    local firstimage
    local lastimage
    local par
    local tel
    local str
    local pan
    local zoom
    local ext
    local keys
    local sw
    local sh
    local w
    local h
    local sname
    local newframe
    local hdr
    local tmpsh=$(mktemp "/tmp/tmp_script_XXXXXX.sh")
    chmod u+x $tmpsh
    

    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: AIexamine [-v] [-l] [-c] [-n ds9name] [-w wcshead] [-a ds9anafile] <image1|regfile1> [image2|regfile2 ...]" >&2 &&
        return 1
    ! type -p ds9 > /dev/null 2>&1 &&
        echo "ERROR: program ds9 not in search path." >&2 && return 255
    test "$wcshead" && test ! -f "$wcshead" &&
        echo "ERROR: file $wcshead not found." >&2 && return 255
    
    test "$AI_DEBUG" && verbose=$((verbose+1))
    test ! -d $tdir &&
        echo "ERROR: missing temp directory $tdir" >&2 && return 255
    
    # check for an existing instance of ds9
    case "$(xpaaccess -n -t "2,2" $ds9name)" in
        0)  add="";;
        1)  add=1;;
        *)  echo "WARNING: multiple ds9 instances using name $name." >&2
            add=1;;
    esac


    # ds9 startup options
    sw=$(xrandr --current | grep "^Screen 0" | tr ',' '\n' | grep current | awk '{print $2}')
    sh=$(xrandr --current | grep "^Screen 0" | tr ',' '\n' | grep current | awk '{print $4}')
    h=$((sh-80))
    #test $h -gt 1200 && h=1200
    case "$small" in
        0)  w=$((h-130));;
        1)  h=$((h*75/100)); w=$((h-90));;
        *)  h=$((h*58/100)); w=$((h-50));;
    esac
    test $w -lt 480 && w=480
    geom="${w}x${h}"
    test "$AI_DEBUG" && echo "screen=${sw}x${sh}  geom=$geom" >&2
    opts="-title $ds9name -geometry $geom -regions system physical -view physical no"
    test $small -gt 1 && opts="$opts -view colorbar no -view panner no -view object no \
        -view magnifier no -view frame no"
    # TL: line disabled in v2.8.1 to suit ds9 v7.5
    #opts="$opts -frame delete"

    # check for analysis file
    if [ "$afile" ]
    then
        str=$(type -p $afile)
        test -z "$str" && test -e $afile &&
            str=$afile
        test -z "$str" && test -e /usr/share/airtools/$afile &&
            str=/usr/share/airtools/$afile
        test -z "$str" && test -e /usr/local/share/airtools/$afile &&
            str=/usr/local/share/airtools/$afile
        test -z "$str" &&
            echo "ERROR: ds9 analysis file $afile not found." >&2 &&
            return 255
        afile=$str
        opts="$opts -analysis load $afile"
    fi
    test "$AI_DEBUG" && echo "afile=$afile" >&2

    # set ds9 options for intensity scaling
    if [ "$do_linear" ]
    then
        fopts="-scale linear"
    else
        fopts="-scale log"
    fi
    fopts="$fopts -scale mode zmax"  # -cmap value 2.5 0.15

    # set xpa commands to be used for every image
    if [ "$add" ]
    then
        zoom=$(xpaget $ds9name zoom)
        pan=$(xpaget $ds9name pan)
        fxcmd="xpaset -p $ds9name zoom to $zoom; xpaset -p $ds9name pan to $pan"
    fi
    
    # determine if images are loaded into new frame or current frame
    newframe="new"
    test "$do_replace_image" && newframe=""
    
    # cycle over input files and create ds9 input file parameter list
    xcmd=""
    for infile in "$@"
    do
        test ! -f "$infile" &&
            echo "ERROR: input file $infile does not exist." >&2 && return 255
        # check region file
        is_reg "$infile" &&
            opts="$opts -region $infile" &&
            xcmd="$xcmd; xpaset -p $ds9name region $infile" &&
            continue
        # check image file type
        ftype=""
        is_fitzip "$infile" && ftype="FITZIP"
        test -z "$ftype" && is_fitscube "$infile" && ftype="FITSCUBE"
        test -z "$ftype" && is_fits "$infile" && ftype="FITS"
        test -z "$ftype" && is_raw "$infile" && ftype="RAW"
        test -z "$ftype" && ftype=$(gm identify "$infile" | cut -d " " -f2)
        test -z "$ftype" &&
            echo "ERROR: $infile is neither region file nor image." >&2 && return 255

        test "$AI_DEBUG" && echo "$ftype: $infile" >&2
        b=$(basename "${infile%.*}" | tr ' ' '_')
        case "$ftype" in
            FITS)   tfits=$tdir/tmp_${RANDOM}_$b.fits
                    cp "$infile" $tfits
                    tlist="$tlist $tfits"
                    opts="$opts -fits $tfits"
                    xcmd="$xcmd; xpaset -p $ds9name fits $newframe $tfits"
                    #opts="$opts -fits \"$infile\""
                    #xcmd="$xcmd; xpaset -p $ds9name fits $newframe \"$infile\""
                    ! is_wcs "$infile" && has_wcs=""
                    test -z "$firstimage" && firstimage="$infile"
                    lastimage="$infile"
                    nimg=$((nimg + 1));;
            FITZIP) tfits=$tdir/tmp_${RANDOM}_$b.fits
                    unzip -p "$infile" > $tfits
                    tlist="$tlist $tfits"
                    opts="$opts -fits $tfits"
                    xcmd="$xcmd; xpaset -p $ds9name fits $newframe $tfits"
                    ! is_wcs $tfits && has_wcs=""
                    test -z "$firstimage" && firstimage="$infile"
                    lastimage="$infile"
                    nimg=$((nimg + 1));;
            FITSCUBE) tfits=$tdir/tmp_${RANDOM}_$b.fits
                    imslice "$infile" 2 > $tfits
                    tlist="$tlist $tfits"
                    opts="$opts -fits $tfits"
                    xcmd="$xcmd; xpaset -p $ds9name fits $newframe $tfits"
                    ! is_wcs $tfits && has_wcs=""
                    test -z "$firstimage" && firstimage="$infile"
                    lastimage="$infile"
                    nimg=$((nimg + 1));;
            PBM|PGM|PPM|PNG|JPEG|RAW)
                    hdr=${infile%.*}.head
                    test -f $hdr || hdr=""
                    test -z "$wcshead" && has_wcs=""
                    tfits=$tdir/$b.tmp_${RANDOM}.fits
                    tlist="$tlist $tfits"
                    opts="$opts -fits $tfits"
                    xcmd="$xcmd; xpaset -p $ds9name fits $newframe $tfits"
                    test -z "$firstimage" && firstimage=$infile
                    lastimage=$infile
                    echo "$ftype $infile $tfits $hdr" >> $tmpconv
                    nimg=$((nimg + 1));;
            *)      echo "WARNING: ignoring $infile, unsupported filetype $ftype." >&2
                    continue;;
        esac
        xcmd="$xcmd; $fxcmd"
    done
    xcmd=$(echo $xcmd | sed -e 's,^;,,')
    test "$AI_DEBUG" && echo "# xcmd=$xcmd" >&2

    
    cat <<EOF > $tmpsh
#!/bin/bash
. airfun.sh > /dev/null
wcshead="$wcshead"
tdir=$tdir

_imconv_parallel \$@
EOF

    _imconv_parallel () {
        local ftype=$1
        local infile=$2
        local tfits=$3
        local hdr=$4
        local tmp1=$(mktemp "$tdir/tmp_wcs_XXXXXX.head")
        
        #echo "# $1 $2 $3 $4" >&2
        case $ftype in
            PPM|PGM)    ppm2gray -q -f $infile $hdr > $tfits;;
            RAW)        AIraw2rgb -q 0 $infile | ppm2gray -q -f - $hdr > $tfits;;
            PNG|JPEG)	gm convert $infile pgm:- | ppm2gray -q -f - $hdr > $tfits;;
            *)	        ppm2gray -q -f "$infile" $hdr > $tfits;;
        esac
        test "$hdr" && delwcs $tfits
        sethead $tfits AI_IMAGE="$infile"
        if [ "$wcshead" ]
        then
            cat "$wcshead" | grep -Ev "^SIMPLE|^BITPIX|^NAXIS" > $tmp1
            sethead $tfits "@${tmp1}"
            set - $(imsize "$infile")
            cx=$(echo $1 | awk '{print $1/2}')
            cy=$(echo $2 | awk '{print $1/2}')
            sethead $tfits CRPIX1=$cx CRPIX2=$cy
            #! is_wcs $tmp1 && has_wcs=""
        fi
        rm -f $tmp1
    }

    export -f _imconv_parallel
    popts=""; test "$AI_MAXPROCS" && popts="-P $AI_MAXPROCS"
    cat $tmpconv | parallel $popts -k $tmpsh
    unset -f _imconv_parallel
    # TODO: error handling

    # more ds9 command line options
    test $nimg -gt 1 && opts="$opts -single -frame first"
    opts="$opts -mode region $fopts -match scale -match colorbar"
    test "$do_lock_colorbar" && opts="$opts -lock scale yes -lock colorbar yes"
    test "$has_wcs" &&
        opts="$opts -lock frame wcs"
    test ! "$has_wcs" &&
        opts="$opts -lock frame image"


    #### creating ds9 parameter files used by analysis tasks
    test -d $pardir || mkdir $pardir

    # names of all image sets
    test -f $sdat && slist=$(grep -v "^#" $sdat | awk '{
            x=$5""$6""$7; gsub(/[0-9]/,"",x); if($4=="o" && x==""){print $2}}' | \
        tr '\n' '|' | sed -e 's/.$//')
    # get setname from $firstimage or use first entry in $slist
    if [ "$firstimage" ]
    then
        sname=$(basename "$firstimage")
        sname=${sname%%.*}
        echo $slist | grep -q -w "$sname"
        test $? -ne 0 && sname=""
    fi
    test -z "$sname" && sname=$(echo $slist | awk -F "|" '{printf("%s", $1)}')
    
    if [ "$afile" ] # && [ ! "$(xpaget xpans 2>/dev/null)" ]
    then
        # ref.: https://heasarc.gsfc.nasa.gov/lheasoft/headas/pil/node12.html
        # default parameter file used by tasks test, regstat, imflip
        cat <<EOF > $pardir/airtools.par
#
# default airtools parameter file
#
image,s,l,,,,"Image file name (default: current image)"
EOF
        #cp -p $pardir/airtools.par $pardir/regstat.par
        #cp -p $pardir/airtools.par $pardir/imflip.par

        cat <<EOF > $pardir/regphot.par
#
# regphot parameter file
#
image,s,l,,,,"Image to be measured (default: current)"
bgrgb,s,l,2000,,,"Background rgb (comma separated)"
EOF
#photcat,s,l,,,,"Photometry data file (default: comet/\$sname.newphot.dat)"
#ddiff,r,l,,,,"Approx. mag difference in case of double star"
    fi

    # display images
    if [ "$add" ]
    then
        test "$verbose" && echo $xcmd >&2
        echo "$xcmd" | bash
    else
        # UPARM is used by ds9 when searching for parameter files
        # user modified variables are NOT written back to parameter files
        export DS9NAME=$ds9name
        export UPARM=$pardir
        test "$verbose" && echo ds9 $opts $ds9opts >&2
        ds9 $opts $ds9opts
    fi

    test "$tlist" && test -z "$AI_DEBUG" && rm $tlist
    rm -f $tmpconv $tmpsh
    rm -f $pardir/*
    rmdir $pardir
    return
}


AIimcompare () {
    local showhelp
    local no_divide     # not implemented yet
    local do_average    # if set, then average of img1 img3 are compared to img2=ref
    local dmag
    for i in 1 2 3 4
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-a" && do_average=1 && shift 1
        test "$1" == "-n" && no_divide=1 && shift 1
        test "$1" == "-m" && dmag=$2 && shift 2
    done
    #local image1=${1:-""}
    #local image2=${2:-""}
    #local image3=${3:-""}
    local img1=${1:-""}
    local ref=${2:-""}
    local img2=${3:-""}
    local sdat=${AI_SETS:-"set.dat"}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local wdir=$(mktemp -d "$tdir/tmp_imcomp_XXXXXX")
    local tmpgray=$(mktemp "$wdir/tmp_gray_XXXXXX.pnm")
    local tmpref=$(mktemp "$wdir/tmp_ref_XXXXXX.pnm")
    local tmpim1=$(mktemp "$wdir/tmp_im1_XXXXXX.pnm")
    local tmpim2=$(mktemp "$wdir/tmp_im2_XXXXXX.pnm")
    local mean=$(mktemp "$wdir/tmp_mean_XXXXXX.pnm")
    local mask=$(mktemp "$wdir/tmp_mask_XXXXXX.pnm")
    local div=$(mktemp "$wdir/tmp_div_XXXXXX.pnm")
    local diff=$(mktemp "$wdir/tmp_diff_XXXXXX.pnm")
    local difflow=$(mktemp "$wdir/tmp_difflow_XXXXXX.pnm")
    local tmpscat=$(mktemp "$wdir/tmp_scat_XXXXXX.dat")
    local tmp1=$(mktemp "$wdir/tmp_dat1_XXXXXX.dat")
    local tmp2=$(mktemp "$wdir/tmp_dat2_XXXXXX.dat")
    local tmpreg=$(mktemp "$wdir/tmp_reg_XXXXXX.dat")
    local bgmean=1000    # background of tmpim1, tmpim2, mean image
    local bgdiff=20000  # average intensity of diff image
    local add
    local x
    #local ref
    #local img1
    #local img2
    local aprad
    local mhigh
    local low
    local val
    local imlist
    local ds9opts

    (test "$showhelp" || test $# -lt 2 ) &&
        echo "usage: AIimcompare [-h] [-a] [-m dmag] <image> <refimage> [checkimage]" >&2 &&
        return 1

    # check if header files exist
    for x in $img1 $ref $img2
    do
        test ! -f $x && echo "ERROR: image $x not found." >&2 && return 255
        test ! -f ${x%.*}.head &&
            echo "ERROR: image header file ${x%.*}.head is missing" >&2 && return 255
        test ! -f ${x%.*}.wcs.head &&
            echo "ERROR: wcs header file ${x%.*}.wcs.head is missing" >&2 && return 255
    done
    
    # determine reference image
    #img1=$image1; ref=$image2; img2=""
    #test "$image3" && ! test "$do_average" && ref=$image3 && img2=$image2
    #test "$image3" &&   test "$do_average" && ref=$image2 && img2=$image3

    
    # remove bg structure and warp ref image
    echo "warping images ..."
    ppm2gray $ref > $tmpgray
    pgmtopbm -threshold -value 0.000001 $tmpgray > $mask
    (cd $wdir && AIbgmap -q $tmpgray 256 1 $mask)
    imbgsub $tmpgray ${tmpgray%.*}".bgm1.pgm" "" 1 "" $bgmean | \
        pnmarith -mult - $mask > $tmpref
    cp ${ref%.*}.head ${tmpref%.*}.head
    cp ${ref%.*}.wcs.head ${tmpref%.*}.wcs.head
    (cd $wdir && AIwarp -q -r bilinear -w $mask $tmpref)

    # remove bg structure and warp img1/img2
    ppm2gray $img1 > $tmpgray
    pgmtopbm -threshold -value 0.000001 $tmpgray > $mask
    (cd $wdir && AIbgmap -q $tmpgray 256 1 $mask)
    imbgsub $tmpgray ${tmpgray%.*}".bgm1.pgm" "" 1 "" $bgmean | \
        pnmarith -mult - $mask > $tmpim1
    cp ${img1%.*}.head ${tmpim1%.*}.head
    cp ${img1%.*}.wcs.head ${tmpim1%.*}.wcs.head
    (cd $wdir && AIwarp -q -r bilinear -w $mask ${tmpref%.*}.warped.head $tmpim1)
    if [ "$img2" ]
    then
        ppm2gray $img2 > $tmpgray
        pgmtopbm -threshold -value 0.000001 $tmpgray > $mask
        (cd $wdir && AIbgmap -q $tmpgray 256 1 $mask)
        imbgsub $tmpgray ${tmpgray%.*}".bgm1.pgm" "" 1 "" $bgmean | \
            pnmarith -mult - $mask > $tmpim2
        cp ${img2%.*}.head ${tmpim2%.*}.head
        cp ${img2%.*}.wcs.head ${tmpim2%.*}.wcs.head
        (cd $wdir && AIwarp -q -r bilinear -w $mask ${tmpref%.*}.warped.head $tmpim2)
    fi

    
    # create mean images
    echo "creating mean and mask images ..."
    if [ "$img2" ] && [ "$do_average" ]
    then
        # mask of all images
        pnmarith -minimum ${tmpref%.*}.warped.pgm ${tmpim1%.*}.warped.pgm | \
            pnmarith -minimum - ${tmpim2%.*}.warped.pgm | \
            pgmtopbm  -threshold -value 0.000001 > $mask
            #convert - -morphology Dilate Disk:1.5 -morphology Erode Disk:2.0 $mask
        # mean of all images
        pnmcombine ${tmpref%.*}.warped.pgm ${tmpim1%.*}.warped.pgm ${tmpim2%.*}.warped.pgm $tmpim2
        pnmarith -mult $tmpim2 $mask > $mean
        # average of img1 img2
        pnmcombine ${tmpim1%.*}.warped.pgm ${tmpim2%.*}.warped.pgm $tmpim2
        pnmarith -mult $tmpim2 $mask > $tmpim1
    else
        # mask of all images
        pnmarith -minimum ${tmpref%.*}.warped.pgm ${tmpim1%.*}.warped.pgm | \
            pgmtopbm  -threshold -value 0.000001 > $mask
        # mean of all images
        pnmcombine ${tmpref%.*}.warped.pgm ${tmpim1%.*}.warped.pgm $tmpim2
        pnmarith -mult $tmpim2 $mask > $mean
        # img1
        cp ${tmpim1%.*}.warped.pgm $tmpim1
    fi
    cp ${img1%.*}.head ${mean%.*}.head
    cp ${tmpref%.*}.warped.pgm $tmpref
    
    
    if [ ! "$dmag" ]
    then
        # photometry of some stars
        echo "do aperture photometry ..."
        AIsource -q -o $tmpscat $mean "" 20
        # determine aprad and high mag limit (brightest+0.5mag)
        sexselect -s $tmpscat "" 0.03 500  "" "" 0 > $tmp1
        aprad=$(grep FWHM $tmp1 | awk '{printf("%.1f", sqrt($2*$2+3)-0.3)}')
        mhigh=$(grep MAG_AUTO $tmp1 | awk '{printf("%.2f", $5+0.5)}')
        # select brightest 15 stars (below mhigh) for photometry
        # TODO: determine rlim
        sexselect -r $tmpscat "" 0.03 500  "" "" 0 > $tmp1
        grep -v "^circle(" $tmp1 > $tmpreg
        grep "^circle(" $tmp1 | sort -n -k4,4 | \
            awk -v mh=$mhigh '{if(1*$4>mh)print $0}' | lines 15 >> $tmpreg
        AIaphot $tmpref $tmpreg $aprad 4 > $tmp1
        AIaphot $tmpim1 $tmpreg $aprad 4 > $tmp2
        dmag=$(join $tmp1 $tmp2 | grep -v "^#" | awk '{print $16-$5}' | median -)
        echo "dmag=$dmag  aprad=$aprad  mhigh=$mhigh"
    fi
    
    # create unscaled diff image (at bg level bg)
    add=$(echo $bgmean $(dmag2di $dmag) | awk '{printf("%.0f", $1*(1-$2))}')
    pnmccdred -a $add -m $(dmag2di $dmag) $tmpim1 - | \
        pnmccdred -a $bgdiff -d ${tmpref%.*}.warped.pgm - - | \
        pnmarith -mult - $mask > $diff

    # create divider image used to scale down differences around bright sources
    set - $(imcrop -1 $diff 3 | AIval -a - | kappasigma -)
    echo $2 | awk '{printf("rms(diff)=%.1f\n", $1)}'
    low=$(echo $2 | awk -v l=20 -v bg=$bgmean '{printf("%d", bg+l*$1)}')
    val=$(echo $2 | awk -v s=0.08 '{print $1*s}')
    pnmccdred -a -$low $mean - | pnmccdred -a 100 -m $val - $div

    # create scaled diff image
    # signal above <bg>
    pnmccdred -a -$bgdiff $diff - | pnmccdred -m 100 -s $div - - | \
        pnmarith -mult - $mask > $tmpim1
    # signal below <bg>
    pnmccdred -a $bgdiff -m 0 $diff - | pnmccdred -d $diff - - | \
        pnmccdred -m 100 -s $div - - | \
        pnmarith -mult - $mask > $tmpim2
    pnmccdred -a 1000 -m 0 $diff - | pnmccdred -d $tmpim2 - - | \
        pnmarith -add - $tmpim1 > $difflow
    
    # get list of warped images
    imlist="${tmpim1%.*}.warped.pgm ${tmpref%.*}.warped.pgm"
    test "$img2" && imlist="$imlist ${tmpim2%.*}.warped.pgm"
    
    # display
    ds9opts="-grid yes -grid system image -grid grid no -grid axes type exterior"
    ds9opts="$ds9opts -view layout vertical -zoom 2"
    AIexamine -p "$ds9opts" -w ${tmpref%.*}.warped.head $difflow $imlist $mean

    test ! "$AI_DEBUG" && rm $wdir/* && rmdir $wdir
    return
}


AIplot () {
    local a10k      # if set, add 10000 to x values starting with 0
    local nofit     # if set, linear fit of points is omitted
    local small=0   # control plot window size
    local wide=0    # control plot window size
    local useboxes  # if set plot histogram like filled boxes
    local uselines  # if set plot lines and points
    local printfile # if set the plot is saved to printfile
    local gpcmd     # gnuplot commands inserted before plotting
    local nodisplay # if set do not display resulting plot
    local title
    local quiet
    local showhelp
    local i
    for i in $(seq 1 12)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-a" && a10k=1 && shift 1
        test "$1" == "-p" && nofit=1 && shift 1
        test "$1" == "-l" && uselines=1 && nofit=1 && shift 1
        test "$1" == "-b" && useboxes=1 && nofit=1 && shift 1
        test "$1" == "-s" && small=1 && shift 1
        test "$1" == "-w" && wide=1 && shift 1
        test "$1" == "-o" && printfile="$2" && shift 2
        test "$1" == "-t" && title="$2" && shift 2
        test "$1" == "-g" && gpcmd="$2" && shift 2
        test "$1" == "-n" && nodisplay=1 && shift 1
        test "$1" == "-q" && quiet=1 && shift 1
    done
    
    local dat="$1"      # datafile
    local xcol=$2       # x column to be plotted
    local ycol=${3:-""} # if empty, then use ycol=xcol and xcol=1
    local xmin=${4:-""}
    local xmax=${5:-""}
    local ranges=${6:-""}    # ranges passed to plot command
    local ex=${AI_XSKIP:-""}  # space separated list of x values
    local pat
    local term="x11"
    local termopts
    local font=sans
    local fsize=12
    local tfsize
    local timefmt
    local w
    local h
    local n
    local lnum
    local afit
    local bfit
    local tmp1=$(mktemp "/tmp/tmp_dat_$$.XXXXXX")
    local tmp2=$(mktemp "/tmp/tmp_cmd_$$.XXXXXX")
    local tmpfit=$(mktemp "/tmp/tmp_fit_$$.XXXXXX")
    local log=$(mktemp "/tmp/tmp_log_$$.XXXXXX")

    test "$showhelp" &&
        echo "usage: AIplot [-a] [-o outfile] [-t title] [-g gpcmd] [-p|b] [-s|w]" \
            "<dat> [xcol] <ycol> [xmin] [xmax] [ranges]" >&2 &&
        return 1

    test "$dat" == "-" && dat="/dev/stdin"
    test -z "$xcol" && echo "ERROR: missing parameter." >&2 && return 255
    pat="$(echo $ex | sed -e 's/ / |^/g; s/^/\^/; s/$/ /')"
    test -z "$ycol" && ycol=$xcol && xcol=1
    cat $dat | awk -v xc=$xcol -v yc=$ycol -v xmin="$xmin" -v xmax="$xmax" \
        -v a10k="$a10k" 'BEGIN{i=0}{
        if ($1~/^#/) next
        i++
        if (xc == yc) {x=i} else {
            if ($xc~/:/) {
                # hexadecimal notation
                split($xc, a, ":")
                x=a[1]+a[2]/60.+a[3]/3600.
            } else {
                if ($xc~/^[0-9]{4}-[0-9]{2}-[0-9]{2}./) {
                    # ICQ date notation like 2018-12-04.69
                    x=$xc
                    split($xc, a, ".")
                    frac="0."a[2]
                    h=int(24*frac)
                    m=int(24*frac*60-h*60+0.5)
                    x=sprintf("%s.%02d:%02d", a[1], h, m)
                } else {
                    x=$xc
                }
            }
        }
        if (a10k!~/^$/ && x~/^0[0-9][0-9][0-9]$/) {x=x+10000}
        if ((xmin != "") && (x < xmin)) next
        if ((xmax != "") && (x > xmax)) next
        printf("%s %s\n", x, $yc)
        }' | grep -Ev "${pat}" > $tmp1
    test ! -s $tmp1 &&
        echo "ERROR: no data to be plotted." >&2 &&
        rm -f $tmp1 $tmp2 $log && return 1
    
    # determine terminal type
    if [ "$printfile" ]
    then
        case ${printfile##*.} in
            ps|PS|eps|EPS)  term=postscript
                            termopts="enhanced eps color blacktext dashlength 2.5"
                            font=""; fsize=20
                            ;;
            png|PNG)        term=pngcairo
                            termopts="enhanced"
                            font="sans"; fsize=10
                            ;;
            *)              printfile=""
                            echo "# WARNING: unknown output file type" >&2
                            ;;
        esac
    fi
    
    # set plot window size
    case "$small$wide" in
        10) w=400; h=280
            fsize=$(echo $fsize | awk '{printf("%.0f", 0.9*$1)}')
            ;;
        01) w=950; h=350
            ;;
        11) w=500; h=230
            fsize=$(echo $fsize | awk '{printf("%.0f", 0.9*$1)}')
            ;;
        *)  w=630; h=460
            ;;
    esac
    echo -n "set terminal $term $termopts font '$font,$fsize'" >> $tmp2
    if [ "$w" ] && [ "$h" ]
    then
        test "$term" == "postscript" &&
            w=$(echo $w | awk '{print $1/100}') &&
            h=$(echo $h | awk '{print $1/100}')
        echo -n " size $w,$h" >> $tmp2
    fi
    echo "" >> $tmp2
    test "$printfile" && echo "set output '$printfile'" >> $tmp2
    test "$quiet" && echo "set fit quiet" >> $tmp2
    
    # set plot title
    if [ -z "$title" ]
    then
        title="$dat col$ycol=f(col$xcol)"
        test $xcol -eq 1 && test $ycol -eq 2 && title="$dat"
        test $xcol -eq $ycol && title="$dat"
    fi
    tfsize=$(echo $fsize | awk '{printf("%.0f", 1.15*$1)}')
    echo "set title '$title' font '$font,$tfsize'" >> $tmp2
    
    # some style changes
    echo "set style line 11 lc rgb '#505050' lt 1
        set border lw 1.2
        set style line 1 lc rgb '#e00000' # --- red
        set style line 2 lc rgb '#00e000' # --- green" >> $tmp2
    test "$useboxes" && echo "set style fill solid 1.00 border
        set boxwidth 1" >> $tmp2
    echo "set offsets graph 0.02, graph 0.02, graph 0.03, graph 0.03" >> $tmp2
    echo "set grid" >> $tmp2
    
    # check for several date formats
    # YYYY-MM-DD.HH:MM
    head -1 $tmp1 | grep -qE "^[0-9]{4}-[0-9]{2}-[0-9]{2}" && timefmt="%Y-%m-%d"
    head -1 $tmp1 | grep -qE "^[0-9]{4}-[0-9]{2}-[0-9]{2}.[0-9]{2}:[0-9]{2}" && timefmt="%Y-%m-%d.%H:%M"
    # YYYYMMDD.HH:MM
    head -1 $tmp1 | grep -qE "^[0-9]{8}" && timefmt="%Y%m%d"
    head -1 $tmp1 | grep -qE "^[0-9]{8}.[0-9]{2}:[0-9]{2}" && timefmt="%Y%m%d.%H:%M"

    # optionally set date/time data
    if [ "$timefmt" ]
    then
        echo "set timefmt '$timefmt'
        set xdata time
        set format x '${timefmt%.*}'" >> $tmp2
    fi
    
    # linear fit
    # TODO: make better guess on start values of coefficients
    if [ -z "$nofit" ]
    then
        if [ "$quiet" ]
        then
            gplinfit -q $tmp1 1 2 > $tmpfit 2>/dev/null
        else
            gplinfit $tmp1 1 2 > $tmpfit
        fi 
        afit=$(grep "^a " $tmpfit | awk '{if (NF>=3) printf("%s", $2)}')
        bfit=$(grep "^b " $tmpfit | awk '{if (NF>=3) printf("%s", $2)}')
        echo "f1(x) = a0 + a1*x
        a0 = $afit; a1 = $bfit" >> $tmp2
    fi
    
    # insert user provided gnuplot commands
    echo "$gpcmd" >> $tmp2

    # plotting data
    echo -n "plot $ranges '$tmp1' u 1:2 title '' ls 1" >> $tmp2
    test "$useboxes" && echo -n " with boxes" >> $tmp2
    test "$uselines" && echo -n " with linespoints" >> $tmp2
    test -z "$nofit" && echo ", f1(x)" >> $tmp2
    echo "" >> $tmp2
    
    false && if [ "$printfile" ]
    then
        echo -n "set term postscript enhanced eps $termopts " >> $tmp2
        case "$small$wide" in
            10) echo "font ',16' size 4,  2.8" >> $tmp2;;
            01) echo "font ',20' size 9.5,3.5" >> $tmp2;;
            11) echo "font ',16' size 5,  2.3" >> $tmp2;;
            *)  echo "font ',20' size 6.3,4.6" >> $tmp2;;
        esac
        echo "set title '$title' font ',24'" >> $tmp2
        echo "set output '$printfile'; replot" >> $tmp2
    fi
    
    cat $tmp2 | gnuplot -p > $log 2>&1
    if [ $? -eq 0 ]
    then
        false && test -z "$nofit" && test -z "$quiet" &&
            lnum=$(grep -n "After .* iterations the fit converged" fit.log | \
                tail -1 | cut -d ":" -f1) &&
            sed -ne "$lnum,\$p" fit.log
        test "$printfile" && test -z "$nodisplay" && AIdisplay $printfile &
    else
        cat $log
        echo "ERROR: gnuplot error in AIplot."
    fi
    test "$AI_DEBUG" && echo "$tmp1 $tmp2 $tmpfit $log" >&2 && return
    rm -f $tmp1 $tmp2 $tmpfit $log
    return
}


AIdisplay () {
    # display raster graphics
    # if single image then try to reuse existing window
    local showhelp
    local verbose
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-v" && verbose="1" && shift 1
    done
    local imglist=$@
    local viewer=feh
    local image
    local single
    local pid
    local wid
    local wpos
    local x
    
    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: AIdisplay [-v] <image1> [image2 ...]" >&2 &&
        return 1

    test $# -eq 1 && single=1
    image=$1
    file $image | cut -d ':' -f2 | grep -qi "postscript" &&
        viewer="xdg-open" && single=""
    
    if [ ! "$single" ]
    then
        $viewer $imglist &
        return
    fi
    
    # single image
    # TODO: atril allows reloading by Strg+R
    pid=$(ps -C "$viewer" -o pid=,cmd= | sed -e 's,^ ,,g' | \
        grep "^[0-9]* $viewer " | grep " $image$" | cut -d ' ' -f1)
    if [ "$pid" ]
    then
        test "$verbose" && echo "# viewer pid=$pid" >&2

        case $viewer in
            display)
                # obtain window id and position
                wid=$(xdotool search --name "^ImageMagick: $image$")
                wpos=$(xwininfo -id $wid | grep upper-left | cut -d ":" -f2 | \
                    tr '\n' ' ' | awk '{printf("%d %d", $1-$3, $2-$4)}')
                test "$verbose" && echo "# window wid=$wid wpos=$wpos" >&2
                kill $pid
                $viewer -geometry 100%x100%+${wpos/ /+} $image 2>/dev/null &
                # remove "Pan Icon" window created by Imagemagick display command
                xdotool search --onlyvisible --name "Pan Icon" windowclose
                x=$?; i=1
                while [ $x -ne 0 ] && [ $i -le 20 ]
                do
                    sleep 0.1
                    xdotool search --onlyvisible --name "Pan Icon" windowclose
                    x=$?
                    i=$((i+1))
                done
                test "$verbose" && echo "# windowclose: $i iterations" >&2
                ;;
            feh)
                xdotool search --name "^$viewer.*$image$" key r windowactivate
                ;;
            *)  echo "WARNING: viewer $viewer is untested" >&2
                kill $pid
                $viewer $imglist 2>/dev/null &
                ;;
        esac
    else
        $viewer $imglist 2>/dev/null &
    fi

}


AIpreview () {
    # create 8bit preview of DSLR images
    local showhelp
    local nlist
    local do_color
    local nproc
    local verbose
    local do_examine
    local do_halfsize
    local tlow=15   # low,high threshold for stats in bg image
    local thigh=75
    local i
    for i in $(seq 1 8)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-n" && nlist=$(mknlist "$2") && shift 2
        test "$1" == "-c" && do_color="1" && shift 1
        test "$1" == "-p" && nproc="$2" && shift 2
        test "$1" == "-e" && do_examine="1" && shift 1
        test "$1" == "-2" && do_halfsize="1" && shift 1
        test "$1" == "-t" && tlow=${2//,*/} && thigh=${2//*,/} && shift 2
        test "$1" == "-v" && verbose="1" && shift 1
    done
    local rdir=$1
    local telid=$2
    local contrast=${3:-"100"}     # contrast scaling
    local ext="png" # output format
    local dcrawopts=${AI_DCRAWOPTS:-""}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmp1=$(mktemp -d $tdir/tmp_preview_$day.XXXXXX)
    local tmpscript=$(mktemp $tdir/tmp_script_$day.XXXXXX)
    local tmpimg
    local tmpcrop
    local tmpdat
    local imlist
    local flat
    local f
    local num
    local black
    local fbopts
    local n
    local md
    local low
    local high
    local gam
    local x
    
    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: AIpreview [-v] [-c] [-2] [-t low,high|$tlow,$thigh] [-p nproc] [-n nlist] <rawdir> <telid|flat> [contrast|$contrast]" >&2 &&
        return 1

    if [ -f "$telid" ]
    then
        flat=$telid
    else
    case $telid in
        K135)   flat=$A/calib/170127/sk03.pgm # 2.0/135, K5II
                ;;
        K300)   flat=$A/calib/181011/sk46.pgm # 4.0/300 poly K5II
                ;;
        GSO)    flat=$A/calib/190624/sk01.pgm  # 200/800 poly MPCC K5IIs
                ;;
        GSOG)   flat=$A/calib/190324/sk14.pgm  # 200/800 poly GPUCC K5II
                ;;
        RC5s)   flat=$A/calib/181010/sk01.pgm  # RS 12" f/5, poly
                ;;
        *)      echo "WARNING: unknown telid, no flat field correction" >&2
                ;;
    esac
    fi
    if [ -z "$dcrawopts" ]
    then
        test "$flat" && dcrawopts="-R 4950 3284 0 0"
        test "$do_halfsize" && dcrawopts="$dcrawopts -h"
    fi
    nproc=$(cat /proc/cpuinfo | grep processor | wc -l)
    nproc=$((nproc - 1))
    test $nproc -gt 4 && nproc=4
    test $nproc -eq 0 && nproc=1
    
    imlist=$(ls $rdir/*.{pef,PEF,fits,FITS,cr2,CR2,nef,NEF,raf,RAF} \
    	$rdir/*/*.{pef,PEF,fits,FITS,cr2,CR2,nef,NEF,raf,RAF} \
    	2>/dev/null)
    test -z "$imlist" &&
        echo "ERROR: no images to process" >&2 &&
        return 255
    
    echo '#!/bin/bash
        f=$1
        
        nlist="'$nlist'"
        tmp1='$tmp1'
        tlow='$tlow'
        thigh='$thigh'
        contrast='$contrast'
        dcrawopts="'$dcrawopts'"
        flat="'$flat'"
        ext="'$ext'"
        
        . $(type -p airfun.sh) > /dev/null 2>&1
        num=$(basename ${f%.*} | sed -e '\''s/^[^0-9]*//; s/[^0-9]*$//'\'')
        tmpimg=$(mktemp /tmp/tmp_img.XXXXXX.pnm)
        tmpcrop=$(mktemp /tmp/tmp_crop.XXXXXX.pnm)
        tmpdat=$(mktemp /tmp/tmp_tmp1.XXXXXX.dat)
        test "$nlist" && ! echo "$nlist" | grep -qw $num && exit 0
        test -f $tmp1/$num.png && exit 0

        is_fits $f && meftopnm $f | pnmflip -tb | \
            convert - -normalize -gamma 2 -level 3%,80% -depth 8 $tmp1/$num.png &&
            exit 0
        black=$(AI_TZOFF=1 img_info $f | tail -1 | awk '\''{printf("%s", $9)}'\'')
        fbopts=""
        test "$flat" && fbopts="-F $flat"
        test "$black" && test "$black" != "-" && fbopts="$fbopts -k $((black/4))"
        echo -n "$num " >&2
        if [ "$do_color" ]
        then
            dcraw-tl -c -r 1.7 1 2.2 1 -q 0 -4 -t 0 -h $fbopts $dcrawopts -o 0 $f > $tmpimg
            imcrop $tmpimg 70 > $tmpcrop
            (cd /tmp
                AIbgmap -q -m $tmpcrop 64
                AIval -a ${tmpcrop/.pgm/.bgm1.pgm} | awk '\''{printf("%s\n", $2)}'\''
                rm -f ${tmpcrop/.pgm/.bgm1.pgm}
            ) | sort -n > $tmpdat
            n=$(cat $tmpdat | wc -l)
            md=$(head -$((n*50/100)) $tmpdat | tail -1)
            low=$(head -$((n*30/100))  $tmpdat | tail -1 | awk -v m=$md '\''{print 2*$1-m}'\'')
            high=$(echo $contrast | awk '\''{x=7000/$1; printf("%.0f", x*x)}'\'')
            rm -f $tmpcrop $tmpdat
            echo $low $md $high >&2
            #convert $tmpimg -level $((low-md*max/2000-50)),$((high+md*max/300+400)) -gamma 2.5 -depth 8 $tmp1/$num.$ext
            convert $tmpimg -level $((low-md*2/contrast-50)),$((high+md*13/contrast+400)) -gamma 2.2 -depth 8 $tmp1/$num.$ext
        else
            #echo "#" dcraw-tl -c -r 1 1 1 1 -q 0 -4 -t 0 $fbopts $dcrawopts -o 0 $f >&2
            dcraw-tl -c -r 1 1 1 1 -q 0 -4 -t 0 $fbopts $dcrawopts -o 0 $f | \
            ppm2gray - > $tmpimg
            imcrop $tmpimg 70 > $tmpcrop
            (cd /tmp
                AIbgmap -q -m $tmpcrop 64
                AIval -a ${tmpcrop/.pgm/.bgm1.pgm}
                rm -f ${tmpcrop/.pgm/.bgm1.pgm}
            ) | sort -n > $tmpdat
            n=$(cat $tmpdat | wc -l)
            md=$(head -$((n*50/100)) $tmpdat | tail -1)
            low=$(head -$((n*tlow/100))  $tmpdat | tail -1 | awk -v m=$md '\''{print 2*$1-m}'\'')
            high=$(head -$((n*thigh/100)) $tmpdat | tail -1 | awk -v m=$md '\''{print 2*$1-m}'\'')
            rm -f $tmpcrop $tmpdat
            echo $low $md $high >&2
            #convert $tmpimg -level $((low-md*max/2000-50)),$((high+md*max/300+400)) -gamma 2.2 -depth 8 $tmp1/$num.$ext
            convert $tmpimg -level $((low-md*2/contrast-50)),$((high+md*13/contrast+400)) -gamma 2.2 -depth 8 $tmp1/$num.$ext
        fi
        # ln -s $f $tmp1
        rm -f $tmpimg $tmpcrop $tmpdat
    ' > $tmpscript
    chmod u+x $tmpscript
    ls -l $tmpscript

    echo $tmp1
    if [ "$do_examine" ]
    then
        echo "$imlist" | parallel -j $nproc -k $tmpscript {}
        AIexamine -n BadMasks -l $tmp1/*.$ext &
        wait_for_saoimage -n BadMasks
    else
        if type geeqie >/dev/null 2>&1
        then
            geeqie $tmp1 &
        else
            if type gthumb >/dev/null 2>&1
            then
                gthumb $tmp1 &  # high CPU load
            else
                if type ristretto >/dev/null 2>&1
                then
                    ristretto $tmp1 &   # doesn't update ?
                else
                    xdg-open $tmp1
                fi
            fi
        fi
        echo "$imlist" | parallel -j $nproc -k $tmpscript {}
    fi
    return
}


AIfpreview () {
    # preview bayered raw fits images
    # notes:
    #   images must all have same size
    #   bayer grid: 3 4  RGGB:  G B   fcol/frow: 12 22
    #               1 2         R G              11 21
    #   AIstat -b prints 12 22 11 21 (starting upper left)
    local showhelp
    local mode="green"  # extract green channel only, 1/2 image size
    local dark=0        # average dark value
    local flat          # flat field image
    local telid="RASA"
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-c" && mode="ccdred" && shift 1
        test "$1" == "-d" && dark=$2 && shift 2
        test "$1" == "-f" && flat=$2 && shift 2
        test "$1" == "-t" && telid=$2 && shift 2
    done
    local slist=$@  # list of set names or image numbers (space sep.) or file names
    local nlist
    local flist
    local s
    local n
    local f
    local w
    local h
    local range
    local xlist
    local flip
    local tdir=${AI_TMPDIR:-"/tmp"}
    local wdir=$(mktemp -d $tdir/tmp_fpreview_$$.XXXXXX)
    local timlist=$(mktemp $tdir/tmp_imlist_XXXXXX.dat)
    local tfits=$(mktemp $tdir/tmp_tfits_XXXXXX.fits)

    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: AIfpreview [-c] [-t telid|$telid] [-d darkvalue] [-f flatimg] <set|numlist>" >&2 &&
        return

    test "$mode" == "ccdred" && test ! -f $flat &&
        echo "WARNING: flat field image not specified" >&2 && return 255
    test "$flat" && ! test -f "$flat" &&
        echo "ERROR: flat $flat not found" >&2 && return 255

    test -f set.dat && for s in $slist
    do
        is_setname $s || continue
        AIimlist $s "" raw | awk '{printf("%s %s\n", $2, $3)}'
    done > $timlist
    if [ ! -s $timlist ]
    then
        f=$(echo $slist | cut -d ' ' -f1)
        if [ -s  $(echo $slist | cut -d ' ' -f1) ]
        then
            n=0
            for f in $slist
            do
                test ! -s $f && continue
                n=$((n+1))
                printf "%04d $f\n" $n
            done > $timlist
        else
            nlist=$(mknlist $slist)
            for n in $nlist
            do
                f=$(get_rawfile $n 2>/dev/null)
                test -z "$f" && continue
                echo $n $f
            done > $timlist
        fi
    fi
    nimg=$(cat $timlist | wc -l)
    test $nimg -eq 0 && echo "ERROR: no raw images found." >&2 && return 255
    
    if [ "$mode" == "green" ]
    then
        echo "# extracting green channel from $nimg FITS images ..." >&2
        while read n f
        do
            is_fitzip $f && unzip -p $f > $tfits && f=$tfits
            set - $(imsize $f)
            w=$1
            h=$2
            # extract green channel
            flip=$(get_param camera.dat flip $telid)
            if [ "$flip" == "1" ]
            then
                fitscopy $f"[1:$w:2,$h:2:2]" $wdir/$n.fits
            else
                fitscopy $f"[1:$w:2,2:$h:2]" $wdir/$n.fits  # upper left
                #fitscopy $f"[2:$w:2,1:$h:2]" $tdir/g21.fits    # lower right
            fi
        done < $timlist
        echo "# loading $nimg images ..."
        AIexamine -n preview $wdir/[0-9]???.fits
    else
        # simple ccd reduction
        test -z "$nlist" &&
            echo "ERROR: simple ccd reduction not supported if input is raw images." >&2 &&
            return 255
        echo "# simple ccd reduction of $nimg FITS images ..." >&2
        range=$(echo $nlist | tr ' ' '\n' | minmax -)
        xlist=$(for num in $(mknlist ${range/ /-}); do
            echo $nlist | grep -q -w $num || echo $num; done)
        rm -f x.dk.pgm x.sk.pgm
        if [ "$flat" ]
        then
            ln -s $flat x.sk.pgm
            pnmccdred -a $dark -m 0 x.sk.pgm x.dk.pgm
        else
            set - $(imsize $(get_rawfile $(echo $nlist | cut -d ' ' -f1)))
            w=$1
            h=$2
            mkpgm 0 $w $h x.dk.pgm
            mkpgm 10000 $w $h x.sk.pgm
        fi
        echo "20:00 prev01 xxx o 1 $range ${range%% *} x.dk x.sk $telid" > x.set.dat
        AI_EXCLUDE=$xlist AI_SETS=x.set.dat AI_TMPDIR=$wdir \
            AIccd -q 0 3>&1 1>&2 2>&3 3>&- | grep -vwE "^excluding image|AI_SETS"
        test $? -ne 0 &&
            echo "ERROR: failed command" >&2 &&
            echo "    AI_SETS=x.set.dat AI_TMPDIR=$wdir AIccd -q 0" >&2 &&
            return 255
        echo "# loading $nimg images ..."
        AIexamine -n preview $wdir/[0-9]???.p[gp]m
    fi
    rm -rf $wdir $timlist $tfits
    return
}


AIpublish () {
    local showhelp
    local mag
    local tscale=1  # text scaling
    local author="Unknown Author"
    local outfile
    local do_quick      # skip any parsing of set info
    local is_negative   # if image is grayscale negative choose different line
                        # and text colors
    local quality=90
    local quiet
    local i
    for i in 1 2 3 4 5 6 7
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-m" && mag=$2 && shift 2
        test "$1" == "-t" && tscale=$2 && shift 2
        test "$1" == "-o" && outfile=$2 && shift 2
        test "$1" == "-j" && quality=$2 && shift 2
        test "$1" == "-q" && quiet=1 && shift 1
        test "$1" == "-n" && is_negative=1 && shift 1
        test "$1" == "-a" && author=$2 && shift 2
        test "$1" == "-x" && do_quick=1 && shift 1
    done
    local set="$1"
    local img="$2"
    local scale="$3"
    local object=${4:-""}
    local title=${5:-""}
    local text=${6:-""}
    local camera    # "DSLR Pentax K5IIs"
    local telescope
    local iso
    local jd
    local texp
    local nexp
    local utdate
    local uttime
    local oshort
    local add
    local x
    local w
    local fov
    local jpg
    local add
    local tsize
    local bs
    local fg
    local bg
    local copyright
    local caption
    local subtxt
    local tprop
    local str

    (test "$showhelp" || test $# -lt 3) &&
        echo "usage: AIpublish [-q] [-a author] [-m mag] [-j quality] [-t tscale] [-o outfile] <set> <img> <scale> <object> <title> <text>" >&2 &&
        return
    
    test ! -f $set.wcs.head && test -z "$do_quick" &&
        echo "ERROR: $set.wcs.head not found." >&2 && return 255
    
    if [ -z "$do_quick" ]
    then
        # determine telescope
        x=$(get_telescope $set)
        if [ "$x" ]
        then
            camera=$(get_param camera.dat camera $x)
            case $camera in
                K5II*)  camera="Pentax $camera";;
            esac
            str=$(get_param camera.dat ctype $x)
            if [ "$str" == "DSLR" ]
            then
                set - $(AIsetinfo $set)
                iso="ISO"$7
            fi
            str=$(get_param camera.dat flen $x)
            if [ $str -le 400 ]
            then
                telescope="telelens ${str}mm f/$(get_param camera.dat fratio $x)"
            else
                telescope=$(get_param camera.dat aperture $x | awk '{printf("%.0f", $1/25.4)}')"\""
                telescope="$telescope f/$(get_param camera.dat fratio $x)"
            fi
        fi
        test -z "$telescope" && telescope="unknown telescope"
        
        # get ut
        oshort=$(get_header $set.head OBJECT)
        test -z "$object" && object=$oshort
        x=$(jd2ut $(get_jd $set.head))
        utdate=${x%.*}
        uttime=$(echo 0.${x#*.} | awk '{
            x=$1*24; printf("%02d:%02.0f", int(x), (x-int(x))*60)}')
        
        # extract some data from image stack header
        jd=$(get_header $set.head MJD_OBS)
        nexp=$(get_header $set.head NEXP)
        texp=$(echo $(get_header $set.head EXPTIME) | awk -v n=$nexp '{
            s=1*$1/n
            if (s<60) {printf("%.0fs", s)} else {printf("%.0fmin", s/60)}}')

        # determine field size from image dimension
        x=$(get_wcspscale $set.wcs.head)
        fov=$(identify $img | cut -d " " -f3 | awk -F "x" -v ps=$x -v s=$scale '{
            if (s>2) {s=s/100}
            w=$1*ps/s/3600; h=$2*ps/s/3600
            fmt="%.1fx%.1f"
            if (w>10 && h>10) fmt="%.0fx%.0f"
            printf(fmt, w, h)
            }')
    fi
    
    # set outfile name
    jpg=${oshort}_${day}_${set}.jpg
    test "$outfile" && jpg="$outfile"

    # additional text info
    test "$mag" && add="$add, mv=${mag}mag"
    
    test -z "$title" &&
        title="$utdate, $uttime UT, ${nexp}x$texp, field size $fov" &&
        echo "##  title=\"$title\""
    test -z "$text" &&
        text="$telescope, $camera, $iso, ${nexp}x$texp, FOV ${fov///}deg$add" &&
        echo "##  text=\"$text\""
    echo "##  web form data:"
    echo "##  ;;;${utdate//-/.};;;;;$object;$uttime UT, $text;$jpg;;$oshort;$author;"
    test -z "$outfile" && test -f "$jpg" &&
        echo "WARNING: keeping existing $jpg" >&2 && return

    # create jpg image with borders and annotations
    set - $(identify $img | cut -d " " -f3 | awk -F "x" -v s=$tscale '{w=$1; h=$2;
        x=sqrt($1*$1+$2*$2); bs=s*x/130+2; printf("%.0f %.0f %.0f", s*x/110+2, bs, w+4+bs*4/6)}')
    tsize=$1    # text size
    bs=$2       # border scaling constant (~tsize)
    w=$3        # label width
    bg="#080808"
    fg="gray60"
    test "$is_negative" && fg="gray80"
    test "$utdate" && copyright=" ${utdate%%-*}, ${author%%,*}"
    test -z "$utdate" && copyright=" ${author%%,*}"
    test "$AI_DEBUG" && echo "tsize=$tsize bs=$bs" >&2
    
    # text labels
    x=$(echo -e "$title" | wc -l)
    echo "x=$x  h=$((tsize*x+5*(x-1)))"
    tprop="-fill $fg -font Helvetica -pointsize $tsize -interline-spacing 5"
    caption="$object  -  $title"
    convert -size ${w}x$((tsize*x+5*x)) -background $bg $tprop -gravity west label:"$caption" \
        -bordercolor $bg -border $bsx$((bs*1/3)) label.l.tif
    # add copyright text to label
    convert -background $bg $tprop label:"$copyright" \
        -bordercolor $bg -border $bsx$((bs*1/3)) label.r.tif
    composite -gravity northeast -geometry +1+1 label.r.tif label.l.tif label.tif
    # adding border and labels
    convert $img ppm:- | convert - -bordercolor $bg -border $((bs*4/6))x$((bs*4/6)) \
        -bordercolor "#a0a0a0" -border 2x2 -bordercolor $bg -border 0x$((bs*5/6)) \
        -background $bg label.tif -append -border $((bs*12/6))x$((bs*4/6)) \
        -quality $quality "$jpg"
    test $? != 0 && return 255
    test -z "$quiet" && xdg-open "$jpg" &
    test ! "$AI_DEBUG" && rm -f label.l.tif label.r.tif label.tif
    return
}


# create subimages (and headers) from original image around objects in catalog
# optionally create associated object lists within a given mask (twice boxsize)
# write results to outdir
cropstars () {
    local showhelp
    local maskreg   # region mask centered at bsize/2,bsize/2
    local starcat   # phot star catalog (id x y r g b ...) which is filtered
                    # by maskreg (default: use photcat)
    local outdir
    local i
    for i in 1 2 3 4
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-m" && maskreg=$2 && shift 2
        test "$1" == "-s" && starcat=$2 && shift 2
        test "$1" == "-o" && outdir=$2 && shift 2
    done
    local img=$1        # image containing objects
    local photcat=$2    # photometry data file with fields id,x,y,r,g,b
                        # where x,y are in image coordinates
    local bsize=$3      # subimage box size image
    local margin=4      # margin to add around box
    local imgtype="ppm"
    local clist="red grn blu"
    local f
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpsh=$(mktemp "$tdir/tmp_script_XXXXXX.sh")
    chmod u+x $tmpsh

    (test "$showhelp" || test $# -lt 3) &&
        echo "usage: cropstars [-o outdir] [-m maskreg] [-s starcat]" \
            "<img> <photcat> <bsize>" >&2 &&
        return 1

    for f in $img $photcat
    do
        test ! -f $f && echo "ERROR: file $f not found." >&2 && return 255
    done
    is_pgm $img && imgtype="pgm" && clist="gray"

    test "$outdir" && test ! -d "$outdir" &&
        echo "ERROR: directory $outdir does not exist." >&2 && return 255
    test -z "$outdir" &&
        outdir=$(mktemp -d "$tdir/tmp_cropstars_XXXXXX") &&
        echo "# writing cropped images to $outdir" >&2
    
    test -z "$starcat" && starcat=$photcat

    cat <<EOF > $tmpsh
#!/bin/bash
. airfun.sh > /dev/null
img=$img
photcat=$photcat
bsize=$bsize
margin=$margin
clist="$clist"
imgtype="$imgtype"

tdir="$tdir"
outdir="$outdir"
maskreg="$maskreg"
starcat="$starcat"

_crop_parallel \$@
EOF

    # extract sub-images for individual objects
    _crop_parallel () {
        local nimg=$1
        local id=$2
        local xc=$3
        local yc=$4
        local r=$5
        local g=$6
        local b=$7
        local subsize
        local xi
        local yi
        local pscale
        local cx
        local cy
        local dx
        local dy
        local c
        splitdir=$(mktemp -d "$tdir/tmp_split_XXXXXX")
        tmpreg=$(mktemp "$tdir/tmp_mask_XXXXXX.reg")
        tmpcat=$(mktemp "$tdir/tmp_cat_XXXXXX.dat")
        
        (echo "$id" | grep -q "^#") && continue
        test -z "$yc" && continue

        # add some margin
        subsize=$((bsize + 2*margin))

        # extract and translate oimg section to center object at subsize/2, subsize/2
        xi=$(echo $xc | awk '{printf("%d", $1)}')
        yi=$(echo $yc | awk '{printf("%d", $1)}')
        #sx=$(echo $xi $xc | awk -v s=$scale '{printf("%.2f", s*($1-$2))}')
        #sy=$(echo $yi $yc | awk -v s=$scale '{printf("%.2f", s*($2-$1))}')
        # echo $xi $yi $sx $sy
        if [ "$imgtype" == "pgm" ]
        then
            false && imcrop -1 $img $subsize $subsize $((xi - subsize/2)) $((yi - subsize/2)) | \
                pnmtomef - > $outdir/$id.$clist.fits
            convert $img -crop ${subsize}x${subsize}+$((xi - subsize/2))+$((yi - subsize/2)) pgm:- | \
                pnmtomef - > $outdir/$id.$clist.fits
        else
            false && imcrop -1 $img $subsize $subsize $((xi - subsize/2)) $((yi - subsize/2)) | \
                (cd $splitdir; ppmtorgb3)
            convert $img -crop ${subsize}x${subsize}+$((xi - subsize/2))+$((yi - subsize/2)) ppm:- | \
                (cd $splitdir; ppmtorgb3)
            for c in red grn blu
            do
                pnmtomef $splitdir/noname.$c > $outdir/$id.$c.fits
            done
            rm -rf $splitdir
        fi
        
        # create artificial .head files
        # note: cx cy are in fits image coordinates
        pscale=$(echo 1 | awk '{print $1/3600.}')
        cx=$(echo $subsize $xc $xi | awk '{printf("%.3f", $1/2+$2-$3+0.5)}')
        cy=$(echo $subsize $yc $yi | awk '{printf("%.3f", $1/2-$2+$3+0.5)}')
        echo "EXPTIME =      1       / Exposure time in seconds
EPOCH   =      2000.0  / Epoch
EQUINOX =      2000.0  / Mean equinox
CTYPE1  = 'RA---TAN'   / WCS projection type for this axis
CUNIT1  = 'deg     '   / Axis unit
CRVAL1  =      10.0    / World coordinate on this axis
CRPIX1  =      $cx     / Reference pixel on this axis
CD1_1   =      -$pscale   / Linear projection matrix
CD1_2   =      0          / Linear projection matrix
CTYPE2  = 'DEC--TAN'   / WCS projection type for this axis
CUNIT2  = 'deg     '   / Axis unit
CRVAL2  =      0.0     / World coordinate on this axis
CRPIX2  =      $cy     / Reference pixel on this axis
CD2_1   =      0          / Linear projection matrix
CD2_2   =      $pscale    / Linear projection matrix
END     " > $outdir/$id.red.head
        if [ "$imgtype" == "pgm" ]
        then
            mv $outdir/$id.red.head $outdir/$id.gray.head
        else
            cp -p $outdir/$id.red.head $outdir/$id.grn.head
            cp -p $outdir/$id.red.head $outdir/$id.blu.head
        fi
        
        if [ "$maskreg" ]
        then
            false && (
            # translate mask and flip horizontally to match image coordinates in $img
            dx=$((xi - bsize/2))
            dy=$((yi - bsize/2))
            regshift -f $maskreg $dx $dy "" $bsize $bsize > $tmpreg
            
            # match field stars within mask
            xyinreg $starcat $tmpreg "id X_IMAGE Y_IMAGE r g b x x x x x" > $tmpcat
            grep -v "^#" $tmpcat | awk -v id=$id -v dx=$((xi-subsize/2)) -v dy=$((yi-subsize/2)) '{
                if ($1==id) next
                printf("%-11s %7.2f %7.2f  %5.2f %5.2f %5.2f  0 0 0 0 0\n", $1, $2-dx, $3-dy, $4, $5, $6)
            }' > $outdir/$id.phot.dat

            cp -p $tmpreg $outdir/$id.mask.reg
            cp -p $tmpcat $outdir/$id.phot0.dat
            )
            
            # match field stars within quadratic mask
            grep -v "^#" $starcat | awk -v id=$id -v xc=$xc -v yc=$yc -v s=$bsize '{
                w=20+1.2*s
                if($2<xc-w) next; if($2>xc+w) next
                if($3<yc-w) next; if($3>yc+w) next
                if($1==id) next
                print $0}' > $outdir/$id.phot0.dat
        fi
        
        rm -f $tmpreg $tmpcat
    }
    

    export -f _crop_parallel
    popts=""; test "$AI_MAXPROCS" && popts="-P $AI_MAXPROCS"
    grep -nv "^#" $photcat | sed 's,:, ,' | parallel $popts -k $tmpsh
    unset -f _crop_parallel
    # TODO: error handling
    
    rm -f $tmpsh
    return
}


# combine object images (names: <id>.<color.fits), e.g. to create high S/N PSF image
# by default use re-sampling to 1/scale-pixels for better preservation of resolution
# e.g. run after cropstars
#   cropstars -o $imgdir $bigimg $photcat $psfsize
starcombine () {
    local showhelp
    local resamptype    # resampling type (e.g. lanczos3, bilinear)
    local fwhm=4        # fwhm of stars, used to define region where peak
                        # intensity is measured
    local psfmult=1     # scale factor for psf intensities
    local inbg          # average bg value of psf stars in input images (comma
                        #   separated r,g,b)
    local outbg         # background level of resulting psf image (default: inbg)
    local i
    for i in 1 2 3 4 5 6
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-f" && fwhm="$2" && shift 2
        test "$1" == "-r" && resamptype="$2" && shift 2
        test "$1" == "-b" && inbg="$2" && shift 2
        test "$1" == "-m" && psfmult="$2" && shift 2
        test "$1" == "-o" && outbg="$2" && shift 2
    done
    local imgdir=$1             # directory containing psf objects (subimages) to combine
    local outpsf=$2             # output psf image
    local psfsize=${3:-"100"}   # image box size used for psf
    local scale=${4:-"4"}       # scale up psf image for better sampling
    local tdir=${AI_TMPDIR:-"/tmp"}
    local conf=$(mktemp "$tdir/tmp_swarp.XXXXXX.conf")
    local wdir=$(mktemp -d "$tdir/tmp_combine_XXXXXX")
    local ext="ppm"
    local clist="red grn blu"
    local psfrgb
    local psfadd
    local str
    local mult
    local bg
    local add
    local param
    local xbgval
    local f
    local retval
    
    (test "$showhelp" || test $# -lt 3) &&
        echo "usage: starcombine [-f fwhm|$fwhm] [-b imgbg|$inbg] [-o outbg|$outbg] [-m psfmult|$psfmult] [-r resamptype]" \
            "<imgdir> <outpsf> [psfsize|$psfsize] [scale|$scale]" >&2 &&
        return 1

    # determine colors
    ls $imgdir/*.gray.fits 2>/dev/null > /dev/null && ext="pgm" && clist="gray"
    
    # average sub-images using different pscale
    pscale=$(echo 1 $scale | awk '{printf("%f", $1/$2)}')
    swarp -d > $conf
    param="-resample_dir $wdir"
    test "$resamptype" && param="$param -resampling_type $resamptype"
    for c in $clist
    do
        swarp -c $conf -combine_type average -subtract_back N \
            -fscale_default $((scale*scale)) \
            -pixelscale_type manual -pixel_scale $pscale \
            -center_type manual -center 10,0 \
            -image_size $((psfsize*scale)),$((psfsize*scale)) \
            -verbose_type QUIET $param $imgdir/*.$c.fits
        sethead coadd.fits datamin=0 datamax=65535
        
        if [ "$psfmult" != "1" ]
        then
            ## scale intensities to max=50000
            #str=$(echo $psfsize $scale $fwhm | awk '{
            #    a=$1*$2/2-$2*($3+2); b=$1*$2/2+$2*($3+2)
            #    printf("[%.0f:%.0f,%.0f:%.0f]\n", a,b,a,b)}')
            #mult=$(imlist "coadd.fits$str" | tr ' ' '\n' | sort -nr | head -1 | \
            #    awk '{printf("%.3f", 50000/$1)}')
            #test "$psfmult" && psfmult=$psfmult","
            #psfmult="$psfmult$mult"
            imarith coadd.fits $psfmult mul - > $wdir/$c.fits
            mv $wdir/$c.fits coadd.fits
        fi

        if [ -z "$inbg" ]
        then
            # radii for measurement of xbgval (psf background)
            if [ -z "$bg" ]
            then
                r=$(echo $fwhm $scale | awk -v rmax=$((psfsize*scale/4)) '{
                    r=(4*$1+1)*$2; if(r>rmax){r=rmax}; printf("%.0f", r)}')
                y=$((r/4+scale+2))
                echo "# measure psf bg in annulus $((r+y)) $((r+3*y))" >&2
            fi

            # measure (unscaled) bg
            x=$((psfsize*scale/2))
            meftopnm coadd.fits > $wdir/$c.pgm
            bg=$(echo "psfcenter $x $x" | \
                AI_MAGZERO=20 AIaphot $wdir/$c.pgm - $r $y $((3*y)) | grep -v "^#" | \
                awk -v m=$psfmult '{printf("%.1f", $9/m)}')
            test "$xbgval" && xbgval=$xbgval","
            xbgval="$xbgval$bg"
        else
            case $c in
                grn)    x=2;;
                blu)    x=3;;
                *)      x=1;;
            esac
            bg=$(echo $inbg | tr ',' '\n' | head -$x | tail -1)
        fi

        # shift the bg level to outbg
        test -z "$outbg" && outbg=$inbg
        add=$(echo $bg $psfmult $outbg | awk '{printf("%.1f", $3-$1*$2)}')
        test "$psfadd" && psfadd=$psfadd","
        psfadd="$psfadd$add"
        if [ "$add" == "0.0" ] || [ "$add" == "-0.0" ]
        then
            mv coadd.fits $wdir/$c.fits
        else
            imarith coadd.fits $add add - > $wdir/$c.fits
        fi
        rm -f coadd.fits coadd.weight.fits swarp.xml
        
        #cp coadd.fits x.psf.$c.fits
        #meftopnm coadd.fits > $wdir/$c.pgm
    done
    
    test "$xbgval" && echo "# xbgval=$xbgval" >&2
    test "$AI_DEBUG" && echo "# psfadd=$psfadd" >&2

    if [ "$ext" == "pgm" ]
    then
        meftopnm $wdir/gray.fits > $outpsf
        retval=$?
    else
        fits3toppm $wdir/red.fits $wdir/grn.fits $wdir/blu.fits $outpsf
        retval=$?
    fi
    
    # clean-up
    rm -f $conf
    if [ $retval -eq 0 ] && [ -z "$AI_DEBUG" ]
    then
        rm -rf $wdir
    else
        echo $wdir >&2
    fi
    return $retval
}


applymask () {
    local inpsf=$1
    local outpsf=$2
    local psfoff=${3:-1000}
    local mask
    local tmpmask=$(mktemp "$tdir/tmp_mask_XXXXXX.pbm")

    if is_reg $mask
    then
        reg2pbm $inpsf $mask > $tmpmask
    else
        cp $mask $tmpmask
    fi

    # apply mask
    pnmccdred -m 0 $inpsf - | \
        pnmccdred -a $psfoff - - | \
        pnmcomp -alpha $tmpmask $inpsf > $outpsf
}


# create region mask, output to stdout
mkmask () {
    local showhelp
    local trail
    local i
    for i in $(seq 1 4)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-t" && trail=$2   && shift 2
    done
    
    local img=$1    # image to extract width from # TODO: or value to use as width and height
    local rad=$2    # mask radius

    (test "$showhelp" || test $# -ne 2) &&
        echo "usage: mkmask [-t traillen,pa,cfrac] <img> <radius>" >&2 &&
        return 1

    test ! -e $img && echo "ERROR: file $img not found." >&2 && return 255
    
    echo "# Region file format: DS9 version 4.1"
    echo "global color=green dashlist=8 3 width=1 font=\"helvetica 10 normal roman\"" \
        "select=1 highlite=1 dash=0 fixed=0 edit=1 move=1 delete=1 include=1 source=1
physical"

    if [ -z "$trail" ]
    then
        imsize $img | awk -v r=$rad '{
            printf ("circle(%f,%f,%f) # text={star_mask}\n", $1/2+0.5, $2/2+0.5, r)}'
    else
        echo $(imsize $img) ${trail//,/ } 0.5 | awk -v s=1 -v r=$rad '{
            pi=3.141592653
            
            # center 1
            l=s*$3*($5-1)
            x=$1/2+l*cos($4*pi/180)+0.5
            y=$2/2+l*sin($4*pi/180)+0.5
            # point 1
            dx=s*r*cos(($4-90)*pi/180)
            dy=s*r*sin(($4-90)*pi/180)
            printf("polygon(%.1f,%.1f,", x+dx, y+dy)
            # point 2
            dx=s*r*cos(($4-135)*pi/180)
            dy=s*r*sin(($4-135)*pi/180)
            printf("%.1f,%.1f,", x+dx, y+dy)
            # point 3
            dx=s*r*cos(($4-180)*pi/180)
            dy=s*r*sin(($4-180)*pi/180)
            printf("%.1f,%.1f,", x+dx, y+dy)
            # point 4
            dx=s*r*cos(($4-225)*pi/180)
            dy=s*r*sin(($4-225)*pi/180)
            printf("%.1f,%.1f,", x+dx, y+dy)
            # point 5
            dx=s*r*cos(($4-270)*pi/180)
            dy=s*r*sin(($4-270)*pi/180)
            printf("%.1f,%.1f,", x+dx, y+dy)

            # center 2
            l=s*$3*$5
            x=$1/2+l*cos($4*pi/180)+0.5
            y=$2/2+l*sin($4*pi/180)+0.5
            # point 6
            dx=s*r*cos(($4+90)*pi/180)
            dy=s*r*sin(($4+90)*pi/180)
            printf("%.1f,%.1f,", x+dx, y+dy)
            # point 7
            dx=s*r*cos(($4+45)*pi/180)
            dy=s*r*sin(($4+45)*pi/180)
            printf("%.1f,%.1f,", x+dx, y+dy)
            # point 8
            dx=s*r*cos(($4+0)*pi/180)
            dy=s*r*sin(($4+0)*pi/180)
            printf("%.1f,%.1f,", x+dx, y+dy)
            # point 9
            dx=s*r*cos(($4-45)*pi/180)
            dy=s*r*sin(($4-45)*pi/180)
            printf("%.1f,%.1f,", x+dx, y+dy)
            # point 10
            dx=s*r*cos(($4-90)*pi/180)
            dy=s*r*sin(($4-90)*pi/180)
            printf("%.1f,%.1f) # text={trail_mask}\n", x+dx, y+dy)
        }'
    fi
}


# wrapper around sky(maker) to create artificial star field image from
#   star photometry file (generated by AIaphot) and psf image
# number of color planes is taken from psf-image
# format of stars photometry catalog: id xc yc rmag gmag bmag
#   xc, yc in image coordinates starting at upper left corner=0,0
# default output image name: ${photcat%.dat}.$ext
# output image has background level of 0
AIskygen () {
    local do_fits           # if set generate FITS output file instead of PGM/PPM
    local outfile           # name of output file (default: ${photcat%.dat}.$ext
    local vtype="quiet"     # value of verbose_type parameter of sky
    local mcorr             # mag correction dr,dg,db applied to photcat
    local showhelp
    for i in $(seq 1 3)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-f" && do_fits=1 && shift 1
        test "$1" == "-o" && outfile=$2 && shift 2
        test "$1" == "-m" && mcorr="$2" && shift 2
        test "$1" == "-v" && vtype="normal" && shift 1
    done
    
    local photcat=$1
    local psf=$2            # psf image (TODO: width of gaussian profile)
    local texp=$3           # exposure time in seconds 
    local magzero=$4        # magnitude zero point
    local oversamp=${5:-4}  # psf oversampling factor
    local w=${6:-1024}
    local h=${7:-1024}
    local psfbg=${8:-"1000"}
    #local noise=${9:-""}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpdat=$(mktemp "$tdir/tmp_dat_XXXXXX.dat")
    local tmppsf=$(mktemp "$tdir/tmp_psf_XXXXXX.fits")
    local tmpfits1=$(mktemp "$tdir/tmp_im1_XXXXXX.fits")
    local tmpfits2=$(mktemp "$tdir/tmp_im2_XXXXXX.fits")
    local tmpr=$(mktemp "$tdir/tmp_r_XXXXXX.fits")
    local tmpg=$(mktemp "$tdir/tmp_g_XXXXXX.fits")
    local tmpb=$(mktemp "$tdir/tmp_b_XXXXXX.fits")
    local conf=$(mktemp "$tdir/tmp_sky_XXXXXX.conf")
    local ext
    local ncol
    local pw
    local ph
    local colorcol
    local x
    local y
    local c
    local madd
    
    (test "$showhelp" || test $# -lt 4) &&
        echo "usage: AIskygen [-v] [-o outfile] [-m dr,dg,db] <photcat> <psf> <texp>" \
            "<magzero> [oversamp|$oversamp] [width|$w] [height|$h] [psfbg|$psfbg]" >&2 &&
        return 1

    for f in $photcat $psf
    do
        test ! -e $f && echo "ERROR: file $f not found." >&2 && return 255
    done
    
    ext="pgm"; ncol=1
    is_ppm $psf && ext="ppm" && ncol=3
    if [ ! "$outfile" ]
    then
        outfile=$(basename ${photcat%.dat}.$ext)
        test "$do_fits" && outfile=$(basename ${photcat%.dat}.fits)
    fi
    test "$do_fits" && echo "ERROR: not implemented yet." >&2

    pw=$(identify $psf | cut -d " " -f3 | cut -d "x" -f1)
    ph=$(identify $psf | cut -d " " -f3 | cut -d "x" -f2)

    pnmtomef $psf > $tmppsf
    for c in $(seq 1 $ncol)
    do
        # additive mag correction
        madd=0
        test "$mcorr" && madd=$(echo ${mcorr//,/ } | cut -d " " -f$c)
        
        # note: default oversampled psf peak in skymaker has offset
        #   for even number of cols/rows center+(0.5,0.5)/s
        #   for odd number of cols/rows there is correct center
        cat $photcat | awk -v mcol=$((c+3)) -v madd=$madd -v s=$oversamp \
            -v pw=$pw -v ph=$ph -v h=$h 'BEGIN{xoff=(1-pw%2)*0.5/s; yoff=(1-ph%2)*0.5/s}{
            if ($1~/^#/) next
            printf("100 %7.2f %7.2f %5.2f # %-10s\n",
                $2+0.5+xoff, h-$3+0.5+yoff, $mcol+madd, $1)}' > $tmpdat
        #test "$AI_DEBUG" && cat $tmpdat
        # prepare psf image
        x=$(echo $texp $oversamp | awk '{print $1*$2*$2}')
        y=$(echo $psfbg | awk '{print 2^15-$1}')
        
        imcopy $tmppsf[$((c-1))] - > $tmpfits1
        sethead $tmpfits1 EXPTIME=$x MAGZERO=$magzero PSFSAMP=$oversamp BZERO=$y
        #echo sky -image_size $w","$h -exposure_time $texp -mag_zeropoint $magzero \
        #    -pixel_size 3.5 -seeing_fwhm 6 -starcount_zp 0 -readout_noise 0 \
        #    -back_mag 22 -psf_oversamp 20 $tmpdat
        sky -d > $conf
        sky -c $conf -image_name $tmpfits2 -image_size $w","$h \
            -image_type sky_nonoise -verbose_type quiet \
            -psf_oversamp $oversamp -seeing_type none -aureole_radius 0 \
            -exposure_time $texp -mag_zeropoint $magzero -back_mag 99 -starcount_zp 0 \
            -psf_type file -psf_name $tmpfits1 $tmpdat
        test $? -ne 0 &&
            echo "ERROR: command sky ... has failed." >&2 && return 255
        rm ${tmpfits2%.fits}.list
        
        sethead $tmpfits2 datamin=0 datamax=65535
        test $c -eq 1 && mv $tmpfits2 $tmpr
        test $c -eq 2 && mv $tmpfits2 $tmpg
        test $c -eq 3 && mv $tmpfits2 $tmpb
    done
    
    # combine color channels    
    if [ $ncol -eq 1 ]
    then
        meftopnm $tmpr > $outfile
    else
        fits3toppm $tmpr $tmpg $tmpb $outfile
    fi
    #echo $tmpr $tmpg $tmpb >&2
    #return
    
    rm -f $conf $tmppsf $tmpdat $tmppsf $tmpfits1 $tmpfits2 $tmpr $tmpg $tmpb
    return
}



#--------------------
#   imred functions
#--------------------

# create master dark image
# lineary scale up images from 12 to 16 bit
# median group of 3+ images (to get rid of cosmics)
# average those
AIdark () {
    AIcheck_ok -r || return 255
    local rowsub    # if set then subtract median from each row to remove column structure
    local mode="avmedian" # median from group of 3 images, average of medians
    local showhelp
    for i in $(seq 1 3)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-r" && rowsub=1 && shift 1
        test "$1" == "-a" && mode="average" && shift 1
        test "$1" == "-d" && mode="median" && shift 1
    done

    local setname=${1:-""}
    local rdir=${AI_RAWDIR:-"."}
    #local bad=${AI_BADPIX:-""}
    local sdat=${AI_SETS:-"set.dat"}
    local ccdregion=${AI_CCDREGION:-""}  # w h xoff yoff
    local tdir=${AI_TMPDIR:-"/tmp"}
    local imlist=$(mktemp "$tdir/tmp_imlist_XXXXXX.dat")
    local sname
    local target
    local type
    local texp
    local n1
    local n2
    local nref
    local dark
    local flat
    local x
    local i
    local ilist
    local dcrawopts
    local n
    local ng
    local ig
    local scale
    local flip
    local opts

    test "$showhelp" &&
        echo "usage: AIdark [-a|-d] [set]" >&2 &&
        return 1
    
    while read ltime sname target type texp n1 n2 nref dark flat x
    do
        (echo "$ltime" | grep -q "^#") && continue
        test "$type" != "d" && continue
        test "$setname" && test "$setname" != "$sname" && continue
        (! is_integer "$n1" || ! is_integer "$n2") && continue
        
        test -f $sname.pgm &&
            echo "WARNING: $sname.pgm exists, skipping set $sname." >&2 && continue
        
        is_dark_subtracted=""
        test "$(AIsetinfo $sname | awk '{print $11}')" == "0" &&
            is_dark_subtracted=1 &&
            echo "$sname: in-camera dark subtraction assumed."
        
        AIimlist $sname "" raw > $imlist
        n=$(cat $imlist | wc -l)
        test $n -lt 3 && echo "ERROR: set $sname has too few images ($n < 3)." >&2 &&
            rm $imlist && continue
        echo "processing $n darks in set $sname ..."
        
        dcrawopts=""
        is_gacam_raw $(head -1 $imlist | cut -d ' ' -f3) && test "$ccdregion" &&
            dcrawopts="-R $ccdregion"

        # determine intensity scaling factor to stretch to full 16bit range
        # this is used by AIraw2gray in case of FITS images only
        scale=$(get_param camera.dat rawbits $sname | awk '{if ($1!="-" && $1<16) print 2^(16-$1)}')

        # check if top-down image flipping is required
        flip=$(get_param camera.dat flip $sname | awk '{if ($1=="1") print 1}')
        
        # options for raw image conversion
        opts="-c"   # apply AI_CCDREGION
        test "$scale" && opts=$(echo $opts "-s $scale")
        test "$flip"  && opts=$(echo $opts "-f")

        test "$mode" == "avmedian" && test $n -lt 6 && mode="median" &&
            echo "WARNING: set $sname has few images ($n < 6)." >&2

        case $mode in
            average)
                while read x num fname x
                do
                    echo "  $num"
                    i=$(($i+1)); ilist="$ilist $tdir/$num.pgm"
                    (test ! -f $tdir/$num.pgm || test -s $tdir/$num.pgm) &&
                        AI_DCRAWPARAM="$dcrawopts $AI_DCRAWPARAM" \
                        AIraw2gray $opts $fname $tdir/$num.pgm
                    test "$rowsub" && impatsub $tdir/$num.pgm
                done < $imlist
                pnmcombine2 $ilist $sname.pgm
                ;;
            median)
                while read x num fname x
                do
                    echo "  $num"
                    i=$(($i+1)); ilist="$ilist $tdir/$num.pgm"
                    (test ! -f $tdir/$num.pgm || test -s $tdir/$num.pgm) &&
                        AI_DCRAWPARAM="$dcrawopts $AI_DCRAWPARAM" \
                        AIraw2gray $opts $fname $tdir/$num.pgm
                    test "$rowsub" && impatsub $tdir/$num.pgm
                done < $imlist
                pnmcombine2 -d $ilist $sname.pgm
                ;;
            avmedian)
                # median in groups of 3+ images
                ng=$(($n / 3))
                ig=1
                i=0; ilist=""
                rm -f $tdir/$sname.m[0-9][0-9].pgm
                while read x num fname x
                do
                    echo "  $num"
                    i=$(($i+1)); ilist="$ilist $tdir/$num.pgm"
                    (test ! -f $tdir/$num.pgm || test ! -s $tdir/$num.pgm) &&
                        AI_DCRAWPARAM="$dcrawopts $AI_DCRAWPARAM" \
                        AIraw2gray $opts $fname $tdir/$num.pgm
                    test "$rowsub" && impatsub $tdir/$num.pgm
                    test $ig -lt $ng && test $(($i %3)) -eq 0 &&
                        ig2=$(printf "%02d" $ig) &&
                        echo "median in group $ig -> $tdir/$sname.m$ig2.pgm" &&
                        pnmcombine2 -d $ilist $tdir/$sname.m$ig2.pgm &&
                        ig=$(($ig+1)) && ilist=""
                    test $ig -eq $ng && test $i -eq $n &&
                        ig2=$(printf "%02d" $ig) &&
                        echo "median in group $ig -> $tdir/$sname.m$ig2.pgm" &&
                        pnmcombine2 -d $ilist $tdir/$sname.m$ig2.pgm &&
                        ilist=""
                done < $imlist
        
                # average over medians
                echo "average median images ..."
                pnmcombine2 $tdir/$sname.m[0-9][0-9].pgm $sname.pgm
                ;;
        esac
        
        # clean up
        rm -f $tdir/$sname.m[0-9][0-9].pgm
    done < $sdat
    test "$AI_DEBUG" && echo $tdir
    rm -f $imlist
}


# create master flat field image
# scale from 12bit to 16bit, subtract (optionally cropped) dark
# work within groups of 6+ images
#   - get mean intensity of each image (center region)
#   - normalize flats
#   - median of odd/even images in group (to get rid of stars),
#     e.g.: median of 1 3 5 and median of 2 4 6
# average those median frames
AIflat () {
    AIcheck_ok -r || return 255
    local showhelp
    local do_bayer      # if set then keep bayer matrix and create gray
                        # flat field instead of rgb
    local do_simple     # simple algorithm using single group of images
    local i
    for i in 1 2 3
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-b" && do_bayer=1 && shift 1
        test "$1" == "-s" && do_simple=1 && shift 1
    done
    
    local setname=${1:-""}
    local rdir=${AI_RAWDIR:-"."}
    local bad=${AI_BADPIX:-""}
    local sdat=${AI_SETS:-"set.dat"}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local ccdregion=${AI_CCDREGION:-""}  # w h xoff yoff
    local imlist=$(mktemp "$tdir/tmp_imlist_XXXXXX.dat")
    local statfile=$(mktemp "$tdir/tmp_imstat_XXXXXX.dat")
    local tmpim=$(mktemp "$tdir/tmp_im1_XXXXXX.pnm")
    #### TL: next line workaround libvips error reading stdin only
    local tmpim2=$(mktemp "$tdir/tmp_im1_XXXXXX.pnm")
    local tmpdark=$(mktemp "$tdir/tmp_dark_XXXXXX.pgm")
    local tmpmean=$(mktemp "$tdir/tmp_mean_XXXXXX.pnm")
    local mask=$(mktemp "$tdir/tmp_mask_XXXXXX.pbm")
    local ltime
    local sname
    local target
    local type
    local texp
    local n1
    local n2
    local nref
    local dark
    local flat
    local x
    local mdk
    local num
    local ext
    local fname
    local ielist
    local iolist
    local n
    local w
    local h
    local ng
    local ig
    local im
    local im2
    local mxx
    local mrgb
    local mr
    local mg
    local mb
    local xx
    local draw
    local dcrawopts
    local is_dark_subtracted
    local scale
    local flip
    local opts
    local skipset
    local tmpsh=$(mktemp "/tmp/tmp_script_XXXXXX.sh")
    chmod u+x $tmpsh

    test "$showhelp" &&
        echo "usage: AIflat [-b] [-s] [set]" >&2 &&
        return 1
    
    test "$bad" && test ! -e $bad &&
        echo "ERROR: badpix file $bad is missing." >&2 &&
        return 1

    skipset=""
    while read ltime sname target type texp n1 n2 nref dark flat x
    do
        (echo "$ltime" | grep -q "^#") && continue
        test "$type" != "f" && continue
        test "$setname" && test "$setname" != "$sname" && continue
        (! is_integer "$n1" || ! is_integer "$n2") && continue
        
        test ! "$dark" &&
            echo "ERROR: set $sname has no dark defined." && skipset=1 && continue
        test ! -f "$dark".pgm &&
            echo "ERROR: dark image $dark.pgm for set $sname not found." && skipset=1 && continue
        
        is_dark_subtracted=""
        test "$(AIsetinfo $sname | awk '{print $11}')" == "0" &&
            is_dark_subtracted=1 &&
            echo "$sname: in-camera dark subtraction assumed."

        AIimlist $sname "" raw > $imlist
        n=$(cat $imlist | wc -l)
        test $n -lt 3 &&
            echo "ERROR: set $sname has too few images ($n < 3)." &&
            rm $imlist && skipset=1 && continue
        test ! "$do_simple" && test $n -lt 6 &&
            echo "WARNING: set $sname has few images ($n < 6), using single group only." &&
            do_simple=1
        
        ext="ppm"
        fname=$(head -1 $imlist | awk '{print $3}')
        is_fits $fname && ! is_fitscube $fname && ext=pgm
        #is_fitzip $fname && ext=pgm
        test "$do_bayer" && ext="pgm"
        test -f $sname.$ext &&
            echo "WARNING: $sname.$ext exists, skipping set $sname." >&2 && continue
        

        # if necessary apply ccdregion
        dcrawopts=""
        if [ "$ccdregion" ]
        then
            is_gacam_raw "$fname" && dcrawopts="-R $ccdregion"
            w=$(echo $ccdregion | cut -d ' ' -f1)
            h=$(echo $ccdregion | cut -d ' ' -f2)
        else
            set - $(imsize "$fname")
            w=$1
            h=$2
        fi
        
        # crop dark image if necessary
        if [ "$(imsize $dark.pgm)" != "$w $h" ]
        then
            if [ "$ccdregion" ]
            then
                echo "# croping $dark.pgm to ccdregion"
                # TODO: if flip then we need to flip ccdregion as well
                imcrop -1 $dark.pgm $ccdregion > $tmpdark
            else
                echo "# croping $dark.pgm to $w $h"
                imcrop -1 $dark.pgm $w $h 0 0 > $tmpdark
            fi
        else
            cp $dark.pgm $tmpdark
        fi

        # check for in-camera dark subtraction (black=0)
        test "$is_dark_subtracted" &&
            mdk=$(AImstat $tmpdark  | awk '{printf("%d", $5+0.5)}') &&
            dcrawopts="$dcrawopts -B $mdk"
        test "$dcrawopts" && echo "# dcrawopts = $dcrawopts"

        # determine intensity scaling factor to stretch to full 16bit range
        # this is used by AIraw2gray in case of FITS images only
        scale=$(get_param camera.dat rawbits $sname | awk '{if ($1!="-" && $1<16) print 2^(16-$1)}')

        # check if top-down image flipping is required
        flip=$(get_param camera.dat flip $sname | awk '{if ($1=="1") print 1}')
        
        # options for raw image conversion
        opts="-c"   # apply AI_CCDREGION
        test "$scale" && opts=$(echo $opts "-s $scale")
        test "$flip"  && opts=$(echo $opts "-f")

        echo "processing $n flats in set $sname ..."
        echo "dark subtraction"

		cat <<EOF > $tmpsh
#!/bin/bash
. airfun.sh > /dev/null
tdir=$tdir
ext=$ext
opts="$opts"
tmpdark="$tmpdark"
bad="$bad"

AI_DCRAWPARAM="$AI_DCRAWPARAM"
dcrawopts="$dcrawopts"

_aiflat_parallel \$@
EOF

        _aiflat_parallel () {
            local num=$2
            local fname=$3
            echo "  $num"
            if [ "$ext" == "pgm" ]
            then
                AI_DCRAWPARAM="$AI_DCRAWPARAM $dcrawopts" \
                AIraw2gray $opts $fname $tdir/$num.$ext $tmpdark $bad
            else
                AI_DCRAWPARAM="$AI_DCRAWPARAM $dcrawopts" \
                AIraw2rgb  $opts $fname $tmpdark $bad > $tdir/$num.$ext
            fi
        }

        export -f _aiflat_parallel
        popts=""; test "$AI_MAXPROCS" && popts="-P $AI_MAXPROCS"
        cat $imlist | parallel $popts -k $tmpsh
        unset -f _aiflat_parallel
		# TODO: error handling
        
        # get image dimensions
        num=$(head -1 $imlist | awk '{printf("%s", $2)}')
        w=$(identify $tdir/$num.$ext | cut -d " " -f3 | cut -d "x" -f1)
        h=$(identify $tdir/$num.$ext | cut -d " " -f3 | cut -d "x" -f2)
        
        # median in even/odd images in groups of 6+ images
        ng=$(($n / 6))
        test "$do_simple" && ng=1
        ig=1; im=1
        i=0; ielist=""; iolist=""  # lists with even and odd image index
        rm -f $tdir/$sname.m[0-9][0-9].$ext
        while read x num fname x
        do
            i=$(($i+1))
            if [ "$do_simple" ]
            then
                iolist="$iolist $tdir/$num.$ext"
            else
                test $(($i %2)) -eq 0 && ielist="$ielist $tdir/$num.$ext"
                test $(($i %2)) -eq 1 && iolist="$iolist $tdir/$num.$ext"
            fi
            if ([ $ig -lt $ng ] && [ $(($i %6)) -eq 0 ]) ||
               ([ $ig -eq $ng ] && [ $i -eq $n ])
            then
                # statistics for images of this group
                echo "normalize group $ig out of $ng ..."
                if [ $do_bayer ]
                then
                    AImstat -b -c $ielist $iolist > $statfile
                    cat $statfile
                    # get mean rgb
                    mxx=$(cat $statfile | awk '{a=a+$5; b=b+$9; c=c+$13; d=d+$17}END{
                        printf("%.1f %.1f %.1f %.1f", a/NR, b/NR, c/NR, d/NR)}')
                    echo "  mean mxx = $mxx"
                else
                    AImstat -c $ielist $iolist > $statfile
                    cat $statfile
                    if [ "$ext" == "pgm" ]
                    then
                        mxx=$(mean $statfile 5 | awk '{printf("%.1f", $1)}')
                        echo "  mean mxx = $mxx"
                    else
                        # get mean rgb
                        mrgb=$(cat $statfile | awk '{r=r+$5; g=g+$9; b=b+$13}END{
                            printf("%.1f %.1f %.1f", r/NR, g/NR, b/NR)}')
                        mr=$(echo $mrgb | cut -d " " -f1)
                        mg=$(echo $mrgb | cut -d " " -f2)
                        mb=$(echo $mrgb | cut -d " " -f3)
                        echo "  mean rgb = $mrgb"
                    fi
                fi
                
                # normalize images
                if [ $do_bayer ]
                then
                    while read f x   x x a x   x x b x   x x c x   x x d x
                    do
                        xx=$(echo $mxx $a $b $c $d | awk -v l=20000 '{
                            printf("%.0f %.0f %.0f %.0f\n",
                                l*$5/$1, l*$6/$2, l*$7/$3, l*$8/$4)}')
                        echo $f $xx
                        #### TODO: next line is using tmpim2 as a workaround for libvips error
                        echo -e "P2\n2 2\n65535\n$xx" | pnmtile $w $h > $tmpim2
                            pnmccdred2 -m 20000 -s $tmpim2 $tdir/$f $tmpim &&
                            mv $tmpim $tdir/$f
                    done < $statfile
                else
                    if [ "$ext" == "pgm" ]
                    then
                        while read f x   x x a x
                        do
                            xx=$(echo "scale=4; $mxx/$a" | bc)
                            pnmccdred2 -m $xx $tdir/$f $tmpim &&
                                mv $tmpim $tdir/$f
                        done < $statfile
                    else
                        while read f x   x x r x   x x g x   x x b x
                        do
                            mulR=$(echo "scale=4; $mr/$r" | bc)
                            mulG=$(echo "scale=4; $mg/$g" | bc)
                            mulB=$(echo "scale=4; $mb/$b" | bc)
                            echo "  normalize $f: $mulR,$mulG,$mulB"
                            pnmccdred2 -m $mulR,$mulG,$mulB $tdir/$f $tmpim &&
                                mv $tmpim $tdir/$f
                        done < $statfile
                    fi
                fi
                
                # process iolist
                im2=$(printf "%02d" $im)
                if [ $n -gt 2 ]
                then
	                echo "median odd images in group $ig -> $tdir/$sname.m$im2.$ext"
                	pnmcombine2 -d $iolist $tdir/$sname.m$im2.$ext
                else
                	if [ $n -eq 2 ]
                	then
		                echo "mean from odd images in group $ig -> $tdir/$sname.m$im2.$ext"
                		pnmcombine2 $iolist $tdir/$sname.m$im2.$ext
                	else
                		cp $iolist $tdir/$sname.m$im2.$ext
                	fi
                fi
                im=$(($im + 1))
                # process ielist
                if [ "$ielist" ]
                then
                    im2=$(printf "%02d" $im)
                    echo "median even images in group $ig -> $tdir/$sname.m$im2.$ext"
                    pnmcombine2 -d $ielist $tdir/$sname.m$im2.$ext
                    im=$(($im + 1))
                fi
                ig=$(($ig+1))
                ielist=""; iolist=""
            fi
        done < $imlist
        
        # average over medians
        if [ "$do_simple" ]
        then
            mv $tdir/$sname.m01.$ext $sname.$ext
        else
            echo "average median images ..."
            pnmcombine2 $tdir/$sname.m[0-9][0-9].$ext $sname.$ext
        fi
        
        # interpolation of bad pixels
        if [ "$do_bayer" ] && [ "$bad" ]
        then
            mv $sname.$ext $tmpim
            # average 4 cells in 2 pix distance
            convert $tmpim -define convolve:scale=\! \
                -morphology Convolve Ring:1.5,2 $tmpmean
            # convert bad to mask image
            draw=$(grep -v "^#" $bad | grep "[0-9]" | awk -v w=$w -v h=$h '{
                if(found>0)printf("; ")
                if ($1<w && $2<h) {
                    printf("color %d,%d point", $1, $2)
                    found=1
                }}')
            convert $tmpim -fill black -draw 'color 1,1 reset' -fill white \
                -draw "$draw" $mask
            # replace bad pixels by interpolated pixel
            pnmcomp -alpha $mask $tmpmean $tmpim $sname.$ext
        fi

        # clean up
        rm -f $tdir/$sname.m[0-9][0-9].$ext
        while read x num fname x
        do
            rm -f $tdir/$num.$ext
        done < $imlist
    done < $sdat
    rm -f $imlist $statfile $tmpim $tmpdark $tmpmean $mask $tmpsh
    rm -f $tmpim2
    test "$skipset" && return 255
    return 0
}


# DSLR ccd image reduction (bad pixel, dark, flat)
# optionally limit to a given set name (first argument)
# it creates PPM or PGM images in $AI_TMPDIR
AIccd () {
    AIcheck_ok -r || return 255
    local showhelp
    local do_bayer          # if set then keep bayer matrix and create gray
                            # images instead of rgb
    local quality=3         # set demosaicing algorithm ("quality"):
                            # 0=bilinear, 1=VNG, 2=PPG, 3=AHD
    local add=0             # add offset to output image
    local doff=0            # offset of dark counts (FITS only)
    local is_calibrated     # if set ignore dark and flat
    local i
    for i in 1 2 3 4 5 6 7
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-z" && echo "WARNING: obsolete option -z." >&2 && shift 1
        test "$1" == "-b" && do_bayer=1 && shift 1
        test "$1" == "-q" && quality=$2 && shift 2
        test "$1" == "-a" && add=$2 && shift 2
        test "$1" == "-o" && doff=$2 && shift 2
        test "$1" == "-c" && is_calibrated=1 && shift 1
    done
    local setname=${1:-""}
    local rdir=${AI_RAWDIR:-"."}
    local bad=${AI_BADPIX:-""}
    local sdat=${AI_SETS:-"set.dat"}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local ex=${AI_EXCLUDE:-""}  # space separated list of image numbers
    local ccdregion=${AI_CCDREGION:-""}  # w h xoff yoff
    local imlist=$(mktemp "$tdir/tmp_imlist_XXXXXX.dat")
    local imlist2=$(mktemp "$tdir/tmp_imlist2_XXXXXX.dat")
    local tmpim=$(mktemp "$tdir/tmp_im_XXXXXX.pnm")
    local tmpbad=$(mktemp "$tdir/tmp_bad_XXXXXX.dat")
    local ltime
    local sname
    local target
    local type
    local texp
    local n1
    local n2
    local nref
    local dark
    local flat
    local n
    local nlist
    local ext
    local fext
    local lastdark
    local mdk
    local darkcrop
    local flatcrop
    local fnorm=10000
    local is_dark_subtracted    # black=0 indicates in-camera dark subtraction
    local x
    local num
    local fname
    local mdk
    local dcrawopts
    local bytesperpix
    local opts
    local mxx
    local mrgb
    local size
    local scale
    local flip
    local ctype
    local bayerpattern
    local lastdark
    local lastflat
    local ccdopts
    local str
    local npp
    local popts
    local retval=0
    local tmpsh=$(mktemp "/tmp/tmp_script_XXXXXX.sh")
    chmod u+x $tmpsh

    test "$showhelp" &&
        echo "usage: AIccd [-b] [-q quality|$quality] [-o doff] [-a add] [-c] [set]" >&2 &&
        return 1
    
    test "$bad" && test ! -e $bad &&
        echo "ERROR: badpix file $bad is missing." >&2 &&
        return 1

    while read ltime sname target type texp n1 n2 nref dark flat x
    do
        (echo "$ltime" | grep -q "^#") && continue
        echo "$ltime" | grep -q "^[0-9][0-9]:[0-9][0-9]$" || continue
        test "$type" != "o" && test "$type" != "s" && continue
        test "$setname" && test "$setname" != "$sname" && continue
        (! is_integer "$n1" || ! is_integer "$n2") && continue
        
        # get some camera related settings
        # determine intensity scaling factor to stretch to full 16bit range
        # this is used by AIraw2rgb in case of FITS images only
        scale=$(get_param camera.dat rawbits $sname | awk '{if ($1!="-" && $1<16) print 2^(16-$1)}')
        
        # check if top-down image flipping is required
        flip=$(get_param camera.dat flip $sname | awk '{if ($1=="1") print 1}')
        
        # get bayer matrix pattern from column ctype in camera.dat
        ctype=$(get_param camera.dat ctype $sname)
        bayerpattern=$(echo $ctype | grep -vwE "CCD|CMOS|DSLR")
        
        # if necessary convert hotpixel image file to text file suitable for dcraw
        if [ "$bad" ] && [ "$ctype" == "DSLR" ] && is_png $bad
        then
            convert $bad pbm:- | AIval -a -c -1 - > $tmpbad
            bad=$tmpbad
        fi
        
        # determine extension of output images
        ext=ppm
        test "$do_bayer" && ext=pgm
        if [ ! "$bayerpattern" ]
        then
            fname=$(get_rawfile $nref)
            is_fits $fname && ! is_fitscube $fname && ext=pgm
            is_fitzip $fname && ext=pgm
        fi

        # check if all images of this set have been processed already
        AIimlist -q $sname "" raw > $imlist
        while read x num fname x
        do
            test -f $tdir/$num.$ext && test -s $tdir/$num.$ext && continue
            echo $num
        done < $imlist > $imlist2
        ! test -s $imlist2 &&
            echo "WARNING: all images in $sname are calibrated already" >&2 &&
            continue

        # check if dslr raw file is already dark subtracted
        fname=$(get_rawfile $nref)
        is_dark_subtracted=""
        is_raw $fname && test ! "$is_calibrated" && test "$(AIsetinfo $sname | awk '{print $11}')" == "0" &&
            is_dark_subtracted=1 &&
            echo "# $sname: in-camera dark subtraction assumed."
        
        # check if images are calibrated
        test "$dark" == "cal" && test "$flat" == "cal" &&
            is_calibrated=1 &&
            echo "# $sname: calibrated images (ignoring dark, flat)."
        
        # determine size of output images of this set
        ccdopts=""
        if [ "$ccdregion" ]
        then
            is_gacam_raw "$fname" && ccdopts="-R $ccdregion" # passed over to dcraw
            w=$(echo $ccdregion | cut -d ' ' -f1)
            h=$(echo $ccdregion | cut -d ' ' -f2)
        else
            set - $(imsize "$fname")
            w=$1
            h=$2
        fi
        test "$ccdopts" && echo "# dcrawopts = $ccdopts"
        
            
        # check for darks and flats
        darkcrop=""
        flatcrop=""
        lastdark=""
        mdk=0
        AIimlist $sname "" raw > $imlist
        while read x num fname x dark flat x
        do
            test -f $tdir/$num.$ext && test -s $tdir/$num.$ext &&
                echo "image $num.$ext already processed." >&2 &&
                continue
            
            echo $ex | grep -q -w $num - && echo "excluding image $num." >&2 && continue

            test "$is_calibrated" && echo $num $fname && continue

            # check dark and flat
            (test ! "$dark" || test "$dark" == "-") &&
                echo "ERROR: set $sname has no dark defined." >&2 &&
                return 255
            test ! -f "$dark".pgm &&
                echo "ERROR: dark image $dark.pgm for set $sname not found." >&2 &&
                return 255
            (test ! "$flat" || test "$flat" == "-") &&
                echo "ERROR: set $sname has no flat defined." >&2 &&
                return 255
            test "$do_bayer" && test ! -f "$flat".pgm &&
                echo "ERROR: flat image $flat.pgm for set $sname not found." >&2 &&
                return 255
            test ! -f "$flat".pgm && test ! -f "$flat".ppm &&
                echo "ERROR: flat image $flat.p[gp]m for set $sname not found." >&2 &&
                return 255

            # crop dark image if necessary
            darkcrop=$tdir/$dark.crop.pgm
            test -s "$darkcrop" && test $dark.pgm -nt $darkcrop &&
                echo "# update darkcrop ($dark.pgm has changed)" &&
                rm -f "$darkcrop"
            if [ ! -s  "$darkcrop" ] || [ "$(imsize $darkcrop)" != "$w $h" ]
            then
                if [ "$(imsize $dark.pgm)" != "$w $h" ]
                then
                    if [ "$ccdregion" ]
                    then
                        echo "# croping $dark.pgm to ccdregion" >&2
                        # TODO: if flip then we need to flip ccdregion as well
                        imcrop -1 $dark.pgm $ccdregion > $darkcrop
                    else
                        echo "# croping $dark.pgm to $w $h" >&2
                        imcrop -1 $dark.pgm $w $h 0 0 > $darkcrop
                    fi
                else
                    cp $dark.pgm $darkcrop
                fi
            fi
            
            # get mean value of dark
            test "$dark" != "$lastdark" &&
            test "$is_dark_subtracted" &&
                mdk=$(AImstat $darkcrop | awk '{printf("%d", $5+0.5)}') &&
                echo "  $dark: mdk = $mdk" >&2
            lastdark=$dark

            # crop flat image if necessary
            test -f $flat.pgm && fext=pgm && flatcrop=$tdir/$flat.crop.pgm
            test -f $flat.ppm && fext=ppm && flatcrop=$tdir/$flat.crop.ppm
            test -s "$flatcrop" && test $flat.$fext -nt "$flatcrop" &&
                echo "# update flatcrop ($flat.$fext has changed)" &&
                rm -f "$flatcrop"
            if [ ! -e  "$flatcrop" ]
            then
                if [ "$(imsize $flat.$fext)" != "$w $h" ]
                then
                    if [ "$ccdregion" ]
                    then
                        echo "# croping $flat.$fext to ccdregion" >&2
                        # TODO: if flip then we need to flip ccdregion as well
                        imcrop -1 $flat.$fext $ccdregion > $tmpim
                    else
                        echo "# croping $flat.$fext to $w $h" >&2
                        imcrop -1 $flat.$fext $w $h 0 0 > $tmpim
                    fi
                else
                    cp $flat.$fext $tmpim
                fi
                
                # normalize flat to value fnorm
                if is_pgm $tmpim
                then
                    printf "  $flat: " >&2
                    AIbnorm $tmpim > $flatcrop
                else
                    mrgb=$(AImstat -c $tmpflat | awk '{
                        if ($13=="") {print $3" "$4" "$5} else {print $5" "$9" "$13}}')
                    echo "  $flat: mrgb = $mrgb" >&2
                    mult=$(echo $mrgb | awk -v x=$fnorm '{
                        printf("%.5f", x/$1)
                        if (NF>1) printf(",%.5f,%.5f", x/$2, x/$3)
                        }')
                    pnmccdred -m $mult $tmpim $flatcrop
                fi
            fi
            
            # check sizes of dark and flat
            test "$(imsize $darkcrop)" != "$(imsize $flatcrop)" &&
                echo "ERROR: size mismatch between dark and flat" >&2 &&
                return 255
            
            echo $num $fname $darkcrop $flatcrop $mdk
        done < $imlist > $imlist2
        test ! -s $imlist2 && continue
        
        # check disk space requirements
        bytesperpix=6
        test "$ext" == "pgm" && bytesperpix=2
        dark=$(head -1 $imlist | awk '{printf("%s", $5)}')
        test ! "$is_calibrated" && ! is_diskspace_ok "$tdir" "$dark.pgm" $n $bytesperpix &&
            echo "ERROR: not enough disk space to process set $sname." &&
            retval=255 && continue
        echo "processing $(cat $imlist2 | wc -l) images in set $sname ..."
        
        # ccd reduction
        opts="-c"   # apply AI_CCDREGION
        test "$scale" && opts=$(echo $opts "-s $scale")
        test "$flip"  && opts=$(echo $opts "-f")
        test "$doff"  && opts=$(echo $opts "-o $doff")
        test -z "$do_bayer" && test "$bayerpattern" &&
            opts=$(echo $opts "-b $bayerpattern")

		cat <<EOF > $tmpsh
#!/bin/bash
. airfun.sh > /dev/null
quality=$quality
add=$add

tdir=$tdir
ext=$ext
ccdopts="$ccdopts"
bad="$bad"
opts="$opts"
fnorm=$fnorm
bayerpattern="$bayerpattern"
do_bayer="$do_bayer"

_aiccd_parallel \$@
EOF

        _aiccd_parallel () {
            local num=$1
            local fname=$2
            local dark=$3
            local flat=$4
            local mdk=$5
            local dcrawopts="$ccdopts"
            local retval=0

            test "$mdk" && test $mdk -gt 0 && dcrawopts="$dcrawopts -B $mdk" &&
            echo "  $num" >&2
            
            # monochrome image
            if [ "$do_bayer" ] || [ "$ext" == "pgm" ] || (is_fits $fname && test -z "$bayerpattern")
            then
                test "$AI_DEBUG" && echo "AI_DCRAWPARAM=\"$AI_DCRAWPARAM $dcrawopts\" \
                    AIraw2gray $opts -a $add $fname $tdir/$num.$ext \"$dark\" \"$bad\" \"$flat\""
                AI_DCRAWPARAM="$AI_DCRAWPARAM $dcrawopts" \
                AIraw2gray $opts -a $add $fname $tdir/$num.$ext "$dark" "$bad" "$flat"
                retval=$?
            fi
            (test "$do_bayer" || test "$ext" == "pgm" || (is_fits $fname && test -z "$bayerpattern")) &&
                return $retval
            
            # RGB image
            if is_pgm $flat || [ -z "$flat" ]
            then
                test "$AI_DEBUG" && echo "AI_DCRAWPARAM=\"$AI_DCRAWPARAM $dcrawopts\" \
                AIraw2rgb $opts -a $add -q $quality $fname \"$dark\" \"$bad\" \"$flat\" > $tdir/$num.$ext"
                AI_DCRAWPARAM="$AI_DCRAWPARAM $dcrawopts" \
                AIraw2rgb $opts -a $add -q $quality $fname "$dark" "$bad" "$flat" > $tdir/$num.$ext
                retval=$?
            else
                test "$AI_DEBUG" && echo "AI_DCRAWPARAM=\"$AI_DCRAWPARAM $dcrawopts\" \
                AIraw2rgb $opts -a $add -q $quality $fname \"$dark\" \"$bad\"  | \
                    pnmccdred -s \"$flat\" -m $fnorm - $tdir/$num.$ext"
                AI_DCRAWPARAM="$AI_DCRAWPARAM $dcrawopts" \
                AIraw2rgb $opts -a $add -q $quality $fname "$dark" "$bad" | \
                    pnmccdred -s "$flat" -m $fnorm - $tdir/$num.$ext
                retval=$?
            fi
            return $retval
		}

        if [ "$AI_NOPARALLEL" ]
        then
            echo "# WARNING: GNU parallel is disabled" >&2
            i=0;
            npp=${AI_MAXPROCS}
            test -z "$npp" && npp=$(grep "^processor" /proc/cpuinfo | wc -l)
            while read
            do
                i=$((i+1))
                _aiccd_parallel $REPLY &
                eval BGPID$i=$!
                if [ $i -eq $npp ] || [ "$REPLY" == "$(tail -1 $imlist2)" ]
                then
                    npp=$i
                    str=$(for i in $(seq 1 $npp); do echo $[BGPID$i]; done)
                    echo "waiting for bg jobs" $str "..." >&2
                    i=0
                    wait $str
                fi
            done < $imlist2
        else
            export -f _aiccd_parallel
            popts=""; test "$AI_MAXPROCS" && popts="-P $AI_MAXPROCS"
            #cat $imlist2 | parallel $popts -k $tmpsh
            cat $imlist2 | parallel $popts $tmpsh
    		# TODO: error handling
            unset -f _aiccd_parallel
        fi

    done < $sdat
    test "$AI_DEBUG"    && echo $imlist $imlist2 $tmpim $tmpbad $tmpsh >&2
    test -z "$AI_DEBUG" && rm -f $imlist $imlist2 $tmpim $tmpbad $tmpsh
    return $retval
}


# source extraction
# requires PPM/PGM images as produced by AIccd in $AI_TMPDIR
# creates sources data files in directory measure
# note on bayer images: single color images g1 or g2 are heavily undersampled
#   resulting in poor detections, therefore we operate on g1+g2 and replace
#   b1,r1 by average of 4 surrounding green pixel values
AIsource () {
    #AIcheck_ok || return 255
    local showhelp
    local quiet         # if set suppress messages from sextractor
    local color         # if set then extract given color channel, either 1,2,3
                        # for r,g,b or g to use gray conversion, default is to
                        # process all channels
    local outascii      # change results file format to ASCII_HEAD (default FITS-LDAC)
    local outname
    local do_bayer      # if set then use g1/g2 from bayer matrix of gray
                        # input images (produced by AIccd -b)
    local do_crossmatch # if set then associate detections in different color
                        # bands (NOT implemented yet!)
    local dbnthresh     # Number of deblending sub-thresholds
    local dbmincont     # Minimum contrast parameter for deblending
    local fwhm=4        # FWHM in pix (used to auto set dbnthresh and dbmincont)
    local fwhmarg
    local sparam        # additional sextractor parameters
    local i
    for i in $(seq 1 7)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-q" && quiet=1 && shift 1
        (test "$1" == "-1" || test "$1" == "-2" || test "$1" == "-3" || \
            test "$1" == "-g") && color=${1#-} && shift 1
        test "$1" == "-a" && outascii=1 && shift 1
        test "$1" == "-o" && outname=$2 && shift 2
        test "$1" == "-b" &&
            echo "WARNING: using deprecated option -b." >&2 && do_bayer=1 && shift 1
        test "$1" == "-x" && do_crossmatch=1 && shift 1
        test "$1" == "-dbn" && dbnthresh=$2 && shift 2
        test "$1" == "-dbc" && dbmincont=$2 && shift 2
        test "$1" == "-f" && fwhm=$2 && fwhmarg=1 && shift 2
        test "$1" == "-s" && sparam=$2 && shift 2
    done
    local setname=${1:-""}
    local use_isophotes=${2:-""} # use isophotes for object shape instead of
                                 # windowed measurements (sextractor)
    local threshold=${3:-10}     # detection threshold (sextractor)
    local bgsize=${4:-"64"}      # bg mesh size used for bg subtraction
    local sdat=${AI_SETS:-"set.dat"}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local imlist=$(mktemp "$tdir/tmp_imlist_XXXXXX.dat")
    local sfits=$(mktemp "$tdir/tmp_im_XXXXXX.fits")
    local g12img=$(mktemp "$tdir/tmp_g12img_XXXXXX.pgm")
    local assoclist=$(mktemp "$tdir/tmp_assoc_XXXXXX.dat")
    local tmpcat=$(mktemp "$tdir/tmp_scat_XXXXXX.dat")
    local saturation            # saturation in ADU (scaled to 16bit)
    local gain                  # effective gain in e-/ADU
    local magzero               # magzero for texp=1
    local hdr
    local sname
    local target
    local type
    local texp
    local n1
    local n2
    local nref
    local dark
    local flat
    local singleimage
    local inext
    local setparam
    local pixscale
    local sopts
    local assocopts
    local nexp
    local mag0
    local w
    local h
    local telid
    local x
    local tmpsh=$(mktemp "/tmp/tmp_script_XXXXXX.sh")
    chmod u+x $tmpsh

    sopts="-backphoto_type local -filter N $sparam"
    test "$quiet" && sopts="-verbose_type quiet $sopts"
    
    test "$showhelp" &&
        echo "usage: AIsource [-q] [-a] [-o outname] [-b] [-1|2|3|g]" \
            "[-dbn dbnthresh] [-dbc dbmincont] [-f fwhm|$fwhm] [-s sparam]" \
            " [set|img] [use_isophotes] [thres|$threshold] [bgsize|$bgsize]" >&2 &&
        return 1
    # <200826
    false && test "$showhelp" &&
        echo "usage: AIsource [-q] [-a] [-o outname] [-b] [-1|2|3|g] [set|img]" \
            "[use_isophotes] [thres|$threshold]" \
            "[bgsize|$bgsize] [dbnthresh|$dbnthresh] [dbmincont|$dbmincont]" \
            "[fwhm\"|$fwhm] [sparam|$sparam]" >&2 &&
        return 1
    # <130611
    false && test "$showhelp" &&
        echo "usage: AIsource [set|img] [use_isophotes] [thres|$threshold]"\
            "[bgsize|$bgsize] [fwhm\"|$fwhm] [magzero|$magzero] [gain|$gain]" >&2 &&
        return 1

    # experimental features
    test "$do_crossmatch" &&
        echo "WARNING: using experimental feature is highly discouraged!" >&2 &&
        echo "    continue in 10 seconds ..." >&2 &&
        sleep 10

    # determine deblending parameters according to fwhm
    if [ -z "$dbnthresh" ] || [ -z "$dbmincont" ]
    then
        x=$(echo $fwhm | awk '{printf("%.0f", $1*10)}')
        if [ -z "$dbnthresh" ]
        then
            dbnthresh=32
            test $x -gt 50 && dbnthresh=16
            test $x -gt 80 && dbnthresh=8        
        fi
        if [ -z "$dbmincont" ]
        then
            dbmincont=0.003
            test $x -gt 40 && dbmincont=0.005
            test $x -gt 50 && dbmincont=0.01
            test $x -gt 60 && dbmincont=0.015
            test $x -gt 70 && dbmincont=0.02
            test $x -gt 80 && dbmincont=0.03
            test $x -gt 90 && dbmincont=0.05
            test $x -gt 100 && dbmincont=0.1
        fi
        test "$fwhmarg" && test -z "$quiet" &&
            echo "# using dbnthresh=$dbnthresh dbmincont=$dbmincont" >&2
    fi
    # sextractor parameters
    sconf=$tdir/sex.config
    sex -d > $sconf
    fields=$tdir/sex.fields
    if [ "$use_isophotes" ]
    then
        echo NUMBER EXT_NUMBER X_IMAGE Y_IMAGE ERRX2_IMAGE ERRY2_IMAGE \
        A_IMAGE B_IMAGE THETA_IMAGE ERRA_IMAGE ERRB_IMAGE \
        ERRTHETA_IMAGE ELONGATION FWHM_IMAGE \
        MAG_AUTO MAGERR_AUTO FLUX_AUTO FLUXERR_AUTO FLUX_RADIUS \
        FLAGS FLAGS_WEIGHT | tr ' ' '\n' > $fields
    else
        echo NUMBER EXT_NUMBER XWIN_IMAGE YWIN_IMAGE ERRX2_IMAGE ERRY2_IMAGE \
        AWIN_IMAGE BWIN_IMAGE THETAWIN_IMAGE ERRAWIN_IMAGE ERRBWIN_IMAGE \
        ERRTHETAWIN_IMAGE ELONGATION FWHM_IMAGE \
        MAG_AUTO MAGERR_AUTO FLUX_AUTO FLUXERR_AUTO FLUX_RADIUS \
        FLAGS FLAGS_WEIGHT | tr ' ' '\n' > $fields
    fi
    sopts="-parameters_name $fields -back_size $bgsize
        -deblend_nthresh $dbnthresh -deblend_mincont $dbmincont
        -seeing_fwhm 4
        $sopts"
    assocopts="-assoc_name $assoclist -assoc_radius 1 -assoc_type nearest -assoc_data 0"
    if [ "$outascii" ]
    then
        sopts="$sopts -catalog_type ASCII_HEAD"
    else
        sopts="$sopts -catalog_type FITS_LDAC"
    fi


    if [ -f "$setname" ]
    then
        ! (is_fits $setname || is_pnm $setname) &&
            echo "ERROR: $setname is not a recogniced file type (FITS|PNM)." >&2 &&
            rm -f $imlist $sfits &&
            return 255
        
        test -z "$outname" && outname=$(basename ${setname%.*}.src.dat)

        # try to read some keywords from $img.head
        hdr=${setname%.*}.head
        texp=""     # exposure time in sec
        nexp=""     # number of exposures that have been averaged
        if [ -f $hdr ]
        then
            texp=$(grep "^EXPTIME" $hdr | tr '=' ' ' | awk '{if ($2>0) printf("%d", 1*$2)}')
            nexp=$(grep "^NEXP" $hdr | tr '=' ' ' | awk '{if ($2>0) printf("%d", $2)}')
            gain=$(grep "^GAIN" $hdr | tr '=' ' ' | awk '{if ($2>0) printf("%.3f", 1*$2)}')
            magzero=$(grep "^MAGZERO" $hdr | tr '=' ' ' | awk '{if ($2>0) printf("%.2f", $2)}')
            saturation=$(grep "^SATURATE" $hdr | tr '=' ' ' | awk '{if ($2>0) printf("%.2f", $2)}')
            pixscale=$(get_wcspscale $hdr)
            telid=$(get_header -q $hdr AI_TELID)
            if [ "$telid" ]
            then
                test -z "$gain"       && gain=$(get_param       camera.dat gain     $telid)
                test -z "$pixscale"   && pixscale=$(get_param   camera.dat pixscale $telid)
                test -z "$magzero"    && magzero=$(get_param    camera.dat magzero  $telid) &&
                    set_header $hdr MAGZERO=$magzero
                test -z "$saturation" && saturation=$(get_param camera.dat satur    $telid) &&
                    set_header $hdr SATURATE=$saturation
            fi
        fi
        test -z "$texp"   && texp=1
        test -z "$nexp"   && nexp=1

        # read data from environment
        test "$AI_SATURATION"   && saturation=$AI_SATURATION
        test "$AI_GAIN"         && gain=$AI_GAIN
        test "$AI_PIXSCALE"     && pixscale=$AI_PIXSCALE
        test "$AI_MAGZERO"      && magzero=$AI_MAGZERO
        
        sdat=$tdir/tmp_set_$$.dat
        echo "00:00 $setname xx o $texp 0 0 0 xx xx xx" > $sdat

        singleimage="y"
    else
        test ! -d measure && mkdir measure
        nexp=1
    fi

    while read ltime sname target type texp n1 n2 nref dark flat x
    do
        (echo "$ltime" | grep -q "^#") && continue
        test "$type" != "o" && continue
        test "$setname" && test "$setname" != "$sname" && continue
        (! is_integer "$n1" || ! is_integer "$n2") && continue

        inext=""
        if [ "$singleimage" != "y" ]
        then
            test -z "$(AIimlist -q $sname)" &&
                echo "WARNING: skipping set $sname (missing lights)" && continue
            AIimlist $sname > $imlist
            n=0; nlist=""
            while read x num fname x
            do
                test -z "$inext" && is_pgm $fname && inext="pgm"
                test -z "$inext" && inext="ppm"
                if [ "$do_bayer" ]
                then
                    test ! -f "$tdir/$num.pgm" &&
                        echo "ERROR: $tdir/$num.pgm not found." >&2 && n=0 && break
                    test -f "measure/$num.src.dat" &&
                        echo "WARNING: skipping $num, measure/$num.src.dat exists." >&2 &&
                        continue 
                else
                    test ! -f "$tdir/$num.$inext" &&
                        echo "ERROR: $tdir/$num.$inext not found." >&2 && n=0 && break
                    test -f "measure/$num.src.dat" &&
                        echo "WARNING: skipping $num, measure/$num.src.dat exists." >&2 &&
                        continue 
                fi
                n=$(($n + 1))
                nlist="$nlist $num"
            done < $imlist
            test $n -eq 0 && echo "WARNING: skipping set $sname" && continue
            echo "processing $n images in set $sname ..."

            # read data from camera.dat or environment
            get_telescope $sname > /dev/null
            test $? -ne 0 && continue
            saturation=$(get_param camera.dat satur    $sname AI_SATURATION)
            gain=$(get_param       camera.dat gain     $sname AI_GAIN)
            pixscale=$(get_param   camera.dat pixscale $sname AI_PIXSCALE)
            magzero=$(get_param    camera.dat magzero  $sname AI_MAGZERO)
        fi
        
        # set parameters depending on set name (e.g. pixscale, magzero)
        setparam=""
        test "$gain"       && setparam="$setparam -gain $gain"
        test "$saturation" && setparam="$setparam -satur_level $saturation"
        test "$pixscale"   && setparam="$setparam -pixel_scale $pixscale"
        test -z "$magzero" &&
            echo "WARNING: magzero unknown, using 25.5" >&2 && magzero=25.5
        mag0=$(echo $magzero $texp $nexp | awk '{
            printf("%.2f\n", $1+2.5/log(10)*log($2/$3))}')
        setparam="$setparam -mag_zeropoint $mag0"
        if [ ! "$singleimage" ]
        then
            echo "# texp=$texp nexp=$nexp gain=$gain pixscale=$pixscale" \
                "magzero=$magzero saturation=$(echo $saturation | awk '{printf("%.0f", $1)}')" >&2
        fi

        if [ "$singleimage" == "y" ]
        then
            sopts="$sopts -detect_thresh $threshold"
            if is_pnm "$setname"
            then
                if is_pgm "$setname"
                then
                    if [ "$do_bayer" ]
                    then
                        w=$(identify $setname | cut -d " " -f3 | cut -d "x" -f1)
                        h=$(identify $setname | cut -d " " -f3 | cut -d "x" -f2)
                        echo -e "P2\n2 2\n1\n0 1 1 0" | pnmtile $w $h - | \
                            pnmarith -mult - $setname > $g12img
                        convert $g12img -morphology Convolve "$kernel" pgm:- | \
                            pnmarith -add $g12img - | pnmtomef - > $sfits
                    else
                        pnmtomef "$setname" > $sfits
                    fi
                    sex -c $sconf $setparam $sopts -catalog_name $outname $sfits
                    test $? -ne 0 && echo "ERROR: sex failed." >&2 && return 255
                else
                    if [ "$color" ]
                    then
                        case "$color" in
                            # old: ppm2gray -f "$setname" "1,0,0" > $sfits;;
                            1)  gm convert "$setname" -channel Red   pgm:- | pnmtomef - > $sfits;;
                            2)  gm convert "$setname" -channel Green pgm:- | pnmtomef - > $sfits;;
                            3)  gm convert "$setname" -channel Blue  pgm:- | pnmtomef - > $sfits;;
                            g)  ppm2gray -f "$setname" > $sfits;;
                        esac
                        sex -c $sconf $setparam $sopts -catalog_name $outname $sfits
                        test $? -ne 0 && echo "ERROR: sex failed." >&2 && return 255
                    else
                        if [ "$do_crossmatch" ]
                        then
                            # G
                            # old: ppm2gray -f "$setname" "0,1,0" > $sfits
                            gm convert "$setname" -channel Green pgm:- | pnmtomef - > $sfits
                            #echo sex -c $sconf $setparam $sopts -catalog_name $outname $sfits >&2
                            sex -c $sconf $setparam $sopts -catalog_name $outname $sfits
                            test $? -ne 0 && echo "ERROR: sex failed." >&2 && return 255
                            sexselect $outname "" "" "" "" "NUMBER,X*,Y*,MAG_AUTO" > $assoclist
                            echo "VECTOR_ASSOC()" >> $fields
                            # R
                            gm convert "$setname" -channel Red   pgm:- | pnmtomef - > $sfits
                            sex -c $sconf $setparam $sopts $assocopts -catalog_name $tmpcat $sfits
                            test $? -ne 0 && echo "ERROR: sex failed." >&2 && return 255
                            echo "G=$outname R=$tmpcat" >&2
                            echo "WARNING: further processing needed ..."
                            return
                            # merge tables $outname and $tmpcat, rename to $outname
                            gm convert "$setname" -channel Blue  pgm:- | pnmtomef - > $sfits
                            sex -c $sconf $setparam $sopts $assocopts -catalog_name $tmpcat $sfits
                            test $? -ne 0 && echo "ERROR: sex failed." >&2 && return 255
                            # merge tables $outname and $tmpcat, rename to $outname
                        else
                            pnmtomef "$setname" > $sfits
                            sex -c $sconf $setparam $sopts -catalog_name $outname $sfits
                            test $? -ne 0 && echo "ERROR: sex failed." >&2 && return 255
                        fi
                    fi
                fi
            else
                # TODO: try to read exposure time from FITS header and adjust magzero
                sex -c $sconf $setparam $sopts -catalog_name $outname $setname
                test $? -ne 0 && echo "ERROR: sex failed." >&2 && return 255
            fi
        else
            # TODO: if requested increase threshold based on object counts
            #   in $tdir/$nref.$inext
            sopts="$sopts -detect_thresh $threshold"
            inext=""
            test -f $tdir/$nref.pgm && inext="pgm"
            test -f $tdir/$nref.ppm && inext="ppm"
			w=$(identify $tdir/$nref.$inext | cut -d " " -f3 | cut -d "x" -f1)
			h=$(identify $tdir/$nref.$inext | cut -d " " -f3 | cut -d "x" -f2)
			# echo $num $w $h
			cat <<EOF > $tmpsh
#!/bin/bash
. airfun.sh > /dev/null
tdir=$tdir
w=$w
h=$h
inext=$inext
color=$color
do_bayer="$do_bayer"
sconf=$sconf
setparam="$setparam"
sopts="$sopts"
_run_parallel \$@
EOF

            _run_parallel () {
				local num=$1
                local outname=measure/$num.src.dat
				local sfits=$(mktemp "$tdir/tmp_im_${num}_XXXXXX.fits")
				local g12img=$(mktemp "$tdir/tmp_g12img_${num}_XXXXXX.pgm")
                if [ -z "$color" ]
                then
                    if [ "$do_bayer" ]
                    then
                        echo -e "P2\n2 2\n1\n0 1 1 0" | pnmtile $w $h - | \
                            pnmarith -mult - $tdir/$num.pgm > $g12img
                        convert $g12img -morphology Convolve \
                            "3x3: 0.0,0.25,0.0  0.25,0.0,0.25   0.0,0.25,0.0" pgm:- | \
                            pnmarith -add $g12img - | pnmtomef - > $sfits
                    else
                        pnmtomef $tdir/$num.$inext > $sfits
                    fi
                else
                    if [ "$inext" == "ppm"]
                    then
                        case "$color" in
                            # old: ppm2gray -f $tdir/$num.ppm "1,0,0" > $sfits;;
                            1)  gm convert $tdir/$num.ppm -channel Red   pgm:- | pnmtomef - > $sfits;;
                            2)  gm convert $tdir/$num.ppm -channel Green pgm:- | pnmtomef - > $sfits;;
                            3)  gm convert $tdir/$num.ppm -channel Blue  pgm:- | pnmtomef - > $sfits;;
                            g)  ppm2gray -f $tdir/$num.ppm > $sfits;;
                        esac
                    else
                        pnmtomef $tdir/$num.$inext > $sfits
                    fi
                fi
                sex -c $sconf -verbose_type quiet \
                    $setparam $sopts \
                    -catalog_name $outname $sfits
                test $? -ne 0 && echo "ERROR: sex failed." >&2 && return 255
                rm -f $sfits $g12img
            }
            
			if [ "$nlist" ]
			then
				export -f _run_parallel
				parallel -k $tmpsh ::: $nlist
				unset -f _run_parallel
			fi
        fi
    done < $sdat
    rm -f $fields $sconf $imlist $sfits $g12img $tmpcat $assoclist
    test "$singleimage" && rm $sdat
    return 0
}


# register stars with respect to reference image
# output: results are written to stdout
# input: requires sources data files in directory measure
# notes:
#   - if no images are found in $AI_TMPDIR and $AI_RAWDIR then use n1 and n2
#     to guess relevant source cataloges
#   - if header files are not found ($AI_RAWDIR) some header data
#     might not be propagated to measure/<num>.src.head (e.g. ra, de)
AIregister () {
    AIcheck_ok || return 255
    local showhelp
    local coloropt      # set color channel to use (1 or 2 or 3) if
                        # source catalog contains multiple ext_numbers
                        # default: 2
    local has_poor_pos  # if set allow for larger errors on position
    local do_show_processed # if set results from previous registration are
                        # shown
    local mdiff=0.2     # allowed mag diff between images
    local nbright=250   # number of brightmost stars to use for matching
    local mres          # match_resol in arcsec 0=auto (default: 3*pixscale)
    local quiet         # if set suppress output of some warnings
    for i in $(seq 1 8)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        (test "$1" == "-1" || test "$1" == "-2" || test "$1" == "-3") &&
            coloropt=$1 && shift 1
        test "$1" == "-p" && has_poor_pos=1 && shift 1
        test "$1" == "-s" && do_show_processed=1 && shift 1
        test "$1" == "-m" && mdiff=$2 && shift 2
        test "$1" == "-n" && nbright=$2 && shift 2
        test "$1" == "-r" && mres=$2 && shift 2
        test "$1" == "-q" && quiet=1 && shift 1
    done
    local setname=${1:-""}
    local refimg=${2:-""}
    local magerrlim=${3:-"0.03"}
    local scampopts=${4:-""}
    local sdat=${AI_SETS:-"set.dat"}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local rdir=${AI_RAWDIR:-"."}
    local exifdat="exif.dat"
    local rawfilesdat="rawfiles.dat"
    local conf=$(mktemp "$tdir/tmp_sconf_XXXXXX.txt")
    local refldac=$(mktemp "$tdir/tmp_refldac_XXXXXX.fits")
    local xyref=$(mktemp "$tdir/tmp_xyref_XXXXXX.dat")
    local wcscat=$(mktemp "$tdir/tmp_wcscat_XXXXXX.fits")
    local ahead=$(mktemp "$tdir/tmp_ahead_XXXXXX.dat")
    local sname
    local type
    local nref
    local dark
    local mycolor
    local has_hline
    local refcat
    local acat
    local singleimage
    local w
    local h
    local cx
    local cy
    local pixscale
    local pscale
    local crad
    local posmaxerr
    local anglemaxerr
    local snhigh
    local mref
    local nsrc
    local nmatch
    local nhigh
    local nmag
    local filter
    local line
    local refroll   # refroll=1 if ref image has IMGROLL=Y, otherwise 0
    local imgroll   # imgroll=1 if image has IMGROLL=Y, otherwise 0
    local x
    local nmax
    local mm
    local rfile
    local popts
    local tmpsh=$(mktemp "/tmp/tmp_script_XXXXXX.sh")
    chmod u+x $tmpsh
    
    test "$showhelp" &&
        echo "usage: AIregister [-1|2|3] [-p] [-s] [-v] [-m mdiff|$mdiff] [-n nbright|$nbright] [-r match_resol]" \
            "[set|img] [refimg] [magerrlim|$magerrlim] [scampopts|$scampopts]" >&2 &&
        return 1

    # some checkings
    test "$refimg" && test ! -f $refimg &&
        echo "ERROR: reference image $refimg not found." >&2 && return 255

    if [ -f "$setname" ]
    then
        ! is_pnm "$setname" &&
            echo "ERROR: $setname is not a recogniced file type (PNM)." >&2 &&
            rm -f $sfits &&
            return 255
        test -z "$refimg" &&
            echo "ERROR: ref image argument missing." >&2 && return 255

        # try to read some keywords from $img.head
        hdr=${setname%.*}.head
        if [ -f $hdr ]
        then
            pixscale=$(get_wcspscale $hdr)
        fi
        test "$AI_PIXSCALE" && pixscale=$AI_PIXSCALE

        sdat=$tdir/tmp_set_$$.dat
        echo "00:00 $setname xx o 0 0 0 $refimg xx xx xx" > $sdat
        singleimage="y"
    else
        test ! -d measure && mkdir measure
    fi

    # high s/n detection level
    snhigh=$(echo $magerrlim | awk '{x=1.2/$1; if(x<10) {x=10}; printf("%d", x)}')
    
    while read ltime sname target type texp n1 n2 nref dark flat x
    do
        (echo "$ltime" | grep -q "^#") && continue
        test "$type" != "o" && test "$type" != "s" && continue
        test "$setname" && test "$setname" != "$sname" && continue
        (! is_integer "$n1" || ! is_integer "$n2") && continue
        test -z "$singleimage" && ! is_integer "$nref" &&
            echo "ERROR: nref for $sname undefined, skipping set." >&2 && return 255
        
        # check for refcat
        refcat=""
        if [ "$singleimage" ]
        then
            test -f "${refimg%.*}.src.dat" && refcat="${refimg%.*}.src.dat"
        else
            test -z "$refcat" &&
                test -f "measure/$(basename $nref.src.dat)" &&
                refcat="measure/$(basename $nref.src.dat)"
        fi
        test -z "$refcat" &&
            echo "ERROR: reference catalog $nref.src.dat not found." >&2 && return 255
        
        # check for raw image header file
        rfile=$(get_rawfile $nref)
        test -z "$rfile" &&
            echo "ERROR: no entry for $nref in $exifdat/$rawfilesdat." >&2 &&
            return 255
        false && test ! -f ${rfile%.*}.hdr && ! is_fits "$rfile" && ! is_fitzip "$rfile" &&
            echo "WARNING: missing raw header files, some keywords will be missing." >&2
        
        if [ ! "$singleimage" ]
        then
            nlist=$(AIimlist -n $sname 2>/dev/null)
            test $? -ne 0 &&
                echo "WARNING: no images in AI_TMPDIR found." >&2 &&
                nlist=$(AIimlist -n $sname "" raw 2>/dev/null) &&
                test $? -ne 0 &&
                    echo "WARNING: no images in AI_RAWDIR found." >&2 &&
                    nlist=$(seq $n1 $n2 | awk '{printf("%04d\n", $0)}')
            n=0; nlistok=""
            for num in $nlist
            do
                test ! -f "measure/$num.src.dat" &&
                    echo "WARNING: measure/$num.src.dat not found." >&2 && continue
                n=$(($n + 1))
                nlistok="$nlistok $num"
            done
            nlist=$nlistok
            test $n -eq 0 && echo "WARNING: skipping set $sname" >&2 && continue
            echo "processing $n source lists in set $sname ..." >&2

            # read data from camera.dat or environment
            pixscale=$(get_param camera.dat pixscale $sname AI_PIXSCALE)
        else
            n=1; nlist="$(basename ${setname%.*})"
        fi
        
        # determine parameters depending on set (e.g. pixscale, magzero)
        test -z "$pixscale" &&
            echo "ERROR: $sname: pixscale unknown" >&2 && return 255
        #crad=$(echo $pixscale | awk '{print 3*$1}')    # crossid_radius
        mres=$(echo $pixscale | awk '{print 3*$1}')     # match_resol

        # check FITS header keyword IMGROLL in reference image
        refroll=0
        (is_fits "$rfile" || is_fitzip "$rfile") &&
            test "$(get_header -q "$rfile" IMGROLL | tr -d ' ')" == "Y" &&
            refroll=1
        
        # get image width and height from LDAC_IMHEAD in refcat
        w=$(stilts tpipe in=$refcat"#"1 ofmt=fits-basic | fold | grep "[[:alnum:]]" | \
            grep -A 100000 "EXTNAME .*LDAC_IMHEAD" | \
            grep NAXIS1 | (lines 1; dd of=/dev/null status=none) | awk '{print $3}')
        h=$(stilts tpipe in=$refcat"#"1 ofmt=fits-basic | fold | grep "[[:alnum:]]" | \
            grep -A 100000 "EXTNAME .*LDAC_IMHEAD" | \
            grep NAXIS2 | (lines 1; dd of=/dev/null status=none) | awk '{print $3}')

        # max distance from image center for statistics (a, e, fwhm, dm)
        dlim=0.3
        rmax=$(echo $w $h | awk -v dlim=$dlim '{
            printf("%d", dlim*sqrt($1*$1+$2*$2))}')

        # create global ahead file (only approx. pixscale required)
        # cx,cy are center of image in fits pixel coordinates
        # 140823: replaced pixscale/3600 by fixed pscale (in deg), crad in asec
        #pscale=$(echo $pixscale | awk '{print $1/3600.}')
        pscale=0.0003; mres=5
        cx=$(echo $w | awk '{printf("%.3f", $1/2+0.5)}')
        cy=$(echo $h | awk '{printf("%.3f", $1/2+0.5)}')
        echo "TELESCOP= 'Telescope'  / Observatory: Telescope
INSTRUME= 'Camera'     / Detector: Camera
FILTER  = 'FILTER'     / Detector: Filter
EXPTIME =      1       / Exposure time in seconds
EPOCH   =      2000.0  / Epoch
EQUINOX =      2000.0  / Mean equinox
RADESYS = 'ICRS    '   / Astrometric system
CTYPE1  = 'RA---TAN'   / WCS projection type for this axis
CUNIT1  = 'deg     '   / Axis unit
CRVAL1  =      10.0    / World coordinate on this axis
CRPIX1  =      $cx     / Reference pixel on this axis
CD1_1   =      -$pscale   / Linear projection matrix
CD1_2   =      0          / Linear projection matrix
CTYPE2  = 'DEC--TAN'   / WCS projection type for this axis
CUNIT2  = 'deg     '   / Axis unit
CRVAL2  =      0.0     / World coordinate on this axis
CRPIX2  =      $cy     / Reference pixel on this axis
CD2_1   =      0          / Linear projection matrix
CD2_2   =      $pscale    / Linear projection matrix
PHOTFLAG=      F
END     " > $ahead

        # extract good sources for single color channel from reference
        # catalog and convert to FITS_LDAC format
        sexselect -f $coloropt $refcat "" $magerrlim "" "" "*" 0 | \
            addldacwcs - $ahead > $refldac
        # bright sources in central region used by photometric calibration
        sexselect $refldac "" "" $rmax | sort -n -k7,7 | \
            grep -v "^#" | (head -$nbright; dd of=/dev/null status=none) > $xyref
        x=$(tail -1 $xyref | awk -v m=$mdiff '{printf("%.2f", m+$7)}')
        sexselect $refldac $x "" $rmax | sort -n -k7,7 | \
            grep -v "^#" > $xyref
        
        # add required columns to WCS reference catalog
        fitscopy "$refldac[LDAC_OBJECTS][col \
            NUMBER;\
            EXT_NUMBER;\
            X_WORLD=10+($w/2+0.5-XWIN_IMAGE)*$pscale;\
            Y_WORLD=(YWIN_IMAGE-$h/2-0.5)*$pscale;\
            ERRA_WORLD=ERRAWIN_IMAGE*$pscale;\
            ERRB_WORLD=ERRBWIN_IMAGE*$pscale;\
            MAG=MAG_AUTO;\
            MAGERR=MAGERR_AUTO;\
            OBSDATE=2000.0;\
            FLAGS;\
            ]" - > $wcscat
        sethead $wcscat",2" TUNIT3='deg'
        sethead $wcscat",2" TUNIT4='deg'
        sethead $wcscat",2" TUNIT5='deg'
        sethead $wcscat",2" TUNIT6='deg'
        sethead $wcscat",2" TUNIT7='mag'
        sethead $wcscat",2" TUNIT8='mag'
        sethead $wcscat",2" TUNIT9='yr'
        
        # match and register stars using scamp, creates measure/$num.src.head
        test -z "$has_hline" &&
            echo "# num nref nsrc nhigh a   e   fw    ns nmag  dm      sx     sy   0  da    dmsd  sxsd sysd 0"
        has_hline=1
        scamp -d > $conf
		cat <<EOF > $tmpsh
#!/bin/bash
. airfun.sh > /dev/null
tdir=$tdir
rdir=$rdir
nbright=$nbright
w=$w
h=$h
pscale=$pscale
inext=$inext
coloropt=$coloropt
magerrlim=$magerrlim
rmax=$rmax
do_bayer="$do_bayer"
has_poor_pos="$has_poor_pos"
exifdat=$exifdat
conf=$conf
setparam="$setparam"
sopts="$sopts"
ahead=$ahead
nref=$nref
refroll=$refroll
wcscat=$wcscat
scampopts=$scampopts
mres=$mres
snhigh=$snhigh
xyref=$xyref
quiet="$quiet"
_airegister_parallel \$@
EOF

        _airegister_parallel () {
			num=$1
            local acat
            local imgroll
            local rfile
            local nsrc=-1
            local nmatch=-1
            local nhigh=-1
            local rot180=""
            local posmaxerr
            local anglemaxerr
            local cmd
            local line
            local filter
            local x
            local sx
            local sy
            local da
            local sxsd
            local sysd
            local a
            local e
            local fw
			local inldac=$(mktemp "$tdir/tmp_inldac_XXXXXX.fits")
			local xydat=$(mktemp "$tdir/tmp_xy_XXXXXX.dat")
			local xmldat=$(mktemp "$tdir/tmp_scamp_XXXXXX.xml")
			local tmp1=$(mktemp "$tdir/tmp_tmp1_XXXXXX.dat")
			local tmp2=$(mktemp "$tdir/tmp_tmp2_XXXXXX.dat")
            
            test -f "$num.src.dat" && acat=$num.src.dat
            test -z "$acat" &&
                test -f "measure/$num.src.dat" && acat=measure/$num.src.dat
            test -z "$acat" &&
                echo "WARNING: object catalog $num.src.dat not found." >&2 && return
            if [ -f ${acat%.*}.head ]
            then
                test -z "$quiet" &&
                    echo "WARNING: skipping $num (${acat%.*}.head exists)" >&2
                return
            fi

            # extract good sources for single color channel from sextractor
            # catalog and convert to FITS_LDAC format
            sexselect -f $coloropt $acat "" $magerrlim "" "" "*" 0 > $inldac

            # create inldac header file
            cp $ahead ${inldac/.fits/.ahead}
            # check of FITS header keyword IMGROLL
            imgroll=0
            rfile=$(get_rawfile $num)
            (is_fits "$rfile" || is_fitzip "$rfile") &&
                test "$(get_header -q "$rfile" IMGROLL | tr -d ' ')" == "Y" &&
                imgroll=1
            test $imgroll -ne $refroll &&
                echo "WARNING: IMGROLL of $num differs from $nref." >&2 &&
                grep "^CD[12]_[12] " $ahead | \
                    sed -e 's/^CD1_1 /CDX_1 /; s/^CD2_2 /CD1_1 /; s/^CDX_1 /CD2_2 /' \
                    > ${inldac/.fits/.ahead}

            # set posmaxerr in arcmin, anglemaxerr in degrees
            posmaxerr=$(echo "0.15*($w+$h)/2*$pscale*60" | bc -l)
            anglemaxerr=10
            test "$has_poor_pos" &&
                posmaxerr=$(echo "0.5*($w+$h)/2*$pscale*60" | bc -l) &&
                anglemaxerr=40
            test "$num" == "$nref" &&
                posmaxerr=$(echo "0.02*($w+$h)/2*$pscale*60" | bc -l) &&
                anglemaxerr=1

            # run scamp
            # 131121: replaced "-crossid_radius $crad" by "-match_resol $mres"
            # 140823: removed -match_resol $mres
            # 140909: added "-match_resol $mres" back
            cmd="scamp -c $conf -astref_catalog file -astrefcat_name $wcscat \
                -aheader_global $ahead -position_maxerr $posmaxerr -posangle_maxerr $anglemaxerr \
                -match_resol $mres -sn_thresholds 5,$snhigh $scampopts \
                -xml_name $xmldat $inldac"
                #-mergedoutcat_type FITS_LDAC -fulloutcat_type FITS_LDAC \

            test ! "$AI_DEBUG" && cmd="$cmd -verbose_type quiet -checkplot_type NONE"
            test "$AI_DEBUG" && echo $cmd
            eval "$cmd" 2>/dev/null
            test $? -ne 0 &&
                echo "ERROR: scamp terminated with error (num=$num)." >&2 &&
                return 255

            test ! -f  ${inldac/.fits/.head} &&
                echo "ERROR: ${inldac/.fits/.head} not found." >&2 &&
                return 255

            # extract scamp fitting data from scamp.xml
            line=$(stilts tpipe ofmt=text $xmldat cmd=transpose | \
            awk 'BEGIN{nsrc=0;nmatch=0;nhigh=0;dm=0}{
                    if($2=="NDetect")               nsrc=$4
                    if($2=="NDeg_Reference")        nmatch=$4
                    if($2=="NDeg_Reference_HighSN") nhigh=$4
                    if($2=="ZeroPoint_Corr")        dm=$4
                }END{
                    printf("%d %d %d %.3f", nsrc, nmatch, nhigh, dm)
                }')
            nsrc=$(echo $line | awk '{print $1}')
            nmatch=$(echo $line | awk '{print $2}')
            nhigh=$(echo $line | awk '{print $3}')
        
            # TODO: check number of detections
            #   if below threshold then try with large posmaxerr/anglemaxerr
            #   if still below match try with rot180 and small posmaxerr/anglemaxerr
            #   if still below match try with rot180 and large posmaxerr/anglemaxerr
            rot180=$(echo $nsrc $nmatch | awk '{r=$2/$1; x=1
                if ($1>500 && r>0.18) x=""
                if ($1>200 && r>0.20) x=""
                if ($1>100 && r>0.24) x=""
                if ($1>50 && r>0.28) x=""
                if ($1>30 && r>0.35) x=""
                if ($1>14 && r>0.5) x=""
                if ($2>3 && $1<=14 && r>0.6) x=""
                print x
            }')
            if [ "$rot180" ]
            then
                echo "WARNING: $num has poor match ($nmatch/$nsrc), trying rot180." >&2
                cp ${inldac/.fits/.ahead} $tmp1
                grep "^CD[12]_[12] " $tmp1 | \
                sed -e 's/^CD1_1 /CDX_1 /; s/^CD2_2 /CD1_1 /; s/^CDX_1 /CD2_2 /' \
                > ${inldac/.fits/.ahead}
                
                eval "$cmd" 2>/dev/null
                test $? -ne 0 &&
                    echo "ERROR: scamp terminated with error (num=$num)." >&2 &&
                    return 255

                test ! -f  ${inldac/.fits/.head} &&
                    echo "ERROR: ${inldac/.fits/.head} not found." >&2 &&
                    return 255

                # extract scamp fitting data from scamp.xml
                line=$(stilts tpipe ofmt=text $xmldat cmd=transpose | \
                awk 'BEGIN{nsrc=0;nmatch=0;nhigh=0;dm=0}{
                        if($2=="NDetect")               nsrc=$4
                        if($2=="NDeg_Reference")        nmatch=$4
                        if($2=="NDeg_Reference_HighSN") nhigh=$4
                        if($2=="ZeroPoint_Corr")        dm=$4
                    }END{
                        printf("%d %d %d %.3f", nsrc, nmatch, nhigh, dm)
                    }')
                nsrc=$(echo $line | awk '{print $1}')
                nmatch=$(echo $line | awk '{print $2}')
                nhigh=$(echo $line | awk '{print $3}')                    
            fi
            
            # propagate some header keywords
            if [ -f ${rfile%.*}.hdr ]
            then
                hdr2ahead ${rfile%.*}.hdr > ${acat%.*}.head
            else
                filter="^OBJECT  =|^DATE-OBS=|^EXPTIME =|^EXPOSURE=|^JD      =|^MJD|^OBSERVAT=|^TELESCOP="
                filter="$filter|^IMGROLL =|^PIERSIDE=|^PEDESTAL=|^BINNING =|^[XY]BINNING="
                filter="$filter|^FILTER  =|^AIRMASS =|^ST      =|^RA      =|^DEC     ="
                rfile=$(get_rawfile $num)
                test -z "$rfile" &&
                    echo "ERROR: no entry for $num in $exifdat/$rawfilesdat." >&2 &&
                    return 255
                
                if is_fitzip "$rfile"
                then
                    unzip -p "$rfile" | listhead - | grep -E "$filter" > ${acat%.*}.head
                else
                    if is_fitsgz "$rfile"
                    then
                        gunzip -c "$rfile" | listhead - | grep -E "$filter" > ${acat%.*}.head
                    else
                        if is_fits "$rfile"
                        then
                            imhead "$rfile" | grep -E "$filter" > ${acat%.*}.head
                        else
                            touch ${acat%.*}.head
                            # get texp jd from exifdat
                            set - $(test -e $exifdat && grep -v "^#" $exifdat | \
                                awk -v n=$num '{if($2==n){printf("%s", $0)}}' | lines 1) x
                            if [ $# -ge 3 ]
                            then
                                texp=$4
                                set_header ${acat%.*}.head EXPTIME=$texp/"Exposure time in seconds"
                                x=$(ut2jd $3 $day | awk '{printf("%.5f", $1)}')
                                test ${3:0:1} -eq 0 && x=$(echo $x | awk '{printf("%.5f", $1+1)}')
                                set_header ${acat%.*}.head MJD_OBS=$x/"Time of observation in julian days"
                            else
                                # get texp jd from rawfilesdat
                                set - $(test -e $rawfilesdat && grep -v "^#" $rawfilesdat | \
                                    awk -v n=$num '{if($1==n){printf("%s", $0)}}' | lines 1) x
                                set_header ${acat%.*}.head EXPTIME=$4/"Exposure time in seconds"
                                set_header ${acat%.*}.head MJD_OBS=$5/"Time of observation in julian days"                                
                            fi
                            x=$(echo $day | awk '{
                                    y=substr($1,1,2)
                                    m=substr($1,3,2)
                                    d=substr($1,5,2)
                                    printf("%.1f\n", 2000+y+((m-1)*30.4+d)/365)
                                }')
                            set_header ${acat%.*}.head EPOCH=$x/"Epoch"
                        fi
                    fi
                fi
            fi
            # reformat EXPTIME
            x=$(get_header -q ${acat%.*}.head EXPTIME)
            test "$x" && set_header ${acat%.*}.head EXPTIME=$(echo $x | awk '{printf("%.2f", 1*$1)}')
            # combine headers
            sed -i '/^END$/d' ${acat%.*}.head
            cat ${inldac/.fits/.head} >> ${acat%.*}.head
            rm -f ${inldac/.fits/.head} ${inldac/.fits/.ahead}

            # compute pixel offset and rotation angle from ${acat%.*}.head
            sx=$(grep "^CRVAL1" ${acat%.*}.head  | tr '=' ' ' | \
                awk -v p=$pscale '{printf("%.2f", (10-$2)/p)}')
            sy=$(grep "^CRVAL2" ${acat%.*}.head  | tr '=' ' ' | \
                awk -v p=$pscale '{printf("%.2f", $2/p)}')
            da=$(grep "^CD._" ${acat%.*}.head  | tr '=' ' ' | sort | \
                awk '{print $2}' | tr '\n' ' ' | awk '{
                    pi=3.141592653
                    r1=180/pi*atan2($2, -$1)
                    r2=180/pi*atan2($3, $4)
                    printf("%.3f\n", (r1+r2)/2)
                }')
            #test "$rot180" && da=$(echo "$da + 180" | bc)
            
            sxsd=$(grep "^ASTRRMS1" ${acat%.*}.head  | tr '=' ' ' | \
                awk -v p=$pscale '{printf("%.2f", $2/p)}')
            sysd=$(grep "^ASTRRMS2" ${acat%.*}.head  | tr '=' ' ' | \
                awk -v p=$pscale '{printf("%.2f", $2/p)}')

            # determine a e fw, from a subset of measure/$num.src.dat
            set - $(sexselect -s $inldac "" $magerrlim $rmax $((w/2)),$((h/2)) \
                2>/dev/null | awk '{
                    if($1~/^#/) next
                    if($1~/^AWIN/) a=$2
                    if($1~/^BWIN/) e=a/$2
                    if($1~/^FWHM/) f=$2
                }END{printf("%.2f %.2f %.2f", a, e, f)}')
            a=$1
            e=$2
            fw=$3
            
            # determine mag offset from bright sources
            #test $num == "0001" && echo sexselect $inldac "" "" $rmax ";" $xyref && return 1
            sexselect $inldac "" "" $rmax | sort -n -k7,7 | \
                grep -v "^#" | (head -$nbright; dd of=/dev/null status=none) > $xydat
            x=$(tail -1 $xydat | awk -v m=0.1 '{printf("%.2f", m+$7)}')
            sexselect $inldac $x "" $rmax | sort -n -k7,7 | \
                grep -v "^#" > $xydat

            #echo "" > $tmp1
            #xymatch $xydat $xyref 2 $sx $sy $da $w $h | grep -v "^#" | \
            #    (head -250; dd of=/dev/null status=none) > $tmp1
            xymatch $xydat $xyref 2 $sx $sy $da $w $h | grep -v "^#" | \
                lines 250 > $tmp1
            nmag=$(cat $tmp1 | wc -l | awk '{x=$1; if($1>12) x=0.9*$1; if($1>25) x=0.8*$1+6;
                if($1>40) x=0.7*$1; if($1>70) x=0.6*$1; printf("%.0f", x)}')
            cat $tmp1 | while read id x x x x x x x idref
            do
                mref=$(grep "^[ ]*$idref " $xyref | awk '{print $7}')
                mm=$(grep "^[ ]*$id " $xydat | awk -v mref=$mref '{printf("%.2f", (mref+$7)/2)}')
                dm=$(grep "^[ ]*$id " $xydat | awk -v mref=$mref '{printf("%.2f", mref-$7)}')
                printf "%6s %6s  %5.2f  %5.2f\n" $idref $id $mm $dm
            done | sort -n -k3,3 | (head -$nmag; dd of=/dev/null status=none) > $tmp2
            dm=-2
            dmsd=99
            if [ $nmag -ge 3 ]
            then
                set - $(kappasigma $tmp2 4 || echo error)
                if [ "$1" != "error" ]
                then
                    dm=$(echo $1 | awk '{printf("%.3f", $1)}')
                    dmsd=$(echo $2 | awk '{printf("%.3f", $1)}')
                fi
            fi
            test "$dm" == "-2" && (
                echo "WARNING: $num has no match of sources for estimation of dmag." >&2 &&
                cp -p $xydat $tdir/regerr.$num.xydat
                cp -p $xyref $tdir/regerr.$num.xyref
                cp -p $tmp1 $tdir/regerr.$num.tmp1
                cp -p $tmp2 $tdir/regerr.$num.tmp2
            )

            # na, dasd are undefined/unset (0)
            line=$(printf "%s %s %4d %4d" $num $nref $nsrc $nhigh
            printf " %s %s %s %4d %3d" $a $e $fw $nmatch $nmag
            printf " %6.3f %6.2f %6.2f 0 %6.3f" $dm $sx $sy $da
            printf " %s %s %s 0\n" $dmsd $sxsd $sysd)
            test $nsrc -lt 0 && echo "$line" >&2 # set already processed
            test $nsrc -ge 0 && echo "$line"
			test "$AI_DEBUG" && echo "inldac=$inldac" >&2
			test "$AI_DEBUG" && echo "xydat=$xydat; xyref=$xyref" >&2
            test "$AI_DEBUG" || rm $inldac $xydat $xmldat $tmp1 $tmp2
        }
        
		if [ "$nlist" ]
		then
			export -f _airegister_parallel
            popts=""; test "$AI_MAXPROCS" && popts="-P $AI_MAXPROCS"
			parallel $popts -k $tmpsh ::: $nlist
			unset -f _airegister_parallel
		fi

    done < $sdat
    test "$singleimage" && rm $sdat
    test "$AI_DEBUG" || rm -f $conf $wcscat $ahead $xyref
    return 0
}


AIfwhm () {
    # plot fwhm across image
    # TODO: implement rejection of outliers
    local showhelp
    local outfile=x.fwhm.png    # output PNG file
    local range     # plot range of fwhm, either low:high or dfwhm or "full"
    local nodisplay # do not display image of fwhm distribution
    local boxsize   # limit to center box of given size width:high
    local keep      # if set then keep fwhm data used by fit (xfits,yfits,fwhm,mag)
    local verbose
    local sopts="-dbn 2 -dbc 0.2"
    local i
    for i in 1 2 3 4 5 6 7
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-r" && range="$2" && shift 2
        test "$1" == "-o" && outfile="$2" && shift 2
        test "$1" == "-n" && nodisplay=1 && shift 1
        test "$1" == "-k" && keep=1 && shift 1
        test "$1" == "-v" && verbose=1 && shift 1
        test "$1" == "-b" && boxsize="$2" && shift 2
    done
    local set=$1    # image set or sextractor catalog or image
    local src
    local fwhm
    local w
    local h
    local x
    local xrange
    local yrange
    local opts
    local retval
    local imgname
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpsrc=$(mktemp "$tdir/tmp_insrc_$$.XXXXXX.src.dat")
    local tmp1=$(mktemp "$tdir/tmp_src_$$.XXXXXX")
    local tmp2=$(mktemp "$tdir/tmp_dat_$$.XXXXXX")
    local tmpfit=$(mktemp "$tdir/tmp_fit_$$.XXXXXX.dat")

    (test "$showhelp" || test $# -ne 1) &&
        echo "usage: AIfwhm [-n] [-k] [-v] [-o outfile|$outfile] [-b w:h] [-r low:high | -r dfwhm] <set|srcdat>" >&2 && return 1

    test "$AI_DEBUG" && verbose=1
    if [ -s $set ]
    then
        if is_pnm $set
        then
            if [ -s ${set%.*}.src.dat ]
            then
                src=${set%.*}.src.dat
            else
                echo "# extracting sources ..."
                is_ppm $set && AIsource -q $sopts -2 -o $tmpsrc $set
                is_pgm $set && AIsource -q $sopts -o $tmpsrc $set
                test -s $tmpsrc && src=$tmpsrc
            fi
        fi
        if is_fits $set
        then
            if [ "$(listhead $set | grep "XTENSION.*BINTABLE.*LDACTOOLS")" ]
            then
                src=$set
            else
                # FITS image
                AIsource -q $sopts -o $tmpsrc $set
                test -s $tmpsrc && src=$tmpsrc
            fi
        fi
    fi
    test -z "$src" && test -s $set.src.dat && src=$set.src.dat
    test -z "$src" &&
        echo "ERROR: sextractor sources file is missing." >&2 && return 255

    # get image width and height from LDAC_IMHEAD in refcat
    w=$(stilts tpipe in=$src"#"1 ofmt=fits-basic | fold | grep "[[:alnum:]]" | \
        grep -A 100000 "EXTNAME .*LDAC_IMHEAD" | \
        grep NAXIS1 | (lines 1; dd of=/dev/null status=none) | awk '{print $3}')
    h=$(stilts tpipe in=$src"#"1 ofmt=fits-basic | fold | grep "[[:alnum:]]" | \
        grep -A 100000 "EXTNAME .*LDAC_IMHEAD" | \
        grep NAXIS2 | (lines 1; dd of=/dev/null status=none) | awk '{print $3}')

    # x,y data range
    xrange="0:$w"
    yrange="0:$h"
    if [ "$boxsize" ]
    then
        xrange=$(echo $w $h ${boxsize/:/ } | awk '{l=int(($1-$3)/2); h=l+$3; print l":"h}')
        yrange=$(echo $w $h ${boxsize/:/ } | awk '{l=int(($2-$4)/2); h=l+$4; print l":"h}')
        echo "# $xrange,$yrange" >&2
    fi
    
    # identify bright sources (FITS coordinates)
    sexselect $src "" "" "" "" "NUMBER,X*,Y*,A*,FWHM_IMAGE,MAG_AUTO,MAGERR_AUTO,FLAGS" 0 | \
        sort -n -k6,6 | grep -v "^#" | lines 500 > $tmp1
    # determine median fwhm from bright sources
    set - $(kappasigma $tmp1 5)
    fwhm=$(echo $1 | awk '{printf("%.2f", $1)}')
    x=$(echo $2 | awk '{printf("%.2f", $1)}')
    #echo "# all:  fwhm=$fwhm"+-"$x (n=$(cat $tmp1 | wc -l))" >&2
    cat $tmp1 | awk -v f=$fwhm -v s=$x -v w=$w -v h=$h '{
        if ($1~/^#/) {print $0; next}
        if ($5 > 1+1.5*f+5*s) next
        section=0
        x=h; if (w<h) x=w
        if ($2 >= w/2-x/2 && $2 < w/2) {
            if ($3 >= h/2-x/2 && $3 < h/2) section="ll"
            if ($3 >= h/2 && $3 < h/2+x/2) section="ul"
        }
        if ($2 >= w/2 && $2 < w/2+x/2) {
            if ($3 >= h/2-x/2 && $3 < h/2) section="lr"
            if ($3 >= h/2 && $3 < h/2+x/2) section="ur"
        }
        if (sqrt(($2-w/2)^2 + ($3-h/2)^2) < x/4) section="c"
        printf("%.0f %.0f %.2f %.2f %s\n", $2, $3, 1*$5, 1*$6, section)
    }' > $tmp2

    # new stats after rejection
    set - $(kappasigma $tmp2 3)
    fwhm=$(echo $1 | awk '{printf("%.2f", $1)}')
    x=$(echo $2 | awk '{printf("%.2f", $1)}')
    echo "# fwhm=$fwhm"+-"$x (n=$(cat $tmp2 | wc -l))" >&2
    
    # median in each section
    if [ "$verbose" ]
    then
        printf "+------------+\n"
        printf "|%4.1f    %4.1f|\n" $(grep "ul$" $tmp2 | median - 3) $(grep "ur$" $tmp2 | median - 3)
        printf "|    %4.1f    |\n" $(grep "c$" $tmp2 | median - 3)
        printf "|%4.1f    %4.1f|\n" $(grep "ll$" $tmp2 | median - 3) $(grep "lr$" $tmp2 | median - 3)
        printf "+------------+\n"
    fi
    
    # if requested save tmp2
    test "$keep" && cp $tmp2 x.fwhm.dat
    
    gpsurfit -q -p4 -o $tmpfit $tmp2   
    retval=$?
    if [ $retval -eq 0 ]
    then
        opts="-b $xrange,$yrange"
        if [ -z "$range" ]
        then
            # clip fit data to levels 2%, 85% and add some margins
            range=$(cliprange $tmpfit 3 2 85 | awk '{printf("%.1f:%.1f", 0.95*$1, 1.2*$2+0.5)}')
        fi
        test "$range" && test $range != "full" && opts="$opts -r $range"
        imgname="$(basename $set | sed -e 's,_,\\_,g')"
        plot2d $opts -o $outfile -t "FWHM ($imgname: $fwhm +-$x px)" $tmpfit
        retval=$?
    else
        echo "ERROR: gpsurfit $tmp2 has failed" >&2
    fi
    if [ $retval -eq 0 ] && [ -z "$nodisplay" ]
    then
        display $outfile &
    fi
    
    (test "$AI_DEBUG" || test $retval -ne 0) &&
        echo "$tmp1 $tmp2 $tmpfit" >&2 && return $retval
    rm -f $tmp1 $tmp2 $tmpfit $tmpsrc
    return $retval
}


# simplified AIccd/AIsource/crossmatch(part)/AIplot procedure to estimate
# best focus from a set of images in current directory
# TODO: check directories . $AI_TMPDIR, $AI_RAWDIR for images and hdr files
AIfocus () {
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1

    local nmin=$1
    local nmax=$2
    local threshold=${3:-5}     # detection threshold (sextractor)
    local rlim=${4:-1200}       # limit stars to center distance < rlim
    local ex=${AI_EXCLUDE:-""}  # space separated list of image numbers
    local magzero=${AI_MAGZERO:-"25.5"}
    local tdir="/tmp"
    local raw
    local hdr
    local xy
    local dlim=""
    local magerrlim=0.03
    local i
    local texp
    local mag0
    local tmp1=$(mktemp "/tmp/tmp_src_$$.XXXXXX")
    local tmp2=$(mktemp "/tmp/tmp_ptsrc_$$.XXXXXX")

    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: AIfocus <nmin> <nmax> [thres|$threshold] [rlim|$rlim]" >&2 &&
        return 1

    rm -f focus.dat
    for i in $(seq $nmin $nmax)
    do
        num=$(echo $i | awk '{printf("%04d", $1)}')
        echo $ex | grep -q -w $num - && echo "excluding image $num." >&2 && continue
        raw=""
        raw=$(get_imfilename $num)
        test -z "$raw" && echo "WARNING: raw file for $num not found." >&2 && continue

        # get image width and height, determine dlim
        if [ -z "$dlim" ]
        then
            w=$(dcraw-tl -i -v $raw | grep "Output size:" | awk '{print $3}')
            h=$(dcraw-tl -i -v $raw | grep "Output size:" | awk '{print $5}')
            dlim=$(echo $w $h $rlim | awk '{printf("%.2f", 2*$3/sqrt($1*$1+$2*$2))}')
            echo "# image ${w}x${h}, using dlim=$dlim" >&2
        fi
        
        # get xy offset for use in AI_DCRAWPARAM
        if [ $((2*rlim)) -lt $w ] && [ $((2*rlim)) -lt $h ]
        then
            xy=$(echo $w $h $rlim | awk '{x=$1/2-$3; y=$2/2-$3; printf("%d %d", x, y)}')
            AI_DCRAWPARAM="-R $((2*rlim)) $((2*rlim)) $xy"
        fi

        # source extraction
        if [ -f $num.src.dat ]
        then
            echo -n "$num (existing $num.src.dat) " >&2
        else
            # raw to fits
            echo -n "$num " >&2
            AIraw2rgb -q 0 $raw | gm convert - -channel Green pgm:- | \
                pnmtomef - > $tdir/$num.fits

            # try to read exposure time from exif data
            texp=""     # exposure time in sec
            texp=$(exiv2 -g Exif.Photo.ExposureTime $raw | awk '{print $4}')
            test -z "$texp" && texp=1
            mag0=$(echo $magzero $texp 1 | awk '{
                printf("%.2f\n", $1+2.5/log(10)*log($2/$3))}')
            
            # source extraction
            AI_MAGZERO=$mag0 AIsource -q $tdir/$num.fits "" $threshold 2>/dev/null
            test $? -ne 0 &&
                echo "ERROR: AIsource failed." >&2 && return 255
        fi
    
        # get stats from point sources in center region
        sexselect $num.src.dat "" $magerrlim 2>/dev/null | awk -v amin=0.4 '{
                if($1~/^#/) next
                if($4<amin) next  # cosmic or hot pixel
                print $0
            }' > $tmp1
        n=$(cat $tmp1 | wc -l)
        test $n -lt 8 &&
            echo "WARNING: $num too few stars (n=$n)" >&2 && continue
            
        a=$(kappasigma $tmp1 4 | awk '{printf("%.2f", $1)}')
        e=$(kappasigma $tmp1 5 | awk '{printf("%.2f", $1)}')
        fwhm=$(kappasigma $tmp1 6 | awk '{printf("%.2f", $1)}')
        m=$(kappasigma $tmp1 7 | awk '{printf("%.2f", $1)}')
        
        false && (set - $(sexselect -s $num.src.dat "" $magerrlim \
            2>/dev/null | awk '{
                if($1~/^#/) next
                if($1~/^AWIN/) a=$2
                if($1~/^BWIN/) e=a/$2
                if($1~/^FWHM/) {f=$2; n=$7}
                if($1~/^MAG/)  m=$2
            }END{printf("%d %.2f %.2f %.2f %.2f", n, a, e, f, m)}')
        n=$1
        a=$2
        e=$3
        fwhm=$4
        m=$5)
        
        # try to find hdr file
        hdr=""
        for d in . $AI_TMPDIR $AI_RAWDIR
        do
            test -z "$hdr" && test -f $d/$num.hdr && hdr=$d/$num.hdr
            test -z "$hdr" && test -f $d/IMG_$num.hdr && hdr=$d/IMG_$num.hdr
        done

        # get focus value from comment in hdr file
        test "$hdr" &&
            f=$(grep "^comment" $hdr | cut -d '=' -f2- | tr -d '=' | \
                tr ' ,;/' '\n' | grep -E "^f[0-9]+$" | cut -c 2-)
        test -z "$f" && f=$num
        echo $f $n $fwhm $e $m >&2
        echo $num $f $n $fwhm $e $m >> focus.dat
    done
    rm -f $tmp1 $tmp2
    # TODO: handle 100
    AIplot -p -t "fwhm(f)" focus.dat 2 4
}


# sky background estimation
AIbg () {
    AIcheck_ok || return 255
    local showhelp
    local i
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1

    local img=${1:-""}
    local bsize=${2:-20}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local nx=4
    local ny=3
    local w
    local h
    local nc
    local j
    local x0
    local y0
    local tmp1=$(mktemp "/tmp/tmp_bg_val_$$.XXXXXX")
    local tmp2=$(mktemp "/tmp/tmp_bg_med_$$.XXXXXX")

    test "$showhelp" &&
        echo "usage: AIbg [img] [bsize|$bsize]" >&2 &&
        return 1

    is_pgm $img && nc=1
    test -z "$nc" && is_ppm $img && nc=3
    test -z "$nc" && echo "ERROR: unsupported image format." >&2 && return 255
    
    # build list of regions
    w=$(identify $img | cut -d " " -f3 | cut -d "x" -f1)
    h=$(identify $img | cut -d " " -f3 | cut -d "x" -f2)
    for j in $(seq 1 $ny)
    do
        y0=$(echo $j $ny $h $bsize | awk '{
            x=(0.2+0.6*($1-1)/($2-1))*$3 - $4/2
            printf("%d", x)}')
        for i in $(seq 1 $nx)
        do
            x0=$(echo $i $nx $w $bsize | awk '{
                x=(0.2+0.6*($1-1)/($2-1))*$3 - $4/2
                printf("%d", x)}')
            AIval $img $bsize $bsize $x0 $y0 > $tmp1
            kappasigma $tmp1 1 | sed -e 's,^,1 ,'>> $tmp2
            test $nc -eq 3 &&
                kappasigma $tmp1 2 | sed -e 's,^,2 ,'>> $tmp2 &&
                kappasigma $tmp1 3 | sed -e 's,^,3 ,'>> $tmp2
        done
    done
    for i in $(seq 1 $nc)
    do
        grep "^$i " $tmp2 | sort -nr -k2,2 > $tmp1
        # cat $tmp1 | sed -e 's,^,# ,' >&2
        tail -$((nx*ny*45/100)) $tmp1 | lines 1
    done
    test "$AI_DEBUG" && echo $tmp1 $tmp2 >&2
    test -z "$AI_DEBUG" && rm -f $tmp1 $tmp2
}


# determine sky background diffs of images within set
# output (small) PPM images to directory bgvar
# masking bad areas taken from bgvar/<num>.bad.reg or bgvar/<num>.bad.png
AIbgdiff () {
    AIcheck_ok || return 255
    local showhelp
    local do_bayer          # if set then operate separately on each bayer grid
                            # color
    local do_keepdiff       # if set then the bg mesh of diff image is kept
    local do_use_nref       # use nref instead of mean image (default until v2.2.2)
    local do_all_mean       # include images which have a bad region mask when
                            # creating mean image
    local do_plane          # fit diff image by plane instead of surface
    local nmax=11           # max. number of images to use
    local i
    for i in 1 2 3 4 5 6
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-b" &&
            echo "WARNING: using deprecated option -b." >&2 && do_bayer=1 && shift 1
        test "$1" == "-k" && do_keepdiff=1 && shift 1
        test "$1" == "-r" && do_use_nref=1 && shift 1
        test "$1" == "-a" && do_all_mean=1 && shift 1
        test "$1" == "-p" && do_plane=1 && shift 1
        test "$1" == "-n" && nmax=$2 && shift 2
    done
    local setname=${1:-""}
    local bsize=${2:-"128"}
    local bgzero=${3:-"10000"}
    local diffdir=${4:-"bgvar"}
    local sfitdat="bgsfit.dat"
    local sdat=${AI_SETS:-"set.dat"}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local ccdregion=${AI_CCDREGION:-"10000 10000 0 0"}
    local imlist=$(mktemp "$tdir/tmp_imlist_XXXXXX.dat")
    local imlist2=$(mktemp "$tdir/tmp_imlist2_XXXXXX.dat")
    local tmpref=$(mktemp "$tdir/tmp_ref_$$.XXXXXX.pnm")
    local tmpim=$(mktemp "$tdir/tmp_im2_$$.XXXXXX.pnm")
    local bgrgb
    local sname
    local type
    local nref
    local b
    local n
    local inext
    local nlist
    local has_bgdiff
    local num
    local fname
    local ref
    local nbad
    local filter
    local popts
    local retval=0
    local tmpsh=$(mktemp "/tmp/tmp_script_XXXXXX.sh")
    chmod u+x $tmpsh

    test "$showhelp" &&
        echo "usage: AIbgdiff [-b] [-k] [-r|-a] [-n nmax|$nmax] [-p] [set] [bsize|$bsize] [bgzero|$bgzero] [diffdir|$diffdir]" >&2 &&
        return 1
    test -d "$diffdir" || mkdir "$diffdir"

    if [ "$AI_DEBUG" ]
    then
        echo "WARNING: DEBUG mode - no diff stats are written to output files !" >&2 &&
        sleep 5 && echo "" >&2
    fi
    
    while read ltime sname target type texp n1 n2 nref dark flat x
    do
        (echo "$ltime" | grep -q "^#") && continue
        test "$type" != "o" && test "$type" != "s" && continue
        test "$setname" && test "$setname" != "$sname" && continue
        (! is_integer "$n1" || ! is_integer "$n2" || ! is_integer "$nref") && continue

        inext=""
        test -f $tdir/$nref.pgm && inext="pgm"
        test -f $tdir/$nref.ppm && inext="ppm"
        test -z "$inext" &&
            echo "ERROR: set $sname has no ref image $nref.{pgm,ppm}." >&2 &&
            retval=255 && continue

        if [ "$do_bayer" ]
        then
            AIimlist $sname "" pgm > $imlist
        else
            AIimlist $sname > $imlist
        fi
        n=0; nlist=""; has_bgdiff=""
        while read x num fname ref x
        do
            test -f $diffdir/$num.bgdiff.$inext && has_bgdiff=1 && continue
            n=$(($n + 1)) && nlist="$nlist $num"
        done < $imlist
        test "$has_bgdiff" && echo "WARNING: some bgdiff images do already exist." >&2
        test $n -eq 0 && echo "WARNING: skipping set $sname" >&2 && continue
        echo "processing $n $inext images in set $sname ..." >&2

        # determine background of reference image
        if [ "$do_bayer" ]
        then
            if [ "$do_use_nref" ]
            then
                AIbsplit $tdir/$nref.pgm
                rgb3toppm $nref.r1.pgm $nref.g1.pgm $nref.b1.pgm > $tmpref
                rm $nref.[rgb][12].pgm
            else
                # skip images with associated mask bgvar/$num.bad.*
                nbad=$(cd bgvar && ls [0-9][0-9][0-9][0-9].bad.* | cut -d '.' -f1)
                grep -Ewv "$(echo $nbad | tr ' ' '|')" $imlist > $imlist2
                n=$(cat $imlist2 | wc -l)
                test $n -le 9 && echo "create mean of $n images ..." >&2
                test $n -gt 9 && echo "create mean using 9 out of $n images ..." >&2
                pnmcombine2 $(cut -d " " -f3 $imlist2 | head -$((n-(n-9)/2)) | tail -9) $tmpim
                AIbsplit $tmpim
                b=$(basename ${tmpim%.*})
                rgb3toppm $b.r1.pgm $b.g1.pgm $b.b1.pgm > $tmpref
                rm $b.[rgb][12].pgm
            fi
        else
            if [ "$do_use_nref" ]
            then
                cp $tdir/$nref.$inext $tmpref
            else
                # skip images with associated bad region mask bgvar/$num.bad.*
                if [ -z "$do_all_mean" ] && ls bgvar/[0-9][0-9][0-9][0-9].bad.* > /dev/null 2>&1
                then
                    filter=""
                    nbad=$(cd bgvar && ls [0-9][0-9][0-9][0-9].bad.* | cut -d '.' -f1)
                    AI_EXCLUDE="$AI_EXCLUDE $nbad" AIimlist -q $sname > $imlist2
                else
                    cp $imlist $imlist2
                fi
                n=$(cat $imlist2 | wc -l)
                test $n -le 9 && echo "create mean of $n images ..." >&2
                test $n -gt 9 && echo "create mean using 9 out of $n images ..." >&2
                pnmcombine2 $(cut -d " " -f3 $imlist2 | head -$((n-(n-9)/2)) | tail -9) $tmpref
                test $? -ne 0 &&
                    echo "ERROR: pnmcombine failed." >&2 && retval=255 && continue
            fi
        fi
        AIbgmap -q -m $tmpref $bsize 1
        test $? -ne 0 &&
            echo "Failed command: AIbgmap -q -m $tmpref $bsize 1" >&2 && return 255
        b=$(basename ${tmpref%.*})
        case $inext in
            ppm)    bgrgb=$(imcrop -1 $b.bgm1.$inext 80 | AImstat - | awk '{
                    printf("%.1f %.1f %.1f", $5, $9, $13)}');;
            pgm)    bgrgb=$(imcrop -1 $b.bgm1.$inext 80 | AImstat - | awk '{
                    printf("%.1f", $5)}');;
        esac
        test -z "$bgrgb" &&
            echo "ERROR: imcrop -1 $b.bgm1.$inext 80 failed" >&2 && return 255
        rm $b.bgm1.$inext
        echo "bgref = $bgrgb" >&2
        test $n -eq 1 &&
            echo "WARNING: single image, no diffs" >&2 &&
            echo "$nref.$inext $nref $bgzero $bgzero $bgzero (0.0) ${bgrgb//,/ }" &&
            continue

        
        # create small bgdiff images
		cat <<EOF > $tmpsh
#!/bin/bash
. airfun.sh > /dev/null
tdir=$tdir
nref=$nref
inext=$inext
diffdir=$diffdir
sfitdat=$sfitdat
tmpref=$tmpref
do_use_nref="$do_use_nref"
do_keepdiff="$do_keepdiff"
do_bayer="$do_bayer"
do_plane="$do_plane"
bsize=$bsize
bgzero=$bgzero
_aibgdiff_parallel \$@
EOF
		_aibgdiff_parallel () {
			local x=$1
			local num=$2
			local fname=$3
			local bgm
			local w
			local h
			local tmpdiff=$(mktemp "$tdir/tmp_diff_$$.XXXXXX.pnm")
			local tmpim2=$(mktemp "$tdir/tmp_im2_$$.XXXXXX.pnm")
			local tmpdat=$(mktemp "$tdir/tmp_txt1_$$.XXXXXX.dat")
            test "$do_use_nref" && test $num -eq $nref && return
            test -f $diffdir/$num.bgdiff.$inext &&
                echo "$num (reusing $num.bgdiff.$inext)" >&2 &&
                return

            echo -n "$num " >&2
            if [ "$do_bayer" ]
            then
                AIbsplit $fname
                rgb3toppm $num.r1.pgm $num.g1.pgm $num.b1.pgm | \
                    pnmccdred2 -a $bgzero -d $tmpref - $tmpdiff
                rm $num.[rgb][12].pgm
            else
                pnmccdred2 -a $bgzero -d $tmpref $fname $tmpdiff
            fi
            AIbgmap -q -m $tmpdiff $bsize 1
            test $? -ne 0 &&
                echo "Failed command: AIbgmap -q -m $tmpdiff $bsize 1" && return 255
            bgm=$(basename ${tmpdiff/.pnm/.bgm1.$inext})
            test "$do_keepdiff" && cp $bgm $diffdir/$num.bgm1.$inext
            w=$(gm identify $bgm | cut -d " " -f3 | cut -d "x" -f1)
            h=$(gm identify $bgm | cut -d " " -f3 | cut -d "x" -f2)
            #echo $num $tmpref $bgm $w $h >&2
            # mask bad pixels to be excluded from fit
            if [ -f $diffdir/$num.bad.reg ]
            then
                reg2pbm $tmpref $diffdir/$num.bad.reg | \
                gm convert - -resize ${w}x${h}\! \
                    -threshold 10% -negate -depth 16 $inext:- | \
                    pnmarith -min $bgm - > $tmpim2
                test $? -ne 0 && return 255
            else
                if [ -f $diffdir/$num.bad.png ]
                then
                    ! is_mask $diffdir/$num.bad.png white &&
                        echo "ERROR: $diffdir/$num.bad.png is not a valid mask (white on black)." >&2 &&
                        return 255
                
                    gm convert $diffdir/$num.bad.png -resize ${w}x${h}\! \
                        -threshold 10% -negate -depth 16 $inext:- | \
                        pnmarith -min $bgm - > $tmpim2
                    test $? -ne 0 && return 255
                else
                    cp $bgm $tmpim2
                fi
            fi

            if [ "$AI_DEBUG" ]
            then
                mv $tmpim2 ${tmpim2/im2/$num}
            else
                # surface fit, print coeffs to $sfitdat and partly to stderr
                if [ "$do_plane" ]
                then
                    AIsfit -p $tmpim2 > $diffdir/$num.bgdiff.$inext 2> $tmpdat
                else
                    AIsfit $tmpim2 > $diffdir/$num.bgdiff.$inext 2> $tmpdat
                fi
                test $? -ne 0 &&
                    echo "ERROR during: AIsfit $tmpim2" >&2 &&
                    rm -f $diffdir/$num.bgdiff.$inext \
                          $(basename ${tmpdiff/.pnm/.bgm1.$inext}) \
                          $tmpdat $tmpdiff &&
                    return 255
                x=1
                test "$inext" == "ppm" && x=2
                grep "^$x " $tmpdat >&2
                cat $tmpdat | awk -v n=$num '{print n" "$0}' >> $sfitdat 
            fi
			test "$AI_DEBUG" && echo "nref=$nref  wxh=${w}x${h}  bgzero=$bgzero" >&2
            rm -f $tmpdiff $bgm $tmpim2 $tmpdat
		}

        export -f _aibgdiff_parallel
        popts=""; test "$AI_MAXPROCS" && popts="-P $AI_MAXPROCS"
        cat $imlist | parallel $popts -k $tmpsh
        unset -f _aibgdiff_parallel
		# TODO: error handling

        # get stats from bgdiff images
        test "$AI_DEBUG" || while read x num fname x
        do
            test "$do_use_nref" && test $num -eq $nref && test "$inext" == "ppm" &&
                echo "$num.xxxxxx.$inext $num $bgzero $bgzero $bgzero (0.0) $bgzero $bgzero $bgzero (0.0)" \
                    "$bgzero $bgzero $bgzero (0.0)" $bgrgb &&
                continue
            test "$do_use_nref" && test $num -eq $nref && test "$inext" == "pgm" &&
                echo "$num.xxxxxx.$inext $num $bgzero $bgzero $bgzero (0.0)" $bgrgb &&
                continue
            test ! -f $diffdir/$num.bgdiff.$inext &&
                echo "ERROR: $diffdir/$num.bgdiff.$inext does not exist." >&2 &&
                continue
            imcrop $diffdir/$num.bgdiff.$inext 70 > $tmpim
            AIstat $tmpim | awk -v img=$num.bgdiff.$inext -v num=$num -v bgrgb="$bgrgb" -v z=$bgzero '{
                n=split(bgrgb, bg)
                skip=length($1)+length($2)+3
                if (n>1) {
                    printf("%s %s %s %.1f %.1f %.1f\n", img, num, substr($0,skip), $5+bg[1]-z,
                        $9+bg[2]-z, $13+bg[3]-z)
                } else {
                    printf("%s %s %s %.1f\n", img, num, substr($0,skip), $5+bg[1]-z)
                }}'
        done < $imlist
        rm -f $tmpref $tmpim
    done < $sdat
    rm -f $imlist $imlist2 $tmpsh
    return $retval
}


# extract smoothed background map using sextractor
# note: bgoff is not subtracted from outsmall but taken into account for stats
AIbgmap () {
    local showhelp
    local quiet     # if set suppress messages from sextractor
    local do_fitplane
    local do_fitsurface     # parabolic curve at image center
    local do_fitcenter      # parabolic curve + center fit
    local do_minibg_only
    local do_stats_only # ignore all image creation
    local do_diag   # additionally create normalized bg image and residual image
    local bgmsub    # if given, subtract it before fitting data, intensities
                    # are assumed to be scaled by mult
    local maxbad=60 # max. percent of bad pixel to exclude from bg
    local bgoff=0   # offset (-1*pedestal) which was added to img
    local show_bg_stddev
    for i in $(seq 1 10)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-q" && quiet=1 && shift 1
        test "$1" == "-p" && do_fitplane=1 && shift 1
        test "$1" == "-s" && do_fitsurface=1 && shift 1
        test "$1" == "-c" && do_fitcenter=1 && shift 1
        test "$1" == "-m" && do_minibg_only=1 && shift 1
        test "$1" == "-d" && do_diag=1 && shift 1
        test "$1" == "-b" && bgmsub=$2 && shift 2
        test "$1" == "-o" && bgoff=$2 && shift 2
        test "$1" == "-sd" && show_bg_stddev=1 && shift 1
        test "$1" == "-x" && maxbad=$2 && shift 2
        test "$1" == "-stats" && do_stats_only=1 && shift 1
    done
    local img=${1:-""}
    local bsize=${2:-256}   # background area size (default in sex: 128)
    local msize=${3:-3}     # background mesh size = median points (default: 3)
    local weightmap=${4:-""}   # weight map, pgm or png, black = bad background
    local mult=${5:-1}      # intensity multiplier
    local bwidth=1          # border width in %, used to remove edges before AIsfit
    local tdir=${AI_TMPDIR:-"/tmp"}
    local conf=$(mktemp "$tdir/tmp_conf_XXXXXX.dat")
    local tmpxml=$(mktemp "$tdir/tmp_sex_XXXXXX.xml")
    local tmpmask=$(mktemp "$tdir/tmp_mask_XXXXXX.pbm")
    local tmp1=$(mktemp "$tdir/tmp_tmp1_XXXXXX.pnm")
    local tmpnofit=$(mktemp "$tdir/tmp_tmpnofit_XXXXXX.pnm")
    local tmpbg=$(mktemp "$tdir/tmp_tmpbg_XXXXXX.pnm")
    local tmpfits=$(mktemp "$tdir/tmp_tmpfits_XXXXXX.fits")

    local out
    local outsmall
    local f
    local b
    local c
    local clist
    local inext="ppm"
    local param="-filter N -detect_thresh 100 -write_xml Y"
    local fields=$tdir/sex.$$.fields
    local wfits=$tdir/weight.$$.fits
    local rgb
    local mrgb
    local ampl
    local bgsd
    local size
    local xm
    local ym
    local ci
    local val

    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: AIbgmap [-q] [-p|s|c] [-m] [-d] [-sd] [-o pedestal] [-x maxbad|$maxbad]" \
            "[-b bgmsubimg] <img> [bsize|$bsize] [msize|$msize] [bgmask] [mult|$mult]" >&2 &&
        return 1

    for f in $img $bgmsub $weightmap
    do
        test ! -f $f && echo "ERROR: file $f does not exist." >&2 && return 255
    done

    # TODO: check img is either ppm or pgm
    
    # TODO: improve performance (takes 40%)
    if [ "$weightmap" ]
    then
        # convert bad bg region to mask
        if is_reg $weightmap
        then
            reg2pbm $img $weightmap | gm convert - -negate $tmpmask
            test $(identify -format "%k" $tmpmask) -eq 1 &&
                echo "WARNING: empty regions file $weightmap." >&2 &&
                weightmap=""
            test "$weightmap" && weightmap=$tmpmask
        else
            # ignore bgmask if it is of uniform color
            test $(identify -format "%k" $weightmap) -eq 1 &&
                echo "WARNING: weightmap $weightmap has constant value." >&2 &&
                weightmap=""
        fi

        # check if mask is black/white only
        test "$weightmap" && ! is_mask $weightmap black $maxbad && return 255
    fi
    
    echo XWIN_IMAGE YWIN_IMAGE | tr ' ' '\n' > $fields
    test "$quiet" && param="$param -verbose_type quiet"
    # TODO: sex does not work with weightmap
    #test "$weightmap" &&
    #    pnmtomef $weightmap > $wfits &&
    #    param="$param -weight_type map_weight -weight_image $wfits"

    
    # abbreviations
    b=$(basename ${img%\.*})
    is_pgm $img && inext="pgm"
    out="$b.bg.$inext"
    outsmall="$b.bgm$mult.$inext"
    #day=$(basename $(dirname $img))
    #test "$day" && test "$day" != "." && out="$day.$b.bg$bsize.ppm"

    if [ ! "$do_stats_only" ]
    then
        # convert pnm to monochrome fits
        # note: if noise in $img is low (<~3) then background image from sex and
        #   the residual image will show staircase structure, independant of $mult
        #   maybe we should add some random noise proportional to $mult
        # TODO: begin run parallel (takes 45% of time)
        case $inext in
            ppm)    clist="red grn blu"
                    pnmccdred2 -f -m $mult $img $tmpfits
                    imslice $tmpfits 1 > $tdir/$b.red.fits
                    imslice $tmpfits 2 > $tdir/$b.grn.fits
                    imslice $tmpfits 3 > $tdir/$b.blu.fits
                    ;;
            pgm)    clist="gray"
                    pnmccdred2 -f -m $mult $img $tmpfits
                    imslice $tmpfits 1 > $tdir/$b.$clist.fits
                    ;;
        esac
        
        # create background map
        test "$quiet" || echo "creating $out and $outsmall ..." >&2
        sex -d > $conf
        for c in $clist
        do
            sex -c $conf -xml_name $tmpxml -parameters_name $fields \
                $param -back_size $bsize -back_filtersize $msize \
                -checkimage_type "background minibackground" \
                -checkimage_name "$tdir/bg.$b.$c.fits $tdir/bgm.$b.$c.fits" \
                $tdir/$b.$c.fits
            #test ! "$do_minibg_only" && convert $tdir/bg.$b.$c.fits pgm:- > $tdir/bg.$b.$c.pgm
            #convert $tdir/bgm.$b.$c.fits pgm:- > $tdir/bgm.$b.$c.pgm
            test ! "$do_minibg_only" && meftopnm $tdir/bg.$b.$c.fits > $tdir/bg.$b.$c.pgm
            meftopnm $tdir/bgm.$b.$c.fits > $tdir/bgm.$b.$c.pgm
            rm $tdir/$b.$c.fits $tdir/bg.$b.$c.fits $tdir/bgm.$b.$c.fits
            
            # bg stddev
            test "$bgsd" && bgsd=$bgsd","
            bgsd="$bgsd"$(stilts tpipe ofmt=text $tmpxml cmd=transpose | \
                grep -w Background_StDev | awk '{printf("%.1f", $4)}')
            rm -f $tmpxml
        done
        # TODO: end run parallel

        case $inext in
            ppm)    test ! "$do_minibg_only" && rgb3toppm $tdir/bg.$b.red.pgm $tdir/bg.$b.grn.pgm $tdir/bg.$b.blu.pgm \
                        > $out
                    rgb3toppm $tdir/bgm.$b.red.pgm $tdir/bgm.$b.grn.pgm $tdir/bgm.$b.blu.pgm \
                        > $outsmall
                    rm -f $tdir/bg.$b.red.pgm $tdir/bg.$b.grn.pgm $tdir/bg.$b.blu.pgm
                    rm -f $tdir/bgm.$b.red.pgm $tdir/bgm.$b.grn.pgm $tdir/bgm.$b.blu.pgm
                    ;;
            pgm)    test ! "$do_minibg_only" && mv $tdir/bg.$b.$clist.pgm $out
                    mv $tdir/bgm.$b.$clist.pgm $outsmall
                    ;;
        esac
        rm -f test.cat $conf $fields
        
        # optionally apply fit to create smoothed background map
        if [ "$do_fitplane" ] || [ "$do_fitsurface" ] || [ "$do_fitcenter" ]
        then
            test "$do_fitplane"   && echo "fitting plane surface to background ..." >&2
            test "$do_fitsurface" && echo "fitting plane and centered parabolic to background ..." >&2
            test "$do_fitcenter"  && echo "fitting parabolic surface (arbitrary center) to background ..." >&2
            cp $outsmall $tmpnofit
            # subtract user-provided bg model image first
            if [ "$bgmsub" ]
            then
                gm convert "$bgmsub" -scale $(gm identify $outsmall | cut -d ' ' -f3)\! $tmpbg
                pnmccdred -a 1000 -d $tmpbg $tmpnofit $outsmall
            fi

            # apply weightmap and replace edges from image
            xm=$(echo $bwidth $(imsize $outsmall) | awk '{printf("%.0f", $1*$2/100+1.1)}')
            ym=$(echo $bwidth $(imsize $outsmall) | awk '{printf("%.0f", $1*$3/100+1.1)}')
            if [ "$weightmap" ]
            then
                gm convert $weightmap -scale $(gm identify $outsmall | cut -d ' ' -f3)\! \
                    -depth 1 pbm:- | pnmarith -mul $outsmall -  2>/dev/null | \
                     convert - -shave ${xm}x${ym} -bordercolor black -border ${xm}x${ym} $tmp1
            else
                convert $outsmall -shave ${xm}x${ym} -bordercolor black -border ${xm}x${ym} $tmp1
            fi
            
            # fit
            param=""
            test "$do_fitplane" && param="-p"
            test "$do_fitcenter" && param="-c"
            test "$AI_DEBUG" &&
                echo "AIsfit $param $tmp1 > $outsmall" >&2
            AIsfit $param $tmp1 > $outsmall
            test $? -ne 0 &&
                echo "ERROR: AIsfit failed" >&2 &&
                return 255
            ! is_pnm $outsmall &&
                echo "ERROR: invalid image $outsmall created by AIsfit" >&2 &&
                return 255
            if [ "$bgmsub" ]
            then
                pnmarith -add $outsmall $tmpbg | pnmccdred -a -1000 - $tmp1
                mv $tmp1 $outsmall
            fi
            test ! "$do_minibg_only" &&
                gm convert $outsmall -resize $(gm identify $img | cut -d ' ' -f3)\! $out
            # optionally create residual image
            test "$do_diag" &&
                pnmccdred -a 1000 -d $outsmall $tmpnofit $b.bgm${mult}res.$inext
        fi
    fi

    # optionally create normalized $outsmall and show some statistics
    if [ "$do_diag" ] || [ "$do_stats_only" ]
    then
        # statistics using masked outsmall
        if [ "$weightmap" ]
        then
            gm convert $weightmap -scale $(gm identify $outsmall | cut -d ' ' -f3)\! \
                -depth 1 pbm:- | pnmarith -mul $outsmall - 2>/dev/null | AIval -a - | \
                grep -v -w 0 > $tmp1
            rgb=$(median $tmp1 1 | awk -v a=$((-1*bgoff*mult)) '{print $1+a}')
            if [ $(head -1 $tmp1 | wc -w) -eq 3 ]
            then
                val=$(median $tmp1 2 | awk -v a=$((-1*bgoff*mult)) '{print $1+a}')
                rgb=$rgb","$val
                val=$(median $tmp1 3 | awk -v a=$((-1*bgoff*mult)) '{print $1+a}')
                rgb=$rgb","$val
            fi
        else
            rgb=$(pnmccdred -a $((-1*bgoff*mult)) $outsmall - | AIstat - | awk '{
                if(NF>8) {printf("%.0f,%.0f,%.0f", $5, $9, $13)} else {printf("%f", $5)}}')
        fi
        false && ampl=$(imcrop -1 $outsmall 85 | AImstat - | awk -v rgb=$rgb '{
            if(NF>8) {
                split(rgb,mn,",")
                x=($8-$7)/mn[2]
            } else {
                x=($4-$3)/rgb
            }
            printf("%.1f", x*100)}')

        size=$(imsize $outsmall)
        ampl=$(AIval -c -a $outsmall | \
        awk -v w=${size% *} -v h=${size#* } -v a=$((-1*bgoff*mult)) 'BEGIN{
            rmax=w/2; if (h<w) rmax=h/2
            gmin=2^16; gmax=0; gsum=0; gnum=0
        }{
            if (NF==5) {col=4} else {col=3}
            dx=$1-(w/2-0.5)
            dy=$2-(h/2-0.5)
            r=sqrt(dx*dx+dy*dy)
            if(r<rmax) {
                gnum=gnum+1
                gsum=gsum+$col+a
                if ($col < gmin) gmin=$col
                if ($col > gmax) gmax=$col
                #printf("%s %.1f %d %d\n", $0, r, gmin, gmax)
            }
        }END{
            printf("%.1f\n", 1.2*100*(gmax-gmin)/gsum*gnum)
        }')
        if [ "${rgb//,/ }" != "$rgb" ]
        then
            ci=$(echo $rgb | awk -F ',' '{printf("%.1f", $1/$3)}')
            echo "$outsmall:  ampl=$ampl%  rgb*$mult=$rgb  r/b=$ci"
        else
            echo "$outsmall:  ampl=$ampl%  rgb*$mult=$rgb"
        fi
    fi
    if [ "$do_diag" ] && [ ! "$do_stats_only" ]
    then
        # create normalized bg image (take bgoff into account)
        mrgb=$(echo $rgb | awk -F ',' '{x=10000; if(NF>1) {
            printf("%f,%f,%f", x/$1, x/$2, x/$3)} else {printf("%f", x/$1)}}')
        pnmccdred -a $((-1*bgoff*mult)) $outsmall - | \
            pnmccdred -m $mrgb - $b.bgm${mult}n.$inext
    fi
    
    test "$show_bg_stddev" && echo "$bgsd"
    test !"$AI_DEBUG" && rm -f $tmp1 $wfits $tmpnofit $tmpbg $tmpmask $tmpfits
    return 0
}


# apply bg model using reference images or straight gradient pattern
AIbgmodel () {
    local showhelp
    local mode="refsets"  # either "refsets" or "bgpattern"
    local do_median # if set apply 3x3 median filter before bluring
    local blur=1.0  # bluring in pixels
    local scale=1.0 # amplitude scaling of model image
    local sd        # if set use it for a fixed amplitude scaling
    local bgmult    # bgmult which has been used for creating residual images
    local bgval     # bgval of target (default: measure in $target.$ext)
    local dcontrast=1.0 # modify display contrast
    local testonly  # if set do not apply model
    local allsets   # create model using bgval=1000 from all sets
    local xlist     # list of sets to be excluded from model computing
    local verbose
    local i
    for i in $(seq 1 10)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-m" && bgmult=$2 && shift 2
        test "$1" == "-bg" && bgval=$2 && shift 2
        test "$1" == "-3" && do_median=1 && shift 1
        test "$1" == "-b" && blur=$2 && shift 2
        test "$1" == "-s" && scale=$2 && shift 2
        test "$1" == "-sd" && sd=$2 && shift 2
        test "$1" == "-c" && dcontrast=$2 && shift 2
        test "$1" == "-t" && testonly=1 && shift 1
        test "$1" == "-a" && allsets=1 && shift 1
        test "$1" == "-x" && xlist=$2 && shift 2
        test "$1" == "-v" && verbose=1 && shift 1
    done
    local target=${1:-""}   # target set name
    local reforreg=${2:-""}  # list of reference sets: [day/]<set>[:<suffix>] separated by ,
                            # or region file containing vector of constant bg brightness
                            # (and optional regions to be ignored during model construction)
    local tdir=${AI_TMPDIR:-"/tmp"}
    local wdir=$(mktemp -d "$tdir/tmp_bgmodel_XXXXXX")
    local cdir=bgcorr   # base name of bgcorr directories to search for res image
    local flist
    local ext
    local bgres=1000    # shift model to this bg value
    local ncol
    local refentry
    local resimg
    local bgimg
    local sname
    local suffix    # optional suffix extending name of cdir
    local x
    local s
    local mult
    local add
    local size
    local opts
    local imlist
    local imlist2
    local mlist
    local rot180
    
    (test "$showhelp" || (test $# -lt 2 && test -z "$allsets")) &&
        echo "usage: AIbgmodel [-v] [-t|-a] [-x exlist] [-3] [-b blur|$blur] [-m bgmult]" \
            "[-bg bgval] [-s scale|$scale] [-sd sd]" \
            "[-c dcontrast|$dcontrast] <target> <refsets | bgreg>" >&2 &&
        return 1
    
    test "${1:0:1}" == "-" &&
        echo "ERROR: unknown option $1." >&2 && return 255

    # determine mode of operation
    is_reg $reforreg && mode="bgpattern"
    
    # deal with allsets
    if [ "$allsets" ]
    then
        bgval=1000
        flist=$(AIsetinfo -b -o | grep -v "^#" | while read x s x
            do
                ls $cdir/$s.{bgm1,bgm10}res.{pgm,ppm} 2>/dev/null
            done)
        x=$(basename $(echo "$flist" | head -1))
        target=$(echo $x | cut -d "." -f1)
        bgmult=$(echo $x | cut -d "." -f2 | tr -d '[a-z]')
        ext=$(echo $x | cut -d "." -f3)
        reforreg=$(AIsetinfo -b -o | grep -v "^#" | while read x s x
            do
                test $s != $target && test -f $cdir/$s.bgm${bgmult}res.$ext && echo $s
            done)
        test "$AI_DEBUG" && echo "# target=$target reforreg=$reforreg" >&2
    fi

    # determine bg multiplier and image extension
    test "$bgmult" && test -f $cdir/$target.bgm${bgmult}res.ppm && ext=ppm
    test "$bgmult" && test -f $cdir/$target.bgm${bgmult}res.pgm && ext=pgm
    if [ -z "$bgmult" ]
    then
        x=$(ls -t $cdir/$target.bgm{1,10}res.p[pg]m 2>/dev/null | tail -1)        
        test "$x" && ext=${x##*.}
        test "$x" && bgmult=$(echo $x | sed -e "s,^$cdir/$target.bgm,,; s,res.$ext$,,")
    fi
    (test -z "$bgmult" || test -z "$ext") &&
        echo "ERROR: unable to find target residual image." >&2 && return 255
    echo "# bgmult=$bgmult ext=$ext" >&2
    
    if [ "$mode" == "refsets" ]
    then
        echo "# measure reference images ..." >&2
        # measure bgvalue on target
        if [ -z "$bgval" ]
        then
            bgval=($(AImstat -c $target.$ext | awk '{
                printf("%s", $5); if(NF>13) {printf(" %s %s", $9, $13)}}'))
            test "$verbose" && echo "# target bgval=${bgval[@]}" >&2
        fi
        ncol=${#bgval[@]}
        test "$ext" == "ppm" && test $ncol -eq 1 && bgval=$bgval" "$bgval" "$bgval

        # normalize bgres images to bgval (in each color)
        for refentry in $target ${reforreg//,/ }
        do
            if [ "${refentry/:/}" != "$refentry" ]
            then
                sname=$(basename ${refentry%%:*})
                suffix=${refentry##*:}
            else
                sname=$(basename $refentry)
                suffix=""
            fi
            resimg=""
            bgimg=""
            for refdir in $(dirname $refentry)/$cdir$suffix \
                          $A/$(dirname $refentry)/$cdir$suffix \
                          $A/results/$(dirname $refentry)/$cdir$suffix
            do
                test "$resimg" && break
                test -e    $refdir/$sname.bgm${bgmult}res.$ext &&
                    resimg=$refdir/$sname.bgm${bgmult}res.$ext &&
                    bgimg=$refdir/$sname.bgm${bgmult}.$ext
            done
            test -z "$resimg" &&
                echo "WARNING: missing image $cdir$suffix/$sname.bgm${bgmult}res.p[pg]m" >&2 &&
                continue
            
            x=($(AIstat -c $bgimg | awk -v m=$bgmult '{
                printf("%s", $5/m); if(NF>13) {printf(" %s %s", $9/m, $13/m)}}'))
            test "$verbose" && echo "# $bgimg: x=${x[@]}" >&2
            for i in $(seq 0 $((ncol-1)))
            do
                mult[$i]=$(echo ${x[i]} ${bgval[i]} | \
                    awk -v s=$scale '{printf("%.4f", $2/$1*s)}')
                add[$i]=$(echo ${x[i]} ${bgval[i]} | \
                    awk -v b=$bgres -v s=$scale '{printf("%.1f", b-$2/$1*s*b)}')
            done
            test "$verbose" && echo "mult=${mult[@]} add=${add[@]}" >&2
            x=$(basename $(dirname $refdir) | tr '/' '_')
            test "$x" == "." && x=""
            test "$x" && x=${x}"_"
            pnmccdred -m $(echo ${mult[@]} | tr ' ' ',') $resimg - | \
                pnmccdred -a $(echo ${add[@]} | tr ' ' ',') - $wdir/$x$sname.norm.$ext
            # imlist: all images to be displayed
            imlist="$imlist $wdir/$x$sname.norm.$ext"
            # mlist: all images used to build model
            if [ "$allsets" ]
            then
                echo "$xlist" | grep -vq $sname && mlist="$mlist $x$sname.norm.$ext"
            else
                echo "$xlist $target" | grep -vq $sname && mlist="$mlist $x$sname.norm.$ext"
            fi
        done
        
        # create model
        test "$verbose" && echo "# mlist = $mlist" >&2
        # rank index: darkest pixel = 0
        x=$(echo $mlist | wc -w | awk '{x=0;
            if($1>3) x=1; if($1>5) x=2; if($1>8) x=int($1/3)
            print x}')
        (cd $wdir; vips bandrank "$(echo $mlist)" $target.bgmin.$ext[strip] --index=$x)
        
        # shift average level to bgres
        x=$(AImstat $wdir/$target.bgmin.$ext | awk -v m=$bgres '{
            printf("%.0f", m-$5); if(NF>13) {printf(",%.0f,%.0f", m-$9, m-$13)}}')
        pnmccdred -a $x $wdir/$target.bgmin.$ext $wdir/x.$target.model.$ext
        # bluring
        if [ "$do_median" ]
        then
            mkkernel 3 3 0 > $wdir/x.kern.pbm
            kmedian $wdir/x.$target.model.$ext $wdir/x.kern.pbm | \
                convert - -blur 0x$blur \
                $wdir/$target.bgm${bgmult}model.$ext
        else
            convert $wdir/x.$target.model.$ext -blur 0x$blur \
                $wdir/$target.bgm${bgmult}model.$ext
        fi
    fi
    
    if [ "$mode" == "bgpattern" ]
    then
        bgimg=$cdir/$target.bgm${bgmult}.$ext
        resimg=$cdir/$target.bgm${bgmult}res.$ext
        for x in $bgimg $resimg
        do
            test ! -f $x && echo "ERROR: image $x is missing." >&2 && return 255
        done
        
        local tmprot=$wdir/x.rot.$ext
        local tmpmask=$wdir/x.mask.pgm
        local tmpbw=$wdir/x.bw.ppm
        local tmpim1=$wdir/x.tmp1.$ext
        local tmpim2=$wdir/x.tmp2.$ext
        
        # get rotation angle (first vector region)
        angle=$(grep -w vector $reforreg | lines 1 | cut -d ',' -f4 | cut -d ')' -f1)
        rot180=$(echo $angle | awk '{if($1>180) print 1}')
        angle=$(echo $angle | awk '{x=$1; if(x>180) x=x-180; if(x>90) x=x-180; printf("%.f", x)}')
        test -z "$angle" &&
            echo "ERROR: missing vector region in $reforreg" >&2 && return 255
        
        # expand (2pix border) and rotate resimg
        set - $(imsize $resimg)
        w=$1; h=$2
        convert $resimg -resize $((w+2))x$((h+2))\! - | pnmpaste $resimg 1 1 - | \
            convert - -resize $((w+4))x$((h+4))\! - | pnmpaste $resimg 2 2 - | \
            pnmrotate $angle - > $tmprot
        size=$(imsize $tmprot | tr ' ' 'x')

        # mask bad regions
        reg2pbm $target.$ext $reforreg | \
            convert - -resize ${w}x${h}\! -negate - | pnmmargin -white 2x2 - | \
            pnmrotate $angle - 2>/dev/null | pgmtopbm -thres -value 0.95 | \
            convert - -negate -depth 16 $tmpmask
        convert pattern:checkerboard -resize 2x2 - | \
            convert -size $size tile:- pbm:- | convert - -depth 16 $tmpbw
        pnmcomp -alpha $tmpmask $tmpbw $tmprot > $tmpim1
    
        # create bg model image
        # collapse columns
        impatsub -q -k -o $tmpim2 $tmpim1
        # expand gradient line
        gm convert x.pat.pnm -resize $size\! $tmpim2
        #echo $wdir >&2 && return

        # rotate bg image back (enlarge image before rotation)
        set - $(imsize $tmpim2)
        w=$1; h=$2
        angle=$(echo $angle | awk '{printf("%f", -1*$1)}')
        test "$rot180" && angle=$(echo $angle | awk '{printf("%f", $1+180)}')
        convert $tmpim2 -rotate $angle - | \
            imcrop -1 - $(imsize $resimg) | \
            convert - -blur 0x$blur $wdir/$target.bgm${bgmult}model.$ext
    fi
    #echo $tmpim2 >&2
    #return

    # create new residual image
    test ! -s $wdir/$target.bgm${bgmult}model.$ext &&
        echo "ERROR: creating model image has failed." >&2 && return 255
    size=$(imsize $wdir/$target.bgm${bgmult}model.$ext | tr ' ' 'x')
    convert $cdir/$target.bgm${bgmult}res.$ext -resize $size\! - | \
        pnmccdred -a 1000 -d $wdir/$target.bgm${bgmult}model.$ext - $wdir/$target.bgm${bgmult}allres.$ext
    
    # show results
    echo "# display residual images ..." >&2
    if [ "$sd" ]
    then
        echo "# fixed sd=$sd" >&2
    else
        sd=$(imcrop $wdir/$target.bgm${bgmult}allres.$ext 90 | AIval -a - | \
            kappasigma - 2 | awk -v c=$dcontrast '{printf("%.0f", (1.5*$2+2)/c)}')
        echo "# measured sd=$sd" >&2
    fi
    test "$verbose" && opts="-v"
    for x in $imlist
    do
        rgbscale $opts $x $sd > ${x/.norm/}
        imlist2="$imlist2 $(basename ${x/.norm/})"
    done
    rgbscale $opts $wdir/$target.bgm${bgmult}model.$ext  $sd > $wdir/model.$ext
    imlist2="$imlist2 model.$ext"
    if [ "$allsets" ]
    then
        (cd $wdir
        montage -background '#202020' -fill '#D0D0D0' -label '%t' \
            $imlist2 -geometry +4+2 -) > bgres.all.$ext
        display bgres.all.$ext &
    else
        rgbscale $opts $wdir/$target.bgm${bgmult}allres.$ext $sd > $wdir/$target.final.$ext
        imlist2="$imlist2 $target.final.$ext"
        (cd $wdir
        montage -background '#202020' -fill '#D0D0D0' -label '%t' \
            $imlist2 -geometry +4+2 -) > bgres.$target.$ext
        display bgres.$target.$ext &
    fi
    test "$verbose" && echo "# imlist2 = $imlist2" >&2

    # apply model
    if [ "$testonly" ] || [ "$allsets" ]
    then
        test "$testonly" &&
            echo "# WARNING: not applying bg model (testonly)" >&2
        test "$allsets" &&
        cp -p $wdir/$target.bgm${bgmult}model.$ext x.bgm${bgmult}model.$ext
    else
        echo "# apply bg model ..." >&2
        cp -p $wdir/$target.bgm${bgmult}model.$ext  $cdir/
        cp -p $wdir/$target.bgm${bgmult}allres.$ext $cdir/
        
        # combine gradient image and residual model for later use by AIcomet
        convert $cdir/$target.bgm${bgmult}.$ext -resize $size\! - | \
            pnmarith -a - $cdir/$target.bgm${bgmult}model.$ext | \
            pnmccdred -a -1000 - $cdir/$target.bgm${bgmult}all.$ext
        # rerun bg image subtraction
        bgimg=$cdir/$target.bgm${bgmult}all.$ext
        imbgsub $target.$ext $bgimg "" $bgmult > $target.bgs.$ext
        test -f ${target}_m.$ext &&
            imbgsub ${target}_m.$ext $bgimg "" $bgmult > ${target}_m.bgs.$ext
    fi

    test "${verbose}${AI_DEBUG}" && echo $wdir >&2 && return
    rm -rf $wdir
    return
}

# fit astrometric solution to a PPM image using a reference catalog (FITS table)
# if the reference catalog is not provided it will be queried from vizier
# database and stored on disk (<set|img>.<refcat>.cat)
# result: WCS FITS image header (<set|img>.wcs.head)
# TODO: using an existing image filename for setname is NOT tested!
#       currently only green channel is fitted, how about color dependant fits
AIwcs () {
    local showhelp
    local plotdev="PNG" # checkplot_dev parameter of scamp (e.g. SVG, NULL)
    local nocatquery    # if set use $set.<refcat>.cat
    local maskreg       # if set then use this region mask to limit image sources
    local maxoff        # max position offset in degrees
    local fitdegrees=3  # degree of polynomial fit of image distortions (<=10)
    local sopts         # additional options passed to scamp
    local noescapes     # strip formatting escape sequences from scamp output
    local quiet         # suppress most of scamps output
    local north         # user defined north position angle (up=0, left=90)
                        # default is using value AI_NPA or entry in camera.dat
    local binning       # detector pixel binning
    local ra            # approx. image center
    local de
    local crossrad      # if given then set value of -crossid_radius (arcsec)
    local do_catonly    # if set then download catalog sources but skip solving
                        # astrometry
    local showplots     # display scamp checkplots
    local i
    for i in $(seq 1 16)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-p" && plotdev=$2 && shift 2
        test "$1" == "-r" && nocatquery=1 && shift 1
        test "$1" == "-f" && noescapes=1 && shift 1
        test "$1" == "-q" && quiet=1 && shift 1
        test "$1" == "-o" && maxoff=$2 && shift 2
        test "$1" == "-d" && fitdegrees=$2 && shift 2
        test "$1" == "-n" && north=$2 && shift 2
        test "$1" == "-b" && binning=$2 && shift 2
        test "$1" == "-c" && ra="$2" && de="$3" && shift 3
        test "$1" == "-cr" && crossrad="$2" && shift 2
        test "$1" == "-x" && sopts="$2" && shift 2
        test "$1" == "-m" && maskreg="$2" && shift 2
        test "$1" == "-z" && do_catonly=1 && shift 1
        test "$1" == "-s" && showplots=1 && shift 1
    done
    local setname=${1:-""}
    local refcat=${2:-""}       # e.g. USNO-B1, 2MASS
    local maglim=${3:-"99"}     # magnitude limit in refcat
    local threshold=${4:-5}     # threshold for object detection by sexselect
    local rdir=${AI_RAWDIR:-"."}
    local sdat=${AI_SETS:-"set.dat"}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpcat=$(mktemp "$tdir/tmp_src_$$.XXXXXX.dat")
    local tmpcat2=$(mktemp "$tdir/tmp_src2_$$.XXXXXX.dat")
    local sconf=$(mktemp "$tdir/tmp_scamp_$$.XXXXXX.conf")
    local slog=$(mktemp "$tdir/tmp_scamp_$$.XXXXXX.log")
    local p
    local b
    local hdr
    local singleimage
    local sexcat
    local refcatfile
    local ahead
    local ltype
    local sname
    local type
    local texp
    local nref
    local rad
    local ded
    local img
    local w
    local h
    local pixscale
    local magzero
    local posmaxerr
    local mres
    local nadd
    local x
    local y
    local kw
    local cmd
    local escfilter
    local allcats
    local server
    local retval
    
    test "$showhelp" &&
        echo "usage: AIwcs [-s] [-r] [-f|-q] [-c ra dec] [-n north] [-b binning]" \
            "[-p plotdev|$plotdev] [-o maxoff_deg] [-cr crossrad] [-d fitdegrees|$fitdegrees]" \
            "[-m maskreg] [-x sopts]" \
            "[set|img] [refcat] [maglim|$maglim] [thres|$threshold]" >&2 &&
        return 1
    
    test "${1:0:1}" == "-" &&
        echo "ERROR: unknown option $1." >&2 && return 255

    if [ -f "$setname" ]
    then
        # try to read some keywords from $img.head
        hdr=${setname%.*}.head
        if [ -f $hdr ]
        then
            magzero=$(get_header -q $hdr MAGZERO)
            test -z "$binning" && binning=$(get_header -q $hdr BINNING)
            test -z "$binning" && binning=1
            pixscale=$(get_wcspscale $hdr | awk -v b=$binning '{print $1*b}')
        fi
        test "$AI_PIXSCALE" && pixscale=$AI_PIXSCALE
        test "$AI_MAGZERO"  && magzero=$AI_MAGZERO

        sdat=$tdir/tmp_set_$$.dat
        echo "00:00 $setname xx o 0 0 0 0 xx xx xx" > $sdat
        singleimage="y"
    fi

    # create output directory for checkplots and catalogs
    test ! -d wcs && mkdir wcs

    # get default astref_catalog
    if [ ! "$refcat" ]
    then
        set - $(scamp -d | grep ASTREF_CATALOG)
        refcat=$2
    else
        # "translate" refcat
        case $refcat in
            ucac3)  refcat=ucac-3;;
            ucac4)  refcat=ucac-4;;
            tycho2) refcat=tycho-2;;
            gsc)    refcat=gsc-2.3;;
            ppm)    refcat=ppmx;;
            cmc14)  refcat=cmc-14;;
        esac
        # check with supported catalogs
        allcats=$(scamp -d | awk '{
            if ($1=="ASTREF_CATALOG") {ok=1} else {if($0!~/^ [ ]*#/){ok=0}}
            if (ok==1) {print tolower($0)}}' | cut -d '#' -f2- | tr ', ' '\n' | \
            grep "[a-z]" | grep -vwE "none|file")
        echo $allcats | grep -wq $refcat
        test $? -ne 0 &&
            echo "ERROR: unsupported catalog $refcat." >&2 &&
            echo "  (choose one of: " $allcats ")" >&2 &&
            return 255
    fi
   
    while read ltime sname target type texp n1 n2 nref dark flat x
    do
        (echo "$ltime" | grep -q "^#") && continue
        test "$type" != "o" && continue
        test "$setname" && test "$setname" != "$sname" && continue

        rad=$ra
        ded=$de
        img=""
        if [ "$singleimage" == "y" ]
        then
            img=$setname
        else
            test -f $sname.pgm && img=$sname.pgm
            test -f $sname.ppm && img=$sname.ppm
            pixscale=$AI_PIXSCALE
            if [ -z "$pixscale" ]
            then
                if [ -e $sname.head ]
                then
                    test -z "$binning" && binning=$(get_header -q $sname.head BINNING)
                    test -z "$binning" && binning=$(get_header -q $sname.head XBINNING)
                fi
                test -z "$binning" && binning=1
                pixscale=$(get_param camera.dat pixscale $sname | \
                    awk -v b=$binning '{print $1*b}')
            fi
            magzero=$(get_param    camera.dat magzero  $sname AI_MAGZERO)
        fi
        test -z "$img" &&
            echo "ERROR: no image found for set $sname." >&2 && return 255
        test ! -f "$img" &&
            echo "ERROR: image $img not found." >&2 && return 255
        
        # determine parameters depending on set (e.g. pixscale, magzero)
        test -z "$pixscale" &&
            echo "ERROR: $sname: pixscale unknown" >&2 && return 255
        #test -z "$magzero" &&
        #    echo "ERROR: $sname: magzero unknown" >&2 && continue
        mres=$(echo $pixscale | awk '{print 1*$1}')  # match_resol
        
        # get image width and height
        w=$(identify $img | cut -d " " -f3 | cut -d "x" -f1)
        h=$(identify $img | cut -d " " -f3 | cut -d "x" -f2)
        
        # determine posmaxerr in arcmin
        if [ "$maxoff" ]
        then
            posmaxerr=$(echo $maxoff | awk '{print $1*60}')
        else
            posmaxerr=$(echo $w $h $pixscale | \
                awk '{printf("%.0f", 10+0.3*sqrt($1*$1+$2*$2)*$3/60)}')
        fi
        
        b=${img%\.*}
        #test -e $b.wcs.head &&
        #    echo "WARNING: skipping $b, WCS data file $b.wcs.head exists" &&
        #    continue
        #sexcat=wcs/$b.src.dat
        sexcat=$b.src.dat
        ahead=${sexcat%.*}.ahead
        #test "$nosex" && test ! -e $sexcat &&
        test ! -e $sexcat &&
            echo "WARNING: skipping $b, $sexcat does not exist." &&
            continue
        refcatfile=wcs/$b.$refcat.dat
        test "$nocatquery" && test ! -e $refcatfile &&
            echo "WARNING: skipping $b, $refcatfile does not exist." &&
            continue
        
        # get ra de from $sname.head or measure/$nref.src.head
        hdr=$sname.head
        test "$singleimage" && hdr=${sname%.*}.head
        test -e $hdr && if [ -z "$rad" ] || [ -z "$ded" ]
        then
            for kw in RA RATEL OBJCTRA AI_CORA
            do
                test -z "$rad" && test -f $hdr &&
                    rad=$(get_header -q $hdr $kw)
                test -z "$rad" && test -f measure/$nref.src.head &&
                    rad=$(get_header -q measure/$nref.src.head $kw)
            done
            test -z "$rad" && test -f $rdir/$nref.hdr &&
                rad=$(grep "^ra=" $rdir/$nref.hdr | cut -d '=' -f2)

            for kw in DEC DETEL OBJCTDEC AI_CODEC
            do
                test -z "$ded" && test -f $hdr &&
                    ded=$(get_header -q $hdr $kw)
                test -z "$ded" && test -f measure/$nref.src.head &&
                    ded=$(get_header -q measure/$nref.src.head $kw)
            done
            test -z "$ded" && test -f $rdir/$nref.hdr &&
                ded=$(grep "^de=" $rdir/$nref.hdr | cut -d '=' -f2)
        fi
        test -z "$rad" &&
            echo "ERROR: unknown ra center coordinate ($sname $nref)." >&2 &&
            return 255
        test -z "$ded" &&
            echo "ERROR: unknown de center coordinate ($sname $nref)." >&2 &&
            return 255

        # convert sexadecimal to decimal coordinates
        rad=$(echo $rad | tr ' ' ':')
        ded=$(echo $ded | tr ' ' ':')
        test "${rad/:/}" != "$rad" && rad=$(sexa2dec $(echo $rad | tr ' ' ':') 15)
        test "${ded/:/}" != "$ded" && ded=$(sexa2dec $(echo $ded | tr ' ' ':'))
        
        # determine north angle from AI_NPA or $cameradat and IMGROLL
        nadd=0
        test -z "$north" && north=$(get_header -q $hdr AI_NPA)
        if [ -z "$north" ]
        then
            north=$(get_param camera.dat rot $sname)
            test "$north" == "-" && north=0
            # check IMGROLL keyword (if required adjust north angle)
            x=$(get_header -q $hdr IMGROLL)
            test -z "$x" && test -f measure/$nref.src.head &&
                x=$(get_header -q measure/$nref.src.head IMGROLL | tr -d ' ')
            test "$x" == "Y" && nadd=180
        fi
        test -z "$north" &&
            echo "WARNING: assuming north is up." >&2 &&
            north=0
            
        if [ "$do_catonly" ]
        then
            echo "downloading catalog for $img using $rad, $ded ..."
        else
            if [ $nadd -eq 0 ]
            then
                x=$(echo $posmaxerr | awk '{printf("%.1f", $1/60)}')
                echo "calibrating $img using $rad, $ded" \
                    "(north=$north, pixscale=${pixscale}\", maxoff=${x}deg) ..."
            else
                echo "calibrating $img using $rad, $ded" \
                    "(north=$north+$nadd, pixscale=${pixscale}\", maxoff=${x}deg) ..."
            fi
        fi
        
        # convert ra, de, if given in sexagesimal units
        rad=$(sexa2dec $rad 15)
        ded=$(sexa2dec $ded)

        # create head file
        # reference pixel (image center) and coefficients cdNN
        x=$(echo "$w/2" | bc)
        y=$(echo "$h/2" | bc)
        scale=$(echo "scale=6; $pixscale/3600" | bc -l)
        # NEW: north is given in degrees
        north=${north#+}    # need to remove leading +
        xproj="RA---TAN"; yproj="DEC--TAN";
        xval=$rad; yval=$ded
        cd11=$(echo "scale=6; -c(($north+$nadd)/180*3.14159)*$pixscale/3600" | bc -l)
        cd12=$(echo "scale=6; -s(($north+$nadd)/180*3.14159)*$pixscale/3600" | bc -l)
        cd21=$(echo "scale=6; -s(($north+$nadd)/180*3.14159)*$pixscale/3600" | bc -l)
        cd22=$(echo "scale=6;  c(($north+$nadd)/180*3.14159)*$pixscale/3600" | bc -l)
        
        # ascii header file
        echo "\
TELESCOP= 'Telescope'  / Observatory: Telescope
INSTRUME= 'Camera'     / Detector: Camera
FILTER  = 'Filter'     / Detector: Filter" > wcs/$b.src.ahead
        if [ -f $rdir/$nref.hdr ]
        then
            # note: only FLXSCALE is affected in scamp output file
            hdr2ahead $rdir/$nref.hdr >> wcs/$b.src.ahead
        fi
        echo "\
EQUINOX =      2000.0000 / Mean equinox
CTYPE1  = '$xproj'           / WCS projection type for this axis
CUNIT1  = 'deg     '           / Axis unit
CRVAL1  =      $xval   / World coordinate on this axis
CRPIX1  =      $x      / Reference pixel on this axis
CD1_1   =      $cd11   / Linear projection matrix
CD1_2   =      $cd12   / Linear projection matrix
CTYPE2  = '$yproj'           / WCS projection type for this axis
CUNIT2  = 'deg     '           / Axis unit
CRVAL2  =      $yval   / World coordinate on this axis
CRPIX2  =      $y      / Reference pixel on this axis
CD2_1   =      $cd21   / Linear projection matrix
CD2_2   =      $cd22   / Linear projection matrix
END     " >> wcs/$b.src.ahead
        #RADECSYS= 'ICRS    '           / Astrometric system
        #GAIN    =      1    / Maximum equivalent gain (e-/ADU)
        
        test ! -f $sexcat &&
            echo "ERROR: $sexcat missing." >&2 && return 255
        test ! -f wcs/$b.src.ahead &&
            echo "ERROR: wcs/$b.src.ahead missing." >&2 && return 255

        # skip bad/poor detections from sexcat
        # convert threshold to magerrlim
        x=$(echo $threshold | awk '{printf("%f", 1/$1)}')
        if [ "$do_catonly" ]
        then
            # create empty catalog
            sexselect -f $coloropt $sexcat -100 $x "" "" "*" 0 > $tmpcat
        else
            sexselect -f $coloropt $sexcat "" $x "" "" "*" 0 > $tmpcat
        fi
        if [ "$maskreg" ]
        then
            regfilter $tmpcat $maskreg > $tmpcat2
            mv $tmpcat2 $tmpcat
        fi
        cp wcs/$b.src.ahead ${tmpcat%.*}.ahead

        # compute wcs
        test "$do_catonly" && plotdev=NULL
        plotparams="-checkplot_dev $plotdev \
            -checkplot_type fgroups,distortion,astr_referror1d \
            -checkplot_name fgroups,distortion,astr_referror1d"
        photparams="-solve_photom N" # "-solve_photom N -magzero_out 25.5"
        posparams="-position_maxerr $posmaxerr -posangle_maxerr 30"
        test "$crossrad" &&
            posparams="$posparams -crossid_radius $crossrad"
        escfilter="cat"
        (test "$noescapes" || test "$quiet") &&
            escfilter="sed -r s/\x1b\[[0-9;]*[mAM]?//g"
        test "$do_catonly" && escfilter="sed -r d"

        rm -f scamp.xml
        scamp -d > $sconf
        failure=""
        cmd="scamp -c $sconf \
                $plotparams $photparams $posparams \
                -astrefmag_limits -99,$maglim -distort_degrees $fitdegrees \
                -sn_thresholds 10,40 -match_resol $mres \
                -mergedoutcat_type FITS_LDAC -mergedoutcat_name wcs/$b.match.dat \
                $sopts $tmpcat"
        if [ "$nocatquery" ]
        then
            cmd="$cmd -astref_catalog file -astrefcat_name $refcatfile"
        else
            cmd="$cmd -astref_catalog  $refcat -save_refcatalog Y"
            # requires aclient and online access to vizier database
            server=$(echo $sopts | sed 's| -|\n-|g' | grep -i REF_SERVER | awk '{printf("%s", $2)}')
            test -z $server &&
                server=$(grep REF_SERVER $sconf | awk '{printf("%s", $2)}')
            test "$AI_DEBUG" && echo "# server = $server"
            ! check_url &&
                echo "ERROR: no internet connection." >&2 &&
                return 255
            # check server url
            # NOTE: disabled, because cds server is not checked reliably
            false && if ! check_url $server
            then
                echo "# WARNING: server $server is unreachable, trying fallback (vizier.cfa.harvard.edu)"
                cmd="$cmd -ref_server vizier.cfa.harvard.edu"
            fi
        fi
        # echo "cmd=$cmd" >&2
        eval "$cmd" 2>&1 | $escfilter > $slog
        (test $? -ne 0 || test ! -f scamp.xml || ! test -s ${tmpcat%.*}.head) &&
            failure=1
        test -z "$nocatquery" &&
            vizcat=$(ls -tr *cat 2>/dev/null | grep -i "^$refcat" | tail -1) &&
            test ! "$vizcat" &&
            echo "# ERROR: scamp has failed" >&2 &&
            failure=1
        test "$failure$AI_DEBUG" && echo "# $cmd" | sed -e 's, [[:space:]]*, ,g'
        if [ "$quiet" ]
        then
            cat $slog | awk '{
                if ($0~/SCAMP .* started/) print $0
                if (tolower($0)~/error|warning/ &&
                    $0!~/executable .* without .* multithreading/) print $0
                if ($0~/detections loaded|standards found/) print $0
                if ($0~/instruments/) print "\n" $0
                if ($0~/^tmp/ && $0!~/detections/) print $0 "\n"
                if ($0~/Astrometric stats \(external\)/) {
                    print $0; for (i=1;i<=4;i++) {getline; print $0}}
            }' >&2
        else
            grep -v "tmp.*reference pair.*processed'" $slog >&2
        fi
        test "$failure" && echo "ERROR: scamp failed:" >&2 && return 255
        test -z "$nocatquery" && test -f "$vizcat" && mv "$vizcat" $refcatfile
        
        test ! "$do_catonly" && mv ${tmpcat%.*}.head $b.wcs.head
        case $plotdev in
            NULL)   ;;
            SVG)    for p in {fgroups,distort,astr_referror}*svg
                    do
                        rsvg-convert $p > wcs/$b.${p%.*}.png && rm $p
                    done
                    ;;
            PNG)    for p in {fgroups,distort,astr_referror}*png
                    do
                        mv $p wcs/$b.$p
                    done
                    ;;
            *)      for p in {fgroups,distort,astr_referror}*
                    do
                        mv $p wcs/$b.$p
                    done
                    echo "WARNING: not converting checkplots ($plotdev)." >&2
                    ;;
        esac

        # TODO: propagate some header keywords to $b.wcs.head, e.g.
        #   EXPTIME,NEXP,MJD_REF,MJD_OBS,MAGZERO,GAIN,SATURATE
        if [ 0 -eq 1 ] && [ -f $hdr ]
        then
            for h in EXPTIME NEXP MJD_REF MJD_OBS MAGZERO GAIN SATURATE
            do
                echo "TODO"
            done
        fi
        
        # evaluate star matches and show summary
        #x=$(get_header -e LDAC_OBJECTS $refcatfile NAXIS2)
        x=$(stilts tpipe ifmt=fits ofmt=ascii cmd='select "mag<='$maglim'"' \
            in=$refcatfile"#2" | grep -v "^#" | wc -l)
        set - $(stilts tpipe ofmt=text scamp.xml cmd=transpose | awk -v ncat=$x '{
            if($2=="NDetect")               nsrc=$4
            if($2=="NDeg_Reference")        nmatch=$4
            if($2=="NDeg_Reference_HighSN") nhigh=$4
        }END{
            printf("%d %d %d %d\n", nsrc, ncat, nmatch, nhigh)
        }')
        
        if [ -z "$do_catonly" ]
        then
            set_header $b.wcs.head AREFCAT=$refcat POLYDEG=$fitdegrees \
                CROSSRAD=$crossrad"/CROSSID_RADIUS (arcsec)" \
                MATCHRES=$mres"/MATCH_RESOL (arcsec)"
            # check for >5% matched stars
            test $((($3-5)*100/$1)) -lt 5 && test $((($3-5)*100/$2)) -lt 5 &&
                echo "ERROR: too few stars matched ($3 out of nimg=$1, ncat=$2)." >&2 &&
                return 255
            set_header $b.wcs.head NIMG=$1 NCAT=$2 NMATCH=$3 NHIGH=$4
            echo ""
            echo "nimg=$1   ncat=$2   nmatch=$3   nhigh=$4"
            echo $(get_header -s $b.wcs.head ASTRRMS1,ASTRRMS2) | awk '{
                printf("xrms=%.3f\"  yrms=%.3f\"\n", $1*3600, $2*3600)}'
        fi
                   
        if [ "$showplots" ]
        then
            ls wcs/$sname.*.png > /dev/null 2>&1 &&
                AIdisplay wcs/$sname.*.png &
        fi
        rm -f $tmpcat $tmpcat2 ${tmpcat%.*}.ahead scamp.xml $sconf $slog
    done < $sdat
    test "$singleimage" == "y" && rm $sdat
    #rm -f $tmp1 $tmp2
    return 0
}


# warp PPM images using wcs calibration data (default: <img>.wcs.head)
# result: <img>.warped.ppm and associated FITS header (<img>.warped.head)
# requires imhead in PATH
# weight maps are used if files $b.num.pgm exist
AIwarp () {
    local showhelp
    local do_quiet
    local resamptype        # resampling type (e.g. lanczos3, bilinear)
    local weightmap
    local i
    for i in 1 2 3 4
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-q" && do_quiet=1 && shift 1
        test "$1" == "-r" && resamptype="$2" && shift 2
        test "$1" == "-w" && weightmap="$2" && shift 2
    done
    
    local rdir=${AI_RAWDIR:-"."}
    local sdat=${AI_SETS:-"set.dat"}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local sconf=$(mktemp "$tdir/tmp_swarp_XXXXXX.conf")
    local param
    local img
    local ref
    local out
    local p
    local n1
    local n2
    local ps
    local ra
    local de
    local b
    local c
    local ropts
    local blist
    local clist
    local wopts
    local imgext    # input image extension (ppm or pgm)
    
    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: AIwarp [-r resamptype] [refhead] <img1> [img2] ..." >&2 &&
        return 1
    
    for p in imhead ppmtorgb3
    do
        ! type -p $p > /dev/null 2>&1 && retval=255 &&
            echo "ERROR: program $p not in search path" >&2 && return 255
    done
    
    # check for reference image header file
    ropts=""
    test -f "$1" &&
        grep -q "^BITPIX" $1 && grep -q "^NAXIS1" $1 && grep -q "^NAXIS2" $1 &&
        ref="$1" && shift 1
    
    # some parameters for swarp
    param="-combine_type average -subtract_back N -fscale_keyword NOTHING -blank_badpixels Y"
    test "$do_quiet"    && param="$param -verbose_type quiet $wopts"
    test "$resamptype"  && param="$param -resampling_type $resamptype"

    # evaluate reference image header
    if [ "$ref" ]
    then
        n1=$(grep "^NAXIS1" "$ref" | tr '=' ' ' | awk '{print $2}')
        n2=$(grep "^NAXIS2" "$ref" | tr '=' ' ' | awk '{print $2}')
        ps=$(grep "^CD2_2" "$ref" | tr '=' ' ' | awk '{print 3600*$2}')
        ra=$(grep "^CRVAL1" "$ref" | tr '=' ' ' | awk '{print $2}')
        de=$(grep "^CRVAL2" "$ref" | tr '=' ' ' | awk '{print $2}')
        (test -z "$ps" || test -z "$ra" || test -z "de") &&
            echo "ERROR: missing wcs keywords in $ref." >&2 && return 255
        ropts="-image_size $n1,$n2 -pixelscale_type manual -pixel_scale $ps
            -center_type manual -center $ra,$de"
    fi
    #echo $ropts
    
    # set output file names
    imgext="ppm"; is_pgm $1 && imgext="pgm"; is_pbm $1 && imgext="pgm"
    out=$(basename ${1%\.*}.warped)
    test -f "$out.$imgext" && echo "ERROR: output file $out.$imgext exists." >&2 && return 255
    test -f "$out.head" && echo "ERROR: output file $out.head exists." >&2 && return 255
    swarp -d > $sconf

    # convert to fits
    blist=""
    wopts=""
    for img in "$@"
    do
        test ! -f $img &&
            echo "WARNING: image $img not found." >&2 && continue

        b=${img%\.*}
        test ! -e $b.wcs.head &&
            echo "WARNING: skipping $img, missing file $b.wcs.head." >&2 &&
            continue

        case "$imgext" in
            ppm)    ppmtorgb3 $img; clist="red grn blu";;
            pgm)    cp $img $b.gray; clist="gray";;
        esac
        for c in $clist
        do
            pnmtomef $b.$c > $b.$c.fits
            cp -p $b.wcs.head $b.$c.head
            # weight map
            if [ "$weightmap" ]
            then
                test -f $weightmap &&
                    pnmtomef $weightmap > $b.$c.weight.fits &&
                    cp -p $b.wcs.head $b.$c.weight.head &&
                    test -z "$wopts" &&
                        wopts="-weight_type MAP_WEIGHT -rescale_weights N"
            else
                test -f $b.num.pgm &&
                    pnmtomef $b.num.pgm > $b.$c.weight.fits &&
                    cp -p $b.wcs.head $b.$c.weight.head &&
                    test -z "$wopts" &&
                        wopts="-weight_type MAP_WEIGHT -rescale_weights N"
            fi
            rm $b.$c
        done
        blist="$blist ${b}.XXX"
    done
    test -z "$blist" && echo "no images to process." >&2 && return 255

    # warp images
    for c in $clist
    do
        test ! "$do_quiet" &&
            echo swarp -c $sconf $param $wopts $ropts ${blist//.XXX/.$c.fits}
        swarp -c $sconf $param $wopts $ropts ${blist//.XXX/.$c.fits}
        (test "$c" == "grn" || test "$c" == "gray") &&
            imhead -z coadd.fits > $out.head &&
            test "$wopts" && cp -p coadd.weight.fits $out.weight.fits
        sethead coadd.fits datamin=0 datamax=65535
        meftopnm coadd.fits > out.$c.pgm
        test "$AI_DEBUG" && mv coadd.fits out.$c.fits
        test ! "$AI_DEBUG" &&
            rm -f ${blist//.XXX/.$c.fits} ${blist//.XXX/.$c.weight.fits} &&
            rm -f ${blist//.XXX/.$c.head} ${blist//.XXX/.$c.weight.head}
    done

    # convert result to ppm
    case "$imgext" in
        ppm)    rgb3toppm out.red.pgm out.grn.pgm out.blu.pgm > $out.ppm;;
        pgm)    mv out.gray.pgm $out.pgm;;
    esac
    
    test "$AI_DEBUG" || rm -f out.red.pgm out.grn.pgm out.blu.pgm
    rm -f coadd.fits coadd.weight.fits swarp.xml $sconf
}


# download DSS image at given center coordinates and field size
# or using an existing image filename (wcs calibration must exist)
AIdss () {
    local showhelp
    local outps             # pixelsize of output dss image in arcsec (default:
                            # pixel size of input image)
    local outfile           # name of output file
    local testonly          # if set, do not download DSS images
    local do_use_eso        # if set retrieve data from ESO archive instead of STScI
    local dsscat="dss2r"    # dss catalog to get images from
    local dssopts
    local i
    for i in 1 2 3 4 5 6
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-p" && outps=$2 && shift 2
        test "$1" == "-1" && dsscat="dss1r" && dssopts="-1" && shift 1
        test "$1" == "-o" && outfile="$2" && shift 2
        test "$1" == "-t" && testonly=1 && shift 1
        test "$1" == "-e" && do_use_eso=1 && shift 1
    done
    
    local imgorrad=${1:-""} # image file name or center RA (sexagesimal or
                            # decimal degrees)
    local ded=${2:-""}      # center DEC (sexagesimal or decimal degrees)
    local width=${3:-""}    # field width in degrees
    local height=${4:-""}   # field height in degrees
    local outps=${5:-""}    # output dss image pixel size in arcsec
    local north=${6:-0}     # pa of celestial north pole on the input image
    local sdat=${AI_SETS:-"set.dat"}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local wdir=$(mktemp -d "$tdir/tmp_dss_XXXXXX")
    local tmpwcshdr=$(mktemp "$tdir/tmp_whdr_XXXXXX.head")
    #local tmppgm=$(mktemp "$tdir/tmp_pgm_XXXXXX.pgm")
    local cgiurl="http://archive.stsci.edu/cgi-bin/dss_search"
    local sizelimit=2.0     # max allowed size of downloadable image (degrees)
    local img
    local whdr
    local rad
    local s
    local w     # dimensions of img in pix
    local h
    local inps  # pixelsize of img in arcsec
    local rot   # position angle of true north in img
    local nx    # number of chunks at given axis
    local ny
    local dx    # offset between chunks in pix
    local dy
    local cx    # chunk size in pix
    local cy
    local x
    local y
    local coord
    local param
    local smult=1.05 # chunk size multiplier to allow for field overlaping
    
    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: AIdss [-t] [-1] [-o outfile]" \
            "<image|ra> [de] [width/deg] [height/deg] [pixscale] [northangle]" >&2 &&
        return 1

    test "$do_use_eso" && cgiurl="http://archive.eso.org/dss/dss"
    
    if [ -f "$imgorrad" ]
    then
        # using image to derive center coordinates and field size
        img=$imgorrad
        whdr=${img%.*}.wcs.head
        test ! -f "$whdr" && echo "ERROR: missing wcs header file $whdr" >&2 && return 255
        set - $(identify $img | cut -d " " -f3 | tr 'x' ' ')
        w=$1; h=$2
        # determine rad ded width height inps
        rad=$(get_header $whdr CRVAL1 | awk '{print 1*$1}')
        ded=$(get_header $whdr CRVAL2 | awk '{print 1*$1}')
        inps=$(get_wcspscale $whdr)
        rot=$(get_wcsrot $whdr | awk '{print -1*$1}')
        test -z "$width"  && width=$(echo $w $h $rot $inps  | \
            awk '{a=$3/180*3.14159; x=$1*cos(a); y=$2*sin(a)
                print (sqrt(x*x)+sqrt(y*y))*$4/3600}')
        test -z "$height" && height=$(echo $w $h $rot $inps | \
            awk '{a=$3/180*3.14159; x=$1*sin(a); y=$2*cos(a)
                print (sqrt(x*x)+sqrt(y*y))*$4/3600}')
        echo "# size $width x $height deg" >&2
    else
        test $# -lt 4 &&
            echo "ERROR: missing required parameters." >&2 && return 255
        rad=$(sexa2dec $imgorrad 15)
        ded=$(sexa2dec $ded)

        # create artificial wcs header file which is later being used to
        # determine center coordinates of image chunks
        # largest image dimension is set to 2000 pix
        set - $(echo $width $height | awk '{
            if ($1>=$2) {
                w=2000; h=$2/$1*2000; ps=$1*3600/w
            } else {
                h=2000; w=$1/$2*2000; ps=$2*3600/h
            }
            printf("%d %d %f\n", w, h, ps)
            }')
        w=$1; h=$2; inps=$3
        mkwcs ${w}x${h} $rad $ded $north $inps > $tmpwcshdr
        whdr=$tmpwcshdr
    fi

    # set output file name
    s="$(dec2sexa -m $rad 15 0 | tr -d ':+')$(dec2sexa -h $ded 1 1 | tr -d ':.')"
    test ! "$outfile" && outfile=$s.$dsscat.fits.gz
    test -s $outfile &&
        echo "ERROR: output file $outfile already exists." >&2 &&
        return 255

    
    # if either image dimension is larger then $sizelimit then divide
    #   image into chunks of max. 1 deg
    # determine chunk size multiplier dependant on declination
    # (because dss images are NOT aligned to north celestial pole)
    smult=1.06
    x=$(echo ${ded%.*} | tr -d "+-")
    test $x -gt 30 && smult=1.10
    test $x -gt 50 && smult=1.14
    test $x -gt 60 && smult=1.20
    test $x -gt 70 && smult=1.30
    test $x -gt 80 && smult=1.40
    set - $(echo $width $height $inps | awk -v lim=$sizelimit -v m=$smult '{
        nx=1; ny=1
        if ($1>lim) {nx=int($1)+1}
        if ($2>lim) {ny=int($2)+1}
        if (nx*ny == 1) {m=1}
        x=$1*3600/nx/$3
        y=$2*3600/ny/$3
        printf("%d %d %.1f %d %d %.1f\n", nx, x, m*$1*60/nx, ny, y, m*$2*60/ny)
        }')
    # number of chunks
    nx=$1; ny=$4
    # offset between chunks in pixel
    dx=$2; dy=$5
    test "$AI_DEBUG" && echo "# offset/pix      dx=$dx dy=$dy" >&2
    # chunk size in arcmin
    cx=$3; cy=$6
    test "$AI_DEBUG" && echo "# chunk size/amin  cx=$cx cy=$cy" >&2


    # downloads
    echo "download $nx x $ny chunks ..." >&2
    i=1
    for y in $(seq $((h/2-(ny-1)*dy/2)) $dy $((h/2+(ny-1)*dy/2+3)))
    do
        for x in $(seq $((w/2-(nx-1)*dx/2)) $dx $((w/2+(nx-1)*dx/2+3)))
        do
            coord=$(echo "id $x $y" | xy2rade - $whdr | awk '{printf("r=%f&d=%f", $1, $2)}')
            param="v=poss2ukstu_red&e=J2000&f=fits&c=gzip&w=$cx&h=$cy&${coord}"
            test "$do_use_eso" &&
                coord=$(echo "id $x $y" | xy2rade - $whdr | awk '{printf("ra=%f&dec=%f", $1, $2)}') &&
                param="Sky-Survey=DSS2-red&mime-type=display/gz-fits&x=$cx&y=$cy&equinox=J2000&${coord}"
            echo "# $i/$(($nx*ny))"
            i=$((i+1))
            test "$testonly" &&
                echo "wget -O $wdir/$$.$x.$y.dss.fits.gz \"$cgiurl?$param\"" &&
                continue
            wget -O $wdir/$$.$x.$y.dss.fits.gz "$cgiurl?$param"
            test $((nx*ny)) -gt 1 && gunzip $wdir/$$.$x.$y.dss.fits.gz
        done
    done

    if [ -z "$testonly" ]
    then
        if [ $((nx*ny)) -gt 1 ] || [ "$outps" ]
        then
            # note: coadded image is always aligned to celestial north pole
            sopts="-subtract_back Y -fscalastro_type none"
            test "$outps" && sopts="$sopts -pixelscale_type manual -pixel_scale $outps"
            swarp -center_type manual -center "$rad,$ded" $sopts $wdir/$$.*.dss.fits
            test $? -ne 0 &&
                echo "ERROR: swarp program error during
swarp -subtract_back Y -center_type manual -center \"$rad,$ded\" \
-pixelscale_type manual -pixel_scale $outps \
-fscalastro_type none $wdir/$$.*.dss.fits" >&2 && return 255
            # -image_size "${size/x/,}"
            #imrot -x 16 coadd.fits
            #mv coaddb16.fits $outfile
            #sethead $outfile TELESCOP="Oschin Schmidt - D"
            gzip -c coadd.fits > $outfile
        else
            # note: dss image is NOT aligned to celestial north pole
            mv $wdir/$$.$x.$y.dss.fits.gz $outfile
        fi
    fi
    
    test -z "$AI_DEBUG" &&
        rm -f $tmpwcshdr &&
        rm -f $wdir/$$.*.dss.fits* &&
        rmdir $wdir &&
        rm -f coadd.fits coadd.weight.fits
    return
}


# start Aladin sky atlas
AIaladin () {
    # TODO: implement [-n north] [-W width/deg] [-H height/deg]
    local showhelp
    local north             # pa of celestial north pole
    local width             # initial field width in degrees
    local height            # initial field height in degrees
    local apass             # if set then load APASS stars
    local mpclabel          # if set add MPES position label
    local jpllabel          # if set add JPL position label
    local skip              # name of query to skip (mpc|jpl)
    local i
    for i in $(seq 1 8)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-n" && north=$2 && shift 2
        test "$1" == "-W" && width=$2 && shift 2
        test "$1" == "-H" && height=$2 && shift 2
        test "$1" == "-a" && apass=1 && shift 1
        test "$1" == "-m" && mpclabel=1 && shift 1
        test "$1" == "-j" && jpllabel=1 && shift 1
        test "$1" == "-s" && skip=$2 && shift 2
    done
    
    local par1=${1:-""}     # image set or center RA  or comet or FITS file name
                            # or common object designation (e.g. M42)
    local par2=${2:-""}     #              center DEC or uttime or utdate or "now"
    local par3=${3:-""}     #                                      uttime
    local sname
    local comet
    local ra
    local dec
    local utdate    # yyyy-mm-dd
    local uttime    # hh:mm
    local sdat=${AI_SETS:-"set.dat"}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpdat=$(mktemp "$tdir/tmp_data_XXXXXX.dat")
    local liteurl="http://aladin.u-strasbg.fr/AladinLite"
    local script
    local object
    local label
    local labelpos
    local catlayer
    local x
    local y
    local line
    local imgcenter
    
    (test "$showhelp" || test $# -lt 1 || test $# -gt 3) &&
        echo "usage: AIaladin [-a] [-j] [-m] <setname |" \
            "ra dec | comet uttime/hh:mm | comet utdate/yyyy-mm-dd uttime/hh:mm>" >&2 &&
        return 1

    # single parameter: setname or object (not solar system)
    if [ $# -eq 1 ]
    then
        if [ -f "$par1" ] && is_fits "$par1"
        then
            # get ra dec object
            ra=$(get_header $par1 RA)
            dec=$(get_header $par1 DEC)
            imgcenter="$ra $dec"
            comet=$(get_header $par1 OBJECT)
            set - $(jd2ut -t $(get_jd $par1))
            utdate="$1"
            uttime="$2"
        else
            if [ -s set.dat ] && is_setname "$par1"
            then
                sname=$par1
                x=$(imcoord $sname)
                test $? -ne 0 &&
                    echo "ERROR: unable to determine image coordinates." >&2 && return 255
                set - $(echo $x)
                ra=$1; dec=$2
                # check for target coordinates and set a label
                label=$(get_header -q $sname.head OBJECT)
                labelpos=$(get_header -q -s $sname.head AI_CORA,AI_CODEC | tr '\n' ',')
                # test -z "$labelpos" && labelpos="$ra,$dec"
            else
                echo "# trying to search for object $par1"
                ra=$par1
                dec=""
                label=$par1
            fi
        fi
    fi

    # two parameters, first one without letters
    test -z "$ra" && if [ $# -eq 2 ] && [ "${1//[a-zA-Z]/}" == "$1" ]
    then
        ra=$par1; dec=$par2
    fi
    
    # two parameters, first one with letters
    test -z "$ra" && if [ $# -eq 2 ] && [ "${1//[a-zA-Z]/}" != "$1" ]
    then
        comet="$par1"; utdate=$(date +'%Y-%m-%d')
        if [ "$par2" == "now" ]
        then
            uttime=$(date -u +'%H:%M')
        else
            uttime=$par2
        fi
    fi
    
    # three parameters
    test -z "$ra" && if [ $# -eq 3 ]
    then
        comet="$par1"; utdate=$par2; uttime=$par3
    fi
    
    # get comet ephemerides if required
    if [ "$comet" ]
    then
        if [ "$skip" != "mpc" ]
        then
            get_mpcephem "$comet" $utdate $uttime | tee $tmpdat
            if [ $? -ne 0 ]
            then
                echo "WARNING: failed command: get_mpcephem \"$comet\" $utdate $uttime" >&2
            else
                set - $(tail -1 $tmpdat)
                shift 4
                ra=$1:$2:$3; dec=$4:$5:$6
            fi
        fi
        if [ "$skip" != "jpl" ]
        then
            get_jplcoord -v "$comet" $utdate $uttime > $tmpdat
            if [ $? -ne 0 ]
            then
                echo "WARNING: failed command: get_jplcoord \"$comet\" $utdate $uttime" >&2
            else
                set - $(tail -1 $tmpdat)
                ra=$1; dec=$2
                echo "# JPL coordinates: $comet  $ra $dec" >&2
            fi
        fi
        label="$comet"
        labelpos="$ra,$dec"
        test -z "$labelpos" &&
            echo "ERROR: unable to determine object coordinates" >&2 && return 255
    fi
    
    # additional labels
    if [ "$mpclabel" ]
    then
        truncate -s 0 $tmpdat
        if [ "$comet" ]
        then
            get_mpcephem "$comet" $utdate $uttime | tee $tmpdat
        else
            test "$sname" && get_mpcephem $sname | tee $tmpdat
        fi
        if [ ! -s $tmpdat ]
        then
            mpclabel=""
        else
            set - $(tail -1 $tmpdat)
            shift 4
            x=$1:$2:$3; y=$4:$5:$6
            cat $tmpdat >&2
            echo "# x=$x y=$y" >&2
            mpclabel="draw rgb(100,120,255) tag($x,$y MPC,30,60,bigcircle,16)"
        fi
    fi
    if [ "$jpllabel" ]
    then
        truncate -s 0 $tmpdat
        if [ "$comet" ]
        then
            get_jplcoord "$comet" $utdate $uttime | tee $tmpdat
        else
            test "$sname" && get_jplcoord $sname | tee $tmpdat
        fi
        if [ ! -s $tmpdat ]
        then
            jpllabel=""
        else
            set - $(tail -1 $tmpdat)
            jpllabel="draw green tag($1,$2 JPL,30,60,bigcircle,16)"
        fi
    fi
 
    if type -p aladin > /dev/null 2>&1
    then
        # use the full featured desktop version
        script="$ra $dec; reticle off"
        test "$imgcenter" && script="$imgcenter; reticle off"
        catlayer=2
        if [ "$label" ]
        then
            catlayer=3
            if [ "$dec" ]
            then
                # using sky coordinates
                test "$mpclabel" && script="$script; $mpclabel"
                test "$jpllabel" && script="$script; $jpllabel"
                script="$script; draw red tag($labelpos '$label',60,30,bigcircle,16)"
            else
                # draw to center of image
                script="$script; setconf frame=XY image; draw red tag(250 -250 '$label',60,30,bigcircle,16)"
            fi
            script="$script; set @2 opacity=40"
        fi
        if [ "$apass" ]
        then
            script="$script; get VizieR(II/336/apass9) $ra $dec 60'"
            script="$script; set @$catlayer opacity=5; set @$catlayer size=3"
        fi
        # TODO: check for running aladin instance
        #ps -C aladin >/dev/null && echo ok
        echo "# aladin script commands: "
        echo "  $script"
        (echo "$script" | aladin) &
    else
        # use aladin lite online version
        # TODO: get displayed image size
        script="target=$ra%20$dec&fov=1"
        test "$AI_DEBUG" && echo "url=$liteurl/?$script"
        xdg-open "$liteurl/?$script" 3>&1 1>&2 2>&3 3>&- | grep -vi "GLib-GObject-CRITICAL **: g_object_.*ref: assertion"
    fi
}


# stack a set of RGB or grayscale images
# uses wcs calibration data and bad region maps (in bgvar)
# output image size is the same as first input image, for mosaics this
#   must be changed to full coverage size (option -f)
# TODO: use instrumental weight map to reduce weight in vignetted areas.
AIstack () {
    local showhelp
    local insuffix=""       # suffix added to base of input images
    local outsuffix=""      # suffix added to base of output file names
    local cropgeom=""       # crop input images before stacking (wxh+x+y), NOT implemented!
    local imgsize=""        # use this image size for coadded image
    local xyscale=1         # scale up/down output image resolution
    local use_full_size     # if set use full coverage of input images
    local do_subtract_bg    # if set apply background subtraction
    local omove=""          # stack on moving object using either dx,dy
                            #   (pix/min) or dr@pa@x,y where dr@pa is object
                            #   move on sky in "/hr,deg and x,y is position of
                            #   object on image in image coords
    local sparam=""         # additional parameters passed over to swarp
    local cref=""           # reference image to get center coordinates from or cxfits,cyfits
    local verbose=0         # if >0 print some info about shifted image center
                            # if >1 print additional messages from scamp
    #local do_weight_combine # if set use combine_type weighted instead of average
    local do_bayer          # if set then stack separately on each bayer grid
                            # color
    local do_halfset        # if set create two stacks from first/second half
                            # number of images in the set
    local do_not_register   # no registration, use combine_type median
    local use_regdat        # use translation data from reg.dat (ignore measure/*head)
    local badpix            # badpix bitmask (ignore white pixels)
    local ctype="average"   # combine_type
    local resamptype="bilinear" # resampling type (e.g. lanczos3, bilinear)
    local bgdiffzero=10000  # must match the bgzero value used by AIbgdiff to
                            # create bgvar/*.bgm1.* images
    local bin               # set BINNING (ignoring value from raw file header)
    local mem               # max memory in MB, default: pram*(RAM-0.5GB)
    local pram=50           # max memory in percent
    local do_parallel=""    # if set then run swarp for all colors in parallel
    local i
    for i in $(seq 1 20)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-i" && insuffix="$2" && shift 2
        test "$1" == "-o" && outsuffix="$2" && shift 2
        #test "$1" == "-g" && cropgeom="$2" && shift 2
        test "$1" == "-c" && cref="$2" && shift 2
        test "$1" == "-s" && imgsize="$2" && shift 2
        test "$1" == "-z" && xyscale="$2" && shift 2
        test "$1" == "-f" && use_full_size=1 && shift 1
        test "$1" == "-b" &&
            echo "WARNING: using experimental option -b." >&2 && do_bayer=1 && shift 1
        test "$1" == "-bg" && do_subtract_bg=1 && shift 1
        test "$1" == "-t" && ctype="$2" && shift 2
        test "$1" == "-w" && do_weight_combine=1 &&
            echo "ERROR: option do_weight_combine is not available any more" >&2 &&
            echo "       please use '-ctype weighted' instead" && return 255
        test "$1" == "-v" && verbose=$((verbose+1)) && shift 1
        test "$1" == "-m" && omove="$2" && shift 2
        test "$1" == "-p" && sparam="$2" && shift 2
        test "$1" == "-2" && do_halfset=1 && shift 1
        test "$1" == "-bad" && badpix=$2 && shift 2
        test "$1" == "-bz" && bgdiffzero=$2 && shift 2
        test "$1" == "-bin" && bin=$2 && shift 2
        test "$1" == "-r" && resamptype="$2" && shift 2
        test "$1" == "-n" && do_not_register=1 && shift 1
        test "$1" == "-reg" && use_regdat=1 && shift 1  # experimental
        test "$1" == "-mem" && mem="$2" && shift 2
    done
    local setname=${1:-""}          # empty or setname or first image
    local bsize=512                 # default: 128
    local iweight="iweight.pgm"     # instrumental weight map
    local sdat=${AI_SETS:-"set.dat"}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local imlist=$(mktemp "$tdir/tmp_imlist_XXXXXX.dat")
    local wdir=$(mktemp -d "$tdir/tmp_mosaic_XXXXXX")
    local xml
    local conf
    local ilist=""          # list of input images
    local wlist=""          # list of input weight images
    local out=""            # base of output file names
    local outlist
    local param             # global parameters
    local setparam          # set specific parameters
    local cparam            # color channel specific parameters
    local gain=1.0          # effective detector gain in e-/ADU
    local saturation
    local pixscale          # (approx.) pixel scale in arcsec per pixel
    local magzero
    local ltime
    local sname
    local target
    local type
    local texp
    local n1
    local n2
    local nref
    local dark
    local flat
    local x
    local has_image_args
    local xycenter
    local inext
    local num
    local fname
    local wcs
    local href
    local rot
    local regpixscale       # arbitrary pixscale used by AIregister
    local clist             # names of color channels
    local c
    local n
    local flist
    local outfits
    local weightfits
    local ncolors
    local bpp
    local b
    local w
    local h
    local jdref
    local jdmean
    local jd
    local dateobs
    local imgroll
    local pierside
    local filter
    local binning
    local popts
    local retval=0
    local tmpsh=$(mktemp "/tmp/tmp_script_XXXXXX.sh")
    chmod u+x $tmpsh

    # max amount of RAM to be used by swarp
    if [ -z "$mem" ]
    then
        mem=$(cat /proc/meminfo | grep "MemTotal:" | awk -v p=$pram '{
            printf("%.0f", p/100*($2/1024-512))}')
        test "$do_parallel"    && test $mem -gt 3072 && mem=3072
        test -z "$do_parallel" && test $mem -gt 1024 && mem=1024
        test $mem -lt 256 && mem=256
    fi
    
    test "$showhelp" &&
        echo "usage: AIstack [-i insuffix] [-o outsuffix] [-2] [-f] [-b] [-bg]" \
            "[-v] [-n] [-bz bgdiffzero|$bgdiffzero] [-mem memory|$mem]" \
            "[-r resamptype] [-bad badpix] [-m dx,dy | -m dr@pa] [-c centerrefimg | -c xfits,yfits]" \
            "[-z xyscale] [-s w,h] [-p sparam] [setname | img1 img2 ...]" >&2 &&
        return 1
    
    test "$badpix" && test ! -f "$badpix" &&
        echo "ERROR: badpix file $badpix not found." >&2 && return 255

    # base parameters for swarp
    param="-resample_dir $wdir"
    param="$param -blank_badpixels Y -fscale_keyword XYZ"
    if [ "$do_subtract_bg" ]
    then
        param="$param -subtract_back Y -back_size $bsize"    # default: 128
    else
        param="$param -subtract_back N"
    fi
    if [ $verbose -gt 1 ] || [ "$AI_DEBUG" ]
    then
        param="$param -verbose_type NORMAL"
    else
        param="$param -verbose_type QUIET"
    fi
    
    # combine_type and resampling type
    test -z "$resamptype" && resamptype="bilinear"
    param="$param -combine_type $ctype -resampling_type $resamptype -weight_type map_weight"
    echo "# combine: $ctype  resampling: $resamptype" >&2


    test "$imgsize"  && param="$param -image_size $imgsize"
    test "$AI_DEBUG" && param="$param -delete_tmpfiles N"

    if [ -f "$setname" ]
    then
        ! is_pnm $setname &&
            echo "ERROR: $setname is not a recogniced file type (PNM)." >&2 &&
            rm -f $imlist &&
            return 255
        sdat=$tdir/tmp_set_$$.dat
        echo "00:00 $setname xx o 0 0 0 ${setname%.*} xx xx" > $sdat
        has_image_args="y"
    fi
    
    if [ "$cref" ]
    then
        if [ "${cref/,/}" != "$cref" ]
        then
            # cref contains FITS image pixel coordinates of new center
            xycenter="${cref/,/ }"
            cref=""
        else
            # cref contains file name of reference image from which center coordinates are taken
            test ! -f "${cref%.*}.head" &&
                echo "ERROR: image header for $cref (cref) not found." >&2 && return 255
            outcrval1=$(grep "^CRVAL1 " ${cref%.*}.head | awk '{print $3}')
            outcrval2=$(grep "^CRVAL2 " ${cref%.*}.head | awk '{print $3}')
            (test -z "$outcrval1" || test -z "$outcrval2") &&
                echo "ERROR: missing CRVAL* in ${cref%.*}.head." >&2 && return 255
            param="$param -center_type manual -center $outcrval1,$outcrval2"
            
            if [ "$use_full_size" ] && [ -z "$imgsize" ]
            then
                param="$param -image_size $(imsize $cref | tr ' ' ',')"
            fi
        fi
    fi

    while read ltime sname target type texp n1 n2 nref dark flat x
    do
        (echo "$ltime" | grep -q "^#") && continue
        test "$type" != "o" && continue
        test "$setname" && test "$setname" != "$sname" && continue
        (! is_integer "$n1" || ! is_integer "$n2") && continue
        test -z "$has_image_args" && ! is_integer "$nref" && continue
 
        inext=""
        regpixscale=""
        if [ "$has_image_args" ]
        then
            echo "WARNING: has_image_args is UNTESTED!" >&2
            for img in "$@"; do echo "xx yy $img" >> $imlist; done
            outlist="mosaic$outsuffix"
            test "$AI_SATURATION" && saturation=$AI_SATURATION
            test "$AI_GAIN"       && gain=$AI_GAIN
            test "$AI_PIXSCALE"   && pixscale=$AI_PIXSCALE && regpixscale=$AI_PIXSCALE
            test "$AI_MAGZERO"    && magzero=$AI_MAGZERO
        else
            if [ "$do_bayer" ]
            then
                AIimlist $sname "" pgm > $imlist
                inext="pgm"
            else
                AIimlist $sname > $imlist
                set - $(head -1 $imlist) x
                test -s "$imlist" && is_pgm $3 && inext="pgm"
                test -z "$inext" && inext="ppm"
            fi
            outlist="${sname}$outsuffix"
            test "$do_halfset" && outlist="${sname}a$outsuffix ${sname}b$outsuffix"

            # read data from camera.dat or environment
            saturation=$(get_param camera.dat satur    $sname AI_SATURATION)
            gain=$(get_param       camera.dat gain     $sname AI_GAIN       $gain)
            pixscale=$(get_param   camera.dat pixscale $sname AI_PIXSCALE)
            magzero=$(get_param    camera.dat magzero  $sname AI_MAGZERO)
            test -z "$pixscale" &&
                echo "ERROR: cannot determine pixscale for $sname, skipping set." >&2 &&
                retval=1 && continue

            if [ "$use_regdat" ]
            then
                regpixscale=1
            else
                # get regpixscale from measure/$nref.src.head
                if [ ! -f measure/$nref.src.head ]
                then
                    echo "ERROR: measure/$nref.src.head is missing." >&2
                else
                    regpixscale=$(get_wcspscale measure/$nref.src.head)
                fi
            fi
            test -z "$regpixscale" && retval=1 &&
                echo "ERROR: cannot determine regpixscale for $sname, skipping set." >&2 &&
                continue
        fi
        for out in $outlist
        do
            test -f $out.head &&
                echo "WARNING: skipping $sname, output header file $out.head already exists." >&2 &&
                rm -f $imlist $conf &&
                continue
        done
        test ! -f $imlist && retval=1 && continue
        
        # determine image rotation of reference image (and star stack) with
        # respect to true north (if omove is given as dr@pa@x,y
        if [ "$omove" ] && [ "${omove/@/}" != "$omove" ]
        then
            rot=$(get_wcsrot $sname $(echo $omove | awk -F "@" '{print $3}' | tr ',' ' '))
            test -z "$rot" &&
                echo "ERROR: cannot get wcsrot for set $sname." >&2 && retval=255 && continue
        fi
        
        # get true pixscale from wcs header file
        if [ "$omove" ] && [ "${omove/@/}" != "$omove" ]
        then
            pixscale=$(get_wcspscale $sname)
            test -z "$pixscale" &&
                echo "ERROR: cannot get wcspscale for set $sname." >&2 && retval=255 && continue
        fi
        
        # determine swarp parameters depending on set (e.g. regpixscale, magzero)
        setparam=""
        test "$gain"       && setparam="$setparam -gain_default $gain"
        test "$saturation" && setparam="$setparam -satlev_default $saturation"
        if [ "$regpixscale" ]
        then
            regpixscale=$(echo $regpixscale $xyscale | awk '{print $1/$2}')
            setparam="$setparam -pixelscale_type manual -pixel_scale $regpixscale"
        else
            # if regpixscale is not set then swarp uses median from input images
            echo "WARNING: regpixscale not set, using median from input images." >&2
        fi

        # check for image file and wcs header
        n=0; ilist=""
        while read x num fname x
        do
            test ! -f ${fname%.*}$insuffix.${fname##*.} &&
                echo "ERROR: ${fname%.*}$insuffix.${fname##*.} not found." >&2 && n=0 && break
            if [ ! "$use_regdat" ]
            then
                wcs=${fname%.*}.wcs.head
                if [ ! -f "$wcs" ]
                then
                    wcs=measure/$(basename ${fname%.*}.src.head)
                    test ! -f "$wcs" &&
                        echo "WARNING: skipping $fname (header file not found)." >&2 &&
                        retval=1 && continue
                fi
                if [ "$omove" ]
                then
                    ! grep -q "^MJD_OBS =" $wcs && ! grep -q "^JD      =" $wcs &&
                        ! grep -q "^DATE-OBS=" $wcs &&
                        echo "WARNING: skipping $fname (missing MJD_OBS in header file)." >&2 &&
                        retval=1 && continue
                fi
            fi
            n=$(($n + 1))
            ilist="$ilist $fname"
        done < $imlist
        
        # if appropriate, set center coordinates
        if [ -z "$use_full_size" ]
        then
            if [ ! "$cref" ]
            then
                if [ "$use_regdat" ]
                then
                    #### EDIT
                    do_something ...
                else
                    wcs=$nref.wcs.head
                    test ! -f "$wcs" && wcs=measure/$nref.src.head
                    test ! -f "$wcs" &&
                        echo "WARNING: $nref.wcs.head not found, cannot set center." >&2 &&
                        break
                    if [ "$xycenter" ]
                    then
                        set - $(echo "center" $xycenter | xy2rade -f -s - $wcs)
                        outcrval1=$(sexa2dec $1 15)
                        outcrval2=$(sexa2dec $2)
                    else
                        outcrval1=$(grep "^CRVAL1 " $wcs | awk '{print $3}')
                        outcrval2=$(grep "^CRVAL2 " $wcs | awk '{print $3}')
                    fi
                    (test -z "$outcrval1" || test -z "$outcrval2") &&
                        echo "ERROR: missing CRVAL* in $wcs." >&2 && return 255
                fi
                setparam="$setparam -center_type manual -center $outcrval1,$outcrval2"
            fi
        fi
        
        if [ "$has_image_args" ]
        then
            test $n -eq 0 && echo "WARNING: no input images." && retval=1 && continue
            echo "processing $n images ..."
        else
            test $n -eq 0 && echo "WARNING: skipping set $sname" && retval=1 && continue
            echo "processing $n images in set $sname ..."
        fi

        # disk space
        #   fits image:     ncolors*2byte*npixin / image
        #   weight maps:    1byte*npixin / image
        #   sratio=npixout/npixin=z*xyscale^2  # z=1 if ! $imgsize and ! use_full_size 
        #   resamp.fits:    3*2byte*npixout/image # 2x because of possible 45deg rotation,
        #                                           # 1.5x because of margins
        #   resamp.weight.fits: 3*2byte*npixout/image
        #   coadding:       2*ncolors*2byte*npixout / set
        img=$(head -1 $imlist | awk '{print $3}')
        if [ -z "$cropgeom" ]
        then
            w=$(identify $img | cut -d " " -f3 | cut -d "x" -f1)
            h=$(identify $img | cut -d " " -f3 | cut -d "x" -f2)
        else
            set - $(echo $cropgeom | tr 'x+-' ' ')
            w=$1
            h=$2
        fi
        ncolors=3
        is_pgm $img && ncolors=1
        test "$do_bayer"     && ncolors=2   # ??
        # wratio=num_weight_maps/num_input_images
        # bpp=2*ncolors*2*(1+wratio+sratio)  # bytes/pixel/input_image
        # bpp=$(echo $ncolors 0.1 $xyscale | awk '{printf("%.0f\n", 3*$1*(1+$2+$3*$3))}')
        bpp=$(echo $ncolors 0.1 $xyscale | awk '{printf("%.0f\n", 2*$1+1 + 12*($3*$3))}')
        ! is_diskspace_ok -v "$tdir" "$img" $((n+2)) $((bpp)) &&
            echo "ERROR: not enough disk space to process set $sname." >&2 && retval=1 && continue
        
        # get jd, filter, pierside, imgroll from reference image header
        jdref=""; filter=""; binning="$bin"; pierside=""; imgroll=""
        if [ "$use_regdat" ]
        then
            #### EDIT
            echo "ERROR: AIstack: use_regdat=${use_regdat} is not supported" >&2
            return 255
            #do_something ...
        else
            href=$nref.head
            test ! -f $href && href=measure/$nref.src.head
            if [ -f $href ]
            then
                jdref=$(get_header -q $href JD)
                test -z "$jdref" &&
                    jdref=$(grep -E "^MJD_REF =|^MJD_OBS =" $href | lines 1 | \
                        awk '{printf("%s", $3)}')
                if [ -z "$jdref" ]
                then
                    dateobs=$(grep "^DATE-OBS=" $href | tr -d "'" | awk '{print $2}')
                    test "$dateobs" && jdref=$(ut2jd $(echo $dateobs | tr -d '-' | \
                        awk -F "T" '{print $2" "substr($1,3)}'))
                fi
                grep "^IMGROLL =" $href | tr -d "'" | grep -q -w Y &&
                    imgroll="yes"
                filter=$(get_header -q $href FILTER)
                test -z "$binning" && binning=$(get_header -q $href BINNING)
                test -z "$binning" && binning=$(get_header -q $href XBINNING)
                pierside=$(get_header -q $href PIERSIDE)
            fi
        fi
        test -z "$jdref" &&
            echo "ERROR: cannot determine jd from reference image header." >&2 &&
            retval=1 && continue
        # determine mean MJD_OBS (mean from all images)
        jdmean=$(printf "%.5f" $(get_jd_dmag $sname | mean - 2))
        test -z "$jdmean" &&
            echo "ERROR: cannot determine mean jd (from get_jd_dmag $sname)." >&2 &&
            retval=1 && continue
        # correct pixscale for binning
        false && test "$binning" &&
            pixscale=$(echo $pixscale $binning | awk '{print $1*$2}') &&
            echo "# binning=$binning, pixscale=$pixscale" >&2

        # determine output image color channels
        clist="red grn blu"
        test "$inext" == "pgm" && test -z "$do_bayer" && clist="gray"

        # create unity weight map used if no badreg/badimg exists
        for c in $clist
        do
            echo -e "P2\n2 2\n1\n0 0 0 1" | \
                pnmtile $w $h - | pnmtomef - > $wdir/$c.weight.fits
        done
            
        # convert to fits images
        echo "converting to fits ($(date +'%H:%M:%S')) ..." >&2
        
        cat <<EOF > $tmpsh
#!/bin/bash
. airfun.sh > /dev/null
tdir=$tdir
wdir=$wdir

verbose=$verbose
omove="$omove"
jdref=$jdref
rot=$rot
pixscale=$pixscale
clist="$clist"
inext=$inext
w=$w
h=$h
bgdiffzero=$bgdiffzero
do_bayer="$do_bayer"
do_not_register="$do_not_register"
badpix="$badpix"

_fitsconv_parallel \$@
EOF

        _fitsconv_parallel () {
            local n=$1      # running number
            local img=$2
            local wcs
            local jd
            local dateobs
            local dsec
            local crpix1
            local crpix2
            local c
            local badreg
            local badimg
            local badtmp=$(mktemp "$tdir/tmp_bad_XXXXXX.pbm")
            local tmpfits=$(mktemp "$tdir/tmp_rgb_XXXXXX.fits")
            test $verbose -gt 0 &&
                echo "$n $img" >&2
            #echo "## n=$n  img=$img" >&2
            # find wcs file to extract jd and crpix1, crpix2
            wcs=${img%.*}.wcs.head
            test ! -f "$wcs" && wcs=measure/$(basename ${img%.*}.src.head)

            if [ "$omove" ] && [ "$jdref" ]
            then
                # determine shifted reference pixel coordinates
                #dsec=$(echo $(getImageDateSec $num) - $(getImageDateSec $nref) | bc)
                jd=$(grep -E "^MJD_OBS =|^JD " $wcs | lines 1 | awk '{printf("%s", $3)}')
                if [ -z "$jd" ]
                then
                    dateobs=$(grep "^DATE-OBS=" $wcs | tr -d "'" | awk '{print $2}')
                    test "$dateobs" && jd=$(ut2jd $(echo $dateobs | tr -d '-' | \
                        awk -F "T" '{print $2" "substr($1,3)}'))
                fi
                dsec=$(echo $jd $jdref | awk '{print ($1-$2)*24*3600}')
                if [ "${omove/@/}" == "$omove" ]
                then
                    # omove=dx,dy
                    crpix1=$(grep "^CRPIX1  =" $wcs | \
                        awk -v s=$dsec -v m=${omove%,*} '{printf("%.2f", $3+m*s/60)}')
                    crpix2=$(grep "^CRPIX2  =" $wcs | \
                        awk -v s=$dsec -v m=${omove#*,} '{printf("%.2f", $3+m*s/60)}')
                else
                    # omove=dr@pa with respect to true wcs
                    # TODO: use true wcs pixscale, add xy to get_wcsrot
                    crpix1=$(grep "^CRPIX1  =" $wcs | awk -v s=$dsec -v r=$rot \
                        -v rimg=$(get_wcsrot $wcs) -v p=$pixscale -v m=$omove '{
                            split(m,a,/@/); r=(a[2]-r-rimg)*3.14159/180
                            printf("%.2f", $3-a[1]*sin(r)*s/3600/p)}')
                    crpix2=$(grep "^CRPIX2  =" $wcs | awk -v s=$dsec -v r=$rot \
                        -v rimg=$(get_wcsrot $wcs) -v p=$pixscale -v m=$omove '{
                            split(m,a,/@/); r=(a[2]-r-rimg)*3.14159/180
                            printf("%.2f", $3+a[1]*cos(r)*s/3600/p)}')
                fi
                test "$verbose" -gt 0 &&
                    echo $img crpix1=$crpix1 crpix2=$crpix2 >&2
            fi
            
            # convert pnm to fits
            if is_pgm $img
            then
                if [ -f bgvar/$(basename ${img%.*}).bgdiff.$inext ]
                then
                    convert bgvar/$(basename ${img%.*}).bgdiff.$inext \
                        -resize ${w}x${h}! - | \
                        pnmccdred -a $bgdiffzero -d - $img - | \
                        pnmtomef - > $wdir/$n.gray.fits
                else
                    pnmtomef $img  > $wdir/$n.gray.fits
                fi
                if [ "$do_bayer" ]
                then
                    for c in $clist
                    do
                        ln -s $wdir/$n.gray.fits $wdir/$n.$c.fits
                    done
                fi
            else
                if [ -f bgvar/$(basename ${img%.*}).bgdiff.$inext ]
                then
                    convert bgvar/$(basename ${img%.*}).bgdiff.$inext \
                        -resize ${w}x${h}! - | \
                        pnmccdred -a $bgdiffzero -d - $img - | pnmtomef - > $tmpfits
                else
                    cat ${img%.*}$insuffix.${img##*.} | pnmtomef - > $tmpfits
                fi
                imslice $tmpfits 0 > $wdir/$n.red.fits
                imslice $tmpfits 1 > $wdir/$n.grn.fits
                imslice $tmpfits 2 > $wdir/$n.blu.fits
            fi
            
            # create/modify wcs header with appropriate reference pixel
            if [ "$omove" ] && [ "$jdref" ]
            then
                for c in $clist
                do
                    cat $wcs | awk -v x=$crpix1 -v y=$crpix2 '{
                        if ($1=="CRPIX1") {printf("CRPIX1  = %s\n", x); next}
                        if ($1=="CRPIX2") {printf("CRPIX2  = %s\n", y); next}
                        print $0}' > $wdir/$n.$c.head
                done
            else
                for c in $clist
                do
                    if [ "$do_not_register" ]
                    then
                        grep -vE "^CRVAL|^CD[12]_|^PV[12]_|^AST.RMS|^END" $wcs \
                            > $wdir/$n.$c.head
                        echo "\
CRVAL1  =      10.0     / World coordinate on this axis
CD1_1   =      -0.0003  / Linear projection matrix
CD1_2   =      0.0      / Linear projection matrix
CRVAL2  =      0.0      / World coordinate on this axis
CD2_1   =      0.0      / Linear projection matrix
CD2_2   =      0.0003   / Linear projection matrix
" >> $wdir/$n.$c.head
                    else
                        cp $wcs $wdir/$n.$c.head
                    fi
                done
            fi
                        
            # combine individual bad region masks with (per set) bad pixel image
            # and add image edge (2pix) to badtmp
            badreg="bgvar/"$(basename ${img%.*}.bad.reg)
            false && if [ -f $badreg ]
            then
                badimg=$wdir/$n.bad.png
                reg2pbm $img $badreg | gm convert - $badimg
                test $? -ne 0 && return 255
            else
                badimg="bgvar/"$(basename ${img%.*}.bad.png)
            fi
            if [ -f $badreg ] || [ -f bgvar/$(basename ${img%.*}.bad.png) ]
            then
                if [ -f $badreg ]
                then
                    test $verbose -gt 0 &&
                        echo "  using $badreg" >&2
                    badimg=$wdir/$n.bad.png
                    if [ -f bgvar/$(basename ${img%.*}.bad.png) ]
                    then
                        test $verbose -gt 0 &&
                            echo "  using bgvar/$(basename ${img%.*}.bad.png)" >&2
                        reg2pbm $img $badreg | convert - -depth 8 \
                            bgvar/$(basename ${img%.*}.bad.png) \
                            -evaluate-sequence max $badimg
                    else
                        reg2pbm $img $badreg | gm convert - $badimg
                        test $? -ne 0 && return 255
                    fi
                else
                    badimg="bgvar/"$(basename ${img%.*}.bad.png)
                fi
            fi
            if [ "$badimg" ] && [ "$badpix" ]
            then
                convert $badimg $badpix -evaluate-sequence max \
                    -shave 2x2 -bordercolor white -border 2x2 $badtmp
            else
                if [ "$badimg" ]
                then
                    convert $badimg -shave 2x2 -bordercolor white -border 2x2 $badtmp
                else
                    if [ "$badpix" ]
                    then
                        test $verbose -gt 0 &&
                            echo "  using $badpix" >&2
                        convert $badpix -shave 2x2 -bordercolor white -border 2x2 $badtmp
                    else
                        echo -e "P2\n1 1\n1\n0" | pnmtile $w $h | \
                            convert - -shave 2x2 -bordercolor white -border 2x2 $badtmp
                    fi
                fi
            fi
            test ! -s $badtmp &&
                echo "ERROR in _fitsconv_parallel using: $n $img" >&2 && return 255
            test ! "$do_bayer" &&
                convert $badtmp -negate -depth 1 pbm:- | \
                    pnmtomef - > $wdir/$n.gray.weight.fits
            for c in $clist
            do
                if [ "$do_bayer" ]
                then
                    convert $badtmp -negate $wdir/$c.weight.fits \
                        -compose Multiply -composite -depth 1 pbm:- | \
                        pnmtomef - > $wdir/$n.$c.weight.fits
                else
                    test ! -f $wdir/$n.$c.weight.fits &&
                        ln -s $wdir/$n.gray.weight.fits $wdir/$n.$c.weight.fits
                fi
                ln -s $wdir/$n.$c.head $wdir/$n.$c.weight.head
            done
            rm -f $badtmp $tmpfits
        }

        export -f _fitsconv_parallel
        i=0
        popts=""; test "$AI_MAXPROCS" && popts="-P $AI_MAXPROCS"
        for img in $ilist
        do
            i=$((i + 1))
            echo $i "$img"
        done | parallel $popts -k $tmpsh
        unset -f _fitsconv_parallel
        # TODO: error handling

        # if requested use image size from first image
        sopts=""
        img=$(echo $ilist | cut -d ' ' -f1)
        if [ -z "$imgsize" ] && [ -z "$use_full_size" ]
        then
            sopts="-image_size $(identify ${img%.*}$insuffix.${img##*.} | \
                cut -d " " -f3 | tr 'x' ' ' | awk -v x=$xyscale '{
                    printf("%d,%d\n", $1*x, $2*x)}')"
        fi

        # combine images
        #   n is number of all (good) images in set
        if [ "$do_parallel" ] && [ "$clist" != "gray" ]
        then
            echo "stacking on $clist ($(date +"%H:%M:%S")) ..." >&2
            setparam="$setparam -mem_max $((mem/3)) -combine_bufsize $((mem/3*9/10))"
            cat <<EOF > $tmpsh
#!/bin/bash
. airfun.sh > /dev/null
wdir=$wdir

n=$n
param="$param"
sopts="$sopts"
setparam="$setparam"
sparam="$sparam"
outlist="$outlist"
verbose="$verbose"
clist="$clist"
do_bayer="$do_bayer"

_stack_parallel \$@
EOF
        else
            setparam="$setparam -mem_max $mem -combine_bufsize $((mem*9/10))"
        fi

        _stack_parallel () {
            # note: local declarations only needed by parallel processing
            local c=$1  # color channel name
            local xml
            local conf
            local out
            local flist
            local outfits
            local weightfits
            local cparam

            xml=$wdir/swarp_$c.xml
            conf=$wdir/swarp_$c.conf
            outfits=$wdir/coadd_$c.fits
            weightfits=$wdir/coaddw_$c.fits
            swarp -d > $conf
            cparam="-imageout_name $outfits -weightout_name $weightfits -xml_name $xml"

            for out in $outlist
            do
                case "$out" in
                    "${sname}a$outsuffix")
                        flist=$(ls -tr $wdir/[0-9]*.$c.fits | lines $((n/2)));;
                    "${sname}b$outsuffix")
                        flist=$(ls -tr $wdir/[0-9]*.$c.fits | tail -$((n - n/2)));;
                    *)  flist="$wdir/[0-9]*.$c.fits";;
                esac
                
                test "$AI_DEBUG" &&
                    echo "swarp -c $conf $sopts $param $setparam $sparam $cparam $flist" >&2
                swarp -c $conf $sopts $param $setparam $sparam $cparam $flist
                if [ $? -ne 0 ]
                then
                    echo "ERROR: swarp failed" >&2
                    test -z "$AI_DEBUG" &&
                    echo "failed command: swarp -c $conf $sopts" \
                        "$param $setparam $sparam $cparam $flist" >&2 &&
                    return 255
                fi
                (test "$c" == "grn" || test "$c" == "gray") &&
                    imhead -z $outfits > $out.head &&
                    cp $weightfits $out.weight.fits &&
                    rm -f $out.weight.fits.gz &&
                    gzip $out.weight.fits
                test "$do_bayer" && test "$c" != "grn" &&
                    imhead -z $outfits > $out.$c.head &&
                    cp $weightfits $out.$c.weight.fits &&
                    rm -f $out.$c.weight.fits.gz &&
                    gzip $out.$c.weight.fits
                sethead $outfits datamin=0 datamax=65535
                meftopnm $outfits > $out.$c.pgm
                rm -f $outfits $weightfits
            done
        }


        if [ "$do_parallel" ] && [ "$clist" != "gray" ]
        then
            export -f _stack_parallel
            for c in $clist
            do
                echo $c
            done | parallel -k $tmpsh
            unset -f _stack_parallel
            # TODO: error handling
        else
            for c in $clist
            do
                echo "stacking on $c ($(date +"%H:%M:%S")) ..." >&2
                _stack_parallel $c
            done
        fi
        echo "stacking finished ($(date +"%H:%M:%S"))" >&2
        
        for out in $outlist
        do
            case "$out" in
                "${sname}a$outsuffix")  x=$((n/2));;
                "${sname}b$outsuffix")  x=$((n - n/2));;
                *)                      x=$n;;
            esac
            set_header $out.head NEXP="$x/Number of stacked exposures"

            test "$filter" &&
                set_header $out.head FILTER="$filter/Filter name"
            test "$binning" &&
                set_header $out.head BINNING=$binning
            test "$pierside" &&
                set_header $out.head PIERSIDE=$pierside
            test "$imgroll" &&
                set_header $out.head IMGROLL='Y'
            test "$omove" &&
                set_header $out.head OMOVE="$omove/Object movement in pix/hr"
            test "$badpix" &&
                set_header $out.head BADPIX="$badpix/Global badpixel mask"
            test "$magzero" &&
                set_header $out.head MAGZERO="$magzero/Arbitrary magnitude zero point (1ADU, 1s)"
            # mean MJD_OBS of all images
            test "$jdmean" &&
                set_header $out.head MJD_OBS="$jdmean/Mean JD of stacked images" &&
                set_header $out.head JD="$jdmean/Mean JD of stacked images"
            # MJD_OBS of reference image
            test "$nref" &&
                set_header $out.head NREF="$nref/Reference image"
            test "$jdref" &&
                set_header $out.head MJD_REF="$jdref/JD of reference image"
            
            # reformat some header keywords
            x=$(get_header -q $out.head EXPTIME)
            test "$x" && set_header $out.head EXPTIME=$(echo $x | awk '{printf("%.2f", 1*$1)}')

            if is_pgm $img
            then
                mv $out.gray.pgm $out.pgm
            else
                # combine color channels into RGB
                rgb3toppm $out.red.pgm $out.grn.pgm $out.blu.pgm > $out.ppm &&
                    test ! "$AI_DEBUG" && rm $out.red.pgm $out.grn.pgm $out.blu.pgm
            fi
        done
        
        (test $verbose -gt 0 || test "$AI_DEBUG") && du -m $wdir
        test "$AI_DEBUG" || rm -rf $wdir/*
    done < $sdat
    rm -f $imlist $tmpsh
    test "$AI_DEBUG" || rmdir $wdir
    test "$has_image_args" && rm $sdat
    return $retval
}


AIsplitstack () {
    # split image set and create cropped stacks around target
    # for multiple objects provide a region file (circles) instead of target
    # the base image set must have been processed (stacked) already
    # splitted sets are named as <baseset><ochar><part> ochar=a,b,... part=1,2,...
    local showhelp
    local nparts=2
    local osize
    local odir="split"
    local mode
    local i
    for i in $(seq 1 3)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-n" && nparts="$2" && shift 2
        test "$1" == "-s" && osize="$2" && shift 2
        test "$1" == "-d" && odir="$2" && shift 2
        test "$1" == "-m" && mode="$2" && shift 2
    done
    local baseset=$1
    local target=$2         # single object name or region file (circles)
    local xycenter=${3:-""} # stack center in FITS image coordinates
    
    local xsetdat=$odir/set.dat
    codir="comet"
    local tdir=${AI_TMPDIR:-"/tmp"}
    local imlist=$(mktemp $tdir/tmp_imlist_XXXXXX.dat)
    local tmpreg=$(mktemp $tdir/tmp_targets_XXXXXX.reg)
    local tmpcreg=$(mktemp $tdir/tmp_comet_XXXXXX.reg)
    local reg
    local ext
    local f
    local tstart
    local texp
    local onum
    local ochar
    local sname
    local slist
    local modlist
    local n
    local str
    local n1
    local n2
    local nrefbase
    local offbase
    local nref
    local off
    local doff
    local jdbase
    local omove
    local dhr
    local line
    
    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: AIsplitstack [-d odir|$odir] [-n nparts|$nparts] [-s osize_w<,h>] <baseset> <regfile | target xcfits,ycfits>" >&2 &&
        return 255

    # check mode
    test "$mode" && case "$mode" in
        setdat) ;;
        *)  echo "ERROR: unknown mode, allowed values: setdat" >&2
            rm -f $imlist $tmpreg $tmpcreg
            return 255;;
    esac
    # check if targets are provided via ds9 region file
    if [ -f "$target" ]
    then
        reg=$target
        target=""
    else
        test -z "$xycenter" &&
            echo "ERROR: missing xycenter" >&2 && return 255
        echo "center($xycenter,10) # text={$target}" > $tmpreg
        reg=$tmpreg
    fi

    # get extension of the baseset stack
    test -f $baseset.ppm && ext="pgm"
    test -f $baseset.ppm && ext="ppm"

    # prepare odir    
    test -d $odir || mkdir $odir
    for f in .airtoolsrc camera.dat rawfiles.dat sites.dat refcat.dat \
        bgdiff.dat bgsfit.dat reg.dat \
        $(get_header $baseset.head BADPIX)
    do
        (cd $odir && test ! -e $f && ln -s ../$f .)
    done
    #test -d $odir/bgvar || mkdir $odir/bgvar
    test -d $odir/measure || mkdir $odir/measure
    for n in $(AIimlist -n $baseset)
    do
        #(cd $odir/bgvar   && test ! -e $n.bad.reg  &&
        #    test -e ../../bgvar/$n.bad.reg         && ln -s ../../bgvar/$n.bad.reg .)
        (cd $odir/measure && test ! -e $n.src.head && ln -s ../../measure/$n.src.head .)
    done
    test -d $odir/$codir || mkdir $odir/$codir

    # get some info about baseset
    set - $(grep -v "^#" set.dat | awk -v s=$baseset '{if($2==s && $4=="o")print $0}') x
    test $# -lt 11 &&
        echo "ERROR: unknown base set $baseset" >&2 && return 255
    tstart=$1
    texp=$5
    shift 5
    str="$4 $5 $6"

    # check if baseset has been processed already
    test -s $xsetdat && slist=$(AI_SETS=$xsetdat AIsetinfo -b | awk -v s=$baseset '{
        pat="^"s; if($2~pat && $4=="o") print $2}')
    if [ "$slist" ]
    then
        # check for any stack
        for f in $slist
        do
            test -e $f.head &&
                echo "ERROR: base set $baseset has been splitted already" >&2 &&
                return 255
        done
    fi

    # create entries in $xsetdat
    AIimlist -n $baseset > $imlist
    n=$(cat $imlist | wc -l)
    test $n -eq 0 && return 255
    slist=""
    onum=0
    while read
    do
        test "${REPLY:0:7}" == "circle(" || continue
        target=$(echo $REPLY | cut -d '=' -f2 | tr -d '{}' | awk '{
            id=$1
            gsub(/\(/,"",id)
            gsub(/\)/,"",id)
            gsub(/\./,"",id)
            gsub(/\//,"",id)
            printf("%s", id)}')
        onum=$((onum+1))
        ochar=$(echo $onum | awk '{printf("%s", sprintf("%c", 96+$1))}')
        test -z "$target" && target=$ochar
        for i in $(seq 0 $((nparts-1)))
        do
            sname=$baseset$ochar$((i+1))
            slist=$(echo $slist $sname)
            n1=$(lines $((1+i*n/nparts)) $imlist | tail -1)
            n2=$(lines $(((i+1)*n/nparts)) $imlist | tail -1)
            nref=$(lines $(((2*i+1)*n/nparts/2+1)) $imlist | tail -1)
            test $i -eq $nparts && n2=$(tail -1 $imlist)
            line="$tstart $sname $target o $texp $n1 $n2 $nref $str"
            test -s $xsetdat && grep "^${line}$" -q $xsetdat && continue
            if [ -s $xsetdat ] && grep " $sname $target o " -q $xsetdat
            then
                # TODO: check/remove already processed stacks and related files
                # replace line
                test ! -e $xsetdat.orig && cp -p $xsetdat $xsetdat.orig
                sed -i "s,.* $sname $target o .*,$line," $xsetdat
                modlist=$(echo $modlist $sname)
            else
                # add new line
                echo $tstart $sname $target o $texp $n1 $n2 $nref $str >> $xsetdat
            fi
        done
    done < $reg
    cat $xsetdat
    test "$mode" == "setdat" && rm -f $imlist $tmpreg $tmpcreg && return

    test -e $xsetdat.orig &&
    echo "ERROR: offending file $xsetdat.orig. This indicates that there might be
    a mismatch of image set definitions and possibly already processed
    stacks in directory $splitdir." >&2 && return 255

    # stack, astrometry, costack
    # note: stacks will have "unusual" CRVAL* (different from (10,0) because of xycenter
    onum=0
    if [ "$osize" ]
    then
        test "${osize/,/}" == "$osize" && osize="$osize,$osize"
        while read
        do
            test "${REPLY:0:7}" == "circle(" || continue
            xycenter=$(echo $REPLY | tr '(),' ' ' | awk '{printf("%.0f,%.0f", $2, $3)}')
            onum=$((onum+1))
            ochar=$(echo $onum | awk '{printf("%s", sprintf("%c", 96+$1))}')
            for task in stack
            do
                for i in $(seq 0 $((nparts-1)))
                do
                    sname=$baseset$ochar$((i+1))
                    (cd $odir && AO_STACK="-s $osize -c $xycenter" \
                        airtools-cli -s $sname -x plot,image $task)
                done
            done
        done < $reg
    fi
    (cd $odir
    airtools-cli stack
    airtools-cli astrometry
    airtools-cli costack)
    # add SPLITREF keyword
    for sname in $(AI_SETS=$xsetdat AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    do
        set_header $odir/$sname.head SPLITREF=$baseset
        set_header $odir/${sname}_m.head SPLITREF=$baseset
    done
    
    # create "comet" region files using ra/dec and wcs calibration
    onum=0
    jdbase=$(get_header $baseset.head MJD_REF)
    while read
    do
        test "${REPLY:0:7}" == "circle(" || continue
        xycenter=$(echo $REPLY | tr '(),' ' ' | awk '{printf("%.0f,%.0f", $2, $3)}')
        crad=$(echo $REPLY | tr '(),' ' ' | awk '{printf("%s", $4)}')
        rade=$(echo "x ${xycenter/,/ }" | xy2rade -f -s - $baseset.wcs.head)
        onum=$((onum+1))
        ochar=$(echo $onum | awk '{printf("%s", sprintf("%c", 96+$1))}')
        for i in $(seq 0 $((nparts-1)))
        do
            sname=$baseset$ochar$((i+1))
            echo "reg $rade" | rade2xy - $odir/$sname.wcs.head | \
                xy2reg $odir/$sname.$ext - "" "" $crad > $tmpcreg
            # TODO: apply object movement according to OMOVE and dhr
            omove=$(get_header $odir/$sname.head AI_OMOVE)
            dmin=$(get_header $odir/$sname.head MJD_REF | awk -v r=$jdbase '{printf("%.2f",24*60*($1-r))}')
            off=$(cd $odir; omove2trail -d $dmin $sname $omove | awk -F "," '{
                a=$2*3.1415926/180
                printf("%.1f %.1f", $1*cos(a), $1*sin(a))}')
            regshift $tmpcreg $off > $odir/$codir/$sname.comet.reg
        done
    done < $reg


    rm -f $imlist $tmpreg $tmpcreg
}


# prepare image for pretty picture processing
AIpretty () {
    # convert ppm to tif, applying white balance and non-linear scaling
    # result may be processed by darktable to create pretty picture
    local showhelp
    local outmult=3
    local wbmul="2.482,1.000,1.362"  # Pentax K5II
    # local wbmul="2.302,0.927,1.263"  # Pentax K5II, dcraw: BGGR
    # local wbmul="2.198,0.933,1.343"  # Canon EOS 6D Mark II, dcraw: RGGB
    local i
    for i in $(seq 1 5)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-m" && outmult=$2 && shift 2
        test "$1" == "-w" && wbmul=$2 && shift 2
        #test "$1" == "-q" && quality=$2 && shift 2
    done

    local set=$1
    local tmp1=$(mktemp "/tmp/tmp_dat_$$.XXXXXX")
    local ext
    local bgmult
    local bgimg
    local x
    local bg
    local sd
    local add
    local m
    local a
    
    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: AIpretty [-w RGBmult|$wbmul] [-m mult|$outmult] <set>" >&2 &&
        return 1

    test -f $set.pgm && ext="pgm"
    test -f $set.ppm && ext="ppm"
    test -z "$ext" &&
        echo "ERROR: missing star stack" >&2 && return 255
    test ! -f $set.bgs.$ext &&
        echo "ERROR: missing bg corrected image $set.bgs.$ext" >&2 && return 255

    # bg gradient image, preferring model corrected image ("all") and bgmult=1
    test -f bgcorr/$set.bgm1all.$ext &&
        bgmult=1 && bgimg=bgcorr/$set.bgm1all.$ext
    test -z "$bgimg" && test -f bgcorr/$set.bgm1.$ext &&
        bgmult=1 && bgimg=bgcorr/$set.bgm1.$ext
    test -z "$bgimg" && test -f bgcorr/$set.bgm10all.$ext &&
        bgmult=10 && bgimg=bgcorr/$set.bgm10all.$ext
    test -z "$bgimg" && test -f bgcorr/$set.bgm10.$ext &&
        bgmult=10 && bgimg=bgcorr/$set.bgm10.$ext
    echo "apply background correction using $bgimg ..."

    # create scaled and white balanced (linear) image
    if [ $ext == "ppm" ]
    then
        a=$(echo ${wbmul//,/ } | awk -v bg=1000 '{
            printf("%.1f,%.1f,%.1f", bg*(1-$1), bg*(1-$2), bg*(1-$3))}')
        imbgsub -m $outmult $set.$ext $bgimg "" $bgmult | \
            pnmccdred -a $a -m $wbmul - x.st.$ext
    else
        imbgsub -m $outmult $set.$ext $bgimg "" $bgmult > x.st.$ext
    fi
    
    # determine background
    echo "measure background ..."
    AIbg x.st.$ext > $tmp1
    # cat $tmp1 >&2
    bg=$(cat $tmp1 | awk '{printf("%.0f,", $2)}' | sed -e 's|,$||')
    sd=$(cat $tmp1 | awk '{printf("%.0f,", $3)}' | sed -e 's|,$||')
    echo "# bg=$bg sd=$sd"  >&2

	if [ $ext == "ppm" ]
	then
        echo "LRGB processing ..."
    	rgbsmooth x.st.$ext $bg $sd > x.rgb.$ext
    	convert x.rgb.$ext -gamma 2.2 $set.wb.tif
    	echo "# image $set.wb.tif created" >&2
	fi
	
    rm -f $tmp1
    return
}


AIstiff () {
    local showhelp
    local bits=8
    local outfile
    local i
    for i in 1 2 3
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-o" && outfile=$2 && shift 2
        test "$1" == "-16" && bits=16 && shift 1
    done
    local img=$1
    local max=${2:-"0.995"}
    local gamfactor=${3:-"0.7"}
    local colorsat=${4:-"2.2"}
    local gamma=${5:-"2.2"}
    local min=${6:-"0.01"}
    local sopts=${7:-""}  # additional options passed to stiff
    local b=${img%\.*}
    
    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: AIstiff [-16] [-o outfile] <img> [max|$max] [gamfactor|$gamfactor]" \
            "[colorsat|$colorsat] [gamma|$gamma] [min|$min] [sopts]" >&2 &&
        return 1

    test -z "$outfile" && outfile=$b.tif
    ppmtorgb3 $img
    for c in red grn blu
    do
        pnmtomef $b.$c > $b.$c.fits
    done
    sopts="-MIN_LEVEL $min -MAX_LEVEL $max -GAMMA $gamma -GAMMA_FAC $gamfactor \
        -COLOUR_SAT $colorsat -BITS_PER_CHANNEL $bits $sopts"
    stiff $sopts -OUTFILE_NAME $outfile $b.red.fits $b.grn.fits $b.blu.fits
    rm $b.{red,grn,blu} $b.{red,grn,blu}.fits
}


# aperture photometry using objects from catalog (id x y) or ds9 region file
# output fields: id  x y  r g b  n nbg bgg sdg gerr
AIaphot () {
    local showhelp
    local drgb=0        # brighten star magnitudes by this values (sep. by comma)
    local precision=3   # number of digits after decimal point
    local do_bg_only    # if set then only bg measurement is returned
    local i
    for i in 1 2 3 4
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-a" && drgb=$2    && shift 2
        test "$1" == "-p" && precision="$2" && shift 2
        test "$1" == "-bg" && do_bg_only=1 && shift 1
    done
    local img="$1"      # image to be measured
    local xydat="$2"    # object catalog with lines id x y or ds9 region file
    local rad=${3:-"3"} # aperture radius or radii for aperture ring <r1>,<r2>
    local gap=${4:-""}  # gap between aperture and bg region
    local bgwidth=${5:-""} # bg annulus width
    local idcol=1
    local xcol=2
    local ycol=3
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpxy=$(mktemp "$tdir/tmp_xyorreg.XXXXXX.dat")
    local opts
    local cmd
    local hdr
    local texp
    local nexp
    local gain=1.0      # default detector gain in e-/ADU
    local mygain
    local magzero
    local id
    local x
    local y
    local z
    local line
    local tmpsh=$(mktemp "$tdir/tmp_script_XXXXXX.sh")
    chmod u+x $tmpsh

    # set gap used in aperture photometry according to aprad
    test -z "$gap" && gap=$(echo $rad | awk '{printf("%.1f", 1.5+$1/2)}')
    test -z "$bgwidth" && bgwidth=$(echo $rad | awk '{printf("%.1f", 2.3+$1/4)}')

    (test "$showhelp" || test $# -lt 2) &&
        echo -e "usage: AIaphot [-a dr,dg,db] [-p prec] <img> <xydat> [rad|$rad] [gap|$gap]" \
            "[bgwidth|$bgwidth]" >&2 &&
        return 1

    test ! -f "$img" &&
        echo "ERROR: image $img not found." >&2 && return 255
    test "$xydat" != "-" && test ! -f "$xydat" &&
        echo "ERROR: object catalog $xydat not found." >&2 && return 255
    test "$xydat" == "-" && xydat=/dev/stdin
    if is_reg $xydat
    then
        reg2xy $img $xydat > $tmpxy
    else
        cp $xydat $tmpxy
    fi
    
    # try to read some keywords from $img.head
    hdr=${img%.*}.head
    texp=""     # exposure time in sec
    nexp=""     # number of exposures that have been averaged
    mygain=""   # effective gain
    magzero=""  # magzero for texp=1
    if [ -f $hdr ]
    then
        texp=$(grep    "^EXPTIME" $hdr | tr '=' ' ' | awk '{if ($2>0) printf("%d", 1*$2)}')
        nexp=$(grep    "^NEXP"    $hdr | tr '=' ' ' | awk '{if ($2>0) printf("%d", $2)}')
        mygain=$(grep  "^GAIN"    $hdr | tr '=' ' ' | awk '{if ($2>0) printf("%.3f", 1*$2)}')
        magzero=$(grep "^MAGZERO" $hdr | tr '=' ' ' | awk '{if ($2>0) printf("%.3f", $2)}')
    fi
    test -z "$texp"    && texp=1
    test -z "$nexp"    && nexp=1
    test -z "$mygain"  && mygain=$gain
        
    # read data from environment
    #saturation=$(get_param camera.dat satur ${setname%.*} AI_SATURATION $saturation)
    test "$AI_GAIN"     && mygain=$AI_GAIN
    test "$AI_MAGZERO"  && magzero=$AI_MAGZERO
    test -z "$magzero" &&
        echo "ERROR: magzero unknown." >&2 && return 255
    if [ "$do_bg_only" ]
    then
        opts="-bg"
        echo "# texp=$texp nexp=$nexp gain=$mygain magzero=$magzero drgb=$drgb"
        echo "# id         bgr    bgg    bgb     nbg   sdr  sdg  sdb"
    else
        echo "# texp=$texp nexp=$nexp gain=$mygain magzero=$magzero drgb=$drgb"
        echo "# id        x       y        r      g      b        n  nbg   bgg sdg gerr$nexp"
    fi
    
    # exposure time of single exposure
    texp=$(echo $texp $nexp | awk '{printf("%f", $1/$2)}')
    
    # shell script
	cat <<EOF > $tmpsh
#!/bin/bash
. airfun.sh > /dev/null
rad=$rad
gap=$gap
bgwidth=$bgwidth
precision=$precision
drgb=$drgb

img=$img
opts="$opts"
texp=$texp
mygain=$mygain
magzero=$magzero

_aiaphot_parallel \$@
EOF
    
    _aiaphot_parallel () {
        local id=$1
        local x=$2
        local y=$3
        local line
        line=$(aphot $opts -p $precision -t $texp -m $magzero -g $mygain -d $drgb \
            $img $x","$y $rad $gap $bgwidth)
        test "${line:0:1}" != "#" && printf "%-10s  %s\n" $id "$line"
        test "${line:0:1}" == "#" && printf "# %-10s  %s\n" $id "${line:2}"
    }

	export -f _aiaphot_parallel
    cat $tmpxy | awk -v cid=$idcol -v cx=$xcol -v cy=$ycol '{
        if ($1~/^#/) next
        if (cid>NF || cx>NF || cy>NF) next
        printf("%s %s %s # %s\n", $cid, $cx, $cy, $0)
    }' | parallel -k $tmpsh
    unset -f _aiaphot_parallel
    
    test "$AI_DEBUG" && echo $tmpxy $tmpsh >&2 && return
    rm -f $tmpxy $tmpsh
}


# match objects between AIaphot photometry output file and vizier catalog
# using their id
# print lines to stdout, fields: id  x y  b g r  bref vref rref  am
AIphotmatch () {
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    local photcat=$1
    local vizcat=$2
    local cattype=$3    # e.g. tycho2
    #local colcorr=${4:-"0"}   # mag = vmag + <colorcorr>*(bmag-vmag)
    local catdef=refcat.dat
    local cid
    local cbmag
    local cvmag
    local crmag
    local cimag
    local cbvmag    # B-V column
    local cvrmag    # V-R column
    local delim="|" # column delimiter in vizier catalogs
    local sname
    local id
    local x
    local y
    local r
    local g
    local b
    local z
    local bvr
    local tmp1=$(mktemp "$tdir/tmp_dat1.XXXXXX.dat")
    local tmp2=$(mktemp "$tdir/tmp_dat2.XXXXXX.dat")
    
    (test "$showhelp" || test $# -lt 3) &&
        echo "usage: AIphotmatch <photcat> <vizcat> <cattype>" >&2 &&
        return 1
    # determine relevant mag columns of vizier catalog using refcat.dat
    # cid=0   ... use line number
    # c?mag=0 ... mag undefined
    cid=$(get_param $catdef cid $cattype)
    test -z "$cid" &&
        echo "ERROR: unsupported catalog type $cattype." >&2 &&
        return 255
    cbmag=$(get_param $catdef cb $cattype); test "$cbmag" == "-" && cbmag=0
    cvmag=$(get_param $catdef cv $cattype); test "$cvmag" == "-" && cvmag=0
    crmag=$(get_param $catdef cr $cattype); test "$crmag" == "-" && crmag=0
    cimag=$(get_param $catdef ci $cattype); test "$cimag" == "-" && cimag=0
    cbvmag=$(get_param $catdef cbv $cattype); test "$cbvmag" == "-" && cbvmag=0
    cvrmag=$(get_param $catdef cvr $cattype); test "$cvrmag" == "-" && cvrmag=0
    case "$cattype" in
        apass10)  delim=",";; # data fetched from AAVSO via web query
    esac

    # combine magnitudes
    echo "# id      x       y        bmag   gmag   rmag    bcat   vcat   rcat   icat   am"
    while read id x y r g b z
    do
        test "${id:0:1}" == "#" && continue
        test -z "$b" && continue
        bvri=$(cat $vizcat | grep -v -E -- "---|^#|^$" | \
            awk -F $delim -v id=$id -v cid=$cid -v cb=$cbmag -v cv=$cvmag -v cr=$crmag -v ci=$cimag \
                -v cbv=$cbvmag -v cvr=$cvrmag '{
                catid=""
                if (cid == "0") {
                    catid=sprintf("S%05d", NR)
                } else {
                    ncid=split(cid,a,",")
                    for (i=1; i<=ncid; i++ ) {
                        sub(/^[[:space:]]*/,"",$a[i])
                        sub(/[[:space:]]*$/,"",$a[i])
                        catid=catid""$a[i]
                    }
                }
                if (catid==id) {
                    v=$cv; if (v~/^[ ]*$/ || v~/[a-zA-Z]/) v="-"
                    if (cb>0) {
                        b=$cb; if (b~/^[ ]*$/ || b~/[a-zA-Z]/) b="-"
                    } else {
                        if (cbv>0) {
                            x=$cbv;
                            if (x~/^[ ]*$/ || x~/[a-zA-Z]/) {
                                b="-"
                            } else {
                                b=v+x
                            }
                        } else {
                            b="-"
                        }
                    }
                    if (cr>0) {
                        r=$cr; if(r~/^[ ]*$/ || r~/[a-zA-Z]/) r="-"
                    } else {
                        if (cvr>0) {
                            x=$cvr;
                            if (x~/^[ ]*$/ || x~/[a-zA-Z]/) {
                                r="-"
                            } else {
                                r=v-x
                            }
                        } else {
                            r="-"
                        }
                    }
                    if (ci>0) {
                        i=$ci; if(i~/^[ ]*$/ || i~/[a-zA-Z]/) i="-"
                    } else {
                        i="-"
                    }
                    
                    if (split(b,a,".")>1 && length(a[2])>3) b=sprintf("%6.3f", b)
                    if (split(v,a,".")>1 && length(a[2])>3) v=sprintf("%6.3f", v)
                    if (split(r,a,".")>1 && length(a[2])>3) r=sprintf("%6.3f", r)
                    if (split(i,a,".")>1 && length(a[2])>3) i=sprintf("%6.3f", i)
                    print b" "v" "r" "i
                }
            }')
        echo $id $x $y $b $g $r $bvri | awk '{
            printf("%-8s  %7.2f %7.2f  %6.3f %6.3f %6.3f  %6s %6s %6s %6s\n",
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10)}'
    done < $photcat > $tmp1

    # if $photcat is related to image set, then add airmass column
    x=$(basename $photcat)
    sname="${x%%.*}"
    if [ "$sname" ] && is_setname $sname && [ -s $sname.wcs.head ]
    then
        xy2rade $tmp1 $sname.wcs.head | rade2altaz $sname - | awk '{printf("%6.3f\n", $3)}' > $tmp2
    else
        cat $tmp1 | awk '{printf("%s\n", 0)}' > $tmp2
    fi
    
    paste -d ' ' $tmp1 $tmp2
}


# calibrate aperture photometry
# TODO: deal with image orientation pa!=0 when computing extinction correction
# for coord. trans ref.: http://star-www.st-and.ac.uk/~fv/webnotes/chapter7.htm
AIphotcal () {
    # note: as of airfun version 4 it requires gnuplot version 5
    local showhelp
    local color="V"     # catalog color band name (e.g. B or V)
    local citerm=""     # catalog color index term (e.g. B-V or V-R) 
    local skip=""       # refcat id's of neglected objects separated by space
    local cxy           # object center <x>,<y> (in fits coordinates)
    local rlim          # max. distance (> 100 in pix, <=100 in % diam) from object
    local nlim=100      # max. number of stars in sextractor source cat (starting
                        #   at brightest)
    local mlim          # aphot mag limit used for final curve fit
    local magerrlim=0.05
    local fittype=0     # 0-normal, 1-color, 2-ext, 3-color+ext
    local maxdist       # max distance for position matching in pixels
    local no_update     # if set do not save results in header keywords
    local adr=10        # apass data release number (web query only)
    local do_all_ci     # use all catalog stars, even those having extreme colors
    local codir="comet"
    local i
    for i in $(seq 1 15)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1

        test "$1" == "-B" && color="B" && shift 1
        test "$1" == "-V" && color="V" && shift 1
        test "$1" == "-R" && color="R" && shift 1
        test "$1" == "-BT" && color="BT" && shift 1
        test "$1" == "-VT" && color="VT" && shift 1
        test "$1" == "-G" && color="G" && shift 1
        test "$1" == "-GB" && color="GB" && shift 1
        #test "$1" == "-GR" && color="GR" && shift 1
        
        test "$1" == "-ci" && citerm="$2" && fittype=$((fittype+1)) && shift 2 # color correction
        test "$1" == "-e"  && fittype=$((fittype+2)) && shift 1    # fit extinction

        test "$1" == "-s" && skip="$2" && shift 2
        test "$1" == "-r" && rlim="$2" && shift 2
        test "$1" == "-n" && nlim="$2" && shift 2
        test "$1" == "-c" && cxy="$2" && shift 2
        test "$1" == "-m" && magerrlim="$2" && shift 2
        test "$1" == "-l" && mlim="$2" && shift 2
        test "$1" == "-d" && maxdist="$2" && shift 2
        test "$1" == "-t" && no_update=1 && shift 1
        test "$1" == "-a" && do_all_ci=1 && shift 1
    done
    local setname=${1:-""}
    local plane=${2:-""}    # image plane number (channel number)
    local catalog=${3:-""}  # e.g. tycho2
    local aprad=${4:-""}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmp1=$(mktemp "$tdir/tmp_dat1.XXXXXX.dat")
    local tmp2=$(mktemp "$tdir/tmp_dat2.XXXXXX.dat")
    local tmpbright=$(mktemp "$tdir/tmp_bright.XXXXXX.dat")
    local tmpgp=$(mktemp "$tdir/tmp_gp.XXXXXX.gp")
    local tmpres=$(mktemp "$tdir/tmp_res.XXXXXX.txt")
    local head
    local whead
    local scat
    local inext
    local fwhm
    local gap
    local centerdeg
    local size
    local opts
    local texp
    local nexp
    local magzero
    local pixscale
    local flen
    local xoff=0
    local yoff=0
    local apcolumn
    local refcolumn
    local ct1column  # id of column used by color term (minuend)
    local ct2column  # id of column used by color term (subtrahend)
    local amcolumn=11
    local gapcorr
    local refmd
    local colormd=0
    local cimin=-99
    local cimax=99
    local amref
    local nstars
    local rmlim     # if mlim is not set estimate reasonable maglim
    local catradius # max distance from object (deg) used to select catalog stars (catalog query)
    local matchrlim # max distance from object (pix) used to select match stars
    # local apmagmd
    local w
    local h
    local c
    local x
    local r
    local str
    local yrange
    local delim
    local coreg
    local rescol
    local refxydat
    local refxyreg
    local skip2
    local skip3
    local magrms
    local afit
    local bfit
    local cfit
    local efit
    local pidx
    local icol
    local comag
    #local codia
    local clist
    local rot
    local tel
    local nlow
    local nskip
    local sd
    local gpversion
    local paramchange
    local photreg
    local idlist
    local pnglist
    local no

    (test "$showhelp" || test $# -lt 3) &&
        echo "usage: AIphotcal [-t] [-a] [-B|-V|-R|-VT|-GB|...] [-ci colorIndex] [-e] [-s skip] [-l maglim] [-d maxdist]" \
            "[-m magerrlim|$magerrlim] [-n nlim] [-r rlim] [-c xc,yc] <set> <plane> <refcat> [aprad]" >&2 &&
        return 1

    # checkings
    head=$setname.head
    test ! -f "$head" &&
        echo "ERROR: image header file $head not found." >&2 && return 255
    whead=$setname.wcs.head
    test ! -f "$whead" &&
        echo "ERROR: image wcs header file $whead not found." >&2 && return 255
    #scat=$codir/$setname.src.dat
    scat=$setname.src.dat
    false && test ! -f "$scat" &&
        echo "WARNING: source catalog $scat not found, trying $setname.src.dat." >&2 &&
        scat=$setname.src.dat
    test ! -f "$scat" &&
        echo "ERROR: source catalog $scat not found." >&2 && return 255
    photreg=$setname.phot.reg

    # check for input image
    inext=""
    test -f ${setname}.pgm   && inext="pgm"
    test -f ${setname}.ppm   && inext="ppm"
    test -z "$inext" &&
        echo "ERROR: no input image ${setname}.p[gp]m found." >&2 && return 255

    # check plane
    test "$inext" == "pgm" && test $plane -ne 1 &&
        echo "ERROR: invalid plane number on pgm image" >&2 && return 255
    test "$inext" == "ppm" && test $plane -ne 1 && test $plane -ne 2 && test $plane -ne 3 &&
        echo "ERROR: invalid plane number on ppm image" >&2 && return 255

    # check gnuplot version
    gpversion=$(gnuplot -V | awk '{printf("%s", $2)}')
    case "$gpversion" in
        5*) ;;
        *)  echo "ERROR: unsupported gnuplot version $gpversion." >&2
            return 255
    esac
    
    # get columns of aperture photometry file according to image color plane
    if [ "$inext" == "ppm" ]
    then
        if [ "$plane" ]
        then
            apcolumn=$((7-$plane))
        else
            case "$color" in
                B|BT)     apcolumn=4;;
                V|VT|GB)  apcolumn=5;;
                R|G)      apcolumn=6;;
                *)  echo "ERROR: unknown color $color." >&2 && return 255;;
            esac
            plane=$((7-$apcolumn))
        fi
    else
        apcolumn=4
        plane=1
    fi
    case "$color" in
        B|BT)     refcolumn=7;;
        V|VT|GB)  refcolumn=8;;
        R|G)      refcolumn=9;;
        *)  echo "ERROR: unknown color $color." >&2 && return 255;;
    esac
    # set columns of aperture photometry file to use in color index term
    case "$citerm" in
        B-V|BT-VT) ct1column=7; ct2column=8;;
        V-R|GB-G)  ct1column=8; ct2column=9;;
        GB-GR)     ct1column=8; ct2column=10;;
        *)  test "$citerm" && echo "ERROR: unknown color term $citerm." >&2 && return 255;;
    esac
    # set limits on color index for GAIA catalog stars
    test -z "$do_all_ci" && case $catalog in
        gaia*)  test "$citerm" == "GB-G"  && cimin=0.1 && cimax=0.8
                test "$citerm" == "GB-GR" && cimin=0.4 && cimax=1.4
            ;;
    esac
    test "$cimin$cimax" != "-9999" &&
        echo "# clipping valid color index to $cimin .. $cimax"

    # get image color (filter) associated with plane (fallback: plane number)
    icol=$(get_header $head AC_ICOL$plane)
    test -z "$icol" && icol=$plane

    # determine magzero
    texp=""
    nexp=""
    magzero=""
    texp=$(grep    "^EXPTIME" $head | tr '=' ' ' | awk '{if ($2>0) printf("%d", 1*$2)}')
    nexp=$(grep    "^NEXP"    $head | tr '=' ' ' | awk '{if ($2>0) printf("%d", $2)}')
    magzero=$(grep "^MAGZERO" $head | tr '=' ' ' | awk '{if ($2>0) printf("%.3f", $2)}')
    tel=$(get_header -q $head AI_TELID)
    test -z "$texp"    && texp=1
    test -z "$nexp"    && nexp=1
    texp=$(echo $texp $nexp | awk '{printf("%f", $1/$2)}')
    test "$AI_MAGZERO" && magzero=$AI_MAGZERO
    if [ -z "$magzero" ] && [ "$tel" ]
    then
        magzero=$(get_param camera.dat magzero $tel)
    fi
    test -z "$magzero"    &&
        echo "ERROR: magzero unknown." >&2 && return 255
    
    # determine pixscale
    pixscale=$(get_wcspscale $whead)
    test -z "$pixscale" &&
        echo "ERROR: pixscale unknown." >&2 && return 255


    test -d phot || mkdir phot

    # calculate image size (degrees)
    size=$(echo $(imsize $setname.$inext) $pixscale | \
        awk '{printf("%.1fx%.1f", $1*$3/3600, $2*$3/3600)}')
    test "$AI_DEBUG" && echo "size=$size" >&2

    # determine max distance to select match stars (in pixels)
    # old: set rlim for wide field images >3 deg to 1/6 diagonale
    # new 150828: set rlim to 1/6 diagonale, 150922: 1/4 diagonale
    # 200909: lower radius 0.25->0.19, 0.22->0.17, 0.19->0.15, 0.17->0.14, 0.16->0.13
    if [ -z "$rlim" ]
    then
        matchrlim=$(echo ${size/x/ } $pixscale | awk '{
            dia=sqrt($1*$1+$2*$2); m=0.19
            if (dia > 4) m=0.17
            if (dia > 6) m=0.15
            if (dia > 8) m=0.14
            if (dia > 12) m=0.13
            printf("%d", m*dia*3600/$3)}')
    else
        matchrlim=$(echo $rlim $(imsize $setname.$inext) | awk '{
            if ($1 > 100) {
                print $1
            } else {
                printf("%.0f", $1/100*sqrt($2*$2+$3*$3))
            }}')
    fi
    # search radius for catalog query (in degrees)
    catradius=$(echo $size | awk -F "x" '{x=0.5*sqrt($1*$1+$2*$2); printf("%.1f", x+0.1)}')
    #catradius=$(echo $matchrlim $pixscale | awk '{x=$1*$2/3600; fmt="%.2f"
    #    if(x>2) {fmt="%.1f"}; if(x>20) {fmt="%.0f"}; printf(fmt, x)}')

    # get center of comet cxy=<xfits>,<yfits>, if comet/$setname.cometin.reg
    # exists, image center otherwise
    w=$(identify $setname.$inext | cut -d " " -f3 | cut -d "x" -f1)
    h=$(identify $setname.$inext | cut -d " " -f3 | cut -d "x" -f2)
    coreg=""
    test -f comet/$setname.comet.reg && coreg=comet/$setname.comet.reg
    test -z "$coreg" && test -f comet/$setname.cometin.reg && coreg=comet/$setname.cometin.reg
    if [ -z "$cxy" ] && [ "$coreg" ] && grep -q "^polygon(" $coreg
    then
        # TODO: check for single object
        echo "# get object center from $coreg" >&2  # FITS ccord
        cxy=$(grep "^polygon(.*)" $coreg | tr '(),' ' ' | awk '{
            x1=$2; x2=$2; y1=$3; y2=$3
            for (i=4;i<=NF;i++) {
                if (i%2==0) {
                    if($i<x1) x1=$i; if($i>x2) x2=$i
                } else {
                    if($i<y1) y1=$i; if($i>y2) y2=$i
                }
            }
            #printf("%s %s   %s %s\n", x1, x2, y1, y2)
            printf("%.0f,%.0f\n", (x1+x2)/2, (y1+y2)/2)}')
    fi
    test -z "$cxy" && cxy=$((w/2))","$((h/2))
    echo "# field size=${size}deg  catradius=${catradius}deg" >&2
    echo "# region center:  cxy=$cxy  matchrlim=${matchrlim}px" >&2

    # download reference stars
    centerdeg=$(echo "object ${cxy//,/ }" | xy2rade -f - $whead | awk '{printf("%s %s", $1, $2)}')
    echo "# centerdeg=$centerdeg" >&2
    #echo $centerdeg >&2
    if [ -s phot/$setname.$catalog.dat ]
    then
        echo "reusing photometric reference catalog phot/$setname.$catalog.dat" >&2
    else
        case "$catalog" in
            apass10) adr=10
                    case "$adr" in
                        9)  url="https://www.aavso.org/cgi-bin/apass_download.pl";;
                        10) url="https://www.aavso.org/cgi-bin/apass_dr10_download.pl";;
                    esac
                    ! check_url $url &&
                        echo "ERROR: no access to url $url." >&2 &&
                        return 255
                    set - $centerdeg
                    opts="ra=$1&dec=$2&radius=$catradius"
                    echo "opts=$opts" >&2
                    wget -O $tmp1 "$url?$opts&outtype=1"
                    case "$adr" in
                        9)  # radeg,raerr("),decdeg,decerr("),nobs,V,Verr,B,Berr,Sg,Sgerr,Sr,Srerr,Si,Sierr
                            cat $tmp1 | awk -F ',' '{if ($6!~/NA/){print $0}}' | \
                                LANG=C sort -n -t ',' -k6,6 | lines 5000 > phot/$setname.$catalog.dat
                            ;;
                        10) # radeg,raerr("),decdeg,decerr("),Johnson_V (V),Verr,Vnobs,Johnson_B (B),Berr,Bnobs,Sloan_u (SU),SUerr,SUnobs,Sloan_g (SG),SGerr,SGnobs,Sloan_r (SR),SRerr,SRnobs,Sloan_i (SI),SIerr,SInobs,Sloan_z (SZ),SZerr,SZnobs,PanSTARRS_Y (Y),Yerr,Ynobs
                            cat $tmp1 | awk -F ',' '{if ($5!~/NA/){
                                print $1","$2","$3","$4","$7","$5","$6","$8","$9","$14","$15","$17","$18","$20","$21}}' | \
                                LANG=C sort -n -t ',' -k6,6 | lines 5000 > phot/$setname.$catalog.dat
                            cp $tmp1 phot/$setname.${catalog}.csv
                            ;;
                    esac
                    ;;
            *)      mkrefcat -n 10000 $catalog $centerdeg $catradius > phot/$setname.$catalog.dat;;
        esac
    fi
    test ! -s phot/$setname.$catalog.dat &&
        echo "ERROR: empty reference star catalog." >&2 && return 255
    grep -q "^#INFO.*Error" phot/$setname.$catalog.dat &&
        echo "ERROR: catalog error, please check phot/$setname.$catalog.dat" >&2 && return 255
    test $(cat phot/$setname.$catalog.dat | wc -l) -le 1 &&
		echo "ERROR: no reference stars found." >&2 && return 255

    # get index of photometric calibration data set
    clist=$(get_header $head all | grep "^AP_PCAT[1-9]=" | cut -c8 | sort -nu)
    c=0
    test "$clist" && for c in $clist
    do
        x=$(get_header -s $head AP_PCAT$c,AP_AIDX$c | tr '\n' ';')
        test "$x" == "$catalog;$plane;" &&
            has_photcal=1 &&
            pidx=$c && break
    done
    test "$has_photcal" && gapcorr=$(get_header -q $head AP_MCOR$pidx)
    test -z "$pidx" && pidx=$((c+1))
   

    # get fwhm
    fwhm=$(get_header -q $head AI_FWHM)
    if [ -z "$fwhm" ] && [ -f $scat ]
    then
        fwhm=$(sexselect -s $scat "" 0.03 $matchrlim "$cxy" "" 0 | \
            grep FWHM_IMAGE | awk '{if($7>3) printf("%.2f", $2)}')
    fi
    test -z "$fwhm" &&
        echo "ERROR: unknown FWHM." >&2 && return 255

    # reuse existing aperture photometry if no critical parameters have changed
    paramchange=""
    x=$(get_header -q $head AP_ARAD$pidx)
    # determine aprad and gap
    test -z "$aprad" &&
        aprad=$(echo $fwhm | awk '{printf("%.1f", 3*sqrt($1+1)+0.1*$1-2.0)}')
    gap=$(echo $aprad | awk '{printf("%.1f", 2+$1/2.5)}')
    #echo "## check aprad change: x=$x aprad=$aprad" >&2
    if [ "$(echo $x $aprad | awk '{if(NF==2) {x=$1-$2; if(x!=0) print 1}}')" ]
    then
        paramchange=1 && gapcorr=""
        echo "# aprad changed ($x -> $aprad)  gap=$gap" >&2
    else
        echo "# aprad=$aprad  gap=$gap" >&2
    fi
    # region for matching stars changed?
    # note: both AP_RMAX and matchrlim must be converted to the same unit (% diam)
    if [ ! "$paramchange" ]
    then
        x=$(get_header -q $head AP_RMAX$pidx)   # nonempty if user has provided a value previously
        if [ -z "$x" ]
        then
            #echo "## check rlim change: x=$x rlim=$rlim" >&2
            test "$rlim" && paramchange=1 &&
                echo "# user provided rlim=$rlim" >&2
        else
            x=$(echo $x $(imsize $setname.$inext) | awk '{
                if ($1>100) {printf("%.0f", 100*$1/sqrt($2*$2+$3*$3))} else {print $1}}')
            r=$(echo $matchrlim $(imsize $setname.$inext) | awk '{
                printf("%.0f", 100*$1/sqrt($2*$2+$3*$3))}')
            #echo "## check rlim change: x=$x r=$r" >&2
            test "${x}${rlim}" && test "$x" != "$r" && paramchange=1 &&
                echo "# rlim changed ($x -> $r)" >&2
        fi
    fi
    # max number of stars changed?
    if [ ! "$paramchange" ]
    then
        x=$(get_header -q $head AP_NMAX$pidx)
        #echo "## check nmax change: x=$x nlim=$nlim" >&2
        test -z "$x" && paramchange=1
        test "$x" && test $x -ne $nlim && paramchange=1 &&
            echo "# nmax changed ($x -> $nlim)" >&2
    fi
    test -s phot/$setname.$catalog.xphot.dat && test "$paramchange" &&
        echo "# paramchange detected" >&2
    
    
    # aperture photometry and matching with reference catalog
    if [ -s phot/$setname.$catalog.xphot.dat ] &&
       [ phot/$setname.$catalog.xphot.dat -nt phot/$setname.$catalog.dat ] &&
       [ ! "$paramchange" ]
    then
        echo "reusing phot/$setname.$catalog.xphot.dat" >&2
    else
        echo "# matching stars ..."
        # determine maxdist
        if [ ! "$maxdist" ]
        then
            maxdist=$(echo $pixscale $fwhm | awk '{printf("%.0f", 2+2/$1+0.3*$2)}')
            echo "# setting maxdist=${maxdist}px" >&2
        else
            echo "# user provided maxdist=${maxdist}px" >&2
        fi
        # convert photometric reference catalog
        delim="|"
        test "$catalog" == "apass10" && delim=","
        if [ -f phot/$setname.$catalog.xymanu.reg ]
        then
            echo "reusing manually created phot/$setname.$catalog.xymanu.reg" >&2
            reg2xy $setname.$inext phot/$setname.$catalog.xymanu.reg > phot/$setname.$catalog.xymanu.dat
            refxyreg=phot/$setname.$catalog.xymanu.reg
            refxydat=phot/$setname.$catalog.xymanu.dat
        else
            rade2xy phot/$setname.$catalog.dat $whead $catalog "$delim" > phot/$setname.$catalog.xy.dat
            test $? -ne 0 &&
                echo "ERROR: failed command: rade2xy phot/$setname.$catalog.dat $whead $catalog \"$delim\"" >&2 &&
                return 255
            test ! -s phot/$setname.$catalog.xy.dat &&
                echo "ERROR: file phot/$setname.$catalog.xy.dat is empty" >&2 &&
                return 255
            #xy2reg $setname.$inext phot/$setname.$catalog.xy.dat > phot/$setname.$catalog.xy.reg
            #sexselect -r $scat "" 0.03 "$matchrlim" "$cxy" | grep "^circ" | \
            #    sort -n -k4,4 | head -$((nlim*2)) | reg2xy $setname.$inext - > $tmp1
            xy2reg $setname.$inext phot/$setname.$catalog.xy.dat $xoff $(echo "-1 * $yoff" | bc) $((maxdist+8)) \
                > phot/$setname.$catalog.xy.reg
            refxydat=phot/$setname.$catalog.xy.dat
            refxyreg=phot/$setname.$catalog.xy.reg
        fi
        # TODO: limit fwhm to exclude galaxies
        sexselect -f $scat "" $magerrlim "$matchrlim" "$cxy" | \
            regfilter - $refxyreg | sexselect -r - | \
            grep "^circ" | reg2xy $setname.$inext - > $tmp1

        # match stars in photometric reference catalog
        # not implemented yet: eliminate stars close to image border
        # co01: eliminate stars close to border -> $setname.$catalog.xy.reg
        #        reg2xy ../$setname.$inext $setname.$catalog.xy.reg > $setname.$catalog.xy.dat
        xymatch $refxydat $tmp1 $maxdist $xoff $yoff > phot/$setname.$catalog.match.dat

        # sort by mag (from sextractor catalog)
        sort -k 1,1 $tmp1 > $tmp2
        grep -v '^#' phot/$setname.$catalog.match.dat | sort -k 9,9 | \
            join -1 9 -2 1 - $tmp2 | sort -n -k 15,15 | lines $nlim |
            cut -d " " -f2- > $tmp1
        
        # do aperture photometry
        nstars=$(cat $tmp1 | wc -l)
        test $nstars -lt 4 &&
            echo "ERROR: only $nstars stars matched (min=4)" >&2 && return 255
        # TODO: only measure stars not present in phot/$setname.$catalog.phot.dat
        echo "# AIaphot on $nstars stars ..." >&2
        AI_MAGZERO=$magzero AIaphot $setname.$inext $tmp1 $aprad $gap > phot/$setname.$catalog.phot.dat
        test "$AI_DEBUG" && echo "AIphotmatch phot/$setname.$catalog.phot.dat" \
            "phot/$setname.$catalog.dat $catalog" >&2
        AIphotmatch phot/$setname.$catalog.phot.dat phot/$setname.$catalog.dat $catalog | \
            sort -n -k5,5 > phot/$setname.$catalog.xphot.dat
        test $? -ne 0 &&
            echo "ERROR: failed command: AIphotmatch phot/$setname.$catalog.phot.dat" \
            "phot/$setname.$catalog.dat $catalog" >&2 && return 255
    fi
    test ! -s phot/$setname.$catalog.xphot.dat &&
        echo "ERROR: no data in phot/$setname.$catalog.xphot.dat" && return 255
    
    # flag those stars which are to be skipped during calibration
    #   inserting "#" at begin of line (phot/$setname.$catalog.xphot.dat)
    #   keep file timestamp (but change inode)
    if [ "$skip" ]
    then
        cp phot/$setname.$catalog.xphot.dat $tmp1
        for id in ${skip//,/ }
        do
            sed --follow-symlinks -i 's/^'$id' /#'$id'/' $tmp1
        done
        touch -r phot/$setname.$catalog.xphot.dat $tmp1
        mv $tmp1 phot/$setname.$catalog.xphot.dat
    fi
    
    # find close companion stars:
    #   stars which have multiple matches in the reference catalog
    #   if brightness differs by >1mag skip the faint one, the brighter one
    #     might still be usable
    #   if brightness differs by <=1mag and catalog is from GAIA then
    #     this is probably a double star unresolved in image and we skip both
    grep -v "^#" phot/$setname.$catalog.xphot.dat | sort -k2,3 | awk -v mcol=$refcolumn '{
        str=$2" "$3
        if (str==laststr) {
            if ($mcol != "-") {
                if (incr > 0) {
                    num++
                    incr=0
                    printf("%d %s %s\n", num, lastid, lastmag)
                }
                printf("%d %s %s\n", num, $1, $mcol)
            }
        } else {
            incr=1
        }
        lastid=$1
        lastmag=$mcol
        laststr=str
    }' > $tmp1
    skip2=$(for x in $(cut -d ' ' -f1 $tmp1 | sort -u)
    do
        grep "^$x " $tmp1 | LANG=C sort -n -k 3,3 | awk -v lim=1.0 -v cat=$catalog '{
            if (NR==1) {
                m=$3; bright=$2
            } else {
                if ($3-m > lim) {
                    printf("%s ", $2)
                } else {
                    if (cat ~ /^gaia/) printf("%s %s ", bright, $2)
                }
            }}'
    done)
    if [ "$skip2" ]
    then
        echo "# skipping $(echo $skip2 | wc -w) close companions"
        cp phot/$setname.$catalog.xphot.dat $tmp1
        for id in $skip2
        do
            sed --follow-symlinks -i 's/^'$id' /#'$id'/' $tmp1
        done
        touch -r phot/$setname.$catalog.xphot.dat $tmp1
        mv $tmp1 phot/$setname.$catalog.xphot.dat
    fi


    # measure gapcorr (photometry offset with respect to large apertures)
    if [ -z "$gapcorr" ]
    then
        # select bright stars
        if [ -s $codir/$setname.psfphot.dat ]
        then
            # using psf stars within matchrlim
            echo "# determine gapcorr using psf stars"
            grep -v "^#" $codir/$setname.psfphot.dat | awk -v h=$h -v cx=${cxy%,*} -v cy=${cxy#*,} -v rlim=$matchrlim '{
                dx=$2-cx; dy=$3-(h-cy)
                d=sqrt(dx*dx+dy*dy)
                if (d<rlim) {print $0}}' > $tmpbright
        else
            # select 30 brightest stars
            # TODO: only use starlike sources
            echo "# determine gapcorr using brightest calibration stars"
            sexselect -r $scat "" $magerrlim "$matchrlim" "$cxy" | \
                grep "^circ" | sort -n -k4,4 | lines 50 | \
                awk -v f=$fwhm '{
                    x=$1; gsub(/[(),]/," ",x);
                    na=split(x,a," ")
                    if (a[4] < 2.7*f) print $0
                }' | head -30 | reg2xy $setname.$inext - > $tmpbright
        fi

        # photometry using different apertures
        AI_MAGZERO=$magzero AIaphot $setname.$inext $tmpbright $aprad $gap | \
            awk -v me=$magerrlim '{if($11<=2*me) print $0}' > x.phot$aprad.dat
        for r in $(echo $aprad | awk '{
            if ($1<6) {
                printf("%.1f %.1f", 1.6+1.4*$1, 6+1.8*$1)
            } else {
                printf("%.1f %.1f", 10.0+($1-6), 16.8+1.2*($1-6))
            }
            }')
        do
            AI_MAGZERO=$magzero AIaphot $setname.$inext $tmpbright $r $gap > x.phot$r.dat
            while read
            do
                test "${REPLY:0:1}" == "#" && continue
                #set - $REPLY
                #echo "$skip" | grep -qw $1 && continue
                grep -v "^#" x.phot$aprad.dat | awk -v l="$REPLY" -v c=$apcolumn '{
                    split(l,a); if($1!=a[1]) next; print $c" "a[c]-$c}'
            done < x.phot$r.dat | sort -n -k2,2 | sed '1,3d' > $tmp2
            gapcorr=$(median $tmp2 2)
            echo "r=$r  gapcorr=$gapcorr" >&2
        done
        yrange=$(kappasigma $tmp2 2 | awk '{l=$1-5*$2-0.05; h=$1+4*$2+0.05
            printf("%.2f:%.2f", h, l)}')
        str=$setname.$catalog.$icol.apcorr
        AIplot -p -o x.$str.png -t "Large Aperture Correction of Stars (m_{r$r}-m_{r$aprad}, $setname)" \
            -g "set xlabel 'mag'; set ylabel 'dmag'; set grid" $tmp2 1 2 "" "" "[][$yrange]" 
        (test -f phot/$str.png && diff -q x.$str.png phot/$str.png >/dev/null) || \
            cp -p x.$str.png phot/$str.png
    fi
    
    # if mlim is not set, use reasonable limit on faint end based
    # on number statistics of stars (possibly eliminating faintest stars)
    if [ ! "$mlim" ]
    then
        nstars=$(grep -v "^#"  phot/$setname.$catalog.xphot.dat | wc -l)
        if [ $nstars -gt 20 ]
        then
            nlow=$((6+nstars/5))    # includes nskip
            nskip=$((1+nstars/35))
            test $nstars -gt 50 &&
                nlow=$((13+nstars/15)) &&
                nskip=$((2+nstars/80))
            grep -v "^#" phot/$setname.$catalog.xphot.dat | \
                awk -v ca=$apcolumn '{printf("%s\n", $ca)}' | \
                sort -n | tail -$nlow | lines $((nlow-nskip)) > $tmp1
            sd=$(stddev $tmp1)
            rmlim=$(tail -1 $tmp1 | awk -v s=$sd '{printf("%.2f", $1+s+0.1)}')
            str=$(printf "sd=%.3f" $sd)
            echo "# setting maglim=$rmlim  (stats: unused=$nskip, n=$((nlow-nskip)), $str)" >&2
        else
            rmlim=99
        fi
    else
        rmlim=$mlim
    fi
     
    # remove stars with missing ref mags and with extreme colors
    # apply maglim (rmlim)
    if [ $fittype -eq 1 ] || [ $fittype -eq 3 ]
    then
        # fitting color requires color information
        # TODO allow maglim with high/low values
        grep -v "^#" phot/$setname.$catalog.xphot.dat | lines $nlim | \
            grep -vEw "^${skip// / |^} " | \
            awk -v lim=$rmlim -v ca=$apcolumn -v cr=$refcolumn \
                -v cc1=$ct1column -v cc2=$ct2column \
                -v cimin=$cimin -v cimax=$cimax '{
                if ($ca>lim || $cr=="-" || $cc1=="-" || $cc2=="-") next
                if ($cc1-$cc2 < cimin || $cc1-$cc2 > cimax) next
                print $0}' > $tmp1
        test $(cat $tmp1 | wc -l) -lt 3 &&
            echo "ERROR: less than 3 stars with known mags" >&2 &&
            echo "       (columns $refcolumn $ct1column $ct2column in phot/$setname.$catalog.xphot.dat)" >&2 &&
            return 255
        colormd=$(cat $tmp1 | awk -v cc1=$ct1column -v cc2=$ct2column '{
            printf("%f\n", $cc1-$cc2)}' | median - 1)
    else
        grep -v "^#" phot/$setname.$catalog.xphot.dat | lines $nlim | \
            grep -vEw "^${skip// / |^} " | \
            awk -v lim=$rmlim -v ca=$apcolumn -v cr=$refcolumn '{
                if ($ca>lim || $cr=="-") next
                print $0}' > $tmp1
        colormd=0
    fi
    false && echo "# awk -v lim=$rmlim -v ca=$apcolumn -v cr=$refcolumn" \
        "-v cc1=$ct1column -v cc2=$ct2column -v cimin=$cimin -v cimax=$cimax" >&2
    #echo $tmp1 >&2
    
    # if necessary limit stars to user defined region
    if [ -s $photreg ]
    then
        echo "# using $photreg to select good stars" >&2
        idlist=$(xy2reg $setname.$inext $tmp1 | tr '(),{}' ' ' | \
            awk '{if ($1=="circle") printf("%s %s %s\n", $7, $2, $3)}' | \
            xyinreg - $photreg | grep -v "^#" | awk '{printf("%s ", $1)}')
        for x in $idlist; do grep -w "^$x" $tmp1; done > $tmp2
        mv $tmp2 $tmp1
    fi
        
    nstars=$(cat $tmp1 | wc -l)
    # median of reference star mag
    refmd=$(cat $tmp1 | awk -v ref=$refcolumn '{
        printf("%f\n", $ref)}' | median - 1)
    # reference airmass (at center position of reference stars)
    #ammd=$(median $tmp1 $amcolumn)
    amref=$(echo $centerdeg | rade2altaz $setname - | awk '{printf("%.3f", $3)}')
    echo "# refmd=$refmd colormd=$colormd amref=$amref" >&2
    cp $tmp1 $tdir/x.gptmp1.dat

    # gnuplot fitting
    # e.g. map = a + b*(V-Vmd)     + c*((B-V)-(B-V)md) + e*(am-amref)
    #      map = a + b*(ref-refmd) + c*(color-colormd) + e*(am-amref)
    # map ... measured mag in aperture using magzero from camera.dat (dependent variable)
    # ref ... reference catalog magnitude of closest color band (independent variable x)
    # color ... reference catalog color index (independant variable y)
    # am  ... airmass at time of observation
    # note about 'using' clause: the last column reference is dependant variable
    echo "# gather statistics
    set fit quiet
    set fit errorvariables
    set dummy x,y,z
    a=$refmd
    b=1
    c=0.01; c_err=99    # until 171118: c=0.00000001
    e=0.01; e_err=99    # until 171118. e=0.00000001
    # data fitting" > $tmpgp
    case $fittype in
        0)  # no color, no ext
            echo "
    f(x) = a + b*(x-$refmd)
    fit f(x)   '$tmp1' using $refcolumn:$apcolumn via a,b"   >> $tmpgp
            ;;
        1)  # color
            echo "
    f(x,y) = a + b*(x-$refmd) + c*(y-$colormd)
    fit f(x,y) '$tmp1' using $refcolumn:(\$$ct1column-\$$ct2column):$apcolumn via a,b,c" >> $tmpgp
            ;;
        2)  # ext
            echo "
    f(x,z) = a + b*(x-$refmd) + e*(z-$amref)
    fit f(x,z) '$tmp1' using $refcolumn:$amcolumn:$apcolumn via a,b,e" >> $tmpgp
            ;;
        3)  # color + ext
            echo "
    f(x,y,z) = a + b*(x-$refmd) + c*(y-$colormd) + e*(z-$amref)
    fit f(x,y,z) '$tmp1' using $refcolumn:(\$$ct1column-\$$ct2column):$amcolumn:$apcolumn via a,b,c,e" >> $tmpgp
            ;;
    esac
    echo "out=sprintf(\"n=%d  rms=%.3f  a=%.3f  b=%.3f  c=%.3f  e=%.6f\", \
        FIT_NDF, FIT_STDFIT, a-b*$refmd-c*$colormd, b, c, e)
    print out
    
    # write coefficients to text file
    set print 'x.gnuplotout.txt'
    print FIT_NDF, FIT_STDFIT
    print \"a \", a-b*$refmd-c*$colormd, a_err
    print \"b \", b, b_err
    print \"c \", c, c_err
    print \"e \", e, e_err
    " >> $tmpgp
    cat $tmpgp | gnuplot -p 2>&1
    test $? -ne 0 &&
        echo "ERROR: gnuplot fitting failed." >&2 &&
        echo $tmpgp >&2 && return 255
   
    # get coefficients/errors from fit
    magrms=$(head -1 x.gnuplotout.txt | awk '{if (NF>=2) printf("%.3f", $2)}')
    afit=$(grep "^a " x.gnuplotout.txt | awk '{if (NF>=3) printf("%.3f,%.3f", $2, $3)}')
    bfit=$(grep "^b " x.gnuplotout.txt | awk '{if (NF>=3) printf("%.3f,%.3f", $2, $3)}')
    grep "^a " x.gnuplotout.txt | awk '{printf("  %s= %7.3f +- %.3f\n", $1, $2, $3)}'
    grep "^b " x.gnuplotout.txt | awk '{printf("  %s= %7.3f +- %.3f\n", $1, $2, $3)}'
    (test $fittype -eq 1 || test $fittype -eq 3) &&
        cfit=$(grep "^c " x.gnuplotout.txt | awk '{if (NF>=3) printf("%.3f,%.3f", $2, $3)}') &&
        grep "^c " x.gnuplotout.txt | awk '{printf("  %s= %7.3f +- %.3f\n", $1, $2, $3)}'
    (test $fittype -eq 2 || test $fittype -eq 3) &&
        efit=$(grep "^e " x.gnuplotout.txt | awk '{if (NF>=3) printf("%.3f,%.3f\n", $2, $3)}') &&
        grep "^e " x.gnuplotout.txt | awk '{printf("  %s= %7.3f +- %.3f\n", $1, $2, $3)}'
    
    # determine true magzero for large aperture photometry
    x=$(echo $magzero ${afit#,*} ${bfit#,*} $refmd 0        | awk '{
        printf("%.3f", $1-$2-($3-1)*$4-$5)}')
    echo "# magzero (stars) = $x"
    x=$(echo $magzero ${afit#,*} ${bfit#,*} $refmd $gapcorr | awk '{
        printf("%.3f", $1-$2-($3-1)*$4-$5)}')
    echo "# magzero (comet) = $x"
    magzero=$x
    
    # create different kinds of "residuals"
    # 1. to check linearity (assume b=1)
    # 2. to view color term (assume c=1)
    # 3. to view extinction (assume e=1)
    # output: id x y  apmag refinstr  color airmass  resid res1 res2 res3
    #    col: 1  2 3   4     5         6     7        8     9    10   11
    test "$AI_DEBUG" &&
        echo "# cmag=$apcolumn cref=$refcolumn cc1=$ct1column cc2=$ct2column cmd=$colormd" >&2 &&
        echo "# cam=$amcolumn c=${cfit%,*} e=${efit%,*}" >&2 &&
        head -5 $tmp1
    echo "# id      x       y        apmag refinstr  color am     res   reslin rescol resext" > $tmpres
    cat $tmp1 | awk -v cmag=$apcolumn -v cref=$refcolumn -v rmd=$refmd \
        -v cc1="$ct1column" -v cc2="$ct2column" -v cmd=$colormd \
        -v cam=$amcolumn -v amref=$amref \
        -v a=${afit%,*} -v b=${bfit%,*} -v c="${cfit%,*}" -v e="${efit%,*}" '{
            refinstr=a+b*$cref
            cindex=0; if (c!="") cindex=$cc1-$cc2
            if (c!="") refinstr+=c*($cc1-$cc2)
            if (e!="") refinstr+=e*($cam-amref)
            reslin=$cmag-refinstr+(b-1)*($cref-rmd)
            rescol=0
            if (c!="") rescol=$cmag-refinstr+c*($cc1-$cc2-cmd)
            resext=0
            if (e!="") resext=$cmag-refinstr+e*($cam-amref)
            printf("%-9s %7.2f %7.2f  %6.3f %6.3f  %6.3f %4.2f  %6.3f %6.3f %6.3f %6.3f\n",
                    $1, $2, $3,   $cmag, refinstr,  cindex, $cam,  $cmag-refinstr, reslin, rescol, resext)
        }' >> $tmpres
    #echo $tmp1; echo $tmpgp; echo $tmpres
    #return
    
    # save residuals to permanent data file
    str=$setname.$catalog.$icol.resid
    (test -f phot/$str.dat && diff -q $tmpres phot/$str.dat >/dev/null) || \
        cp -p $tmpres phot/$str.dat
    #r=$(echo $aprad | awk '{print $1+2}')
    x=$(median phot/$setname.$catalog.$icol.resid.dat 9)   # median of residuals
    xy2reg $setname.$inext phot/$setname.$catalog.$icol.resid.dat "" "" $aprad "" "" "" 9 |
        awk -v md=$x '{
            if ($1~/^circle/) {
                printf("%s", $0)
                x=$NF; sub(/text={/,"",x); sub(/}/,"",x); x=x*1.0
                if (x>md) {
                    printf(" color=blue")
                } else {
                    printf(" color=yellow")
                }
                printf("\n")
            } else {print $0}
            }' > x.$setname.$catalog.reg
    
    # plot residuals
    # extinction
    if [ $fittype -eq 2 ] || [ $fittype -eq 3 ]
    then
        str=$setname.$catalog.$icol.ext
        grep -v "^#" $tmpres | AIplot -q -n -o x.$str.png \
            -t "Extinction (aprad=$aprad, $setname, $catalog)" \
            -g "set xlabel 'air mass'; set ylabel 'dmag'; set yrange [] reverse" \
            - 7 11
        (test -f phot/$str.png && diff -q x.$str.png phot/$str.png >/dev/null) || \
            cp -p x.$str.png phot/$str.png
        pnglist="$pnglist phot/$str.png"
    fi
    # color term
    if [ "$cfit" ]
    then
        str=$setname.$catalog.$icol.color
        grep -v "^#" $tmpres | AIplot -q -n -o x.$str.png \
            -t "Color term (aprad=$aprad, $setname, $catalog)" \
            -g "set xlabel '$citerm'; set ylabel 'dmag'; set yrange [] reverse" \
            - 6 10
        (test -f phot/$str.png && diff -q x.$str.png phot/$str.png >/dev/null) || \
            cp -p x.$str.png phot/$str.png
        pnglist="$pnglist phot/$str.png"
    fi
    # linearity
    str=$setname.$catalog.$icol.lin
    x="set xlabel 'mag'; set ylabel 'mag - f($color)'; set yrange [] reverse"
    test "$citerm" &&
        x="set xlabel 'mag'; set ylabel 'mag - f($color, $citerm)'; set yrange [] reverse"
    grep -v "^#" $tmpres | AIplot -q -n -p -o x.$str.png \
        -t "Photometric error (aprad=$aprad, $setname, $catalog)" \
        -g "$x" \
        - 4 9
    (test -f phot/$str.png && diff -q x.$str.png phot/$str.png >/dev/null) || \
        cp -p x.$str.png phot/$str.png
    pnglist="$pnglist phot/$str.png"
    # residuals
    false && (
    str=$setname.$catalog.$icol.resid
    grep -v "^#" $tmpres | AIplot -q -o x.$str.png \
        -t "Residuals (aprad=${aprad}px, $setname, $catalog)" \
        -g "set xlabel 'mag'; set ylabel 'mag - $color ($catalog)'; set yrange [] reverse" \
        - 4 8
    (test -f phot/$str.png && diff -q x.$str.png phot/$str.png >/dev/null) || \
        cp -p x.$str.png phot/$str.png
    )

    # show plots
    for str in $pnglist
    do
        AIdisplay $str &
        sleep 0.3
    done

    # search for multiple matches of the same star
    # skip2 ... reference star matches multiple stars in image
    # skip3 ... multiple reference stars match same star in image
    skip2=$(grep -v "^#" phot/$setname.$catalog.$icol.resid.dat | cut -d ' ' -f1 | sort | awk '{
        if($1==last)print $1;last=$1}')
    skip3=$(grep -v "^#" phot/$setname.$catalog.$icol.resid.dat | sort -k2,3 | awk '{
        s=$2" "$3; if(s==last)print lastid" "$1;last=s;lastid=$1}')
    (test "$skip2" || test "$skip3") && echo "ambigeous star matches:" >&2 &&
        echo $skip2 $skip3 | tr ' ' '\n' | sort -u | tr '\n' ' ' | sed -e 's/$/\n/' >&2

    # show possible outliers
    if [ $(cat phot/$setname.$catalog.$icol.resid.dat | wc -l) -ge 9 ]
    then
        rescol=9
        set - $(grep -v "^#" phot/$setname.$catalog.$icol.resid.dat | tr '/' ' ' | \
            kappasigma - $rescol 4 2)
        dv=$(echo $1 | awk '{printf("%.2f", $1)}')
        x=$(echo $2 | awk '{printf("%.2f", 4*$1)}')
        grep -v "^#" phot/$setname.$catalog.$icol.resid.dat | tr '/' ' ' | \
                awk -v rcol=$rescol -v dv=$dv -v lim=$x '{
                    x=$rcol+dv; d=x; if(x<0) d=-1*x;
                    if (d>lim) {printf("%s dm=%5.2f |dm|=%5.2f\n", $0, x, d)}
                }' | sort -t '=' -nr -k3,3 > $tmp2
        # limit number of outliers to display (3+3%)
        no=$(grep -v "^#" phot/$setname.$catalog.$icol.resid.dat | wc -l | \
            awk '{printf("%.0f", 3+0.03*$1)}')
        if [ -s "$tmp2" ]
        then
            echo "outliers (mean mag-ref=$dv, rejection limit=$x)" >&2
            cat $tmp2 | lines $no >&2
            str=$(cat $tmp2 | lines $no | awk '{printf(" %s", $1)}')
            echo "# idlist:" $str
            for x in $str
            do
                sed -i '/text={'$x' /s, color=.*, color=red,' x.$setname.$catalog.reg
            done
        fi
    fi


    # saving results to header keywords
    # determine comet magnitude and coma diameter if appropriate
    comag=""
    #codia=""
    # TODO: deal with header files in case of AI_VERSION<2.7
    if [ $plane -eq 0 ]
    then
        echo "WARNING: no matching comet measurements data found." >&2
        # trying old keywords from AI_VERSION<2.7
        x=$(get_header -s $head AI_CSUM,AI_CCORR | tr '\n' ' ' | awk '{if(NF>=1) print $1+$2}')
        test "$x" && comag=$(i2mag $x $texp $magzero  | awk '{printf("%.2f", $1)}')
        #x=$(get_header -s $head AI_CGLIM)
        #test "$x" && stmlim=$(i2mag $x $texp $magzero | awk '{printf("%.1f", $1)}')
        #x=$(get_header $head AI_CDIA)
        #test "$x" && is_number "$x" &&
        #    codia=$(echo $x $pixscale | awk '{printf("%4.1f", $1*$2/60)}')
    else
        echo "# using comet aperture measurements from image color plane $plane"
        x=$(get_header -s $head AC_ASUM$plane,AI_ACOR$plane | tr '\n' ' ' | awk '{if(NF>=1) print $1+$2}')
        test "$x" && comag=$(i2mag $x $texp $magzero  | awk '{printf("%.2f", $1)}')
        #x=$(get_header $head AC_DIAM$plane)
        #test "$x" && is_number "$x" &&
        #    codia=$(echo $x $pixscale | awk '{printf("%4.1f", $1*$2/60)}')
    fi
    test -z "$comag" &&
        echo "WARNING: could not determine comet magnitude" >&2
    
    
    # write results
    # key is made from AP_AIDX + AP_PCAT
    test -z "$has_photcal" && str="writing new calibration results"
    test "$has_photcal"    && str="updating calibration results"
    str="$str (AP-index=$pidx)"
    if [ "$no_update" ]
    then
        echo "WARNING: NOT" $str >&2
    else
        echo "#" $str
        
        set_header $head \
        AP_VERS$pidx="${AI_VERSION}    / airfun version (AIphotcal)" \
        AP_AIDX$pidx="$plane           / Index of related aperture photometry data" \
        AP_PCAT$pidx="$catalog         / Photometric reference catalog" \
        AP_PCOL$pidx="$color           / Photometric reference color band"

        if [ "$rlim" ]
        then
            set_header $head \
        AP_RMAX$pidx="$rlim            / Max. distance for matching catalog objects"
        else
            set_header $head AP_RMAX$pidx=""
        fi
        if [ "$mlim" ]
        then
            set_header $head \
        AP_RLIM$pidx="$mlim            / Mag limit of reference stars"
        else
            set_header $head AP_RLIM$pidx=""
        fi

        set_header $head \
        AP_NMAX$pidx="$nlim            / Max. number of reference stars" \
        AP_NFIT$pidx="$nstars          / Number of valid reference stars" \
        AP_ARAD$pidx="$aprad           / Aperture radius in pix" \
        AP_RMAG$pidx="$refmd           / Reference catalog mag (median)" \
        AP_DMAG$pidx="${afit%,*}       / Mag offset from MAGZERO" \
        AP_DMER$pidx="${afit#*,}       / Mag offset error" \
        AP_SLOP$pidx="${bfit%,*}       / Slope of catalog mag vs. apphot mag" \
        AP_SLER$pidx="${bfit#*,}       / Slope error" \
        AP_MCOR$pidx="$gapcorr         / Mag correction for large aperture" \
        AP_MZER$pidx="$magzero         / Mag zero point, corrected for large aperture" \
        AP_MRMS$pidx="$magrms          / Mag residual rms"
        
        if [ "${cfit/,/}" != "$cfit" ]
        then
            set_header $head \
        AP_CIND$pidx="$citerm          / Photometric reference color index" \
        AP_CIMD$pidx="$colormd         / Color index of reference stars (median)" \
        AP_CTRA$pidx="${cfit%,*}       / Color transformation coefficient" \
        AP_CTER$pidx="${cfit#*,}       / Color transformation coefficient error"
        else
            set_header $head \
        AP_CIND$pidx="" \
        AP_CIMD$pidx="" \
        AP_CTRA$pidx="" \
        AP_CTER$pidx=""
        fi
        
        if [ "${efit/,/}" != "$efit" ]
        then
            set_header $head \
        AP_AMRF$pidx="$amref           / Reference Airmass" \
        AP_EXCO$pidx="${efit%,*}       / Extinction coefficient" \
        AP_EXER$pidx="${efit#*,}       / Extinction coefficient error"
        else
            set_header $head \
        AP_AMRF$pidx="" \
        AP_EXCO$pidx="" \
        AP_EXER$pidx=""
        fi
        
        if [ "$comag" ]
        then
            set_header $head \
        AP_CMAG$pidx="$comag           / Calibrated large aperture comet magnitude"
        else
            set_header $head \
        AP_CMAG$pidx=""
        fi
    fi

    
    #rm -f $tmp2
    test "$AI_DEBUG" && echo "$tmp1" >&2 && echo "$tmpgp" >&2
    test "$AI_DEBUG" || rm -f $tmp1 $tmp2 $tmpbright $tmpgp $tmpres fit.log
}


# extract psf from image
# additionally it creates photometry files and psf mask file
# elongated mask is used when -t <trail> are specified
# results are stored in the directory of <scat>
AIpsfextract () {
    local showhelp
    local trail     # length,angle,centerfrac - length in pix, pa in deg from
                    #   right over top, center fraction (0=start, 1=end of trail)
    local psfoff=2000       # background of resulting psf image
    local nbright=30
    local do_crop	# if set then apply psf subtraction to croped image
    local do_only_photcat   # if set, stop after creating phot catalogs
    local starstack         # image to measure psf background (default: img)
    local i
    for i in $(seq 1 5)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-b" && psfoff=$2 && shift 2
        test "$1" == "-t" && trail=$2 && shift 2
        test "$1" == "-n" && nbright=$2 && shift 2
        test "$1" == "-s" && starstack=$2 && shift 2
        test "$1" == "-p" && do_only_photcat=1 && shift 1
    done
    
    local img=$1
    local scat=$2           # source catalog file (sextractor output file)
                            # AIsource -q -2 -o $srccat $starstack "" 5 32 64 0.0005
    local center=${3:-""}   # xc,yc center of psf stars region in image coords
                            # (e.g. approx. comet center), default is image center
    local rlim=${4:-"10"}   # max distance of psf stars from comet (in percent of image diameter)
    local merrlim=${5:-""}  # mag error limit for field stars
    local psfsize=${6:-"128"}   # size of psf images
    local scale=${7:-"4"}   # psf oversampling factor (used by starcombine)
    #local nreject=7
    local mlimpsf=0.03
    local tdir=${AI_TMPDIR:-"/tmp"}
    local wdir=$(mktemp -d "$tdir/tmp_psf_XXXXXX")
    local tmpcat=$(mktemp "$wdir/tmp_scat_XXXXXX.fits")
    local tmpdat=$(mktemp "$wdir/tmp_dat_XXXXXX.dat")
    local tmpphot=$(mktemp "$wdir/tmp_phot_XXXXXX.dat")
    local tmpreg=$(mktemp "$wdir/tmp_reg_XXXXXX.reg")
    local tmpmask=$(mktemp "$wdir/tmp_mask_XXXXXX.pbm")
    # temp image files which will be assigned names later on
    local tmppsf
    local tmpim1
    local tmpim2
    local psfstarsdir=$(mktemp -d "$tdir/tmp_psfstars_XXXXXX")
    local tmpstarsdir=$(mktemp -d "$tdir/tmp_tmpstars_XXXXXX")
    local sname
    local ext               # image format
    local ncol              # number of colors
    local w
    local h
    local codir="comet"
    local outpsf            # output psf image
    local psfphot           # output psf star photometry file
    local subphot           # companions of psf stars, photometry file
    #local compphot          # output comparison star photometry file
    local subreg            # optional user provided region file to limit comphot
                            # (and star subtraction) to r<rlim and subreg
    local outresid          # residual image after subtracting stars
    local trail2
    local hdr
    local texp
    local nexp
    local magzero
    local resampopts
    local rmax
    local str
    local fwhm
    local xrad
    local col
    local dmag
    local psfrgb
    local psfbg
    local psfmult
    local mcorr
    local id
    local x
    local y
    local r
    local gap
    local bgwidth

    test -z "$merrlim" && test ${rlim%.*} -gt 17 && merrlim=0.1
    test -z "$merrlim" && test ${rlim%.*} -gt 12 && merrlim=0.15
    test -z "$merrlim" && merrlim=0.2
    
    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: AIpsfextract [-p] [-n nbright|$nbright] [-t trail/len,angle,cfrac] [-b $psfoff|$psfoff] <img> <srccat> [<center>]" \
            "[rlim%|$rlim] [merrlim|$merrlim] [psfsize|$psfsize] [psfoversamp|$scale]" >&2 &&
        return 1

    # checkings
    for f in $img ${img%.*}.head $scat $starstack
    do
        test ! -f $f && echo "ERROR: file $f not found." >&2 && return 255
    done
    test -z "$starstack" && starstack=$img
    
    # image set name
    sname=$(basename ${scat//.*/})

    # get image type
    ext="pgm"; ncol=1
    is_ppm $img && ext="ppm" && ncol=3
    
    # assign temp image files
    local tmppsf=$(mktemp "$wdir/tmp_psf_XXXXXX.$ext")
    local tmpim1=$(mktemp "$wdir/tmp_im1_XXXXXX.$ext")
    local tmpim2=$(mktemp "$wdir/tmp_im2_XXXXXX.$ext")

    # assign output files
    psfphot=$codir/$sname.psfphot.dat     # psf stars
    starphot=$codir/$sname.starphot.dat   # all field stars
    subphot=$(mktemp $tdir/tmp_subphot_XXXXXX.dat)
    subreg=$codir/$sname.sub.reg
    if [ -z "$trail" ]
    then
        #outmask=${scat//.*/}.starmask.pbm
        outmask=$codir/$sname.starmask.reg
        outresid=$tdir/x.stsub.$ext
        test -z $outpsf && outpsf=$codir/$sname.starpsf.$ext
    else
        #outmask=${scat//.*/}.trailmask.pbm
        outmask=$codir/$sname.trailmask.reg
        outresid=$tdir/x.cosub.$ext
        test -z $outpsf && outpsf=$codir/$sname.trailpsf.$ext
    fi
    test -e ${outresid%.*}.head && rm ${outresid%.*}.head
    hdr=${img%.*}.head
    test -e $hdr && cp -p $hdr ${outresid%.*}.head &&
        set_header ${outresid%.*}.head AI_SNAME=$sname
    
    test -e $outpsf &&
        echo "ERROR: output psf image $outpsf exists." >&2 && return 255

    # trail parameter for psf mask creation
    if [ "$trail" ]
    then
        # adjust trail parameter to psf oversampling
        set - ${trail//,/ }
        trail=$(echo  $1 $2 $3 0.5 | awk -v s=$scale '{printf("-t %d,%s,%s", s*$1, $2, $3)}')
        trail2=$(echo $1 $2 $3 0.5 | awk -v s=2      '{printf("-t %d,%s,%s", s*$1, $2, $3)}')
    fi
    
    # read some image header keywords
    texp=""     # exposure time in sec
    nexp=""     # number of exposures that have been averaged
    magzero=""  # magzero for texp=1
    if [ -f $hdr ]
    then
        texp=$(grep    "^EXPTIME" $hdr | tr '=' ' ' | awk '{if ($2>0) printf("%d", 1*$2)}')
        nexp=$(grep    "^NEXP"    $hdr | tr '=' ' ' | awk '{if ($2>0) printf("%d", $2)}')
        magzero=$(grep "^MAGZERO" $hdr | tr '=' ' ' | awk '{if ($2>0) printf("%.2f", $2)}')
    fi
    test -z "$texp" &&
        echo "ERROR: missing keyword EXPTIME." >&2 && return 255
    test -z "$nexp" && nexp=1

    # read data from environment
    test "$AI_MAGZERO"  && magzero=$AI_MAGZERO
    test -z "$magzero" &&
        echo "ERROR: magzero unknown." >&2 && return 255

    # exposure time of single exposure
    texp=$(echo $texp $nexp | awk '{printf("%f", $1/$2)}')

    # keep resampling type
    resampopts="$(grep '^RESAMPT1=' ${img%.*}.head | awk -F "'" '{print "-r "$2}')"
    resampopts=""   # 160928 disabled
    #'
    echo "# texp=$texp  magzero=$magzero  resampopts=$resampopts" >&2
    
    
    # -------------------------------------------
    #   extract position and brightness of stars
    # -------------------------------------------
    
    set - $(imsize $img)
    w=$1
    h=$2
    # convert center from image to FITS coordinates
    test "$center" &&
        center=$(echo ${center//,/ } $h | awk '{printf("%.0f,%.0f", $1-0.5, $3-$2+0.5)}')
    # if center has not been specified by the user then use image center
    test -z "$center" && center=$((w/2)),$((h/2))

    rmax=$(echo $w $h | awk -v r=$rlim '{
        printf("%.0f", sqrt($1*$1+$2*$2)*r/100)}')
    echo "# w=$w h=$h rmax=$rmax" >&2
    str="FWHM_IMAGE,MAG_AUTO,MAGERR_AUTO,FLAGS"
    
    # identify bright sources
    sexselect -x $scat "" 0.03 $rmax "$center" "NUMBER,X*,Y*,A*,$str" 0 | \
         sort -n -k6,6 | grep -v "^#" | lines $nbright > $tmpdat
    # determine median fwhm from bright sources
    set - $(kappasigma $tmpdat 5)
    fwhm=$(echo $1 | awk '{printf("%.2f", $1)}')
    x=$(echo $2 | awk '{printf("%.2f", $1)}')   # stddev of fwhm
    xrad=$(echo $fwhm | awk '{printf("%.1f", 0.5+$1/4)}')
    echo "# fwhm=$fwhm"+-"$x  xrad=$xrad" >&2

    # create photometry catalog of psf stars
    if [ -s $psfphot ] && [ $psfphot -nt $scat ]
    then
        echo "reusing existing $psfphot." >&2
    else
        # region file (psf stars only)
        echo -e "# Region file format: DS9 version 4.1
global color=green dashlist=8 3 width=1 font=\"helvetica 10 normal roman\" \
select=1 highlite=1 dash=0 fixed=0 edit=1 move=1 delete=1 include=1 source=1
physical" > $tmpreg
        cat $tmpdat | awk -v w=$w -v h=$h -v f=$fwhm -v s=$x -v pw=$psfsize '{
            if ($1~/^#/) {print $0; next}
            if ($5 > 1.3*f+3*s) next
            # skip sources close to border
            margin=pw/2+2
            if (($2-0.5 < margin) || ($2-0.5 > w-margin)) next
            if (($3-0.5 < margin) || ($3-0.5 > h-margin)) next
            #r=$5-(f3*s); if (r<0) r=0; r=5+r/s+0.1*r*r/s*s
            r=2
            printf("circle(%.2f,%.2f,%.1f) # text={%s %.1f}\n", $2+0.5, h-$3+0.5, r, $1, $6)}' >> $tmpreg
        
        # create photometry data file with columns id xc yc r g b
        if [ $ncol == 3 ]
        then
            sex2rgbdat $scat $xrad $tmpreg > $psfphot 2>/dev/null
            test $? -ne 0 &&
                echo "ERROR: failed command: sex2rgbdat $scat $xrad $tmpreg" >&2 && return 255
        else
            cat $tmpdat | awk -v w=$w -v h=$h -v f=$fwhm -v s=$x -v pw=$psfsize '{
                if ($1~/^#/) {print $0; next}
                if ($5 > 1.3*f+3*s) next
                # skip sources close to border
                margin=pw/2+2
                if (($2-0.5 < margin) || ($2-0.5 > w-margin)) next
                if (($3-0.5 < margin) || ($3-0.5 > h-margin)) next
                printf("%-10s  %7.2f %7.2f  %6.3f %6.3f %6.3f  %3d %3d  %4d %3d %.3f\n",
                    $1, $2, $3, $6, $6, $6, 0, 0, 0, 0, $7)
            }' > $psfphot
        fi
    fi

    # create photometry catalog of field stars
    if [ -s $starphot ] && [ $starphot -nt $scat ]
    then
        echo "reusing existing $starphot." >&2
    else
        echo "# $(date +'%H:%M:%S') creating star catalog ..."
        # filter by merrlim and flags<=7
        if [ -f $subreg ]
        then
            #### TODO: filtering subreg should be shifted to AIcomet
            # apply region filter to field stars
            echo "# select field stars within $subreg (and r<$((rmax+psfsize)))" >&2
            cp $subreg $tmpreg
            echo "circle($center,$((rmax+psfsize)))" >> $tmpreg
            regfilter $scat $tmpreg | \
                sexselect -f -a - "" $merrlim "" "" \
                "*" 7 > $tmpcat
            cp -p $tmpreg x.compreg.reg
        else
            # all stars (except faintest ones)
            sexselect -f -a $scat "" $merrlim "" "" "*" 7 > $tmpcat
        fi
        x=$(echo $fwhm $x | awk '{printf("%.1f", 1+1.3*$1+5*$2)}') # max fwhm for star detection
        if [ $ncol == 3 ]
        then
            echo "# matching objects in color bands ..." >&2
            sex2rgbdat -f $x $tmpcat $xrad > $starphot 2>/dev/null
            test $? -ne 0 &&
                echo "ERROR: failed command: sex2rgbdat -f $x $tmpcat $xrad" >&2 && return 255
        else
            sexselect -x $tmpcat "" "" "" "" "NUMBER,X*,Y*,A*,$str" 99 | awk -v fmax=$x '{
                if ($1~/^#/) {print $0; next}
                #if ($5 > fmax) next
                sflag=""
                if ($NF >= "4") {
                    sflag=" sat"
                } else {
                    if ($5 > fmax) next
                }
                printf("%-10s  %7.2f %7.2f  %6.3f %6.3f %6.3f  %3d %3d  %4d %3d %.3f%s\n",
                    $1, $2, $3, $6, $6, $6, 0, 0, 0, 0, $7, sflag)
            }' > $starphot
        fi
        echo "# catalog of $(grep -v "^#" $starphot | wc -l) field stars created" >&2
    fi
    if [ "$do_only_photcat" ]
    then
        echo "phot catalogs $psfphot and $starphot created" >&2
        echo "WARNING: skip any further processing as requested" >&2
        rm -f $tmpim1 $tmpim2 $tmpphot $tmppsf
        echo "$tmpcat $tmpreg" >&2
        return
    fi
    
    # determine mean brightness and background of psf stars
    echo "# $(date +'%H:%M:%S') measure psf stars for first iteration"
    for col in $(seq 4 $((ncol+3)))
    do
        test "$psfrgb" && psfrgb="$psfrgb,"
        x=$(grep -v "^#" $psfphot | awk -v col=$col '{
                if (NF>=col) i=i+exp(0.9211*(15-$col))
            } END {
                if (NF>=col) printf("%.3f",15-1.0857*log(i/NR))
            }')
        test -z "$x" && break
        psfrgb="$psfrgb$x"
    done
    echo "# psfrgb=$psfrgb" >&2
    # determine first approx. of background around psf stars
    r=$(echo $fwhm | awk '{printf("%.1f", 3*sqrt($1+1)+0.1*$1-2.0)}')
    gap=$(echo $r | awk '{printf("%.1f", 8+$1*1.2)}')
    bgwidth=$(echo $r | awk '{printf("%.1f", 5+$1/2)}')
    x=$(echo $bgwidth $gap | awk '{printf("%.1f", $1+$2)}')
    echo "# bg annulus r=$gap-$x (aprad=$r)" >&2
    AIaphot -bg $starstack $psfphot $r $gap $bgwidth > $tmpdat
    psfbg=$(grep -v "^#" $tmpdat | awk -v ncol=$ncol '{
            r=r+$2
            if(ncol==3) {g=g+$3; b=b+$4}
        }END{
            printf("%.1f", r/NR)
            if(ncol==3) printf(",%.1f,%.1f", g/NR, b/NR)
        }')
    echo "# psfbg=$psfbg  (n=$(grep -v "^#" $tmpdat | wc -l))"

    # determine intensity multiplier
    x=$(grep -v "^#" $psfphot | awk '{printf("%s\n%s\n%s\n", $4, $5, $6)}' | \
        sort -n | lines 1)
    dmag=$(echo $psfrgb | tr ',' '\n' | sort -n | lines 1 | \
        awk -v x=$x '{printf("%.3f", $1-x)}')
    psfmult=$(dmag2di $dmag)
    echo "# psfmult=$psfmult"

    # create (scaled) psf mask image
    x=$((psfsize * scale))
    mkpgm 0 $x $x $tmppsf
    if [ ! -e $outmask ]
    then
        #r=$(echo $fwhm $scale | awk '{printf("%.0f", (4*$1+1)*$2)}')
        r=$(echo $fwhm $scale | awk '{
            x=1.5+1.5*$1+sqrt($1**3+9)
            if($1>3) x=9.6+8*sqrt(0.3*($1-2.7))
            printf("%.0f", x*$2)}')
        # 201127
        r=$(echo $fwhm $scale | awk '{
            x=1+3*$1+3*sqrt($1-0.3)
            if($1>3.5) x=12.5+9*sqrt(0.3*($1-2.7))
            printf("%.1f", x*$2)}')
        test "$AI_DEBUG" && echo "# mask r=$r" >&2
        mkmask $trail $tmppsf $r > $outmask
    fi
    reg2pbm $tmppsf $outmask > $tmpmask

    # create subimages of psf stars
    # create double-size psf mask to identify field stars later on
    # TODO: psfstars must be at least 2*psfsize pixels away from image borders
    mkpgm 0 $((psfsize*2)) $((psfsize*2)) $tmppsf
    r=$(echo $fwhm | awk '{x=12+3*$1; printf("%.0f", x)}')
    mkmask $trail2 $tmppsf $((r*2)) > $tmpreg
    #test "$AI_DEBUG" &&
    echo "# $(date +'%H:%M:%S') cropstars" >&2
    cropstars -o $psfstarsdir -m $tmpreg -s $starphot $img $psfphot $psfsize
    #cropstars -o $psfstarsdir -s $starphot $img $psfphot $psfsize

    # create catalog of stars close to psf stars
    cat $psfstarsdir/*phot0.dat | sort -u > $subphot
    echo "#" $(cat $subphot | wc -l) "field stars close to PSF stars" >&2

    
    # ----------------------------------
    #   determine PSF - first iteration
    # ----------------------------------

    if [ -e $outpsf ]
    then
        echo "reusing existing $outpsf" >&2
    else
        # create first approx of psf
        #test "$AI_DEBUG" &&
        echo "# $(date +'%H:%M:%S') starcombine" >&2
        starcombine -b $psfbg -o $psfoff -m $psfmult -f $fwhm $resampopts $psfstarsdir $tmppsf $psfsize $scale
        (test $? -ne 0 || ! is_pnm $tmppsf) &&
            echo "ERROR: starcombine failed" >&2 &&
            echo "    starcombine -b $psfbg -o $psfoff -m $psfmult -f $fwhm $resampopts $psfstarsdir $tmppsf $psfsize $scale" >&2 &&
            return 255
        test "$AI_DEBUG" && cp -p $tmppsf x.psf0.$ext
        
        # mask central region
        #AIpsfmask $trail $tmppsf $tmpim1 $psfoff $r
        pnmccdred -m 0 $tmppsf - | pnmccdred -a $psfoff - - | \
            pnmcomp -alpha $tmpmask $tmppsf > $tmpim1
        cp $tmpim1 $tmppsf

        # subtract field stars excluding psf stars
        str=$(cat $psfphot | awk '{
            if ($1~/^#/) next
            if (x!="") x=x","; x=x""$1
        } END {printf("%s\n", x)}')
        cp $subphot $tmpdat
        for id in ${str//,/ }; do sed --follow-symlinks -i '/^'$id' /s,^,# ,' $tmpdat; done
        #test "$AI_DEBUG" &&
            echo "# $(date +'%H:%M:%S') AIskygen" >&2
        AIskygen -o $tmpim1 $tmpdat $tmppsf $texp $magzero $scale $w $h $psfoff
        (test $? -ne 0 || ! is_pnm $tmpim1) && echo "ERROR: failed command:" >&2 &&
            echo "  AIskygen -o $tmpim1 $tmpdat $tmppsf $texp $magzero $scale $w $h $psfoff" >&2 &&
            return 255

        # create second approximation of psf
        echo "# $(date +'%H:%M:%S') subtract stars for second iteration"
        #pnmccdred -d $tmpim1 $img $tmpim2
        pnmccdred2 -d $tmpim1 $img $tmpim2
        test $? -ne 0 &&
            echo "ERROR in pnmccdred2" >&2 && return 255
        cp $hdr ${tmpim2%.*}.head

        if [ -z "$trail" ]
        then
            # improve bg measurement by using psf subtracted image
            #   this value is used by AIcomet as bg value of starstack/cometstack
            echo "# $(date +'%H:%M:%S') measure improved psfbg"
            AIaphot -bg $tmpim2 $psfphot $r $gap $bgwidth > $tmpdat
            psfbg=$(grep -v "^#" $tmpdat | awk -v ncol=$ncol '{
                    r=r+$2
                    if(ncol==3) {g=g+$3; b=b+$4}
                }END{
                    printf("%.1f", r/NR)
                    if(ncol==3) printf(",%.1f,%.1f", g/NR, b/NR)
                }')
            echo "# psfbg=$psfbg" >&2
            # TODO: write values to image header
        else
            psfbg=$(get_header -q $hdr AI_PSFBG)
            test "$psfbg" && echo "# reusing psfbg=$psfbg"
        fi
        test -z "$psfbg" &&
            echo "ERROR: unable to determine psfbg" >&2 && return 255
        
        rm -rf $tmpstarsdir/*
        #test "$AI_DEBUG" &&
        echo "# $(date +'%H:%M:%S') cropstars" >&2
        cropstars -o $tmpstarsdir $tmpim2 $psfphot $psfsize
        #test "$AI_DEBUG" &&
        echo "# $(date +'%H:%M:%S') starcombine" >&2
        starcombine -b $psfbg -o $psfoff -m $psfmult -f $fwhm $resampopts $tmpstarsdir $tmppsf $psfsize $scale
        (test $? -ne 0 || ! is_pnm $tmppsf) &&
            echo "ERROR: starcombine failed" >&2 && return 255
        echo "# $(date +'%H:%M:%S') done" >&2
        cp -p $tmppsf $outpsf
        
        # mask central region
        # measure photometric correction in psf image
        # subtract field stars excluding psf stars
        # create psf image
    fi
    
    # mask central region
    #AIpsfmask -m $outmask $trail $outpsf $tmpim1 $psfoff $r
    pnmccdred -m 0 $outpsf - | pnmccdred -a $psfoff - - | \
        pnmcomp -alpha $tmpmask $outpsf > $tmpim1
    cp $tmpim1 $tmppsf
    
    # measure photometric correction in psf image
    if [ -z "$trail" ]
    then
        # do large aperture photometry in $outpsf
        # limit large radius to 1.1*size of starmask
        reg2pbm $tmppsf $outmask > $tmpim1
        rmax=$(imcount $tmpim1 | awk '{printf("%.0f", 1.1*sqrt($1/3.14))}')
        echo $psfsize $scale | awk '{x=$1*$2/2; printf("psfcenter %.1f %.1f\n", x, x)}' > $tmpdat
        x=$(di2dmag $(echo $texp $scale | awk '{printf("%.1f", $1*$2*$2)}') | \
            awk -v m=$magzero -v d=$dmag '{printf("%.3f", m-$1+d)}')
        r=$(echo $fwhm $scale | awk -v rmax=$rmax '{
            r=(4*$1+1)*$2; if(r>rmax){r=rmax}; printf("%.0f", r)}')
        y=$((r/4+scale+2))
        test "$AI_DEBUG" &&
            echo "# AI_MAGZERO=$x AIaphot -p 3 $outpsf $tmpdat $r $y $((4+y/2))" >&2
        AI_MAGZERO=$x AIaphot -p 3 $outpsf $tmpdat $r $y $((4+y/2)) > $tmpphot
        
        # determine mag differences
        set - $(tail -1 $tmpphot)
        mcorr=$(echo ${psfrgb//,/ } $4 $5 $6 | awk '{
            dr=$4-$1; dg=$5-$2; db=$6-$3
            if(dr>0) {dr=0}; if(dg>0) {dg=0}; if(db>0) {db=0}
            printf("%.3f", dr)
            if (NF>4) printf(",%.3f,%.3f", dg, db)}')
        echo "# mcorr=$mcorr" >&2
        set_header $hdr "AI_PSFMC=$mcorr"
        
        # write psfbg, rlim and psfsize to header
        set_header $hdr "AI_PSFBG=$psfbg"
        set_header $hdr "AI_PSFRL=$rlim"
        set_header $hdr "AI_PSFSZ=$psfsize"
    else
        mcorr=$(get_header -q $hdr AI_PSFMC)
        test "$mcorr" && echo "# reusing mcorr=$mcorr"
        if [ -z "$mcorr" ]
        then
            mcorr="0,0,0"
            test $ncol -eq 1 && mcorr="0"
            echo "WARNING: unknown AI_PSFMC, using mcorr=$mcorr" >&2
        fi
    fi

    # subtract both psf and companion stars
    echo "# $(date +'%H:%M:%S') AIskygen" >&2
    # apply mag correction
    cat $psfphot $subphot | grep -v "^#" | sort -u | \
        awk -v mcorr=$mcorr 'BEGIN{ncol=split(mcorr,mc,",")}{
        r=$4+mc[1]
        if (ncol==3) {g=$5+mc[2]; b=$6+mc[3]} else {g=r; b=r}
        printf("%-10s  %7.2f %7.2f  %5.2f %5.2f %5.2f  %3d %3d  %4d %3d %.3f\n",
        $1, $2, $3, r, g, b, $7, $8, $9, $10, $11)}' > $tmpphot
    
    AIskygen -o $tmpim1 $tmpphot $tmppsf $texp $magzero $scale $w $h $psfoff
    (test $? -ne 0 || ! is_pnm $tmpim1) && echo "ERROR: failed command:" >&2 &&
        echo "  AIskygen -o $tmpim1 $tmpphot $tmppsf $texp $magzero $scale $w $h $psfoff" >&2 &&
        return 255
    echo "# $(date +'%H:%M:%S') creating residual image $(basename $outresid)" >&2
    #pnmccdred -a $((bgres-psfoff)) -d $tmpim1 $img $outresid
    #pnmccdred -d $tmpim1 $img $outresid
    pnmccdred2 -d $tmpim1 $img $outresid
    echo "# $(date +'%H:%M:%S') done" >&2
    
    # reject most deviating psf stars
    # rebuild psf
    # rebuild residual image
    
    test "$AI_DEBUG" && echo $wdir >&2 && return
    rm -rf $wdir
    return
}


# comet extraction (star removal) and large aperture photometry
AIcomet () {
    local showhelp
    local newphot       # photometry data file for new/corrected stars,
                        # default: $codir/$sname.newphot.dat
    local bgfit10       # image of background fit (most likely enhanced by factor 10)
    local do_examine    # examine comet/bg regions even if files do already exist
    local no_trail      # currently this variable is never set
    local comult=1      # contrast multiplier for cosub image used by large
                        # aperture photometry (requires bgfit10)
    local rlim          # max distance of stars to subtract, in % of fov
    local no_update     # if set do save results in header keywords
    local codir="comet"
    local i
    for i in $(seq 1 9)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-p" && newphot=$2 && shift 2
        test "$1" == "-d" && codir=$2   && shift 2
        test "$1" == "-b" && bgfit10=$2 && shift 2
        test "$1" == "-e" && do_examine=1    && shift 1
        test "$1" == "-m" && comult=$2  && shift 2
        test "$1" == "-r" && rlim=$2    && shift 2
        test "$1" == "-t" && no_update=1 && shift 1
    done
    
    local ststack=$1
    local costack=${2:-""}
    local omove=$3      # dr@pa@x,y: dr - object move on the sky in "/hr
                        # pa - pa in deg (N over W)
                        # x,y - object position in costack (image coord. system)
    local obsdata=$4    # observations data for individual images of ststack
                        # lines: imageID JD dmag (dmag with arbitrary zero point)
    local psfoff=${5:-"2000"} # background (offset) of psf image
    local starpsf=${6:-""}
    local trailpsf=${7:-""}
    local starmask=${8:-""}
    local trailmask=${9:-""}
    local starphot=${10:-""}
    local psfphot=${11:-""}
    local scale=4           # psf oversampling factor (e.g. used by AIpsfextract)
    #old: local bgres=2000     # background of stsub, cosub, residual image
    local inbg	        # background of starstack/cometstack
    local outbg=2000    # background value to set for all psf subtracted images
    local tdir=${AI_TMPDIR:-"/tmp"}
    local wdir=$(mktemp -d "$tdir/tmp_comet_XXXXXX")
    # temp images which will be assigned file names later on
    local tmpim1
    local tmpim2
    local tmpim3    # not used anymore
    local tmpbgcorr # not used anymore
    # image masks
    local tmpmask=$(mktemp "$wdir/tmp_mask_XXXXXX.pbm")
    local tmpbadmask=$(mktemp "$wdir/tmp_badmask_XXXXXX.pbm")
    local tmpkernel=$(mktemp "$wdir/tmp_kernel_XXXXXX.pbm")
    local tmpdat1=$(mktemp "$wdir/tmp_dat1_XXXXXX.dat")
    local tmpdat2=$(mktemp "$wdir/tmp_dat2_XXXXXX.dat")
    local tmpphot=$(mktemp "$wdir/tmp_phot_XXXXXX.dat")
    local tmpreg=$(mktemp "$wdir/tmp_reg_XXXXXX.reg")
    # temp images not removed at the end of program
    local genstars
    local gentrails
    local stsub
    local stsubhdr
    local cosub
    local cosubhdr
    local coblur
    local coblurhdr
    local residimg
    local residhdr
    local cotrail
    #
    local sname
    local skip_cosub    # if set then skip creting new stsub and cosub images
    local coreg
    local bgreg
    local badreg
    local hdr
    local wcshdr
    local ext
    local w
    local h
    local f
    local fwhm
    local rad
    local gap
    local bgwidth
    local xrad
    local val
    local copos
    local coregion
    local whxy
    local trailbg
    local nref
    local jdref
    local r
    local p
    local cmag
    local mmag
    local dm
    local dt
    local x
    local y
    local texp
    local nexp
    local magzero
    local mcorr
    local str
    local bgmult        # get value from image header?
    local cosubmult     # trail subtracted and scaled result image stored in $codir
    local bgmn
    local bgsd
    local sum
    local area
    local diam
    local aidx
    local filter
    local newmagcorr
    local add
    local blur
    
    (test "$showhelp" || test $# -lt 4) &&
        echo "usage: AIcomet [-t] [-e] [-d outdir|$codir] [-b bgfit10] [-r rlim] [-p newphot]" \
            "<ststack> <costack> <omove> <obsdata> [psfoff|$psfoff] [starpsf|$starpsf]" \
            "[trailpsf|$trailpsf] [starmask|$starmask] [trailmask|$trailmask] [starphot|$starphot]" >&2 &&
        return 1

    ext=""
    is_pgm $ststack && ext="pgm"
    is_ppm $ststack && ext="ppm"
    test -z "$ext" &&
        echo "ERROR: $ststack not in PGM or PPM image format." && return 255

    # temp images
    local tmpim1=$(mktemp "$wdir/tmp_im1_XXXXXX.$ext")
    local tmpim2=$(mktemp "$wdir/tmp_im2_XXXXXX.$ext")
    local tmpim3=$(mktemp "$wdir/tmp_im3_XXXXXX.$ext")
    local tmpbgcorr=$(mktemp "$wdir/tmp_bgcorr_XXXXXX.$ext")

    sname=$(basename ${ststack//.*/})
    test -z "$costack"   && costack=${ststack/./_m.}
    test -z "$starpsf"   && starpsf=$codir/$sname.starpsf.$ext
    test -z "$trailpsf"  && trailpsf=$codir/$sname.trailpsf.$ext
    test -z "$starmask"  && starmask=$codir/$sname.starmask.reg
    test -z "$trailmask" && trailmask=$codir/$sname.trailmask.reg
    test -z "$starphot"  && starphot=$codir/$sname.starphot.dat
    test -z "$psfphot"   && psfphot=$codir/$sname.psfphot.dat
    # allow masks in PBM format
    test ! -e $starmask  && test -e ${starmask%.reg}.pbm  && starmask=${starmask%.reg}.pbm
    test ! -e $trailmask && test -e ${trailmask%.reg}.pbm && trailmask=${trailmask%.reg}.pbm
    # allow masks in PGM format
    test ! -e $starmask  && test -e ${starmask%.reg}.pgm  && starmask=${starmask%.reg}.pgm
    test ! -e $trailmask && test -e ${trailmask%.reg}.pgm && trailmask=${trailmask%.reg}.pgm
    coreg=$codir/$sname.comet.reg
    bgreg=$codir/$sname.cometbg.reg
    badreg=$codir/$sname.bad.reg

    # checkings
    for f in $ststack $costack $obsdata $newphot $bgfit10 \
        $starpsf $trailpsf $starmask $trailmask $starphot $psfphot \
        ${ststack/.bgs/} ${costack/.bgs/}
    do
        test ! -e $f && echo "ERROR: file $f not found." >&2 && return 255
        test ! -s $f && echo "ERROR: file $f is empty." >&2 && return 255
    done
    hdr=${ststack%.$ext}".head"
    test ! -e $hdr && hdr=$sname.head
    test ! -e $hdr &&
        echo "ERROR: file $hdr not found." >&2 && return 255
    wcshdr=${ststack%.$ext}".wcs.head"
    test ! -e $wcshdr && wcshdr=$sname.wcs.head
    test ! -e $wcshdr &&
        echo "ERROR: file $wcshdr not found." >&2 && return 255

    # temp images not removed at the end of program
    genstars=$tdir/x.genstars.$ext
    gentrails=$tdir/x.gentrails.$ext
    stsub=$tdir/x.stsub.$ext
    stsubhdr=$tdir/x.stsub.head
    cosub=$tdir/x.cosub.$ext
    cosubhdr=$tdir/x.cosub.head
    coblur=$tdir/x.coblur.$ext
    coblurhdr=$tdir/x.coblur.head
    residimg=$tdir/x.resid.$ext
    residhdr=$tdir/x.resid.head
    cotrail=$tdir/x.cotrail.$ext

    # output file name containing new or corrected photometry
    test -z "$newphot"  && newphot=$codir/$sname.newphot.dat

    # check if it is required to create new cosubmult
    #       if cosubmult -nt $newphot then do not create stsub and cosub
    cosubmult=$codir/$sname.cosub$comult.$ext
    test "$comult" == "1" && cosubmult=$codir/$sname.cosub.$ext
    test -s $cosubmult && test -s $newphot && test -s $coreg && test -s $bgreg &&
        ! test $newphot -nt $cosubmult &&
        skip_cosub=1

    # check for change of parameters (rlim/AC_RLIM, comult/AC_COMUL, bgfit10/AC_BGSUB) then unset skip_cosub
    if [ "$skip_cosub" ]
    then
        x=$(get_header -q $hdr AC_RLIM || echo 100)
        y=${rlim:-"100"}
        ! is_equal $x $rlim && skip_cosub=""
    fi
    if [ "$skip_cosub" ]
    then
        x=$(get_header -q $hdr AC_COMUL)
        test "$x" && ! is_equal $x $comult && skip_cosub=""
    fi
    if [ "$skip_cosub" ]
    then
        x=$(get_header -q $hdr AC_BGSUB)
        test "$x" && ! test $x == "$(basename $bgfit10)" && skip_cosub=""
    fi

    # check content of already present region files
    if [ "$skip_cosub" ]
    then
        test -s $coreg && ! grep -q -iwE "^circle|^polygon" $coreg &&
            echo "ERROR: no polygon region in $coreg." >&2 && return 255
        test -s $bgreg && ! grep -q -iwE "^circle|^polygon|^box" $bgreg &&
            echo "ERROR: no region in $bgreg." >&2 && return 255
        test -s $bgreg && test $(grep -iwE "^circle|^polygon|^box" $bgreg | sort -u | wc -l) -lt 3 &&
            echo "ERROR: too few region in $bgreg (min=3)." >&2 && return 255
        test -s $badreg && ! grep -q -iwE "^circle|^polygon|^box" $badreg &&
            echo "ERROR: no valid regions in $badreg." >&2 && return 255
        
        # check for identical regions
        for str in $(grep -iwE "^polygon" $coreg | awk '{print $1}')
        do
            grep -q "^$str" $bgreg &&
                echo "ERROR: identical region(s) in $coreg and $bgreg." >&2 && return 255
        done
    fi
    
    # get fwhm
    fwhm=$(get_header -q $hdr AI_FWHM)
    test -z "$fwhm" &&
        echo "ERROR: missing AI_FWHM in $hdr." >&2 && return 255
    # set blur value used by imblur
    blur=$(echo $fwhm | awk '{printf("%.1f", sqrt(0.4-0.07*$1+0.06*$1*$1))}')
    echo "# blur=$blur"

    texp=""     # exposure time in sec
    nexp=""     # number of exposures that have been averaged
    magzero=""  # magzero for texp=1
    if [ -f $hdr ]
    then
        texp=$(grep    "^EXPTIME" $hdr | tr '=' ' ' | awk '{if ($2>0) printf("%d", 1*$2)}')
        nexp=$(grep    "^NEXP"    $hdr | tr '=' ' ' | awk '{if ($2>0) printf("%d", $2)}')
        magzero=$(grep "^MAGZERO" $hdr | tr '=' ' ' | awk '{if ($2>0) printf("%.2f", $2)}')
        filter=$(get_header -q $hdr FILTER)
    fi
    test -z "$texp" &&
        echo "ERROR: missing keyword EXPTIME." >&2 && return 255
    test -z "$nexp" && nexp=1
    texp=$(echo $texp $nexp | awk '{printf("%f", $1/$2)}')  # single exposure
    test -z "$magzero" &&
        magzero=$(get_param camera.dat magzero $sname AI_MAGZERO)
    test -z "$magzero" &&
        echo "ERROR: magzero unknown." >&2 && return 255

    # determine copos in FITS coordinates
    set - $(imsize $ststack)
    w=$1
    h=$2
    copos=$(echo $omove | tr ',@' ' ' | awk -v h=$h '{printf("%.0f %.0f", $3, h-$4)}')
    #echo "# omove=$omove  copos=$copos" >&2

    # determine bgmult
    if [ -f $hdr ]
    then
        bgmult=$(get_header -q $hdr AI_BGMUL)
    fi
    if [ -z "$bgmult" ]
    then
        x=$(echo $bgfit10 | cut -d '.' -f2 | tr -d '[a-zA-Z]')
        is_integer $x && bgmult=$x
    fi
    #test "$bgmult" && echo "# bgmult=$bgmult comult=$comult" >&2
    test -z "$bgmult" &&
        echo "WARNING: unable to determine bgmult, assuming bgmult=10" >&2 &&
        bgmult=10

    # subtract stars and star trails (if not using already existing files)
    if [ ! "$skip_cosub" ]
    then
        # select stars from $starphot according to rlim and apply mag correction -> $tmpphot
        mcorr=$(get_header -q $hdr AI_PSFMC)
        test "$mcorr" && echo "# mcorr=$mcorr"
        if [ -z "$mcorr" ]
        then
            mcorr="0,0,0"
            test $ncol -eq 1 && mcorr="0"
            echo "WARNING: unknown AI_PSFMC, using mcorr=$mcorr" >&2
        fi
        set - $(echo $omove | awk -F '@' '{printf("%s", $NF)}' | tr ',' ' ')
        grep -v "^#" $starphot | awk -v rlim=${rlim:-"100"} -v w=$w -v h=$h -v xc=$1 -v yc=$2 -v mcorr=$mcorr \
            'BEGIN{ncol=split(mcorr,mc,","); rmax=rlim/100*sqrt(w*w+h*h)}{
            dx=$2-xc; dy=$3-yc; dr=sqrt(dx*dx+dy*dy)
            if (dr > rmax) next
            r=$4+mc[1]
            if (ncol==3) {g=$5+mc[2]; b=$6+mc[3]} else {g=r; b=r}
            printf("%-10s  %7.2f %7.2f  %6.3f %6.3f %6.3f  %3d %3d  %4d %3d %.3f\n",
            $1, $2, $3, r, g, b, $7, $8, $9, $10, $11)}' > $tmpphot
        y=$(cat $starphot | grep -v "^#" | wc -l)

        # merging newphot
        grep -v "^#" $tmpphot > $tmpdat1
        if [ -e $newphot ]
        then
            echo "# merging $newphot for photometric corrections" >&2
            str=$(grep -v "^#" $newphot | awk '{printf("%s ", $1)}')
            for id in $str; do sed --follow-symlinks -i '/^'$id' /s,^,# ,' $tmpdat1; done
            cat $newphot >> $tmpdat1
            y=$(cat $starphot $newphot | grep -v "^#" | wc -l)
        fi
        x=$(grep -v "^#" $tmpdat1 | wc -l)
        str="$x"    # number of stars to subtract
        test "$rlim" != "100" && test $x -ne $y && str="$x/$y"

        # determine background of starstack/cometstack
        inbg=$(get_header -q $hdr AI_PSFBG)
        test "$inbg" && echo "# psfbg=$inbg"
        if [ -z "$inbg" ]
        then
            rad=$(echo $fwhm | awk '{printf("%.1f", 3*sqrt($1+1)+0.1*$1-2.0)}')
            gap=$(echo $rad | awk '{printf("%.1f", 8+$1*1.2)}')
            bgwidth=$(echo $rad | awk '{printf("%.1f", 5+$1/2)}')
            AIaphot -bg $ststack $psfphot $rad $gap $bgwidth > $tmpdat1
            inbg=$(grep -v "^#" $tmpdat1 | awk '{
                r=r+$2; g=g+$3; b=b+$4}END{printf("%.1f,%.1f,%.1f", r/NR, g/NR, b/NR)}')
            echo "# bg of star stack = $inbg" >&2
        fi
        
        rm -f $stsubhdr
        # subtract stars from star stack -> stsub
        echo "$(date +'%H:%M:%S') subtracting $str stars from star stack ..." >&2
        #AIpsfmask -q -m $starmask $starpsf $tmpim1 $psfoff
        reg2pbm $starpsf $starmask > $tmpmask
        pnmccdred -m 0 $starpsf - | pnmccdred -a $psfoff - - | \
            pnmcomp -alpha $tmpmask $starpsf > $tmpim1
        AIskygen -o $genstars $tmpdat1 $tmpim1 $texp $magzero $scale $w $h $psfoff
        test $? -ne 0 &&
            echo "ERROR: failed command: AIskygen -o $genstars $tmpdat1 $tmpim1" \
                "$texp $magzero $scale $w $h $psfoff" >&2 && return 255
        #pnmccdred -a $((bgres-psfoff)) -d $genstars $ststack $stsub
        add=$(echo $outbg ${inbg//,/ } | awk '{
            printf("%.0f", $1-$2)
            if (NF>2) printf(",%.0f,%.0f", $1-$3, $1-$4)
        }')
        #echo "pnmccdred -a $add -d $genstars $ststack $stsub" >&2
        #pnmccdred -a "$add" -d $genstars $ststack $stsub
        pnmccdred2 -a "$add" -d $genstars $ststack $stsub
        test $? -ne 0 &&
            echo "ERROR: failed command: pnmccdred -a $add -d $genstars $ststack $stsub" >&2 &&
            return 255

        rm -f $cosubhdr
        # subtract trails from comet stack -> cosub
        echo "$(date +'%H:%M:%S') subtracting $str star trails from comet stack ..." >&2
        #AIpsfmask -m $trailmask $trailpsf $tmpim1 $psfoff
        reg2pbm $trailpsf $trailmask > $tmpmask
        pnmccdred -m 0 $trailpsf - | pnmccdred -a $psfoff - - | \
            pnmcomp -alpha $tmpmask $trailpsf > $tmpim1
        AIskygen -o $gentrails $tmpdat1 $tmpim1 $texp $magzero $scale $w $h $psfoff
        test $? -ne 0 &&
            echo "ERROR: failed command: AIskygen -o $gentrails $tmpdat1 $tmpim1" \
                "$texp $magzero $scale $w $h $psfoff" >&2 && return 255
        #pnmccdred -a $((bgres-psfoff)) -d $gentrails $costack $cosub
        add=$(echo $outbg ${inbg//,/ } | awk '{
            printf("%.0f", $1-$2)
            if (NF>2) printf(",%.0f,%.0f", $1-$3, $1-$4)
        }')
        #pnmccdred -a $add -d $gentrails $costack $cosub
        pnmccdred2 -a $add -d $gentrails $costack $cosub
        test $? -ne 0 &&
            echo "ERROR: failed command: pnmccdred -a $add -d $gentrails $costack $cosub" >&2 &&
            return 255

        cp -p $hdr $stsubhdr
        set_header $stsubhdr AI_SNAME=$sname
        cp -p $hdr $cosubhdr
        set_header $cosubhdr AI_SNAME=$sname

        if [ "$bgfit10" ] && [ $comult -gt 1 ]
        then
            # next section replaced in v5.0.1
            false && (
            # scale bgcorr image to match comult
            x=$(echo $bgmult $comult | awk '{printf("%.6f", $2/$1)}')   # comult/bgmult
            y=$(echo $comult | awk '{printf("%.6f", 1/$1)}')            # 1/comult
            echo "$(date +'%H:%M:%S') create bg correction image ..." >&2
            pnmccdred2 -m $x $bgfit10 $tmpim1
            # note: pyvips pipes are unreliable
            #pnmccdred2 -m $y $tmpim1 - | pnmccdred2 -m $comult - - | \
            #    pnmccdred2 -a $psfoff -d - $tmpim1 - | \
            #    convert - -resize ${w}x${h}\! $tmpbgcorr
            pnmccdred2 -m $y $tmpim1 $tmpim2
            pnmccdred2 -m $comult $tmpim2 $tmpim3
            pnmccdred2 -a $psfoff -d $tmpim3 $tmpim1 - | \
                convert - -resize ${w}x${h}\! $tmpbgcorr
            # create contrast enhanced images
            echo "$(date +'%H:%M:%S') create contrast enhanced image ..." >&2
            add=$(echo $outbg | awk -F ',' -v m=$comult '{
                printf("%.0f", $1*(1-m))}')
            # note: pyvips pipes are unreliable
            #pnmccdred2 -a $add -m $comult $cosub - | \
            #    pnmccdred2 -a $psfoff -d $tmpbgcorr - - | \
            #    imblur -b $blur - > $coblur
            pnmccdred2 -a $add -m $comult $cosub $tmpim2
            pnmccdred2 -a $psfoff -d $tmpbgcorr $tmpim2 - | \
                imblur -b $blur - > $coblur
            )
            
            echo "$(date +'%H:%M:%S') create contrast enhanced image ..." >&2
            # scale up star trail image
            pnmccdred2 -m 10 $gentrails $tmpim1
            # bg subtraction and scaling of non-bgs costack, subtract trails, bluring
            test "$AI_DEBUG" &&
                echo "# imbgsub -m $comult $costack $bgfit10 \"\" $bgmult \"\" $outbg" >&2
            # using pyvips with pipes
            imbgsub -m $comult ${costack/.bgs/} $bgfit10 "" $bgmult "" $outbg | \
                pnmccdred2 -d $tmpim1 - $cosubmult
            imblur -b $blur $cosubmult > $coblur
        else
            if [ $comult -gt 1 ]
            then
                # bgmult=1, comult>1
                add=$(echo $outbg | awk -F ',' -v m=$comult '{
                    printf("%.0f", $1*(1-m))}')
                pnmccdred2 -a $add -m $comult $cosub $cosubmult
                imblur -b $blur $cosubmult > $coblur
            else
                # bgmult=1, comult=1
                imblur -b $blur $cosub > $coblur
                cp -p $cosub $cosubmult
            fi
        fi

        (! test -s $coblur || ! is_pnm $coblur) &&
            echo "ERROR: unable to create $coblur" >&2 && return 255
        cp -p $hdr $coblurhdr
        set_header $coblurhdr AI_SNAME=$sname
    fi
    
    # define regions for comet and background
    str=""
    if [ ! -f $coreg ] || ! grep -q -iwE "^circle|^polygon" $coreg
    then
        str="do_it"
        # get jd (mean jd) and jdref
        jd=$(get_jd -k JD,JD_OBS,DATE-OBS $hdr)
        test -z "$jd" &&
            echo "ERROR: unable to determine JD from $hdr." >&2 &&
            return 255
        
        jdref=$(get_header -q $hdr JD_REF)
        test -z "$jdref" && jdref=$(get_header -q $hdr MJD_REF)
        if [ -z "$jdref" ]
        then
            # get jdref from rawfiles.dat
            nref=$(get_header -q $hdr NREF)
            test -z "$nref" && nref=$(AIsetinfo -b $sname | lines 1 | awk '{printf("%s", $8)}')
            test "$nref" && test -s rawfiles.dat &&
                jdref=$(grep "^$nref " rawfiles.dat | awk '{printf("%s", $5)}') &&
                echo "# nref=$nref jdref=$jdref (rawfiles.dat)"
        fi
        
        if [ -z "$jdref" ]
        then
            echo "# WARNING: unable to determine time of reference image," >&2
            echo "#  initial comet region might be off." >&2
            x=0; y=0
        else
            # time offset between mean jd and nref in seconds
            dt=$(echo $jdref $jd | awk  '{printf("%d", ($2-$1)*24*3600)}')
        
            # image rotation angle and pixel scale
            r=$(get_wcsrot $wcshdr $(echo $omove | awk -F "@" '{print $3}' | tr ',' ' '))
            p=$(get_wcspscale $wcshdr)
            
            # determine comets offset with respect to jdref in cartesian x/y
            x=$(echo $omove $dt $r $p | awk '{
                split($1,a,/@/)
                r=(a[2]-$3)*3.1415926/180
                printf("%.2f", -1*a[1]*sin(r)*$2/$4/3600)}')
            y=$(echo $omove $dt $r $p | awk '{
                split($1,a,/@/)
                r=(a[2]-$3)*3.1415926/180
                printf("%.2f", a[1]*cos(r)*$2/$4/3600)}')
            #echo "# comet offset: x=$x y=$y" >&2
        fi

        # create initial comet region
        echo "# Region file format: DS9 version 4.1
global color=green dashlist=8 3 width=1 font=\"helvetica 10 normal roman\" " \
            "select=1 highlite=1 dash=0 fixed=0 edit=1 move=1 delete=1 " \
            "include=1 source=1" > $coreg
        echo "physical" >> $coreg
        echo ${omove//@/ } | tr ',' ' ' | awk -v r=20 -v h=$h -v x=$x -v y=$y '{
            z=sqrt(2);
            if(NF<4) next
            printf("polygon(%.2f,%.2f", $3-x+0.5-r, h-$4-y+0.5-r)
            printf(",%.2f,%.2f",  $3-x,         h-$4-y+0.5-z*r)
            printf(",%.2f,%.2f",  $3-x+0.5+r,   h-$4-y+0.5-r)
            printf(",%.2f,%.2f",  $3-x+0.5+z*r, h-$4-y)
            printf(",%.2f,%.2f",  $3-x+0.5+r,   h-$4-y+0.5+r)
            printf(",%.2f,%.2f",  $3-x,         h-$4-y+0.5+z*r)
            printf(",%.2f,%.2f",  $3-x+0.5-r,   h-$4-y+0.5+r)
            printf(",%.2f,%.2f)\n", $3-x+0.5-z*r, h-$4-y)
        }' >> $coreg
    else
        echo "reusing comet region from $coreg" >&2
    fi
    if [ ! -f $bgreg ] || ! grep -q -iwE "^circle|^polygon|^box" $bgreg
    then
        str="do_it"
        echo "# Region file format: DS9 version 4.1
global color=green dashlist=8 3 width=1 font=\"helvetica 10 normal roman\" " \
            "select=1 highlite=1 dash=0 fixed=0 edit=1 move=1 delete=1 " \
            "include=1 source=1" > $bgreg
        echo "physical" >> $bgreg
    else
        echo "reusing background region from $codir/$bgreg" >&2
    fi
    test "$str$do_examine" &&
        echo "\
--> define polygon regions for measurements
  - comet region,      save as $coreg
  - background areas,  save as $bgreg
  - areas to exclude,  save as $badreg (optional)
  - when finished close 'SAOImage CometRegions' window to proceed" &&
        AIexamine -n CometRegions -p "-pan to $copos -regions shape polygon" \
            $coblur $coreg $ststack

    # check for correct region format
    for f in $coreg $bgreg $badreg
    do
        ! grep -q -iwE "^physical|^image" $coreg &&
            echo "ERROR: $f has unsupported region file format (must be physical)." >&2 && return 255
    done
    
    # skip regions smaller than 5 pix
    for f in $coreg $bgreg # $badreg
    do
        test -s "$f" && regskip $f > $tmpreg &&
            ! diff -q $tmpreg $f > /dev/null && cp $tmpreg $f
    done
    
    # TODO: allow for ellipse regions, needs some tweeks in reg2pbm
    ! grep -q -iwE "^circle|^polygon" $coreg &&
        echo "ERROR: no polygon region in $coreg." >&2 && return 255
    ! grep -q -iwE "^circle|^polygon|^box" $bgreg &&
        echo "ERROR: no region in $bgreg." >&2 && return 255
    test $(grep -iwE "^circle|^polygon|^box" $bgreg | sort -u | wc -l) -lt 3 &&
        echo "ERROR: too few region in $bgreg (min=3)." >&2 && return 255
    if [ -f $badreg ]
    then
        ! grep -q -iwE "^circle|^polygon|^box" $badreg &&
        echo "WARNING: no valid regions in $badreg." >&2 && badreg=""
    else
        badreg=""
    fi
    
    # check for identical regions
    for str in $(grep -iwE "^polygon" $coreg | awk '{print $1}')
    do
        grep -q "^$str" $bgreg &&
            echo "ERROR: identical region(s) in $coreg and $bgreg." >&2 && return 255
    done
    
    
    # ---------------------
    #   create comet trail
    # ---------------------
    test ! "$skip_cosub" && test ! "$no_trail" && if [ -e $codir/$sname.cotrail.$ext ]
    then
        echo "WARNING: using existing $codir/$sname.cotrail.$ext" >&2
        cp -p $codir/$sname.cotrail.$ext $cotrail
    else
        x=$(grep -v "^#" $obsdata | wc -l)
        echo "$(date +'%H:%M:%S') creating comet trail ($x positions) ..." >&2

        # determine comet extent
        set - $(imsize $ststack)
        w=$1
        h=$2
        # TODO: allow for box as well
        coregion=$(grep -E "^circle\(|^polygon\(" $coreg | tr '() ' ' ' | awk -v w=$w -v h=$h -v m=20 '{
            if ($1 == "circle") {
                n=split($2,a,/,/)
                x1=a[1]-a[3]; x2=a[1]+a[3]
                y1=a[2]-a[3]; y2=a[2]+a[3]
            }
            if ($1 == "polygon") {
                n=split($2,a,/,/)
                for (i=0;i<n/2;i++) {
                    x=a[2*i+1]; y=a[2*i+2]
                    if (i==0) {
                        x1=x; x2=x; y1=y; y2=y
                    } else {
                        if (x<x1) x1=x
                        if (x>x2) x2=x
                        if (y<y1) y1=y
                        if (y>y2) y2=y
                    }
                }
            }
            x1=x1-m; if (x1<0.5)   x1=0.5
            x2=x2+m; if (x2>w+0.5) x2=w+0.5
            y1=y1-m; if (y1<0.5)   y1=0.5
            y2=y2+m; if (y2>h+0.5) y2=h+0.5
            printf("%dx%d+%d+%d\n", int(x2+0.5)-int(x1-0.5), int(h-y1+0.5)-int(h-y2-0.5),
                int(x1-0.5), int(h-y2+0.5))
        }')
        #)
        echo "# coregion=$coregion" >&2
        # add 1/2 psf size (sampled to orig pixscale) around coregion
        x=$(identify $starpsf | cut -d " " -f3 | cut -d "x" -f1)
        whxy=$(echo "$coregion" | tr '+x' ' ' | awk -v x=$x -v scale=$scale -v h=$h -v w=$w '{
            pw=1+2*int(x/scale/2)
            x1=$3-pw/2; if (x1<0) x1=0
            y1=$4-pw/2; if (y1<0) y1=0
            x2=$1+$3+pw/2; if (x2>w) x2=w
            y2=$2+$4+pw/2; if (y2>h) x2=h
            printf("%d %d %d %d", x2-x1+1, y2-y1+1, x1, y1)}')
        echo "# whxy=$whxy"

        # comet mask
        # TODO: use vips
        if [ "$badreg" ]
        then
            reg2pbm $cosub $badreg | imcrop -1 - $whxy | convert - -negate $tmpbadmask
            reg2pbm $cosub $coreg  | imcrop -1 - $whxy | \
                pnmarith -mul - $tmpbadmask 2>/dev/null > $tmpmask
        else
            reg2pbm $cosub $coreg  | imcrop -1 - $whxy > $tmpmask
        fi

        # determine background in $cosub, shift intensity to bg=psfoff
        trailbg=$(regstat2 -q -a $cosub $bgreg $badreg | cut -d ' ' -f1)
        x=$(echo $trailbg | awk -F ',' -v b=$psfoff '{
            printf("%.0f", b-$1)
            if(NF==3) {printf(",%.0f,%.0f", b-$2, b-$3)}
            }')
        # using pyvips with pipes
        imcrop -1 $cosub $whxy | pnmccdred2 -a $x - $tmpim1
        pnmccdred2 -m 0 -a $psfoff $tmpim1 - | \
            pnmcomp -alpha $tmpmask $tmpim1 > $tmpim2

        # smooth cropped costack
        # TODO: for large FWHM work on binned image
        #       use less smoothing for center part of comet
        r=$(get_wcsrot $wcshdr $(echo $omove | awk -F "@" '{print $3}' | tr ',' ' '))
        # core, r=0...3 pix
        x=3
        y=3
        #echo "# mkkernel $x $y" >&2
        #mkkernel $x $y > $tmpkernel
        #kmedian $tmpim2 $tmpkernel > $tmpim1 2>/dev/null
        # inner coma, r=3...15 pix
        x=7
        y=5
        #echo "# mkkernel $x $y" >&2
        #mkkernel $x $y $(echo $r | awk '{printf("%.0f", -1*$1)}') > $tmpkernel
        #kmedian $tmpim2 $tmpkernel > $tmpim1 2>/dev/null
        # outer coma, r>15fwhm
        x=$(echo $fwhm 3.0 | awk '{x=4+$1*$2; printf("%d", 2*int(x/2)+1)}')
        y=$(echo $fwhm 2.0 | awk '{printf("%.0f", 2.5+$1*$2)}')
        #echo "# mkkernel $x $y $(echo $r | awk '{printf("%.0f", -1*$1)}')" >&2
        #mkkernel $x $y $(echo $r | awk '{printf("%.0f", -1*$1)}') > $tmpkernel
        #kmedian $tmpim2 $tmpkernel > $tmpim1 2>/dev/null
        
        x=$(echo $fwhm 2.2 | awk '{x=3+$1*$2; printf("%d", 2*int(x/2)+1)}')
        y=$(echo $fwhm 1.2 | awk '{printf("%.0f", 2+$1*$2)}')
        echo "# mkkernel $x $y $(echo $r | awk '{printf("%.0f", -1*$1)}')" >&2
        mkkernel $x $y $(echo $r | awk '{printf("%.0f", -1*$1)}') > $tmpkernel
        kmedian $tmpim2 $tmpkernel > $tmpim1 2>/dev/null
        test $? -ne 0 &&
            echo "ERROR: kmedian has failed." >&2 && return 255

        # create artificial comet trail
        test "$AI_DEBUG" &&
            echo "mkcotrail -o $tmpim2 $sname $tmpim1 $omove $obsdata $psfoff" >&2
        #echo "# starting mkcotrail at $(date +'%H:%M:%S')" >&2
        mkcotrail -o $tmpim2 $sname $tmpim1 $omove $obsdata $psfoff
        #echo "# finished mkcotrail at $(date +'%H:%M:%S')" >&2
        set - $whxy
        pnmccdred2 -m 0 $ststack - | pnmpaste $tmpim2 $3 $4 - > $cotrail
    fi

    if [ ! "$skip_cosub" ]
    then
        # create residual image
        echo "$(date +'%H:%M:%S') creating residual image ..." >&2
        test "$no_trail" && cp $stsub $residimg
        #test ! "$no_trail" && pnmccdred -d $cotrail $stsub $residimg
        test ! "$no_trail" && pnmccdred2 -d $cotrail $stsub $residimg
        cp -p $hdr $residhdr
        set_header $residhdr AI_SNAME=$sname
    fi

    
    # --------------------------------------------------
    #   new photometry of stars affected by comet trail
    # --------------------------------------------------
    # radii
    # v2.7.3:
    #rad=$(echo $fwhm | awk '{printf("%.1f\n", 3*sqrt($1+1)+0.05*$1-1.3)}')
    #gap=$(echo $rad | awk '{printf("%.1f", 1.5+$1/2)}')
    # new in 3.0.2
    rad=$(echo $fwhm | awk '{printf("%.1f\n", 2.5*sqrt($1+2)-2.8)}')
    gap=$(echo $rad | awk '{printf("%.1f", 3.5+0.7*$1)}')
    xrad=$(echo $fwhm | awk '{printf("%.1f", 1+$1/3)}')
    echo "# fwhm=$fwhm  rad=$rad  gap=$gap  xrad=$xrad" >&2
        
    test ! "$skip_cosub" && if [ ! -e $newphot ]
    then
        # identify stars to be measured/corrected and write x.newphot.reg
        echo "# Region file format: DS9 version 4.1" \
            "global color=green dashlist=8 3 width=1 font=\"helvetica 10 normal roman\" " \
            "select=1 highlite=1 dash=0 fixed=0 edit=1 move=1 delete=1 " \
            "include=1 source=1" > x.newphot.reg
        echo "physical" >> x.newphot.reg
        echo "--> apply photometric correction to selected stars"
        echo "  - use tab to switch between stack and residual image"
        echo "  - select stars in residual image, save as x.newphot.reg"
        echo "  - when finished close the 'SAOImage PhotCorr' window to proceed"
        #AIexamine $ststack $coreg $bgreg $residimg x.newphot.reg
        AIexamine -n PhotCorr -p "-pan to $copos" $ststack $coreg $bgreg $badreg $residimg x.newphot.reg
        cp -p x.newphot.reg x.newphot.00.reg

        # determine aperture correction
        # do small and large aperture photometry in $outpsf
        # limit large radius to 1.1*size of starmask
        r=$(reg2pbm $starpsf $starmask | imcount - | awk '{printf("%.1f", 1.1*sqrt($1/3.14))}')
        set - $(identify $starpsf)
        echo $3 | tr 'x' ' ' | awk '{x=$1/2; printf("psfcenter %.1f %.1f\n", x, x)}' > $tmpdat1
        x=$(echo $rad $scale | awk '{printf("%.0f", $1*$2/2+5)}') # gap
        y=$((4+x/2)) # bg annulus width
        test "$AI_DEBUG" &&
            echo "# AI_MAGZERO=25 AIaphot -p 3 $outpsf $tmpdat $r $x $y" >&2
        AI_MAGZERO=25 AIaphot -p 3 $starpsf $tmpdat1 $r $x $y > $tmpdat2
        # small aperture photometry
        x=$(echo $r $x $rad $scale | awk '{print $1+$2-$3*$4}') # gap
        r=$(echo $rad $scale | awk '{print $1*$2}')
        test "$AI_DEBUG" &&
            echo "# AI_MAGZERO=25 AIaphot -p 3 $outpsf $tmpdat $r $x $y" >&2
        AI_MAGZERO=25 AIaphot -p 3 $starpsf $tmpdat1 $r $x $y >> $tmpdat2
        test "$AI_DEBUG" && cat $tmpdat2
        newmagcorr=$(grep -v "^#" $tmpdat2 | awk '{
            if(NR==1) {r=$4; g=$5; b=$6}
            if(NR==2) {printf("%.3f,%.3f,%.3f", r-$4, g-$5, b-$6)}
        }')
        echo "# newmag in r=$rad, mcorr=$newmagcorr"
        
        newid=0
        if [ ! -e $newphot ]
        then
            echo "# fwhm=$fwhm  rad=$rad  gap=$gap  xrad=$xrad" >> $newphot
            test -e $cosubmult && touch -r $cosubmult $newphot
        fi
        if grep -q -iwE "^circle" x.newphot.reg
        then
            # do aperture photometry on $residimg
            echo "$(date +'%H:%M:%S') aperture photometry of new/corrected stars ..." >&2
            reg2xy $ststack x.newphot.reg > $tmpdat1
            xymatch -a $tmpdat1 $tmpphot $xrad > $tmpdat2
            str=$(grep -v "^#" $tmpdat2 | awk '{printf("%s ", $NF)}')
            echo "# mag corr for: $str" >&2
            cat $tmpdat2 | while read line
            do
                #echo "# line: $line"
                set - $line
                test "$1" == "#" && test "${2:0:1}" != "N" && continue
                if [ $# -ge 9 ]
                then
                    # measure matched stars using their original position from tmpphot
                    x=$2; y=$3; id=$9
                    set - $(aphot -a $residimg $x,$y $rad $gap 4)
                    #echo newmag -q $sname $tmpphot $id 1 $3,$4,$5 1 0
                    newmag -q $sname $tmpphot $id 1 $3,$4,$5 1 0
                else
                    # measure new stars
                    newid=$((newid + 1))
                    id=$(printf "N%04d" $newid); x=$3; y=$4
                    # note: AIaphot $residimg requires MAGZERO keyword
                    #       apply newmagcorr-mcorr
                    echo "$id $x $y" | \
                        AIaphot $residimg - $rad $gap 4 | grep -v "^#" | \
                        awk -v mcorr=$mcorr -v newcorr=$newmagcorr '
                        BEGIN{ncol=split(mcorr,mc,","); split(newcorr,nc,",")}{
                        r=$4+nc[1]-mc[1]
                        if (ncol==3) {g=$5+nc[2]-mc[2]; b=$6+nc[3]-mc[3]} else {g=r; b=r}
                        printf("%-10s  %7.2f %7.2f  %6.3f %6.3f %6.3f  %3d %3d  %4d %3d %.3f\n",
                            $1, $2, $3, r, g, b,
                            $7, $8, $9, $10, $11)
                        }'
                fi
            done | tee -a $newphot
            # sorting newphot
            grep "^#" $newphot > $tmpdat1
            grep "^[0-9]" $newphot | sort -n -k1,1 >> $tmpdat1
            grep -E -v "^#|^[0-9]" $newphot | sort -k1,1 >> $tmpdat1
            cp $tmpdat1 $newphot
            
            # select stars from $starphot according to rlim and apply mag correction
            set - $(echo $omove | awk -F '@' '{printf("%s", $NF)}' | tr ',' ' ')
            grep -v "^#" $starphot | awk -v rlim=${rlim:-"100"} -v w=$w -v h=$h -v xc=$1 -v yc=$2 -v mcorr=$mcorr \
            'BEGIN{ncol=split(mcorr,mc,","); rmax=rlim/100*sqrt(w*w+h*h)}{
                dx=$2-xc; dy=$3-yc; dr=sqrt(dx*dx+dy*dy)
                if (dr > rmax) next
                r=$4+mc[1]
                if (ncol==3) {g=$5+mc[2]; b=$6+mc[3]} else {g=r; b=r}
                printf("%-10s  %7.2f %7.2f  %6.3f %6.3f %6.3f  %3d %3d  %4d %3d %.3f\n",
                $1, $2, $3, r, g, b, $7, $8, $9, $10, $11)}' > $tmpdat1
            # merging newphot
            str=$(grep -v "^#" $newphot | awk '{printf("%s ", $1)}')
            for id in $str; do sed --follow-symlinks -i '/^'$id' /s,^,# ,' $tmpdat1; done
            grep -v "^#" $newphot >> $tmpdat1

            # subtract stars from star stack -> new stsub
            x=$(grep -v "^#" $tmpdat1 | wc -l)
            echo "$(date +'%H:%M:%S') subtracting $x stars and trails ..." >&2
            set - $(imsize $ststack)
            w=$1
            h=$2
            #AIpsfmask -q -m $starmask $starpsf $tmpim1 $psfoff
            reg2pbm $starpsf $starmask > $tmpmask
            pnmccdred -m 0 $starpsf - | pnmccdred -a $psfoff - - | \
                pnmcomp -alpha $tmpmask $starpsf > $tmpim1
            AIskygen -o $genstars $tmpdat1 $tmpim1 $texp $magzero $scale $w $h $psfoff
            #pnmccdred -a $((bgres-psfoff)) -d $genstars $ststack $stsub
            add=$(echo $outbg ${inbg//,/ } | awk '{
                printf("%.0f", $1-$2)
                if (NF>2) printf(",%.0f,%.0f", $1-$3, $1-$4)
            }')
            #pnmccdred -a $add -d $genstars $ststack $stsub
            pnmccdred2 -a $add -d $genstars $ststack $stsub
            # subtract trails from comet stack -> new cosub
            # AIpsfmask -q -m $trailmask $trailpsf $tmpim1 $psfoff
            reg2pbm $trailpsf $trailmask > $tmpmask
            pnmccdred -m 0 $trailpsf - | pnmccdred -a $psfoff - - | \
                pnmcomp -alpha $tmpmask $trailpsf > $tmpim1
            AIskygen -o $gentrails $tmpdat1 $tmpim1 $texp $magzero $scale $w $h $psfoff
            #pnmccdred -a $((bgres-psfoff)) -d $gentrails $costack $cosub
            add=$(echo $outbg ${inbg//,/ } | awk '{
                printf("%.0f", $1-$2)
                if (NF>2) printf(",%.0f,%.0f", $1-$3, $1-$4)
            }')
            #pnmccdred -a $add -d $gentrails $costack $cosub
            pnmccdred2 -a $add -d $gentrails $costack $cosub
            
            echo "$(date +'%H:%M:%S') extracting improved comet image ..." >&2
            if [ "$no_trail" ]
            then
                cp $stsub $residimg
            else
                # create improved comet image
                # comet mask
                if [ "$badreg" ]
                then
                    reg2pbm $cosub $badreg | imcrop -1 - $whxy | convert - -negate $tmpbadmask
                    reg2pbm $cosub $coreg  | imcrop -1 - $whxy | \
                        pnmarith -mul - $tmpbadmask 2>/dev/null > $tmpmask
                else
                    reg2pbm $cosub $coreg  | imcrop -1 - $whxy > $tmpmask
                fi

                # determine background in $cosub, shift intensity to bg=psfoff
                trailbg=$(regstat -q -a $cosub $bgreg $badreg | cut -d ' ' -f1)
                x=$(echo $trailbg | awk -F ',' -v b=$psfoff '{
                    printf("%.0f", b-$1)
                    if(NF==3) {printf(",%.0f,%.0f", b-$2, b-$3)}
                    }')
                # using pyvips with pipes
                imcrop -1 $cosub $whxy | pnmccdred2 -a $x - $tmpim1
                # AIpsfmask -q -m $tmpmask $tmpim1 $tmpim2 $psfoff
                pnmccdred -m 0 -a $psfoff $tmpim1 - | \
                    pnmcomp -alpha $tmpmask $tmpim1 > $tmpim2

                # smooth cropped costack
                kmedian $tmpim2 $tmpkernel > $tmpim1 2>/dev/null
                test $? -ne 0 &&
                    echo "ERROR: kmedian has failed." >&2 && return 255

                # create artificial comet trail
                mkcotrail -o $tmpim2 $sname $tmpim1 $omove $obsdata $psfoff
                set - $whxy
                pnmccdred2 -m 0 $ststack - | pnmpaste $tmpim2 $3 $4 - > $cotrail

                # create improved residuals image
                #pnmccdred -d $cotrail $stsub $residimg
                pnmccdred2 -d $cotrail $stsub $residimg
            fi
            
            # create improved contrast enhanced and blured cosub image
            if [ "$bgfit10" ] && [ $comult -gt 1 ]
            then
                # TODO: move before "--> define polygon region" ...
                false && (
                # create contrast enhanced images
                add=$(echo $outbg | awk -F ',' -v m=$comult '{
                    printf("%.0f", $1*(1-m))}')
                # note: pyvips pipes are unreliable
                #pnmccdred2 -a $add -m $comult $cosub - | \
                #    pnmccdred2 -a $psfoff -d $tmpbgcorr - - | \
                #    imblur -b $blur - > $coblur
                pnmccdred2 -a $add -m $comult $cosub $tmpim1
                pnmccdred2 -a $psfoff -d $tmpbgcorr $tmpim1 - | \
                    imblur -b $blur - > $coblur
                )
                
                # scale up star trail image
                pnmccdred2 -m 10 $gentrails $tmpim1
                # bg subtraction and scaling of non-bgs costack, subtract trails, bluring
                # using pyvips with pipes
                imbgsub -m $comult ${costack/.bgs/} $bgfit10 "" $bgmult "" $outbg | \
                    pnmccdred2 -d $tmpim1 - $cosubmult
                imblur -b $blur $cosubmult > $coblur
            else
                if [ $comult -gt 1 ]
                then
                    add=$(echo $outbg | awk -F ',' -v m=$comult '{
                        printf("%.0f", $1*(1-m))}')
                    pnmccdred2 -a $add -m $comult $cosub $cosubmult
                    imblur -b $blur $cosubmult > $coblur
                else
                    imblur -b $blur $cosub > $coblur
                    cp -p $cosub $cosubmult
                fi
            fi
        fi
    fi


    # ----------------------------------
    #   large aperture comet photometry
    # ----------------------------------

    echo "$(date +'%H:%M:%S') large aperture photometry of comet ..." >&2
    test ! -e $cosubmult &&
        echo "ERROR: missing $cosubmult" >&2 && return 255

    # determine background excluding bad regions
    echo "$(date +'%H:%M:%S') measure bg" >&2
    regstat2 -q $cosubmult $bgreg $badreg | cut -d ' ' -f1 | \
        awk -F ',' -v m=$comult -v b=$outbg '{
            printf("%.1f", ($1-b)/m)
            if (NF==3) printf(" %.1f %.1f", ($2-b)/m, ($3-b)/m)
            printf("\n")
        }' > $tmpdat1
    x=1; test "$ext" == "ppm" && x=3
    for i in $(seq 1 $x)
    do
        test $i -eq 1 &&
            bgmn=$(mean $tmpdat1 $i | awk '{printf("%.2f", $1)}') &&
            bgsd=$(stddev $tmpdat1 $i | awk '{printf("%.2f", $1)}')
        test $i -gt 1 &&
            bgmn="$bgmn,"$(mean $tmpdat1 $i | awk '{printf("%.2f", $1)}') &&
            bgsd="$bgsd,"$(stddev $tmpdat1 $i | awk '{printf("%.2f", $1)}')
    done
    echo "# bgmn=$bgmn  bgsd=$bgsd  nbg=" $(cat $tmpdat1 | wc -l) >&2

    # measure comet region excluding bad regions
    echo "$(date +'%H:%M:%S') measure comet" >&2
    set - $(regstat2 -q -a $cosubmult $coreg $badreg)
    area=$3
    sum=$(echo $4 $bgmn | tr ',' ' ' | awk -v a=$area -v m=$comult -v b=$outbg '{
        if (NF==2) printf("%.0f", ($1-a*b-a*m*$2)/m)
        if (NF==6) printf("%.0f,%.0f,%.0f", ($1-a*b-a*m*$4)/m,
            ($2-a*b-a*m*$5)/m, ($3-a*b-a*m*$6)/m)
    }')
    # measure max intensity
    set - $(regstat2 -q -m $cosubmult $coreg $badreg)
    x=$(echo $2 | tr ',' '\n' | sort -n | tail -1)
    echo "# comet sum=$sum (max=$x)" >&2
    test "$(echo $x $(get_header $hdr SATURATE) | awk '{if($1>=$2){printf("saturated")}}')" &&
        echo "WARNING: saturated pixels found!" >&2
    # total area of comet region
    if [ "$badreg" ]
    then
        set - $(regstat2 -q -a $cosubmult $coreg)
        area=$3
    fi
    # circle of the same area size
    diam=$(echo $area | awk '{x=sqrt($1/3.1415927); printf("%.0f", 2*x)}')
    # mean counts for total comet area
    val=$(echo ${sum//,/ } | awk -v a=$area '{
        if (NF==1) printf("%.2f", $1/a)
        if (NF==3) printf("%.2f,%.2f,%.2f", $1/a, $2/a, $3/a)
    }')
    
    # write results of aperture counts measurements to header
    # converting strings to arrays first
    OLDIFS=$IFS; IFS=,
    sum=($sum); val=($val); bgmn=($bgmn); bgsd=($bgsd)
    IFS=$OLDIFS
    #sum=$(echo ${sum//,/ }   | awk -v i=$i '{printf("%.0f",$i)}') # sum
    #val=$(echo ${val//,/ }   | awk -v i=$i '{printf("%.2f",$i)}') # mean
    #bgmn=$(echo ${bgmn//,/ } | awk -v i=$i -v b=$outbg '{printf("%.2f",b+$i)}') # bg
    #bgsd=$(echo ${bgsd//,/ } | awk -v i=$i '{printf("%.2f",$i)}') # bgsd
    # add bg offset back to bgmn
    for i in $(seq 1 ${#bgmn[@]})
    do
        bgmn[$((i-1))]=$(echo ${bgmn[i-1]} | awk -v b=$outbg '{printf("%.2f",b+$i)}')
    done
    # get name(s) of color band(s)
    #   TODO: should be read from image
    str=""
    case "${filter,,}" in
        r|red)      str="R";;
        g|green)    str="G";;
        b|blue)     str="B";;
        l|luminance)            str="L";;
        c|clear|"no filter")    str="C";;
    esac
    test -z "$str" && test ${#sum[@]} -eq 3 && str=("R" "G" "B")
    test -z "$str" && str="G"

    if [ "$no_update" ]
    then
        echo "# WARNING: Results are NOT saved to header keywords!"
    else
        set_header $hdr \
            AC_VERS="${AI_VERSION} / airfun version (AIcomet)"
        set_header $hdr \
            AC_COMUL="$comult / Intensity multiplier"
        set_header $hdr \
            AC_BGSUB="$(basename $bgfit10) / Background image"
        test "$rlim" && set_header $hdr \
            AC_RLIM="$rlim / Max. distance of stars (in percent of FOV)"
        for aidx in $(seq 1 ${#sum[@]})
        do
            i=$((aidx-1))
            set_header $hdr \
            AC_ICOL$aidx="${str[i]}     / Instrumental color band" \
            AC_AREA$aidx="$area         / Aperture area in pix" \
            AC_ASUM$aidx="${sum[i]}     / Comets total ADU in aperture" \
            AC_MEAN$aidx="${val[i]}     / Comets mean ADU in aperture" \
            AC_DIAM$aidx="$diam         / Equivalent aperture diameter in pix" \
            AC_BCKG$aidx="${bgmn[i]}    / Average background ADU (shifted)" \
            AC_BGER$aidx="${bgsd[i]}    / Background error"
        done
    fi
    unset str   # to change back from array to normal variable
    
    # old format output
    i=1; test ${#sum[@]} -eq 1 && i=0
    echo "# set     mean    area      sum     d    bg-$outbg +- " >&2 
    echo "$sname ${val[i]} $area ${sum[i]} $diam ${bgmn[i]} ${bgsd[i]}" | awk -v b=$outbg '{
            printf("%s     %5.2f  %6d  %7d   %3d   %5.2f  %4.2f\n",
                $1, $2, $3, $4, $5, $6-b, $7)
        }'>&2

    echo "$(date +'%H:%M:%S') finished" >&2

    test "$AI_DEBUG" && echo $wdir >&2 && return
    rm -rf $wdir
    return
}


# freeze comet motion onto background stars
AIcosnap () {
    # output image <sname>.cosnap.<ext>
    local showhelp
    local blurscale=2
    local outmult=2
    local keep_cosnap   # if set then do not overwrite cosnap image
    local wbmul="2.482,1.000,1.362"  # Pentax K5II
    # local wbmul="2.302,0.927,1.263"  # Pentax K5II, dcraw: BGGR
    # local wbmul="2.198,0.933,1.343"  # Canon EOS 6D Mark II, dcraw: RGGB
    local i
    for i in $(seq 1 5)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-s" && blurscale=$2 && shift 2
        test "$1" == "-m" && outmult=$2 && shift 2
        test "$1" == "-w" && wbmul=$2 && shift 2
        test "$1" == "-k" && keep_cosnap=1 && shift 1
        #test "$1" == "-q" && quality=$2 && shift 2
    done

    local set=$1
    local smoothreg=comet/$set.smooth.reg   # core inner outer
    local coreg=comet/$set.comet.reg
    local bgreg=comet/$set.cometbg.reg
    local badreg=comet/$set.bad.reg
    local tmp1=$(mktemp "/tmp/tmp_dat_$$.XXXXXX")
    local f
    local comult
    local cosub
    local bgmult
    local bgimg
    local rmsg
    local aprad
    local omove
    local ocenter
    local oxy
    local bg
    local sd
    local add
    local ext
    local m
    local a
    local id
    local bgoff=2000    # bg in result of cometsmooth
    local msg
    
    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: AIcosnap [-k] [-w RGBmult|$wbmul] [-s blurscale|$blurscale] [-m mult|$outmult] <set>" >&2 &&
        return 1

    test -f $set.pgm && ext="pgm"
    test -f $set.ppm && ext="ppm"
    test -z "$ext" &&
        echo "ERROR: missing star stack" >&2 && return 255
    
    for f in $smoothreg $coreg $bgreg
    do
        ! test -f $f &&
            echo "ERROR: missing region file $f" >&2 && return 255
    done
    ! test -f $badreg && badreg=""

    # check for required region id's in smoothreg
    regid $smoothreg > $tmp1
    for id in core inner outer
    do
        ! grep -q "^$id$" $tmp1 &&
            echo "ERROR: missing region $id in $smoothreg." >&2 && return 255
    done
    
    # cosub image, preferring comult=1
    test -f comet/$set.cosub.$ext &&
        comult=1 && cosub=comet/$set.cosub.$ext
    test -z "$cosub" && test -f comet/$set.cosub10.$ext &&
        comult=10 && cosub=comet/$set.cosub10.$ext
    test -z "$cosub" &&
        echo "ERROR: missing cosub image" >&2 && return 255
    
    # extract some header data
    rmsg=$(get_header $set.$ext AI_RMSG)
    aprad=$(get_header $set.head AI_FWHM | awk '{printf("%.1f", sqrt($3*$3+3)-0.3)}')
    omove=$(get_header $set.head AI_OMOVE)
    ocenter=$(get_header $set.head AI_CORA)" "$(get_header $set.head AI_CODEC)
    oxy=$(echo comet $ocenter | rade2xy - $set.wcs.head | awk '{printf("%.0f,%.0f", $2, $3)}')
    (test -z "$rmsg" || test -z "$aprad" || test -z "$omove" || test -z "$ocenter") &&
        echo "ERROR: some header keywords are missing." >&2 && return 255

    # determine background in cosub
    regstat $cosub $bgreg $badreg | awk '{printf("%s\n", $5)}' | tr ',' ' ' > $tmp1
    if [ $ext == "ppm" ]
	then
    	bg=$(echo $(mean $tmp1 1) $(mean $tmp1 2) $(mean $tmp1 3) | awk -v o=$bgoff -v m=$comult '{
        	printf("%.1f,%.1f,%.1f\n", o+($1-o)/m, o+($2-o)/m, o+($3-o)/m)}')
    else
    	bg=$(echo $(mean $tmp1 1) | awk -v o=$bgoff -v m=$comult '{
        	printf("%.1f\n", o+($1-o)/m)}')
    fi
    echo "# cosub=$cosub  bg=$bg  move=$omove@$oxy" >&2

    if [ -e $set.cosnap.$ext ] && [ "$keep_cosnap" ]
    then
        echo "# WARNING: reusing existing $set.cosnap.$ext" >&2
    else
        # smooth cosub image, scale to outmult and create trail
        m=$(echo $comult | awk -v s=$outmult '{print s/$1}')
        a=$(echo $comult | awk -v s=$outmult '{print 2000*(1-s/$1)}')
        msg="cometsmooth -bg $bg -b $blurscale $set $cosub $smoothreg"
        cometsmooth -bg $bg -b $blurscale $set $cosub $smoothreg | \
            pnmccdred -m $m -a $a - x.comet.$ext
        test $? -ne 0 &&
            echo "ERROR: failed command: $msg" >&2 && return 255
        
        get_jd_dmag $set > x.obs.dat
        msg="mkcotrail -o x.cotrail.$ext $set x.comet.$ext $omove@$oxy x.obs.dat $bgoff"
        mkcotrail -o x.cotrail.$ext $set x.comet.$ext $omove@$oxy x.obs.dat $bgoff
        test $? -ne 0 &&
            echo "ERROR: failed command: $msg" >&2 && return 255

        # bg gradient image, preferring model corrected image ("all") and bgmult=1
        test -f bgcorr/$set.bgm1all.$ext &&
            bgmult=1 && bgimg=bgcorr/$set.bgm1all.$ext
        test -z "$bgimg" && test -f bgcorr/$set.bgm1.$ext &&
            bgmult=1 && bgimg=bgcorr/$set.bgm1.$ext
        test -z "$bgimg" && test -f bgcorr/$set.bgm10all.$ext &&
            bgmult=10 && bgimg=bgcorr/$set.bgm10all.$ext
        test -z "$bgimg" && test -f bgcorr/$set.bgm10.$ext &&
            bgmult=10 && bgimg=bgcorr/$set.bgm10.$ext
        
        # create star image, scaled to outmult
        imbgsub -m $outmult $set.$ext $bgimg "" $bgmult | \
            pnmccdred -d x.cotrail.$ext - x.st.$ext
        #convert x.st.$ext -blur 0x1.0 x.st.blur.$ext
        
        # glue star and comet images together
        pnmccdred -a $((100-bgoff)) x.comet.$ext - | \
            pnmarith -a - x.st.$ext | \
            pnmccdred -a -100 - x.cosnap.$ext
        
        # apply white balance
        if [ $ext == "ppm" ]
        then
        	a=$(echo ${wbmul//,/ } | awk -v bg=1000 '{
            	printf("%.1f,%.1f,%.1f", bg*(1-$1), bg*(1-$2), bg*(1-$3))}')
        	pnmccdred -a $a -m $wbmul x.cosnap.$ext $set.cosnap.$ext
        else
        	ppm2gray x.cosnap.$ext > $set.cosnap.$ext
        fi
    fi
    
    
    # determine background and noise in cosnap
    regstat $set.cosnap.$ext $bgreg $badreg | tr ',' ' ' > $tmp1
    #bg=$(echo $(mean $tmp1 1) $(mean $tmp1 2) $(mean $tmp1 3) | awk -v o=$bgoff -v m=$comult '{
    #    printf("%.1f,%.1f,%.1f\n", o+($1-o)/m, o+($2-o)/m, o+($3-o)/m)}')
    bg=$(echo $(mean $tmp1 1) $(mean $tmp1 2) $(mean $tmp1 3) | awk '{
        printf("%.1f,%.1f,%.1f\n", $1, $2, $3)}')
    sd=$(mean $tmp1 5)
    echo "# cosnap bg=$bg sd=$sd" >&2

	if [ $ext == "ppm" ]
	then
    	rgbsmooth $set.cosnap.$ext $bg $sd > x.rgb.$ext
    	convert x.rgb.$ext -gamma 2.2 $set.cosnapwb.tif
    	echo "# image $set.cosnapwb.tif created" >&2
	fi
	
    rm -f $tmp1
    return
}

# multi-aperture photometry of comets
AImapphot () {
    # multi-aperture photometry of a comet in comet/$set.cosub*.$ext
    # note:
    #   do not overwrite results already present in $comet.mapphot.dat
    #   reuse object center if entry exists in center.dat
    #   large aperture photometry data must exist already
    #   extended ephemerides information (e.g. AI_CODEL) is available for
    #     processed sets starting from 180110
    # TODO: add some S/N measure
    local showhelp
    local bgvalparam
    local centerparam       # xf,yf object center in fits coordinates
    local cmethod=fit       # cometcenter method (object|maxval|fit)
    local apunit=arcsec     # unit of aperture diameters (arcsec|10^3km)
    local csize             # if set then create small checkimages and -regions
    local showimages        # if set show check images
    local basedir           # projects base dir
    local seconddir         # secondary projects base dir
    local i
    for i in $(seq 1 9)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-b" && bgvalparam="$2" && shift 2
        test "$1" == "-c" && centerparam="$2" && shift 2
        test "$1" == "-k" && apunit="tkm" && shift 1
        test "$1" == "-m" && cmethod="$2" && shift 2
        test "$1" == "-s" && csize="$2" && shift 2
        test "$1" == "-i" && showimages=1 && shift 1
        test "$1" == "-d" && basedir="$2" && shift 2
        test "$1" == "-dd" && seconddir="$2" && shift 2
    done
    #local dir=$1
    #local set=$2
    local comet=$1          # short comet name
    local aplist=$2         # apertures (diameter) in arcsec or 10^3km, separated by comma
    local first=${3:-""}    # start date YYMMDD
    local last=${4:-""}     # end date YYMMDD
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpobs=$(mktemp "$tdir/tmp_obs_$$.XXXXXX.dat")
    local tmpim1=$(mktemp "$tdir/tmp_im1_$$.XXXXXX.pnm")
    local tmpim2=$(mktemp "$tdir/tmp_im2_$$.XXXXXX.pnm")
    local tmpdat1=$(mktemp "$tdir/tmp_data1_$$.XXXXXX.dat")
    local catlist=$(mktemp "$tdir/tmp_cat_$$.XXXXXX.dat")
    local apregdir=$(mktemp -d "$tdir/tmp_apreg_$$.XXXXXX")
    local centerdat="center.dat"    # output file to store result from cometcenter
    local chkdir="chkctr"           # directory of checkimages (created by cometcenter)
    local mapdat="$comet.mapphot.dat" # output mapphot data file, new results are appended
    local icqdat="$comet.mapphot.icq" # output icq data file, always overwritten
    local adir
    local dir
    local set
    local hdr
    local ext
    local str
    local b
    local f
    local cosub
    local coreg
    local cobad
    local apreg # apertures in small checkimages
    local pscale
    local mult
    local mjd
    local ut
    local object
    local texp
    local nexp
    local magzero
    local fwhm
    local rmsg
    local dia
    #local papcorr
    #local pcref
    #local paref
    local shrink
    local mbox
    local cfwhm
    local c
    local dmag
    local dasec # aperture diameter in arcsec
    local rpix  # aperture radius in pix
    local bgval
    local line
    local mag
    local aidx
    local xlist
    local pcol
    local pcat
    local prio
    local center
    local chklist
    local apchklist
    local hline
    local x
    local h
    local dist
    local copts
    local val

    
    (test "$showhelp" || test $# -lt 2) &&
        echo "usage: AImapphot [-d basedir] [-m center_method|$cmethod] [-s checkimg_size] [-c xfits,yfits] [-b bgval] [-k] <comet> <aplist> <firstdate> <lastdate>" >&2 &&
        return 1

    # project base directory
    test -z $basedir && basedir=$(dirname $(pwd))

    # determine list of observations
    if [ "$seconddir" ]
    then
        AIlist -d $basedir -d $seconddir $comet "$first" "$last" > $tmpobs
    else
        AIlist -d $basedir $comet "$first" "$last" > $tmpobs
    fi
    if ! grep -q -v "^#" $tmpobs
    then
        echo "WARNING: no data to be processed." >&2
        test ! -s $mapdat && return 255
        echo "WARNING: using previously processed data instead." >&2
    else
        echo "# $(grep -v "^#" $tmpobs | wc -l) observations"
    fi
    
    while read dir set x ut x
    do
        test "${dir:0:1}" == "#" && continue
        adir=""
        test -f $basedir/$dir/comet/$set.comet.reg && adir=$basedir
        test -z "$adir" && adir=$seconddir
        if [ -s $mapdat ] && grep -q "^$dir [ ]*$set " $mapdat
        then
            # TODO: check if all apertures have been measured already
            #   dkm=$5, dasec=$6
            echo "# WARNING: $dir  $set already processed" >&2
            continue
        fi
        echo "# $dir  $set" >&2

        hdr=$adir/$dir/$set.head
        test ! -f $hdr && echo "ERROR: missing $hdr." >&2 && return 255

        apreg=$apregdir/$dir.${set}_m.ap.reg
        
        # get cosub image and image extension
        b=$(basename $hdr)
        cosub=""
        for ext in ppm pgm
        do
            f=$(dirname $hdr)/comet/${b%.*}.cosub10.$ext
            test -f $f && cosub=$f && mult=10 && break
            f=$(dirname $hdr)/comet/${b%.*}.cosub1.$ext
            test -f $f && cosub=$f && mult=1 && break
            f=$(dirname $hdr)/comet/${b%.*}.cosub.$ext
            test -f $f && cosub=$f && mult=1 && break
        done
        test -z "$cosub" && echo "ERROR: no cosub image found." >&2 && return 255
        
        # get coregion file
        coreg=""
        f=$(dirname $hdr)/comet/${b%.*}.comet.reg
        test -f $f && coreg=$f
        test -z "$coreg" && f=$(dirname $hdr)/comet/${b%.*}.cometin.reg &&
            test -f $f && coreg=$f
        test -z "$coreg" && echo "ERROR: no coreg file found." >&2 && return 255

        # get cobad region
        cobad=""
        f=$(dirname $hdr)/comet/${b%.*}.bad.reg
        test -f $f && cobad=$f

        # determine pixelscale
        f=$(dirname $hdr)/${b%.*}.wcs.head
        test ! -f $f && echo "ERROR: wcs header file is missing." >&2 && return 255
        pscale=$(get_wcspscale $f)
        
        # get required keywords from header file
        jd=$(get_header -q $hdr JD)
        test -z "$jd" && jd=$(get_header -q $hdr MJD_OBS)
        test -z "$jd" && echo "ERROR: missing keyword JD or MJD_REF." >&2 && continue
        ut=$(jd2ut -p 2 $jd)
        set - $(get_header -s $hdr OBJECT,EXPTIME,NEXP,AI_FWHM) x
        test $# -ne 5 && echo "ERROR: missing keyword(s)." >&2 && return 255
        object=$1
        texp=$2
        nexp=$3
        fwhm=$4
        
        # get distance from earth
        dist=$(get_header -q $hdr AI_CODEL)
        test -z "$dist" && dist=0
        # TODO: get earth distance from ephemerides
        if [ "$apunit" == "tkm" ] && [ "$dist" == "0" ]
        then
            echo "# WARNING: missing earth distance (AI_CODEL)." >&2
            echo "#    Trying to fetch data using MPC web query." >&2
            get_mpcephem $object $ut > $tmpdat1
            set - $(grep -v "^#" $tmpdat1 | sed -e 's|/.*||' | lines 1) xx
            (test $# -lt 23 || test $# -gt 26) &&
                echo "ERROR: get_mpcephem returned wrong number of values ($#)." >&2 &&
                echo $tmpdat1 >&2 &&
                return 255

            shift 4
            dist=$7
            echo "# using dist=$dist" >&2
        fi
        
        # get index of comet aperture measurements in G color band
        # using catalog with highest priority
        xlist=$(get_header $hdr all | grep "^AP_AIDX[1-9]=" | cut -c8 | sort -nu)
        for x in $xlist
        do
            i=$(get_header $hdr AP_AIDX$x)
            test "$(get_header $hdr AC_ICOL$i)" != "G" && continue
            aidx=$(get_header -q $hdr AP_AIDX$x); test -z "$aidx" && aidx="-"
            pcol=$(get_header -q $hdr AP_PCOL$x); test -z "$pcol" && pcol="-"
            pcat=$(get_header -q $hdr AP_PCAT$x); test -z "$pcat" && pcat="-"
            # choose priority from order in refcat.dat (first=highest)
            prio=$(grep -nw "^$pcat" refcat.dat | cut -d ":" -f1)
            echo $prio $x $pcat
        done | sort -n -k1,1 > $catlist
        aidx=$(lines 1 $catlist | cut -d ' ' -f2)
        rm -f $catlist
        test -z "$aidx" && echo "ERROR: missing measurements in G color band." >&2 && return 255

        # get comet aperture diameter (in pix)
        dia=$(get_header -q -s $hdr AC_DIAM$aidx)
        test -z "$dia" && echo "ERROR: missing keyword(s) AC_DIAM$aidx." >&2 && return 255
        # get comet background (old: AI_CBG)
        bgval="$bgvalparam"
        test -z "$bgval" && bgval=$(get_header $hdr AC_BCKG$aidx)
        test -z "$bgval" && echo "ERROR: missing keyword AC_BCKG$aidx." >&2 && return 255
        texp=$(echo $texp $nexp | awk '{printf $1/$2}')
        echo "# $(basename $cosub) $(basename $coreg) d=$dia bg=$bgval texp=$texp pscale=$pscale" >&2
        # get magzero (1ADU,1s) corrected for large aperture
        magzero=$(get_header -s $hdr AP_MZER$aidx)
        test -z "$magzero" && echo "ERROR: missing keyword." >&2 && return 255

        # correct magzero and background according to intensity multiplier
        magzero=$(echo $magzero $(di2dmag $mult) | awk '{printf("%.2f", $1-$2)}')
        bgval=$(echo $bgval $mult | awk '{x=($1-2000)*$2+2000; printf("%.2f", x)}')
        echo "# intensity_mult=$mult  corr_magzero=$magzero  corr_bg=$bgval" >&2
        
        
        # image preparation: extract green channel, apply $coreg and $cobad
        if is_ppm $cosub
        then
            gm convert $cosub -channel Green pgm:- > $tmpim1
        else
            cp $cosub $tmpim1
        fi
        test "$cobad" &&
            reg2pbm $cosub $cobad | pnminvert | pnmarith -m $tmpim1 - 2>/dev/null > $tmpim2 &&
            mv $tmpim2 $tmpim1


        # determine aperture center using cosub image
        # note: cometcenter does smoothing and converts to pgm using ppm2gray
        #   it limits sources to the comet region
        center="$centerparam"
        if [ -z "$center" ]
        then
            line=""
            test -s $centerdat && line=$(grep -E "^$dir [ ]*$set " $centerdat)
            if [ "$line" ]
            then
                echo "# reusing center position from $centerdat"
            else
                test "$csize" && copts="-s $csize"
                test $AI_DEBUG && echo "# cometcenter $copts -m $cmethod $adir/$dir $set $cosub" >&2
                line=$(cometcenter $copts -m $cmethod $adir/$dir $set $cosub)
                test $? -ne 0 && echo "ERROR: cometcenter failed." >&2 && return 255
                str="# dir     set    object   xfits   yfits    met blu frad mag"
                #    210720    co01   2020V2   4013.99 2318.67  fit 0.6  2.7 14.8
                test -s $centerdat || echo "$str" > $centerdat
                echo "$line" >> $centerdat
            fi
            # get center FITS coordinates
            set - $line
            center="$4,$5"
        fi
        test -z "$center" && echo "ERROR: center undefined" >&2 && return 255
        test -s $chkdir/$dir.${set}_m.c.$ext && test -s $chkdir/$dir.${set}_m.c.reg &&
            chklist="$chklist $chkdir/$dir.${set}_m.c.$ext $chkdir/$dir.${set}_m.c.reg"
        
        
        # do aperture photometry
        test -e $apreg && rm $apreg
        xycenter=$(echo "circle($center,5)" | reg2xy $cosub - | \
            awk '{printf("%.1f,%.1f", $2, $3)}')
        hline="# dir    set    jd          fcenter         d/km  d/\" mag   npx bg      mzero"
        #      .        co01a  2457964.371 2762.0,1662.2 100000 1200 16.38  77 2006.80 23.76
        
        echo "$hline"
        # conversion to image pixel coordinates
        for val in ${aplist//,/ }
        do
            if [ "$apunit" == "tkm" ]
            then
                dkm=$((val*1000))
                dasec=$(echo $dkm $dist | awk '{
                    au=149597871
                    pi=4*atan2(1,1)
                    x=atan2($1,$2*au)*180*3600/pi
                    printf("%.2f", x)}')
            else
                dasec=$val
                dkm=$(echo $dasec $dist | awk '{
                    au=149597871
                    pi=4*atan2(1,1)
                    x=$2*au*sin($1/3600*pi/180)
                    printf("%.0f", x)}')
            fi
            # TODO: skip aperture photometry if it has been measured already

            rpix=$(echo $dasec $pscale | awk '{printf("%.2f", $1/2/$2)}')
            test "$AI_DEBUG" &&
                echo "# aphot -b $bgval -t $texp -m $magzero $tmpim1 $xycenter $rpix" >&2
            line=$(aphot -z -b $bgval -t $texp -m $magzero $tmpim1 $xycenter $rpix)
            set - $line
            if [ "${line:0:1}" == "#" ]
            then
                echo "# WARNING: intensity is below background" >&2
                mag=$5; npx=$7
                printf "# "
            else
                mag=$4; npx=$6
            fi
            test -s $mapdat || echo "$hline" > $mapdat
            printf "%-8s %-6s %11.3f %9s" \
                $(basename $(dirname $hdr)) ${b%.*} $jd $center | tee -a $mapdat
            printf " %6d %4.0f %5.2f %3.0f %s %s\n" \
                $dkm $dasec $mag $npx $bgval $magzero | tee -a $mapdat
            
            if [ "$csize" ] && [ -s $chkdir/$dir.${set}_m.c.reg ]
            then
                x=$(grep "^point" $chkdir/$dir.${set}_m.c.reg | tr '()' ' ' | cut -d ' ' -f2)
                test ! -e $apreg &&
                    echo "# Region file format: DS9 version 4.1
global color=green dashlist=8 3 width=1 font=\"helvetica 10 normal roman\" \
select=1 highlite=1 dash=0 fixed=0 edit=1 move=1 delete=1 include=1 source=1
physical" > $apreg
                echo "circle(${x},$rpix) # text={$val $apunit}" >> $apreg
            fi
        done
        test -s $chkdir/$dir.${set}_m.cb.$ext && test -s $apreg &&
            apchklist="$apchklist $chkdir/$dir.${set}_m.cb.$ext $apreg"
    done < $tmpobs

    # show check images
    if [ "$csize" ] && [ "$showimages" ]
    then
        test "$chklist"   && AIexamine -n "CometCenters" -p "-tile -zoom 2" $chklist &
        test "$apchklist" && AIexamine -n "Apertures"    -p "-tile -zoom 2" $apchklist &
    fi
    
    # show (simple) light curve
    grep -v "^#" $mapdat | while read x x jd x dkm dasec mag x
    do
        ut=$(jd2ut -p 2 $jd)
        x=$(echo $dasec | awk '{print $1/60}')
        LANG=C printf "%s%s  Z %5.2fAQ 99.9L 50999  %4.1f" "$(comet2icq $comet)" "${ut//-/ }" $mag $x
        LANG=C printf "                      %s\n" $((dkm/1000))
    done | LANG=C sort > $icqdat
    x=$(echo ${aplist//,/ } | wc -w)
    i=$(echo ${aplist//,/ } | tr ' ' '\n' | sort -n | awk -v x=$x 'BEGIN{y=1+int(x/2-0.1)}
        {if(NR==y) print $1}')
    x=$(echo ${aplist//,/ } | tr ' ' ',')
    t="$comet - MApPhot ($x arcsec)"
    test "$apunit" == "tkm" && t="$comet - MApPhot ($x x10^3km)"
    icqplot -o $comet.mapphot.png -t "$t" -ff -i $i $comet $icqdat mag
    echo "# AImapphot data file:   $mapdat"
    echo "# created ICQ data file: $icqdat"
    
    if [ "$AI_DEBUG" ]
    then
        echo "# obs:     $tmpobs" >&2
        echo "# image:   $tmpim1" >&2
        echo "# sources: $tmpdat1" >&2
    else
        rm -f $tmpobs $tmpim1 $tmpdat1
    fi
    rm -f $tmpim2
    echo $apregdir >&2
    return
}


AIastrometry () {
    # astrometry of comets (using comet/$set.cosub*.$ext)
    # note: center positions in center.dat are reused
    #   per set mpc report files are overwritten
    #   always use sites.dat from current project
    local showhelp
    local cmethod=fit       # cometcenter method (object|maxval|fit)
    local csize=300         # if set then create small checkimages and -regions
    local showimages        # if set show check images
    local adirlist          # list of base directories containing
                            #   Airtools projects
    local is_splitted       # process stacks in directory splitdir of current project
    local do_all_mpc        # if set combine all measurements in mpc report
    local obscode=${AI_OBSCODE:-""} # MPC observatory code
    local author=${AI_OBSNAME:-"My Full Name"}
    local address=${AI_OBSADDRESS:-"My Street, My Country"}
    local email=${AI_OBSEMAIL:-"mymail@xxx"}
    local i
    for i in $(seq 1 10)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-d" && adirlist="$adirlist $2" && shift 2
        test "$1" == "-cs" && is_splitted=1 && shift 1
        test "$1" == "-m" && cmethod="$2" && shift 2
        test "$1" == "-s" && csize="$2" && shift 2
        test "$1" == "-i" && showimages=1 && shift 1
        test "$1" == "-a" && do_all_mpc=1 && shift 1
        test "$1" == "-o" && author=$2 && shift 2
        test "$1" == "-p" && address=$2 && shift 2
        test "$1" == "-e" && email=$2 && shift 2
        test "$1" == "-c" && obscode=$2 && shift 2
    done
    local comet=$1          # short comet name or image set or "all" (all sets in curr. project)
    local first=${2:-""}    # start date YYMMDD
    local last=${3:-""}     # end date YYMMDD
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpobs=$(mktemp "$tdir/tmp_obs_$$.XXXXXX.dat")
    local sitesdat="sites.dat"
    local centerdat="center.dat"  # output file to store result from cometcenter
    local chkdir="chkctr"   # directory of checkimages (filled by cometcenter)
    local mpcdir="mpc"        # output directory of mpcreports
    local mpcdat            # output mpcreport data file (one per set)
    local splitdir="split"  # directory containing stacks of splitted image sets
    local lopts
    local odir
    local nobs
    local adir
    local dir
    local set
    local ut
    local mag
    local tel
    local hdr
    local ext
    local str
    local b
    local f
    local flist
    local cosub
    local coreg
    local cobad
    local mult
    local copts
    local xfits
    local yfits
    local aidx
    local xlist
    local pcol
    local pcat
    local prio
    local texp
    local bgval
    local nexp
    local magzero
    #local pscale
    local xycenter
    local dasec # aperture diameter in arcsec
    local rpix  # aperture radius in pix
    local line
    local mopts
    local mpclist
    local chklist
    local x

    
    (test "$showhelp" || test $# -lt 1) &&
        echo "usage: AIastrometry [-a] [-d basedir] [-m center_method|$cmethod] [-s checkimg_size|$csize]" \
            "[-o observername|$author] [-p address|$address] [-e email|$email] [-c obscode]" \
            "<cometname_or_imageset> <firstdate> <lastdate>" >&2 &&
        return 1

    # test if operating on single image set
    test -z "$is_splitted" && test -z "$adirlist" && lopts="-c" &&
        is_setname $comet && set=$comet && comet=""
    test "$is_splitted" && lopts="-cs" && adirlist="." &&
        (cd $splitdir && is_setname $comet) && set=$comet && comet=""

    # determine list of observations
    if [ "$comet" ]
    then
        if [ "$comet" == "all" ]
        then
            # all image sets in current project
            comet=""
            AIlist $lopts > $tmpobs
        else
            # search by comet name
            test -z "$adirlist" &&
                echo "ERROR: empty base directory of projects" >&2 && return 255
            AIlist $lopts -d $(echo $adirlist | sed 's, , -d ,g') "$comet" "$first" "$last" > $tmpobs
        fi
    else
        # single image set of current project
        AIlist $lopts | awk -v s=$set '{if($2==s) print $0}' > $tmpobs
    fi
    if ! grep -q -v "^#" $tmpobs
    then
        echo "WARNING: no data to be processed." >&2
        return
        #test ! -s $mpcdat && return 255
        #echo "WARNING: using previously processed data instead." >&2
    else
        nobs=$(grep -v "^#" $tmpobs | wc -l)
        test -z "$set" && echo "# $nobs observations"
    fi

    # create output directory for individual mpc reports
    odir=$mpcdir
    test "$comet" && odir="$mpcdir/$comet"
    test ! -d $odir && mkdir -p $odir
    test ! -d $odir && return 255
    
    while read dir set x ut mag x x x x tel x
    do
        test "${dir:0:1}" == "#" && continue
        test "$is_splitted" && dir=$(basename $(pwd))/$splitdir
        test -z "$tel" && continue
        adir=""
        if [ "$comet" ]
        then
            for str in $adirlist
            do
                test -f $str/$dir/comet/$set.comet.reg && adir=$str
                test "$adir" && break
            done
        else
            test -z "$is_splitted" && test -f comet/$set.comet.reg && adir=".."
            test    "$is_splitted" && test -f $splitdir/comet/$set.comet.reg && adir=".."
        fi
        test -z "$adir" && test $nobs -eq 1 &&
            echo "ERROR: $dir/comet/$set.comet.reg not found" >&2 && return 255
        test -z "$adir" &&
            echo "WARNING: skipping $set, $dir/comet/$set.comet.reg not found" >&2 && continue
        
        # TODO: check already processed set
        #test -s $mpcdat && grep -q "^$dir [ ]*$set " $mpcdat &&
        #    echo "# WARNING: $dir  $set already processed" >&2 && continue
        echo "" >&2
        echo "# $dir  $set" >&2

        hdr=$adir/$dir/$set.head
        test ! -f $hdr && echo "ERROR: missing $hdr." >&2 && return 255

        mpcdat=$odir/${dir%%/*}.$set.mpc.dat
        cosub=""

        line=""
        test -s $centerdat && line=$(grep -E "^${dir%%/*} [ ]*$set " $centerdat)
        if [ "$line" ]
        then
            echo "# reusing center position from $centerdat"
            ext=""
            test -z "$ext" && test -f $chkdir/${dir%%/*}.${set}_m.c.ppm && ext="ppm"
            test -z "$ext" && test -f $chkdir/${dir%%/*}.${set}_m.c.pgm && ext="pgm"
        else
            # get cosub image and image extension
            for ext in ppm pgm
            do
                f=$(dirname $hdr)/comet/$set.cosub10.$ext
                test -f $f && cosub=$f && mult=10 && break
                f=$(dirname $hdr)/comet/$set.cosub1.$ext
                test -f $f && cosub=$f && mult=1 && break
                f=$(dirname $hdr)/comet/$set.cosub.$ext
                test -f $f && cosub=$f && mult=1 && break
            done
            if [ -z "$cosub" ]
            then
                # get costack
                for ext in ppm pgm
                do
                    f=$(dirname $hdr)/${set}_m.$ext
                    test -f $f && cosub=$f && mult=1 && break
                done
                test "$cosub" && echo "WARNING: using costack instead of cosub image" >&2
            fi
            test -z "$cosub" && echo "ERROR: no cosub image found." >&2 && return 255
            
            # determine aperture center using cosub image
            # note: cometcenter does smoothing and converts to pgm using ppm2gray
            test "$csize" && copts="-s $csize"
            test $AI_DEBUG &&
                echo "# cometcenter $copts -m $cmethod $adir/$dir $set $cosub" >&2
            line=$(cometcenter $copts -m $cmethod $adir/$dir $set $cosub)
            test $? -ne 0 && echo "ERROR: cometcenter failed." >&2 && return 255
            
            # rename checkimages in case of splitted sets
            if [ "$is_splitted" ] && [ "$csize" ]
            then
                # file names are starting with $splitdir instead of ${dir%%/*}
                flist=$(ls $chkdir/$splitdir.${set}_m.c* 2>/dev/null)
                test "$flist" && for f in $flist
                do
                    str=$(echo $f | sed -s 's,/'$splitdir'\.,/'${dir%%/*}'\.,')
                    #echo "# mv $f \"$str\"" >&2
                    mv $f "$str"
                done
            fi
            
            # output results to $centerdat
            str="# dir     set    object   xfits   yfits    met blu frad mag"
            #    210720    co01   2020V2   4013.99 2318.67  fit 0.6  2.7 14.8
            test -s $centerdat || echo "$str" > $centerdat
            str=$(printf "%s" "${dir%%/*}")
            echo "$line" | sed -s 's,^'"$splitdir "','"$str "',' >> $centerdat
        fi
        # get center FITS coordinates
        set - $line
        xfits=$4
        yfits=$5
        x=$chkdir/${dir%%/*}.${set}_m.c
        test -s $x.$ext && test -s $x.reg && chklist="$chklist $x.$ext $x.reg"
        
        # use total mag (from output of AIlist) or measure nuclear mag in cosub
        mopts=""
        if [ "$mag" ] && [ "$mag" != "-" ]
        then
            mopts="-m1 $mag"
        else
            if [ -z "$cosub" ]
            then
                # get cosub image and image extension
                for ext in ppm pgm
                do
                    f=$(dirname $hdr)/comet/$set.cosub10.$ext
                    test -f $f && cosub=$f && mult=10 && break
                    f=$(dirname $hdr)/comet/$set.cosub1.$ext
                    test -f $f && cosub=$f && mult=1 && break
                    f=$(dirname $hdr)/comet/$set.cosub.$ext
                    test -f $f && cosub=$f && mult=1 && break
                done
            fi
            if [ -z "$cosub" ]
            then
                # get costack
                for ext in ppm pgm
                do
                    f=$(dirname $hdr)/${set}_m.$ext
                    test -f $f && cosub=$f && mult=1 && break
                done
                test "$cosub" && echo "WARNING: using costack instead of cosub image" >&2
            fi
            test -z "$cosub" && echo "ERROR: no cosub image found." >&2 && return 255
            
            # using catalog with highest priority
            xlist=$(get_header $hdr all | grep "^AP_AIDX[1-9]=" | cut -c8 | sort -nu)
            if [ "$xlist" ]
            then
                aidx=$(for x in $xlist
                do
                    i=$(get_header $hdr AP_AIDX$x)
                    test "$(get_header $hdr AC_ICOL$i)" != "G" && continue
                    aidx=$(get_header -q $hdr AP_AIDX$x); test -z "$aidx" && aidx="-"
                    pcol=$(get_header -q $hdr AP_PCOL$x); test -z "$pcol" && pcol="-"
                    pcat=$(get_header -q $hdr AP_PCAT$x); test -z "$pcat" && pcat="-"
                    # choose priority from order in refcat.dat (first=highest)
                    prio=$(grep -nw "^$pcat" refcat.dat | cut -d ":" -f1)
                    echo $prio $x $pcat
                done | sort -n -k1,1 | lines 1 | cut -d ' ' -f2)
                test -z "$aidx" && echo "ERROR: missing measurements in G color band." >&2 && return 255
            else
                # get texp pscale magzero from image set
                texp=$(get_header -s $hdr EXPTIME,NEXP | tr '\n' ' ' | \
                    awk '{printf("%.1f", $1/$2)}')
                #bgval=2000
                pscale=$(get_wcspscale ${hdr/.head/.wcs.head})
                # TODO: determine aperture photometry index
                pidx=1
                magzero=$(get_header -q -s $hdr AP_MZER$pidx)
                if [ "$is_splitted" ]
                then
                    x=$(get_header -q -s $hdr SPLITREF)
                    test "$x" && magzero=$(get_header -q -s $x.head AP_MZER$pidx)
                fi
                test -z "$magzero" &&
                    magzero=20 &&
                    echo "WARNING: unknown mag zeropoint, using magzero=20." >&1
                
                # do m2 aperture photometry on cosub image
                xycenter=$(echo "circle($xfits,$yfits,5)" | reg2xy $cosub - | \
                    awk '{printf("%.1f,%.1f", $2, $3)}')
                dasec=11
                rpix=$(echo $dasec $pscale | awk '{printf("%.2f", $1/2/$2)}')
                #test "$AI_DEBUG" &&
                echo "# aphot -t $texp -m $magzero $cosub $xycenter $rpix" >&2
                line=$(aphot -z -t $texp -m $magzero $cosub $xycenter $rpix)
                set - $line
                if [ "${line:0:1}" == "#" ]
                then
                    echo "# WARNING: intensity is below background" >&2
                    mag=$5; npx=$7
                else
                    mag=$4; npx=$6
                    mopts="-m2 $mag"
                    echo "# nuclear mag m2=$mag (npx=$npx)" >&2
                fi
            fi
        fi
        
        # write MPCReport
        test "$author"  && mopts="$mopts -a \"$author\""
        test "$address" && mopts="$mopts -p \"$address\""
        test "$email"   && mopts="$mopts -e \"$email\""
        test "$obscode" && mopts="$mopts -c $obscode"
        mopts="$mopts -s $(realpath $sitesdat)"
        (cd $adir/$dir
        test "$AI_DEBUG" &&
            echo "# mpcreport $mopts $set $xfits $yfits" >&2
        eval mpcreport $mopts $set $xfits $yfits) | tee $mpcdat
        mpclist="$mpclist $mpcdat"
    done < $tmpobs

    # show check images created by cometcenter
    #echo "chklist=$chklist" >&2
    if [ "$csize" ] && [ "$showimages" ] && [ "$chklist" ]
    then
        AIexamine -n "CometCenters" -p "-tile -zoom 2" $chklist &
    fi
    
    test "$do_all_mpc" &&
        mpclist=$(ls $mpcdir/*.mpc.dat $mpcdir/*/*.mpc.dat 2>/dev/null)
    if [ "$mpclist" ]
    then
        mpcsort $mpclist > mpcreport.txt
        echo ""
        echo "# results written to MPC report file:   mpcreport.txt" >&2
        if [ "$do_all_mpc" ] || [ $(echo $mpclist | wc -w) -gt 1 ]
        then
            test -s mpcreport.txt && mousepad mpcreport.txt 2>/dev/null &
        fi
    fi
    if [ "$AI_DEBUG" ]
    then
        echo "# obs:     $tmpobs" >&2
    else
        rm -f $tmpobs
    fi
    return
}


# determine noise per pixel for a given set of DSLR images
# normalization is done by image scaling (factor) against average image
# output images: $sname.{mn,sd}.$ext
AInoise () {
    AIcheck_ok -r || return 255
    local showhelp
    local do_bayer          # if set then keep bayer matrix and create gray
                            # output image instead of rgb
    local do_subtract       # do subtraction of mean instead of division
    local i
    for i in 1 2 3
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-b" && do_bayer=1 && shift 1
        test "$1" == "-s" && do_subtract=1 && shift 1
    done

    local setname=${1:-""}
    local intype=${2:-""}
    local dark=${3:-""}     # pgm file
    #local flat=${4:-""}     # ppm file
    #local do_bgscale=${5:-""}  # change bg corr. from offset to scale factor
    local rdir=${AI_RAWDIR:-"."}
    #local bad=${AI_BADPIX:-""}
    local sdat=${AI_SETS:-"set.dat"}
    local ccdregion=${AI_CCDREGION:-""}  # w h xoff yoff
    local tdir=${AI_TMPDIR:-"/tmp"}
    local imlist=$(mktemp "$tdir/tmp_imlist_XXXXXX.dat")
    local wdir=$(mktemp -d "$tdir/tmp_noise_XXXXXX")
    local sname
    local type
    local texp
    local n1
    local n2
    local nref
    local num
    local fname
    #local opts
    local ext
    local ilist
    local mxx
    local mrgb
    local is_dark_subtracted
    local dcrawopts
    local scale
    local flip
    local opts
    local tmpsh=$(mktemp "/tmp/tmp_script_XXXXXX.sh")
    chmod u+x $tmpsh
    
    test "$showhelp" &&
        echo "usage: AInoise [-b] [-s] [set] [intype] [dark]" >&2 &&
        return 1

    # check for presence of dark frame if requested
    test "$dark" && test ! -f "$dark" &&
        echo "ERROR: dark image $dark not found." && return

    while read ltime sname target type texp n1 n2 nref x x x
    do
        (echo "$ltime" | grep -q "^#") && continue
        test "$setname" && test "$setname" != "$sname" && continue
        test -z "$setname" && test "$intype" && test "$type" != "$intype" && continue
        test "$type" == "a" && continue
        (! is_integer "$n1" || ! is_integer "$n2") && continue
        
        # check if output file exists
        ext="ppm"
        (test "$do_bayer" || test "$type" == "d") && ext="pgm"
        test -f $sname.mn.$ext &&
            echo "WARNING: output image $sname.mn.$ext exists, skipping set $sname." >&2 && continue
        test -f $sname.sd.$ext &&
            echo "WARNING: output image $sname.sd.$ext exists, skipping set $sname." >&2 && continue

        is_dark_subtracted=""
        test "$(AIsetinfo $sname | awk '{print $11}')" == "0" &&
            is_dark_subtracted=1 &&
            echo "$sname: in-camera dark subtraction assumed."
        
        # need at least 3 images
        AIimlist $sname "" raw > $imlist
        n=$(cat $imlist | wc -l)
        test $n -lt 3 && echo "ERROR: set $sname has too few images ($n < 3)." &&
            rm $imlist && continue
        echo "processing $n images in set $sname ..."
        
        dcrawopts=""
        is_gacam_raw $(head -1 $imlist | cut -d ' ' -f3) && test "$ccdregion" &&
            dcrawopts="-R $ccdregion"

        # determine intensity scaling factor to stretch to full 16bit range
        # this is used by AIraw2gray in case of FITS images only
        scale=$(get_param camera.dat rawbits $sname | awk '{if ($1!="-" && $1<16) print 2^(16-$1)}')

        # check if top-down image flipping is required
        flip=$(get_param camera.dat flip $sname | awk '{if ($1=="1") print 1}')
        
        # options for raw image conversion
        opts=""
        test "$scale" && opts="-s $scale"
        test "$flip"  && opts=$(echo $opts "-f")

        # ccd reduction (with optional dark subtraction)
        # TODO: deal with in-camera dark subtracted images
        echo "ccd reduction ..."
        ilist=""
        while read x num fname x
        do
            if [ "$do_bayer" ] || [ "$type" == "d" ]
            then
                if [ -s $tdir/$num.$ext ]
                then
                	ln -s $tdir/$num.$ext $wdir/$num.$ext
                else
                	AI_DCRAWPARAM="$dcrawopts $AI_DCRAWPARAM" \
                	AIraw2gray $opts $fname $wdir/$num.$ext $dark
                fi
            else
           		echo "  $num"
                AI_DCRAWPARAM="$dcrawopts $AI_DCRAWPARAM" \
                AIraw2rgb  $opts $fname $dark > $wdir/$num.$ext
            fi
            ilist="$ilist $wdir/$num.$ext"
        done < $imlist
        
        # get image dimensions
        num=$(head -1 $imlist | awk '{printf("%s", $2)}')
        w=$(identify $wdir/$num.$ext | cut -d " " -f3 | cut -d "x" -f1)
        h=$(identify $wdir/$num.$ext | cut -d " " -f3 | cut -d "x" -f2)

        # create average image, used as base for individual scaling
        echo "average images ..."
        pnmcombine2 $ilist $sname.mn.$ext
        
        # statistics for average image
        if [ $do_bayer ] || [ "$type" == "d" ]
        then
            mxx=$(AImstat -b -c $sname.mn.$ext | awk '{
                printf("%.0f %.0f %.0f %.0f", $5, $9, $13, $17)}')
            echo "  mean mxx = $mxx"
        else
            mrgb=$(AImstat -c $sname.mn.$ext | awk '{
                printf("%.0f %.0f %.0f", $5, $9, $13)}')
            echo "  mean rgb = $mrgb"
        fi

        # normalize images (in-place)
        echo "normalize images ..."

		cat <<EOF > $tmpsh
#!/bin/bash
. airfun.sh > /dev/null 2>/dev/null
tdir=$tdir
wdir=$wdir
ext=$ext
type=$type
do_bayer="$do_bayer"
do_subtract="$do_subtract"
w=$w
h=$h
mxx="$mxx"
mrgb="$mrgb"
set +x

_ainoise_parallel \$@
EOF

        _ainoise_parallel () {
            local num=$2
            local xx
            local tmpim=$(mktemp "$tdir/tmp_im1_XXXXXX.pnm")
            
            if [ "$do_bayer" ] || [ "$type" == "d" ]
            then
                set - $(AImstat -b -c $wdir/$num.$ext | awk '{
                    printf("%.0f %.0f %.0f %.0f", $5, $9, $13, $17)}')

                if [ "$do_subtract" ]
                then
                    xx=$(echo $mxx $1 $2 $3 $4 | awk '{
                        printf("%3.0f %3.0f %3.0f %3.0f\n", $1-$5, $2-$6, $3-$7, $4-$8)}')
                    test "$AI_DEBUG" && echo "$num: $xx"
                    xx=$(echo $mxx $1 $2 $3 $4 | awk -v l=10000 '{
                        printf("%.0f %.0f %.0f %.0f\n",
                            l+$5-$1, l+$6-$2, l+$7-$3, l+$8-$4)}')
                    # note pnmccdred2 does not work under parallel with pipes
                    echo -e "P2\n2 2\n65535\n$xx" | pnmtile $w $h - | \
                        pnmccdred -a 20000 -d - $wdir/$num.$ext $tmpim &&
                        mv $tmpim $wdir/$num.$ext
                else
                    xx=$(echo $mxx $1 $2 $3 $4 | awk '{
                        printf("%.4f %.4f %.4f %.4f\n", $1/$5, $2/$6, $3/$7, $4/$8)}')
                    test "$AI_DEBUG" && echo "$num: $xx"
                    xx=$(echo $mxx $1 $2 $3 $4 | awk -v l=20000 '{
                        printf("%.0f %.0f %.0f %.0f\n",
                            l*$5/$1, l*$6/$2, l*$7/$3, l*$8/$4)}')
                    # note pnmccdred2 does not work under parallel with pipes
                    echo -e "P2\n2 2\n65535\n$xx" | pnmtile $w $h - | \
                        pnmccdred -m 20000 -s - $wdir/$num.$ext $tmpim &&
                        mv $tmpim $wdir/$num.$ext
                fi
            else
                set - $(AImstat -c $wdir/$num.$ext | awk '{
                    printf("%.0f %.0f %.0f", $5, $9, $13)}')
                xx=$(echo $mrgb $1 $2 $3 | awk '{
                    printf("%.4f %.4f %.4f\n", $1/$4, $2/$5, $3/$6)}')
                test "$AI_DEBUG" && echo "  $num: $xx"
                pnmccdred2 -m ${xx// /,} $wdir/$num.$ext $tmpim &&
                    mv $tmpim $wdir/$num.$ext
            fi
            rm -f $tmpim
        }
        
        export -f _ainoise_parallel
        popts=""; test "$AI_MAXPROCS" && popts="-P $AI_MAXPROCS"
        cat $imlist | parallel $popts -k $tmpsh
        unset -f _ainoise_parallel
		# TODO: error handling

        # stddev
        pnmcombine2 -s $ilist $sname.sd.$ext
        
        # clean up
        rm -f $ilist
    done < $sdat
    rmdir $wdir
    rm -f $imlist
}


AIbadpix () {
    # find badpixel by analyzing local deviation in a flat field image
    # note: superseeded by AIfindbad which also works for darks or lights
    local showhelp
    local thres=40
    local i
    for i in 1 2 3
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-t" && thres=$2 && shift 2
    done

    local sname=$1
    local tdir=${AI_TMPDIR:-"/tmp"}
    local wdir=$(mktemp -d "$tdir/tmp_badpix_XXXXXX")
    local sd
    local lim

    (test "$showhelp" || test $# -ne 1 ) &&
        echo "usage: AIbadpix [-t thres|$thres] <flatset>" >&2 &&
        return 1
    
    AIbnorm $sname.pgm > $wdir/$sname.norm.pgm
    convert $wdir/$sname.norm.pgm -median 5 - | \
        pnmccdred -a 10000 -d - $wdir/$sname.norm.pgm $wdir/$sname.diff.pgm
    sd=$(AImstat -c $wdir/$sname.diff.pgm | tr -d '()' | awk '{printf("%0.f", $NF)}')
    lim=$((thres*sd))
    echo sd=$sd lim=$lim >&2
    gm convert $wdir/$sname.diff.pgm -threshold $((10000+lim)) x.bad.pbm
    AIval -a -c -1 x.bad.pbm > x.high.dat
    gm convert $wdir/$sname.diff.pgm -threshold $((10000-lim)) x.bad.pbm
    AIval -a -c -0 x.bad.pbm > x.low.dat
    wc -l x.{high,low}.dat >&2
    cat x.high.dat x.low.dat | awk '{print NR" "$0}' | \
        xy2reg $sname.pgm - > $sname.bad.$thres.reg
    echo "# badpix region file $sname.bad.$thres.reg created" >&2
    
    rm -rf $wdir
    return
}


# find hot/cold bad pixel by analyzing bayered/monochrome pgm images of a given set
AIfindbad () {
    local showhelp
    local nmax=25       # max. number of images to use
    local margin=0      # number of columns/rows to skip at each image border
    local do_display    # if set display results (stack and hotpix regions)
    local do_bgsub      # if set do bg image subtraction in AIbnorm
    local bad=""        # used by AIccd (bayered images only)
    local i
    for i in 1 2 3 4 5 6
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-b" && bad=$2 && shift 2
        test "$1" == "-d" && do_display=1 && shift 1
        test "$1" == "-s" && do_bgsub=1 && shift 1
        test "$1" == "-n" && nmax=$2 && shift 2
        test "$1" == "-m" && margin=$2 && shift 2
    done
    local firstset=${1:-""}
    local secondset=${2:-""}
    local hotthresh=${3:-20}    # hot pix detection threshold (in rms units of
                                # the median image)
    local coldthresh=${4:-20}    # cold pix detection threshold
    local sdat=${AI_SETS:-"set.dat"}
    local tdir=${AI_TMPDIR:-"/tmp"}
    local wdir=$(mktemp -d "$tdir/tmp_findbad_XXXXXX")
    local imlist=$(mktemp "$tdir/tmp_list_XXXXXX.dat")
    local imlist2=$(mktemp "$tdir/tmp_list2_XXXXXX.dat")
    local tmpim1=$(mktemp "$tdir/tmp_im1_XXXXXX.pgm")
    local kernel=$(mktemp "$tdir/tmp_kernel_XXXXXX.pbm")
    local exifdat="exif.dat"
    local setname
    local sname
    local type
    local texp
    local nref
    local dark
    local flat
    local x
    local fname
    local is_bayered
    local exlist
    local rms
    local high
    local low
    local diff
    local bg
    local num
    local thres
    local n
    local geom
    local popts
    local tmpsh=$(mktemp "/tmp/tmp_script_XXXXXX.sh")
    chmod u+x $tmpsh

    (test "$showhelp" || test $# -lt 1 ) &&
        echo "usage: AIfindbad [-h] [-s] [-d] [-b badpix] [-n nmax|$nmax] [-m margin|$margin]" \
            "<firstset> [secondset] [hotthresh|$hotthresh] [coldthresh|$coldthresh]" >&2 &&
        return 1

    for setname in $firstset $secondset
    do
        while read ltime sname target type texp n1 n2 nref dark flat x
        do
            (echo "$ltime" | grep -q "^#") && continue
            test "$type" != "o" && continue
            test "$setname" && test "$setname" != "$sname" && continue
            (! is_integer "$n1" || ! is_integer "$n2") && continue

            # check if sensor uses bayer matrix
            is_bayered=""
            fname=$(AIimlist -q -f $sname "" raw | lines 1)
            if [ "$fname" ] && is_raw $fname
            then
                is_bayered=1
            else
                x=$(get_param camera.dat ctype $sname)
                test "$x" && test "$x" != "CCD" && test "$x" != "CMOS" && is_bayered=1
            fi

            diff=bad.$sname.diff.pgm
            if [ -f $diff ]
            then
                echo "WARNING: reusing diff image $diff." >&2
            else
                # run CCD reduction to create calibrated bayered images
                AIimlist -q $sname "" raw | sort > $imlist 2>/dev/null
                n=$(cat $imlist  | wc -l)
                test $n -eq 0 && echo "ERROR: no images found for set $sname." >&2 && continue
                test $n -lt 4 && echo "ERROR: too few images for $sname (min 4)." >&2 && continue
                test $n -le $nmax && echo "processing $n images in set $sname ..."
                test $n -gt $nmax && echo "processing $nmax out of $n images in set $sname ..."
                cat $imlist | awk -v n=$n -v nmax=$nmax '{
                    if (NR==1) {
                        print $0; i=1
                    } else {
                        x=int((nmax-1)/(n-1)*(NR-1)+0.5*nmax/n)
                        if (x>=i) {print $0; i++}
                    }
                }' > $imlist2
                exlist=$(comm -23 $imlist $imlist2 | awk '{printf("%s ", $2)}')
                
                # get image at the middle of the list
                num=$(head -$((n/2)) $imlist2 | tail -1 | awk '{printf("%s", $2)}')
                fname=$(get_rawfile $num)

                test "$is_bayered" &&
                    AI_EXCLUDE="$AI_EXCLUDE $exlist" AI_BADPIX="$bad" AIccd -b $sname
                
                # create kernel used by computing median of surrounding pixels
                #echo -e "P1\n5 5\n10001\n01010\n00100\n01010\n10001" > $kernel
                echo -e "P1\n3 3\n101\n010\n101" > $kernel
                test "$is_bayered" &&
                    echo -e "P1\n5 5\n00100\n00000\n10101\n00000\n00100" > $kernel
    
                # determine threshold by using stats from middle image
                test ! -s $tdir/$num.pgm &&
                    echo "ERROR: gray image $num.pgm is missing." >&2 && continue
                if [ "$is_bayered" ]
                then
                    if [ "$do_bgsub" ]
                    then
                        AIbnorm -b $tdir/$num.pgm > $wdir/$num.pgm
                    else
                        AIbnorm $tdir/$num.pgm > $wdir/$num.pgm
                    fi
                else
                    test ! -e $wdir/$num.pgm && ln -s $tdir/$num.pgm $wdir/$num.pgm
                fi
                thres=$(imcrop $wdir/$num.pgm | AIval -a - | kappasigma - | \
                    awk '{printf("%.0f", 3*$2)}')
                echo "# stars threshold = $thres" >&2
                
                cat <<EOF > $tmpsh
#!/bin/bash
. airfun.sh > /dev/null
tdir=$tdir
wdir=$wdir
is_bayered="$is_bayered"
do_bgsub="$do_bgsub"
kernel=$kernel
thres=$thres

_findbad_parallel \$@
EOF

                _findbad_parallel () {
                    local sname=$1
                    local num=$2
                    local fname=$3
                    local tmpim1=$(mktemp "$wdir/tmp_im1_XXXXXX.pgm")
                    local mask=$(mktemp "$wdir/tmp_im2_XXXXXX.pgm")

                    test ! -f $tdir/$num.pgm &&
                        echo "WARNING: $num.pgm not found." >&2 && return
                    echo $num
                    # color-normalize bayered images
                    if [ "$is_bayered" ]
                    then
                        if [ "$do_bgsub" ]
                        then
                            # subtract smoothed bayered bg image
                            AIbnorm -b -q $tdir/$num.pgm > $wdir/$num.pgm
                        else
                            # divide by mean value per bayer cell
                            AIbnorm -q $tdir/$num.pgm > $wdir/$num.pgm
                        fi
                        test $? -ne 0 && echo "ERROR in _findbad_parallel" >&2 && return 255
                    else
                        test ! -e $wdir/$num.pgm && ln -s $tdir/$num.pgm $wdir/$num.pgm
                    fi
                    # kernel-median
                    kmedian $wdir/$num.pgm $kernel 2> /dev/null > $tmpim1
                    # create star mask (to exclude from hotpix detection), use
                    # intensities above threshold in bg-subtracted median image
                    AIbgmap -q $tmpim1 "" 1
                    pnmccdred2 -d $(basename ${tmpim1/.pgm/.bg.pgm}) $tmpim1 - | \
                        convert - -threshold $thres $mask
                    rm $(basename ${tmpim1/.pgm/.bg.pgm}) $(basename ${tmpim1/.pgm/.bgm1.pgm})
                    # create diff image
                    pnmcomp -alpha $mask $wdir/$num.pgm $tmpim1 - | \
                        pnmccdred2 -a 10000 -d - $wdir/$num.pgm $wdir/$sname.$num.diff.pgm
                    rm -f $mask
                    return
                }

                test "$is_bayered" && echo "# apply color normalization and local filter ..." >&2
                export -f _findbad_parallel
                false && while read
                do
                    $tmpsh $REPLY
                done < $imlist2
                popts=""; test "$AI_MAXPROCS" && popts="-P $AI_MAXPROCS"
                cat $imlist2 | parallel $popts -k $tmpsh
                unset -f _findbad_parallel

                # determine median image (removing stars)
                echo "# median combine difference images ..." >&2
                pnmcombine2 -d $wdir/$sname.[0-9][0-9][0-9][0-9].diff.pgm $tmpim1
                convert $tmpim1 -median 3 - | pnmccdred2 -a 10000 -d - $tmpim1 $diff
            fi
            
            # thresholding
            rms=$(imcrop $diff 10 | AIval -a - | kappasigma - 1 5 3 | awk '{print $2}')
            high=$(echo $rms $hotthresh | awk '{printf("%.0f", $1*$2)}')
            low=$(echo $rms $coldthresh | awk '{printf("%.0f", -1*$1*$2)}')
            echo "thresholds:" $high $low >&2
            
            # apply thresholds, mask out margins at image border
            geom=${margin}x${margin}
            convert $diff -threshold $((10000+high)) \
                -shave $geom -bordercolor black -border $geom bad.$sname.high.png
            test "$AI_DEBUG" && echo "AIval -a -c -1 bad.$sname.high.png" >&2
            AIval -a -c -1 bad.$sname.high.png > $wdir/x.high.dat
            echo $(cat $wdir/x.high.dat | wc -l) "hot pixels" >&2
            
            convert $diff -threshold $((10000+low)) -negate \
                -shave $geom -bordercolor black -border $geom bad.$sname.low.png
            AIval -a -c -1 bad.$sname.low.png > $wdir/x.low.dat
            echo $(cat $wdir/x.low.dat | wc -l) "cold pixels" >&2
            
            if [ "$is_bayered" ]
            then
                cat $wdir/x.high.dat $wdir/x.low.dat | awk -v d=$day '{
                    printf("%-11s # %s\n", $0, d)
                }' | sort > bad.$sname.${hotthresh}_${coldthresh}.dat
                cat bad.$sname.${hotthresh}_${coldthresh}.dat | awk '{print NR" "$1" "$2}' | \
                    xy2reg $diff - 0.5 0.5 > bad.$sname.${hotthresh}_${coldthresh}.reg
                echo "# created bad.$sname.${hotthresh}_${coldthresh}.dat" >&2
            fi
        done < $sdat
    done
    
    if [ "$secondset" ]
    then
        echo "# identify common hot pixels in both sets ..." >&2
        comm -12 bad.$firstset.${hotthresh}_${coldthresh}.dat \
                 bad.$secondset.${hotthresh}_${coldthresh}.dat > bad.$firstset.$secondset.dat
        cat bad.$firstset.$secondset.dat | awk '{print NR" "$1" "$2}' | \
            xy2reg $diff - 0.5 0.5 > bad.$firstset.$secondset.reg
        n=$(cat bad.$firstset.$secondset.dat | wc -l)
        echo "# writing $n hotpixel to file bad.$firstset.$secondset.dat" >&2
    fi

    if [ "$do_display" ]
    then
        x=""
        test -s $firstset.bgs.ppm && x=$firstset.bgs.ppm
        test -z "$x" && test -f $firstset.ppm && x=$firstset.ppm
        test -z "$x" && nref=$(AIsetinfo -b $firstset | lines 1 | awk '{printf("%s", $8)}')
        test -z "$x" && test -f $AI_TMPDIR/$nref.ppm && x=$AI_TMPDIR/$nref.ppm
        test -z "$x" && test -f $AI_TMPDIR/$nref.pgm && x=$AI_TMPDIR/$nref.pgm
        x="$x bad.$firstset.diff.pgm"
        if [ -f bad.$firstset.$secondset.reg ]
        then
            x="$x bad.$firstset.$secondset.reg"
        else
            test -f bad.$firstset.${hotthresh}_${coldthresh}.reg &&
                x="$x bad.$firstset.${hotthresh}_${coldthresh}.reg"
        fi
        echo "# display bad pixel regions ..." >&2
        AIexamine -n "BadPixel" $x &
    fi
    
    rm -f $kernel $imlist $imlist2
    test "$AI_DEBUG" && echo $wdir $tmpim1 >&2
    test "$AI_DEBUG" || rm -f $tmpim1
    test "$AI_DEBUG" || rm -rf $wdir
    return 0
}


AIcosmics () {
    # detect cosmics by applying image filters and thresholds
    # starlike sources (measured by sextractor) are preserved
    # resulting b/w PBM image is written to stdout
    local showhelp
    local nostars
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-d" && nostars=1 && shift 1
    done
    local img=$1
    local cthres=${2:-"10"}     # threshold/stddev for cosmic pixel candidates
    local bthres=${3:-"4"}      # threshold/stddev for saturated stars
    
    local tdir=${AI_TMPDIR:-"/tmp"}
    local ext
    local size
    local bgsd
    local bgm
    local n
    local fwhm
    local f10
    local thres
    local x
    local bgval=1000
    local scat=x.scat.dat
    local starsreg=x.stars.reg
    local brightmask=x.bright.pbm
    local obmask=x.obmask.pbm
    local cbigmask=x.cbig.pbm
    local csmallmask=x.csmall.pbm
    local kimg=$(mktemp $tdir/tmp_kimg_XXXXXX.pnm)
    local tmpim1=$(mktemp $tdir/tmp_im1_XXXXXX.pnm)
    local tmpim2=$(mktemp $tdir/tmp_im2_XXXXXX.pnm)
    local tmpmask1=$(mktemp $tdir/tmp_tmpmask1_XXXXXX.pbm)
    local tmpmask2=$(mktemp $tdir/tmp_tmpmask2_XXXXXX.pbm)
    local tmpmask3=$(mktemp $tdir/tmp_tmpmask3_XXXXXX.pbm)
    local starmask=$(mktemp $tdir/tmp_starmask_XXXXXX.pbm)
    local tmpdat1=$(mktemp $tdir/tmp_dat1_XXXXXX.dat)
    local tmpdat2=$(mktemp $tdir/tmp_dat2_XXXXXX.dat)
    
    (test "$showhelp" || test $# -lt 1 ) &&
        echo "usage: AIcosmics [-h] [-d] <image> [cthres|$cthres] [bgthres|$bgthres]" >&2 &&
        return 1

    ext=""
    is_pgm $img && ext="pgm"
    #is_ppm $img && ext="ppm"
    test -z "$ext" &&
        echo "ERROR: $img has unsupported image format." >&2 && return 255
    
    # bg subtraction and noise measurement
    size=$(gm identify $img | cut -d " " -f3 | cut -d '+' -f1)
    bgsd=$(AIbgmap -q -sd -m $img 32)
    bgm=$(basename ${img%.*})".bgm1".$ext
    gm convert $bgm -resize ${size}\! - | \
        pnmarith -sub $img - > $tmpim1
    rm -f $bgm

    # extract properties of star profiles, create starmask
    if [ ! "$nostars" ]
    then
        AIsource -q -o $scat $img "" 5 32 2>/dev/null
        sexselect $scat > $tmpdat1
        n=$(grep -v "^#" $tmpdat1 | awk '{if ($8<0.03) print $0}' | wc -l)
        grep -v "^#" $tmpdat1 | awk '{if ($8<0.03) print $0}' | \
            sort -n -k7,7 | head -n $((n/2)) > $tmpdat2
        set - $(kappasigma $tmpdat2 4) $(kappasigma $tmpdat2 5) $(kappasigma $tmpdat2 6)
        fwhm=$5    
        printf "# a=%.2f +- %.2f  e=%.2f +- %.2f  fwhm=%.2f +- %.2f\n" $1 $2 $3 $4 $5 $6 >&2
        cat $tmpdat1 | awk -v a=$1 -v da=$2 -v e=$3 -v de=$4 -v f=$5 -v df=$6 'BEGIN{
            alim=0.9*a-4.0*da; elim=1.3*e+4.0*de; flim=0.9*f-3.0*df-0.2
            printf("# stars: a>=%.2f  e<=%.2f  fwhm>=%.2f\n", alim, elim, flim)
            }{
                if ($1~/^#/) next
                if ($4 < alim) next
                if ($5 > elim) next
                if ($6 < flim) next
                print $0
            }' > $tmpdat2
        grep "^#" $tmpdat2 >&2
        echo -e "# Region file format: DS9 version 4.1" > $starsreg
        echo -e "global  color=green dashlist=8 3 width=1 font=\"helvetica 10 normal roman\"" \
            "select=1 highlite=1 dash=0 fixed=0 edit=0 move=0 delete=1 include=1 source=1" >> $starsreg
        grep -v "^#" $tmpdat2 | awk -v f=$fwhm '{
            printf("circle(%.2f,%.2f,%.2f)", $2, $3, 2+1.2*f)
            printf(" # text={%s %.1f}\n", $1, $7)}' >> $starsreg
        reg2pbm $img $starsreg > $starmask  # 1=star
        # test "$AI_DEBUG" && echo $tmpdat1 $tmpdat2 >&2

        # identify saturated stars including their spikes
        x=$(echo $fwhm | awk '{printf("%.0f", 1.3+$1/2)}')
        thres=$(echo $bthres $bgsd | awk '{printf("%.0f", $1*$2)}')
        echo "# sd=$bgsd  thres=$thres rad=$x (brightmask)" >&2
        gm convert $tmpim1 -threshold $thres $tmpmask1     # 1=bright
        # large objects
        convert $tmpmask1 -morphology Erode:$x Diamond $tmpmask2   # 1=center of big objects
        convert $tmpmask1 -negate $tmpmask3
        convert $tmpmask2 -mask $tmpmask3 -morphology Dilate:20 Diamond +mask $brightmask
    else
        fwhm=5
    fi


    # build circular kernel image, n=11
    f10=$(echo $fwhm | awk '{printf("%.0f", 10*$1)}')
    echo -e "P1\n7 7" > $kimg
    test $f10 -lt 30 && echo "
0 0 0 0 0 0 0
0 1 0 1 1 1 0
0 1 0 0 0 0 0
0 1 0 0 0 1 0
0 0 0 0 0 1 0
0 1 0 1 0 1 0
0 0 0 0 0 0 0" | tr -d ' ' >> $kimg
    test $f10 -ge 30 && echo "
0 0 1 0 1 0 0
1 0 0 0 0 0 1
0 0 0 0 0 0 1
1 0 0 0 0 0 0
1 0 0 0 0 0 1
0 0 0 0 0 0 0
0 1 0 1 0 1 0" | tr -d ' ' >> $kimg

    # old: version <2.8.1
    #echo -e "P1\n7 7\n0000000\n0010010\n0000000\n0100000\n0000010\n0001000\n0000000" > $kimg
    #test $f10 -ge 24 &&
    #    echo -e "P1\n7 7\n0000100\n0100000\n0000000\n0000001\n1000000\n0000000\n0001000" > $kimg
    #test $f10 -ge 32 &&
    #    echo -e "P1\n9 9\n000000000\n000010000\n001000000\n000000010\n010000000\n000000001\n000000000\n000100000\n000000100" > $kimg
    #test $f10 -ge 40 &&
    #    echo -e "P1\n9 9\n000100000\n000000010\n010000000\n000000000\n000000000\n100000000\n000000001\n001000000\n000000100" > $kimg


    # create and subtract median smoothed image
    kmedian $img $kimg 2>/dev/null > $tmpim2
    pnmccdred -a $bgval -d $tmpim2 $img $tmpim1

    # identify high signal pixels by thresholding tmpim1 (big cosmics)
    # remove protected areas (starmask, brightmask)
    thres=$(echo $cthres $bgsd | awk -v f=$fwhm '{
        m=0.6; if (f<2.8) m=0.7; if (f<2.3) m=0.8
        printf("%.0f", m*$1*$2)}')
    echo "# high signal pixels thres=$thres" >&2
    if [ -s $starmask ] && [ -s $brightmask ]
    then
        gm convert $tmpim1 -threshold $((thres+bgval)) pbm:- | \
            pnmarith -sub - $starmask | pnmarith -sub - $brightmask > $obmask    # 1=high
    else
        gm convert $tmpim1 -threshold $((thres+bgval)) pbm:- > $obmask
    fi
    
    # count object size in a disklike region
    convert $obmask -depth 16 \
        -define convolve:scale=0.00001526 -morphology Convolve Disk:2.5 pgm:- > $tmpim2

    # big cosmics (>4pix)
    # thresholding 16bit pgm uses intensity value, 8bit pgm uses percent
    gm convert $tmpim2 -threshold 4 - | pnmarith -mul - $obmask > $tmpmask2   # 1=center of big objects
    convert $obmask -negate $tmpmask3
    convert $tmpmask2 -mask $tmpmask3 -morphology Dilate:5 Diamond +mask $cbigmask
    
    # identify small objects (<=4pix) where max > cthres*stddev
    thres=$(echo $cthres $bgsd | awk '{printf("%.0f", $1*$2)}')
    echo "# small cosmics thres=$thres" >&2
    if [ -s $starmask ] && [ -s $brightmask ]
    then
        gm convert $tmpim1 -threshold $((thres+bgval)) pbm:- | \
            pnmarith -sub - $starmask | pnmarith -sub - $brightmask | \
            pnmarith -sub - $cbigmask > $tmpmask1    # 1=center of small cosmics
    else
        gm convert $tmpim1 -threshold $((thres+bgval)) pbm:- | \
            pnmarith -sub - $cbigmask > $tmpmask1    # 1=center of small cosmics
    fi
    convert $tmpmask1 -mask $tmpmask3 -morphology Dilate:3 Diamond +mask $csmallmask
   
    pnmarith -max $csmallmask $cbigmask
    
    test "$AI_DEBUG" && echo $tmpim1 $tmpim2 $starmask >&2 && return
    rm -f $kimg $tmpim1 $tmpim2 $starmask
    rm -f $tmpdat1 $tmpdat2 $tmpmask1 $tmpmask2
    return
}


AIgradient () {
    # apply radial gradient filter (Larsen-Sekanina)
    # result is written to stdout
    local showhelp
    (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
    local img=$1
    local center=${2:-""}   # center x,y in image coord or ds9 region file
                            # containing center point
    local rot=${3:-"20"}
    local offset=${4:-""}   # currently unused

    local ext
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpim1=$(mktemp $tdir/tmp_im1_XXXXXX.pnm)
    local tmpim2=$(mktemp $tdir/tmp_im2_XXXXXX.pnm)
    local tmpim3=$(mktemp $tdir/tmp_im3_XXXXXX.pnm)

    (test "$showhelp" || test $# -lt 1 ) &&
        echo "usage: AIgradient [-h] <image> [center] [rot|$rot]" >&2 &&
        return 1

    ext=""
    is_pgm $img && ext="pgm"
    test -z "$ext" && is_ppm $img && ext="ppm"
    test -z "$ext" &&
        echo "ERROR: $img has unsupported image format." >&2 && return 255
    
    if is_reg $center
    then
        center=$(reg2xy $img $center | awk '{printf("%s,%s", $2, $3)}')
        test "$AI_DEBUG" && echo "# center=$center" >&2
    fi
    
    test "$AI_DEBUG" && echo "convert $img -distort SRT \"$center $rot\" $tmpim1" >&2
    convert $img -distort SRT "$center $rot" $tmpim1
    pnmccdred -a 10000 -d $tmpim1 $img $tmpim2
    rot=$(echo $rot | awk '{print -1*$1}')
    convert $img -distort SRT "$center $rot" $tmpim1
    pnmccdred -a 10000 -d $tmpim1 $img $tmpim3
    pnmarith -add $tmpim2 $tmpim3
    
    rm -f $tmpim1 $tmpim2 $tmpim3
    return
}


# tasks started by ds9 analysis commands
# requires a running instance of ds9 with name $DS9NAME
ds9cmd () {
    local overwrite # if set then previous results are deleted
    test "$1" == "-o" && overwrite=1 && shift 1
    cmd=$1
    shift 1
    
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpdat=$(mktemp "$tdir/tmp_dat_XXXXXX.dat")
    local tmpreg=$(mktemp "$tdir/tmp_reg_XXXXXX.reg")
    local tmpmask=$(mktemp "$tdir/tmp_mask_XXXXXX.pbm")
    local tmpim1=$(mktemp "$tdir/tmp_im1_XXXXXX.pnm")
    local tmpfits1=$(mktemp "$tdir/tmp_im1_XXXXXX.fits")
    local tmpfits2=$(mktemp "$tdir/tmp_im2_XXXXXX.fits")
    local tmpdat1=$(mktemp "$tdir/tmp_dat1_XXXXXX.dat")
    local tmpstamp=$(mktemp "$tdir/tmp_stamp_XXXXXX.dat")
    local ds9name=${DS9NAME:-"AIRTOOLS"}
    local pardir=${UPARM:-"ds9param"}   # directory containing parameter files
    local envfile=$pardir/env.dat       # environment to load at start of any task
    local log=${AI_LOG:-"airtask.log"}
    local sdat=${AI_SETS:-"set.dat"}
    local wdir=$(pwd)
    local set
    local img
    local img2
    local hdr
    local starstack
    local cometstack
    local trail
    local oxy
    local rlim
    local merrlim
    local psfsize
    local ext
    local photcat
    local bgrgb
    local npix
    local narea
    local id
    local nid
    local cnt
    local ddiff
    local line
    local bgfit10
    local comult
    local bgoff
    local tel
    local catalog
    local maglim
    local thres
    local angle
    local bgmult
    local mask
    local aprad
    local maxstars
    local doext
    local dodel
    local skip
    local opts
    #local topts
    #local aopts
    local fname
    local idx
    local mzero
    local mag
    local xlist
    local x
    local y
    local h
    local n
    local badreg
    local str
    local north
    local ra
    local dec
    local binning
    local pixscale
    local fwhm
    local url
    local object
    local script
    local isok
    local fittype
    local bsize
    local xpareg    # should be in local dir
    local ds9version
    local retval
    
    case $cmd in
        setinfo|test|dcontrast|regswitch)
                ;;
        *)      echo ""
                echo "#### AI_VERSION=$AI_VERSION ($(date -I))" >> $log
                ;;
    esac
    
    # load environment
    test -e $envfile &&
        echo "# loading environment ..." >> $log &&
        cat $envfile >> $log &&
        echo "" >> $log &&
        eval $(cat $envfile | grep "=" | sed -e 's/[ ]*=[ ]*/=/')

    # set xpa directory to current working dir (projectdir)
    #xpaset -p $ds9name cd $wdir

    test "$AI_DEBUG" && echo "# DEBUG mode is active (ds9name=$ds9name)"
    test "$AI_DEBUG" && (set -o posix; set) > airtask.env
    
    case $cmd in
        project) #echo "running project"
                # get names of all image sets
                test -f $sdat && str=$(grep -v "^#" $sdat | awk '{
                        x=$5""$6""$7; gsub(/[0-9]/,"",x); if($4=="o" && x==""){print $2}}' | \
                    tr '\n' '|' | sed -e 's/.$//')
                echo "# project dir: $(pwd)"
                echo "# image sets:"
                AIsetinfo -b
                echo
                echo "# ICQ records:"
                phot2icq -c
                echo ""
                ;;
        shorthelp)
                x=$(type -p airds9.ana)
                cat $x | awk '{
                    if($1=="help"){p="ok"; print substr($0,6) "\n"; next}
                    if($1=="endhelp") {p=""}
                    if(p!="") print $0
                }'
                echo ""
                ;;
        usermanual)
                x=/usr/share/doc/airtools-doc
                y="unknown"
                #y="manual-"${LANG%_*}".html"
                test ! -e $x/$y && y="manual-en.html"
                test ! -e $x/$y && y=""
                test ! -e $x/$y && x=/usr/share/doc/airtools-core
                xdg-open $x/$y
                ;;
        expert) str=$(yad --title="AIRTOOLS Expert Menu" --borders=10 --width=400 \
                    --text="\n Run AIRTOOLS command:" --entry 2>/dev/null)
                test "$str" && echo "# $str" && $str
                echo ""
                ;;
        test)   img=$1
                echo "running test $img"
                echo "AI_VERSION=$AI_VERSION"
                ds9version=$(xpaget $ds9name version | awk '{printf("%s", $2)}')
				echo "ds9version=$ds9version"
                echo "ds9name=$ds9name"
                echo "PATH=$PATH"
                echo "PWD=$PWD"
                echo "UPARM=$UPARM"
                echo "pardir=$pardir"
                echo "wdir=$wdir"
                echo "ana=$(realpath $(type -p airds9.ana))"
                echo "airfun=$(realpath $(type -p airfun.sh))"
                # cat $pardir/airtools.par
                echo "program sex is:" $(type -t sex)
                echo "running AIcheck_ok"
                AIcheck_ok
                retval=$?
                test $retval -ne 0 && echo "# ERROR: AIcheck failed" >&2

                # get image name
                if [ -z "$img" ]
                then
                    img=$(xpaget $ds9name fits header keyword AI_IMAGE)
                    test "$img" && echo "# img=$img"
                    # TODO: fallback to use currently displayed fits image
                fi
                test ! -e "$img" && echo "ERROR: missing image $img" >&2 &&
                    echo >&2 && return 255

                x=0
                false && while [ $x -lt 30 ] && [ ! -f /tmp/xxx ]
                do x=$((x+1)); echo $x >&2; sleep 1; done
                
                # switching DEBUG mode                
                if [ "$AI_DEBUG" ] && [ -e $envfile ]
                then
                    sed -i '/^AI_DEBUG[ ]*=/d' $envfile &&
                    echo "switching DEBUG mode OFF"
                else
                    touch $envfile
                    set_header $envfile AI_DEBUG=1 &&
                    echo "switching DEBUG mode ON"
                fi
                # opening new window leaves the task open
                # even if starting as background job
                # xterm &
                
                echo "# test finished"
                echo ""
                return
                ;;
        dcontrast) # set display contrast using noise statistics
                #echo "running dcontrast"
                ds9version=$(xpaget $ds9name version | awk '{printf("%s", $2)}')
                case $ds9version in
					7*) xpaget $ds9name imexam data 63 63 > $tmpdat;;
					8*)	xpaget $ds9name data image \
							$(xpaget $ds9name iexam coordinate image) \
							63 63 yes > $tmpdat;;
				esac
                line=$(cat $tmpdat | tr ' ' '\n' | grep "[0-9]" | kappasigma -)
                test "$AI_DEBUG" && echo "stats: $line"
                set - $line
                test "$2" == "0" && echo "WARNING: constat data, no scaling." && return
                line=$(echo $1 $2 | awk '{printf("%f %f", $1-10*$2-20*sqrt($2), $1+20*$2+500*sqrt($2))}')
                test "$AI_DEBUG" && echo "limits: $line"
                xpaset -p $ds9name scale limits $line
                #xpaset $ds9name mode region
                ;;
        regswitch) # toggle selected region color
                x=$(xpaget $ds9name regions color)
                case "$x" in
                    red)    xpaset -p $ds9name regions color green;;
                    *)      xpaset -p $ds9name regions color red;;
                esac
                ;;
        regstat) img=$1
                echo "running regstat \"$img\""
                
                if [ -z "$img" ]
                then
                    img=$(xpaget $ds9name fits header keyword AI_IMAGE)
                    test -z "$img" && img=$(xpaget $ds9name file)
                    test "$img" && echo "# img=$img"
                fi
                test ! -e "$img" && echo "ERROR: missing image $img" >&2 &&
                    echo >&2 && return 255
                
                # measure stats for every single region
                xpareg=$(mktemp x.tmp_XXXXXX.reg)
                printf "%6s %-5s  %-6s %-7s %-6s\n" \
                    "#bgmean" "stddev" "area" "sum" "mean"
                xpaset -p $ds9name regions system physical
                xpaset -p $ds9name regions save $xpareg
                grep -iwE "^circle|^polygon|^box" $xpareg | while read
                do
                    set - $(echo "$REPLY" | regstat -g $img -)
                    # bgmean sd   area sum mean reg
                    test "$1" == "${1/,/}" &&
                    printf "%6.1f %5.1f  %6.0f %7.0f %6.1f # %s\n" $1 $2 $3 $4 $5 $6
                    test "$1" != "${1/,/}" &&
                    printf "%s %s  %6.0f %s %s # %s\n" \
                        "${1//,/ }" "${2//,/ }" "${3//,/ }" "${4//,/ }" "${5//,/ }" "$6"
                done
                rm -f $xpareg
                echo ""
                ;;
        movestars) # note: using flaged (red) regions only
                img=$1
                skip="$2"

                # get image name
                if [ -z "$img" ]
                then
                    img=$(xpaget $ds9name fits header keyword AI_IMAGE)
                    test "$img" && test "$AI_DEBUG" && echo "# img=$img"
                fi
                test ! -e "$img" && echo "ERROR: missing image $img" >&2 &&
                    echo >&2 && return 255
                
                # determine set name
                set=$(basename ${img%%.*} | sed -e 's|_m.*||')
                ! is_setname $set &&
                    set=$(get_header -q $img AI_SNAME | sed -e 's|_m.*||')
                ! is_setname $set &&
                    set=$(get_header -q $img AI_COMST | sed -e 's|_m.*||')
                ! is_setname $set &&
                    echo "ERROR: unale to determine set name." >&2 && echo >&2 && return 255
                test ! -e $set.head &&
                    echo "ERROR: missing $set.head" >&2 && echo >&2 && return 255

                # get marked objects (red)
                xpareg=$(mktemp x.tmp_XXXXXX.reg)
                xpaset -p $ds9name regions system physical
                xpaset -p $ds9name regions save $xpareg
                x=$(grep "^circle(.* color=red text" $xpareg | tr ' ' '\n' | grep "^text" | \
                    tr '={' ' ' | awk '{printf("%s\n", $2)}')
                if [ "$x" ]
                then
                    skip=$(echo $skip $x | tr ' ' '\n' | sort -u | tr '\n' ' ')
                    echo "# new move=$skip"
                else
                    rm -f $xpareg
                    return
                fi
                
                # check for photometry data file
                fname=comet/$set.newphot.dat
                test ! -f $fname &&
                    echo "ERROR: missing stars database $fname" >&2 &&
                    echo >&2 && return 255

                # get image height
                h=$(xpaget $ds9name fits size | cut -d ' ' -f2)
                
                # move center position
                for id in ${skip//,/ }
                do
                    line=$(grep "^$id " $fname)
                    test -z "$line" && continue
                    set -- $(grep "^circle.* color=red text={"$id"[ }]" $xpareg | tr '(){},' ' ')
                    str=$(echo "$line" | awk -v h=$h -v x=$2 -v y=$3 '{
                        x=sprintf("%.02f", x-0.5)
                        y=sprintf("%.02f", h-y+0.5)
                        oldx=$2
                        oldy=$3
                        sub(oldx,x)
                        sub(oldy,y)
                        if (x!=oldx || y!=oldy) {
                            printf("%s dx=%.2f dy=%.2f", $0, x-oldx, y-oldy)
                        }
                        }')
                    test -z "$str" && continue
                    echo "$line"
                    echo "$str"
                    sed --follow-symlinks -i -e "/^$id / a $str" -e "/^$id / s,^,#," $fname
                done
                rm -f $xpareg
                echo ""
                ;;
        nostars) # note: using flaged (red) regions only
                img=$1
                skip="$2"
                
                # get image name
                if [ -z "$img" ]
                then
                    img=$(xpaget $ds9name fits header keyword AI_IMAGE)
                    test "$img" && test "$AI_DEBUG" && echo "# img=$img"
                fi
                test ! -e "$img" && echo "ERROR: missing image $img" >&2 &&
                    echo >&2 && return 255
                
                # determine set name
                set=$(basename ${img%%.*} | sed -e 's|_m.*||')
                ! is_setname $set &&
                    set=$(get_header -q $img AI_SNAME | sed -e 's|_m.*||')
                ! is_setname $set &&
                    set=$(get_header -q $img AI_COMST | sed -e 's|_m.*||')
                ! is_setname $set &&
                    echo "ERROR: unale to determine set name." >&2 && echo >&2 && return 255
                test ! -e $set.head &&
                    echo "ERROR: missing $set.head" >&2 && echo >&2 && return 255

                # starphot file
                fname=comet/$set.starphot.dat
                test ! -f $fname &&
                    echo "ERROR: missing stars database $fname" >&2 &&
                    echo >&2 && return 255

                # add marked bad objects (red) to variable skip
                xpareg=$(mktemp x.tmp_XXXXXX.reg)
                xpaset -p $ds9name regions system physical
                xpaset -p $ds9name regions save $xpareg
                # old:
                #x=$(grep "^circle(.* color=red text" $xpareg | tr ' ' '\n' | grep "^text" | \
                #    tr '={' ' ' | awk '{printf("%s\n", $2)}')
                test -z "$(grep -E "^circle|^polygon|^box" $xpareg | grep " color=red")" &&
                    rm -f $xpareg && return
                grep -vE "^circle|^polygon|^box" $xpareg > $tmpdat               
                grep -E "^circle|^polygon|^box" $xpareg | grep " color=red" >> $tmpdat
                rm -f $xpareg
                x=$(regfilter $set.src.dat $tmpdat | sexselect -r - "" "" "" "" "" 99 | \
                    grep "^circle" | tr ' ' '\n' | grep "^text" | \
                    tr '={' ' ' | awk '{printf("%s\n", $2)}')
                if [ "$x" ]
                then
                    skip=$(echo $skip $x | tr ' ' '\n' | sort -u | tr '\n' ' ')
                    echo "# new skip=$skip"
                else
                    return
                fi
                
                # skip stars from being used in psf extraction
                for id in ${skip//,/ }
                do
                    sed --follow-symlinks -i 's/^'$id' /#'$id'/' $fname
                done
                echo ""
                ;;
        imload) fname=$(yad --title="Open Image or Region file:" \
                    --borders=10 --width=800 --height=600 --file --multiple \
                    --file-filter="Image files | *.pgm *.ppm *.fits" \
                    --file-filter="Region files | *.reg" 2>/dev/null)
                test "$AI_DEBUG" && echo "files:" && echo "$fname" | tr '|' '\n'
                test "$fname" && AIexamine -n $ds9name ${fname//|/ }
                echo ""
                ;;
        imflip) img=$1
                echo "running imflip \"$img\""
                
                # get image name
                if [ -z "$img" ]
                then
                    img=$(xpaget $ds9name fits header keyword AI_IMAGE)
                    test "$img" && echo "# img=$img"
                fi
                test ! -e "$img" && echo "ERROR: missing image $img" >&2 &&
                    echo >&2 && return 255

                # determine input image type
                ext=""
                is_pgm $img && ext="pgm"
                is_ppm $img && ext="ppm"
                    
                # check for cometstack
                cometstack=$(xpaget $ds9name fits header keyword AI_COMST)

                pnmflip -tb $img > x.$ext && mv x.$ext $img
                AIexamine -r $img
                
                test "$cometstack" && test -e "$cometstack" &&
                    test "$img" != "$cometstack" &&
                    echo "# Please run imflip on comet stack as well."
                echo ""
                ;;
        aladindss) img=$1
                test "$AI_DEBUG" && echo "running aladindss \"$img\""
                
                # get image name
                if [ -z "$img" ]
                then
                    img=$(xpaget $ds9name fits header keyword AI_IMAGE)
                    test "$img" && test "$AI_DEBUG" && echo "# img=$img"
                fi

                if [ -z "$img" ]
                then
                    # try with fits image
                    img=$(xpaget $ds9name file)
                    test "$img" && test "$AI_DEBUG" && echo "# img=$img"
                    AIaladin -a $img &
                else
                    # determine set name
                    set=$(basename ${img%%.*} | sed -e 's|_m.*||')
                    ! is_setname $set &&
                        set=$(get_header -q $img AI_SNAME | sed -e 's|_m.*||')
                    ! is_setname $set &&
                        set=$(get_header -q $img AI_COMST | sed -e 's|_m.*||')
                    ! is_setname $set &&
                        echo "ERROR: unale to determine set name." >&2 && echo >&2 && return 255
                    echo "### img=$img  set=$set"
                    test ! -e $set.head &&
                        echo "ERROR: missing $set.head" >&2 && echo >&2 && return 255

                    # determine approx. fov
                    x=$(imsize $img | awk -v p=$pixscale '{
                        w=$1*p/3600+0.02
                        h=$2*p/3600+0.02
                        printf("%.2fx%.2f", w, h)}')
                    #echo "$ra $dec $x"
                    
                    AIaladin -a $set &
                fi
                echo ""
                ;;
        wcscalib) img=$1
                catalog=$2
                maglim=$3
                thres=$4
                north=$5
                opts=$6     # e.g.: -x '-DISTORT_DEGREES 5'
                echo "running wcscalib \"$img\" $catalog \"$maglim\" \"$thres\" \"$north\" \"$opts\""
                
                # get image name
                if [ -z "$img" ]
                then
                    img=$(xpaget $ds9name fits header keyword AI_IMAGE)
                    test "$img" && echo "# img=$img"
                fi
                test ! -e "$img" && echo "ERROR: missing image $img" >&2 &&
                    echo >&2 && return 255
                
                # determine set name
                set=$(basename ${img%%.*})
                test ! -e $set.head &&
                    echo "ERROR: missing $set.head" >&2 && echo >&2 && return 255
                
                # get initial magzero and saturation
                # TODO: should be implemented by AIsource
                mzero=$(get_header -q $set.head MAGZERO)
                test -z "$mzero" && mzero=$(get_param camera.dat magzero $set AI_MAGZERO)
                x=$(get_header -q $set.head SATURATE)
                test -z "$x" && x=$(get_param camera.dat satur $set AI_SATURATION)
                echo "# magzero=$mzero saturation=$(echo $x | awk '{printf("%.0f", $1)}')"
                
                test "$north" && north="-n $north"
                str="AI_MAGZERO=$mzero AIwcs $opts -q -f $north $set $catalog \"$maglim\" $thres"
                echo "#" $str >&2co01.bgm10res.ppm
                eval $str
                if [ $? -eq 0 ] && [ -s $set.wcs.head ]
                then
                    ls wcs/$set*.png > /dev/null 2>&1 &&
                        display wcs/$set*.png &
                    echo "$cmd finished"
                fi
                echo ""
                ;;
        bggradient) img=$1
                fittype=${2:-"plane"}
                bgmult=$3
                bsize=${4:-""}
                echo "running bggradient \"$img\" $fittype $bgmult \"$bsize\""
                
                # fittype option for AIbgmap
                opts="-p"
                test "$fittype" == "surface" && opts="-s"
                
                # get image name
                if [ -z "$img" ]
                then
                    img=$(xpaget $ds9name fits header keyword AI_IMAGE)
                    test "$img" && echo "# img=$img"
                fi
                test ! -e "$img" && echo "ERROR: missing image $img" >&2 &&
                    echo >&2 && return 255

                # determine input image type
                ext=""
                is_pgm $img && ext="pgm"
                is_ppm $img && ext="ppm"
                
                # determine set name
                set=$(basename ${img%%.*})
                test ! "$(AIsetinfo -b $set)" && set=$(basename ${img%.*})
                
                # determine bg mesh size
                if [ ! "$bsize" ]
                then
                    bsize=64
                    x=$(imsize $img | awk '{x=$1; if($2<$1) x=$2; print x}')
                    test $x -lt 2500 && bsize=48
                    test $x -lt 1500 && bsize=32
                    test $x -lt 1000 && bsize=24
                fi
                
                # check for cometstack
                cometstack=$(get_header -q $img AI_COMST)
                #cometstack=$(xpaget $ds9name fits header keyword AI_COMST)
                # fallback for older airfun versions
                test -z "$cometstack" && test -e ${set}_m.$ext &&
                    cometstack=${set}_m.$ext
                test -z "$cometstack" && test -e ${set}_cs.$ext &&
                    cometstack=${set}_cs.$ext
                test "$cometstack" && test ! -e "$cometstack" &&
                    echo "ERROR: missing comet stack $cometstack" >&2 &&
                    echo >&2 && return 255
                test -z "$cometstack" &&
                    echo "WARNING: no comet stack found" >&2
                test "$cometstack" &&
                    echo "# cometstack=$cometstack"

                # TODO: check if the currently displayed frame belongs to set
                
                # determine badbg region file
                test -d bgcorr || mkdir bgcorr
                badbg=bgcorr/$set.badbg.reg
                
                # delete old results (independent of bgmult)
                if [ "$overwrite" ]
                then
                    flist=$(ls bgcorr/$set.bgm* bgcorr/$set.badbg.reg 2>/dev/null)
                    test "$flist" && echo "# removing previous data" &&
                        for f in $flist; do rm $f; done
                    # TODO: remove AI_BGFIT ?
                fi
                
                # check for existing bg image
                bgimg=""
                test -f bgcorr/$set.bgm${bgmult}.$ext    && bgimg=bgcorr/$set.bgm${bgmult}.$ext
                test -f bgcorr/$set.bgm${bgmult}all.$ext && bgimg=bgcorr/$set.bgm${bgmult}all.$ext
                
                # check if badbg is not empty
                isok=""
                test -s $badbg && grep -q -E "^circle|^polygon|^box|^ellipse" $badbg && isok="has_badbg"
                
                # determine bg mask
                mask=""
                test -s $badbg && test "$isok" &&
                    mask=$badbg &&
                    echo "# reusing bad regions from $mask"
                test -z "$mask" && test -f bgcorr/$set.bgmask.png &&
                    mask=bgcorr/$set.bgmask.png &&
                    echo "# reusing old mask image $mask"
                if [ ! "$mask" ] 
                then
                    # get regions from current frame
                    echo "# saving regions from current frame to $badbg"
                    xpaset -p $ds9name regions system physical
                    xpaset -p $ds9name regions save $badbg
                    mask=$badbg
                fi

                # check if bgfit type has changed
                x=$(get_header -q $set.head AI_BGFIT)
                if [ "$x" ]
                then
                    if [ "$fittype" != "$x" ] && [ "$bgimg" ]
                    then
                        bgimg=""
                    fi
                fi
                
                # get AI_BGOFF
                bgoff=$(get_header -q $set.head AI_BGOFF)
                test "$bgoff" && opts="$opts -o $bgoff"
                
                if [ "$bgimg" ] && [ $bgimg -nt $badbg ] && is_pnm $bgimg
                then
                    echo "reusing bg gradient image $bgimg"
                    # show stats only
                    test "$AI_DEBUG" &&
                        echo "# AIbgmap $opts -stats -x 75 -q ../$set.$ext $bsize 1 ../$mask $bgmult" >&2
                    (cd bgcorr
                    AIbgmap $opts -stats -x 75 -q ../$set.$ext $bsize 1 ../$mask $bgmult)
                else
                    test "$AI_DEBUG" &&
                        echo "AIbgmap $opts -d -m -x 75 -q ../$set.$ext $bsize 1 ../$mask $bgmult" >&2
                    (cd bgcorr
                    AIbgmap $opts -d -m -x 75 -q ../$set.$ext $bsize 1 ../$mask $bgmult)
                    test $? -ne 0 &&
                        echo "ERROR: bggradient failed" \
                            "(hint: lower bgmult to avoid saturation)" >&2 &&
                        echo >&2 && return 255
                    test -f bgcorr/$set.bgm${bgmult}.$ext && bgimg=bgcorr/$set.bgm${bgmult}.$ext
                fi
                
                # TODO: apply correction from additional model image
                
                # subtract bg from stacks
                if [ "$bgimg" ] && (
                    [ ! -e ${img%.*}.bgs.$ext ] || [ $bgimg -nt ${img%.*}.bgs.$ext ] ||
                    ( [ "$cometstack" ] && [ ! -e ${img%.*}.bgs.$ext ] ) ||
                    ( [ "$cometstack" ] && [ $bgimg -nt ${cometstack%.*}.bgs.$ext ] ) )
                then
                    if [ ! -L ${img%.*}.bgs.$ext ]
                    then
                        echo "creating ${img%.*}.bgs.$ext ..."
                        imbgsub $img $bgimg "" $bgmult > ${img%.*}.bgs.$ext
                        test ! -e ${img%.*}.bgs.head &&
                            ln -s $set.head ${img%.*}.bgs.head
                        set_header $set.head AI_BGFIT=$fittype
                    else
                        echo "WARNING: not overwriting ${img%.*}.bgs.$ext"
                    fi
                    test "$cometstack" && if [ ! -L ${cometstack%.*}.bgs.$ext ]
                    then
                        echo "creating ${cometstack%.*}.bgs.$ext ..."
                        imbgsub $cometstack  $bgimg "" $bgmult > ${cometstack%.*}.bgs.$ext
                        test ! -e ${cometstack%.*}.bgs.head &&
                            ln -s $set.head ${cometstack%.*}.bgs.head
                    else
                        echo "WARNING: not overwriting ${cometstack%.*}.bgs.$ext"
                    fi
                    # replace current frame
                    # TODO: switch to frame containing the star stack first
                    AIexamine -r ${img%.*}.bgs.$ext
                fi
                
                echo "displaying check images ..."
                #AIexamine $set.bgs.$ext &
                AIexamine -n Backgrounds -s -s -l -p "-zoom to fit -frame last -scale mode minmax \
                    -frame first -scale mode 99.5" bgcorr/$set.bgm${bgmult}{res,n}.$ext &
                # xpaset -p Backgrounds cmap value 1.5 0.3
                echo "$cmd finished"
                echo ""
                ;;
        psfextract) set=$1
                starstack=$2
                rlim=$3
                merrlim=$4
                psfsize=$5
                skip=$6
                ext=""
                echo "running psfextract $set $starstack \"$rlim\" \"$merrlim\" \"$psfsize\""
                test "$skip" && echo "skip=$skip"
                
                test ! -f $set.head &&
                    echo "ERROR: missing header file $set.head." &&
                    echo "" && return 255
                
                # determine input image type
                is_pgm $starstack && ext="pgm"
                is_ppm $starstack && ext="ppm"
                
                # determine cometstack
                cometstack=$(get_header $starstack AI_COMST)
                test "$cometstack" && test ! -e "$cometstack" &&
                    echo "ERROR: image $cometstack not found." >&2 && echo "" && return 255
                
                # check for bg subtracted images
                ! test -f ${starstack%.*}.bgs.$ext &&
                    echo "ERROR: image ${starstack%.*}.bgs.$ext not found." >&2 &&
                    echo "" && return 255
                starstack=${starstack%.*}.bgs.$ext
                test "$cometstack" && ! test -f ${cometstack%.*}.bgs.$ext &&
                    echo "ERROR: image ${cometstack%.*}.bgs.$ext not found." >&2 &&
                    echo "" && return 255
                cometstack=${cometstack%.*}.bgs.$ext
                test ! -e ${starstack%.*}".head" && ln -s $set.head ${starstack%.*}".head"
                test "$cometstack" && test ! -e ${cometstack%.*}".head" && ln -s $set.head ${cometstack%.*}".head"

                # check for comet position keywords
                oxy=$(get_header -q $set.head AI_OXY)
                test -z "$oxy" && set - $(get_header -s $set.head AI_CORA,AI_CODEC) xx
                test $# -eq 3 &&
                    oxy=$(echo comet $1 $2 | rade2xy - $set.wcs.head | awk '{printf("%.0f,%.0f", $2, $3)}')
                test -z "$oxy" && set - $(get_header -s $set.head AI_OXY) xx &&
                    test $# -eq 2 && echo "# using AI_OXY=$1" >&2 && oxy=$1
                
                if [ "$cometstack" ]
                then
                    test -z "$oxy" && echo "ERROR: missing comet position keywords." &&
                        echo "" && return 255
                    # determine comet motion
                    set - $(get_header $set.head AI_OMOVE) x
                    test $# -ne 2 &&
                        echo "ERROR: missing comet motion keyword." &&
                        echo "" && return 255
                    str=$1
                    
                    # get trail parameters from image header
                    str="${str}@$oxy"
                    echo "# str=$str"
                    trail=$(get_header -q $set.head AI_TRAIL)
                    test -z "$trail" && trail=$(omove2trail $set $str 2>/dev/null)
                    test -z "$trail" && x=$(get_header -q $set.head EXPTIME) &&
                        trail=$(omove2trail -d $(echo $x | awk '{print $1/60}') $set $str)
                    test -z "$trail" &&
                        echo "ERROR: cannot determine comet trail parameters." && echo "" && return 255
                    # if required (AI_TRAIL without angle) append angle to trail
                    test $(echo $trail | tr ',' '\n' | wc -l) -eq 1 &&
                        trail=$trail","$(echo $str | cut -d '@' -f2)
                    echo "# trail=$trail" >&2
                fi
                
                # determine width of psf/psf trail according to fwhm
                x=$(echo $(get_header $set.head AI_FWHM) 10 | awk '{
                    x=1+3*$1+3*sqrt($1-0.3)
                    if($1>3.5) x=12.5+9*sqrt(0.3*($1-2.7))
                    printf("%.1f", x)
                    }')
                
                # determine size of psf image
                test -z "$psfsize" && psfsize=$(echo $x ${trail//,/ } | awk '{
                    a=$4; if(a<0.5) a=1-$4; x=2*($1+a*$2+10)
                    w=80
                    if (x>w) {
                        w=128; b=w; i=0
                        while (w<x) {
                            i++
                            if (i%2 == 0) {
                                w=2*b; b=w
                            } else {
                                w=int(w*sqrt(2)/8+0.49)*8
                            }
                        }
                    }
                    print w
                    }') &&
                    echo "# setting psfsize=$psfsize"
                
                # delete previous data
                if [ "$overwrite" ]
                then
                    echo "# resetting previous data"
                    # remove files
                    flist=$(ls comet/$set.{star,trail}{mask,psf}.* comet/$set.{star,psf}phot.dat 2>/dev/null)
                    test "$flist" && rm -f $flist
                    # delete AI_PSF* keywords
                    sed -i '/^AI_PSF/d' $set.head
                fi
                
                # remove previous psf
                test -d comet || mkdir comet
                rm -f comet/$set.*psf.$ext
                
                # check if psfsize has changed
                x=$(get_header -q $set.head AI_PSFSZ)
                if [ "$x" ]
                then
                    x=$(echo $psfsize $x  | awk -v s=4 '{printf("%d", s*($1-$2)/2)}')
                    if [ $x -ne 0 ]
                    then
                        echo "# detected change of psfsize (shift masks by $x pix)"
                        # shift masks
                        for mask in comet/$set.starmask.reg comet/$set.trailmask.reg
                        do
                            test -s $mask && regshift $mask $x $x > $tmpreg && mv $tmpreg $mask
                        done
                    fi
                fi
                
                # check if rlim has changed
                x=$(get_header -q $set.head AI_PSFRL)
                if [ "$x" ] && ! is_equal $x $rlim
                then
                    rm -f comet/$set.psfphot.dat
                    skip=""
                    echo "# new skip=\"\" (rlim changed)"
                else
                    # add marked bad objects (red) to variable skip
                    xpareg=$(mktemp x.tmp_XXXXXX.reg)
                    xpaset -p $ds9name regions system physical
                    xpaset -p $ds9name regions save $xpareg
                    x=$(grep "^circle(.* color=red text" $xpareg | tr ' ' '\n' | grep "^text" | \
                        tr '={' ' ' | awk '{printf("%s\n", $2)}')
                    rm -f $xpareg
                    if [ "$x" ]
                    then
                        skip=$(echo $skip $x | tr ' ' '\n' | sort -un | tr '\n' ' ')
                        echo "# new skip=$skip"
                    fi
                fi

                # skip stars from being used in psf extraction
                if [ "$skip" ] && [ -f comet/$set.psfphot.dat ]
                then
                    for id in ${skip//,/ }
                    do
                        sed --follow-symlinks -i 's/^'$id' /#'$id'/' comet/$set.psfphot.dat
                    done
                fi
                
                # TODO: if nothing has changed and overwriting is not requested
                #   then run star subtract only and display results
                 
                # extract PSF's
                echo "$(date +'%H:%M:%S')  AIpsfextract on star stack ..."
                test "$AI_DEBUG" &&
                    echo "AIpsfextract $starstack" \
                    "$set.src.dat \"$oxy\" $rlim $merrlim $psfsize" >&2
                AIpsfextract $starstack $set.src.dat "$oxy" $rlim $merrlim $psfsize
                test $? -ne 0 &&
                    echo "ERROR: AIpsfextract has failed." && echo "" && return 255
                #echo "# BREAK"
                #return
                
                if [ "$cometstack" ]
                then
                    echo "$(date +'%H:%M:%S')  AIpsfextract on comet stack ..."
                    test "$AI_DEBUG" &&
                        echo "AIpsfextract -t $trail -s $starstack $cometstack" \
                        "$set.src.dat \"$oxy\" $rlim $merrlim $psfsize" >&2
                    AIpsfextract -t $trail -s $starstack $cometstack $set.src.dat "$oxy" $rlim $merrlim $psfsize
                fi
                
                # star subtracted check image
                echo "# creating check images ..."
                xy2reg $starstack comet/$set.starphot.dat "" "" 4 > x.all.reg
                xy2reg $starstack comet/$set.psfphot.dat "" "" 16 > x.psf.reg
                AIexamine $AI_TMPDIR/x.stsub.$ext x.psf.reg
                xpaset -p $ds9name scale mode zmax
                xpaset -p $ds9name cmap value 2.5 0.15

                # check if psf stars are free of companions (new ds9 window)
                echo "# display check images ..."
                if [ "$cometstack" ]
                then
                    echo "comet ${oxy/,/ }" | xy2reg $starstack - > x.comet.reg
                    AIexamine -n PSF -s -s -p "-zoom to fit" \
                        comet/$set.starpsf.$ext  comet/$set.starmask.reg \
                        comet/$set.trailpsf.$ext comet/$set.trailmask.reg &
                else
                    AIexamine -n PSF -s -s -p "-zoom to fit" \
                        comet/$set.starpsf.$ext  comet/$set.starmask.reg &
                fi
                echo "$cmd finished"
                echo ""
                ;;
        cometextract) set=$1
                starstack=$2
                bgfit10=$3
                comult=$4
                rlim=$5
                opts=$6
                ext=""
                echo "running cometextract $set $starstack \"$bgfit10\" \"$comult\" \"$rlim\" \"$opts\""
                
                # determine input image type
                is_pgm $starstack && ext="pgm"
                is_ppm $starstack && ext="ppm"
                
                # determine cometstack
                cometstack=$(get_header $starstack AI_COMST)
                test -z "$cometstack" &&
                    echo "ERROR: cometstack undefined." >&2 && echo "" && return 255
                test ! -e "$cometstack" &&
                    echo "ERROR: image $cometstack not found." >&2 && echo "" && return 255

                # check for bg subtracted images
                test -f ${starstack%.*}.bgs.$ext &&
                    starstack=${starstack%.*}.bgs.$ext &&
                    echo "# bg subtracted star stack found: $starstack"
                test -f ${cometstack%.*}.bgs.$ext &&
                    cometstack=${cometstack%.*}.bgs.$ext &&
                    echo "# bg subtracted comet stack found: $cometstack"
                test ! -e ${starstack%.*}".head" && ln -s $set.head ${starstack%.*}".head"
                test ! -e ${cometstack%.*}".head" && ln -s $set.head ${cometstack%.*}".head"
                
                # determine comet position
                set - $(get_header -s $set.head AI_CORA,AI_CODEC,AI_OMOVE)
                test $# -ne 3 &&
                    echo "ERROR: missing parameters (comet position or move)." &&
                    echo "" && return 255
                str=$3
                oxy=$(echo comet $1 $2 | rade2xy - $set.wcs.head | awk '{printf("%.0f,%.0f", $2, $3)}')
                
                # get trail parameters from image header
                str="${str}@$oxy"   # omove parameter in AIcomet
                echo "# omove=$str"
                
                get_jd_dmag $set 2>/dev/null > x.obs.dat
                test ! -s x.obs.dat &&
                    echo "# WARNING: time stamp of individual exposures in set $set is unknown." &&
                    get_jd_dmag -g $set 2>/dev/null > x.obs.dat
                test ! -s x.obs.dat &&
                    echo "ERROR: unable to guess time stamp of individual exposures." &&
                    echo "" && return 255
                    
                # delete previous data
                if [ "$overwrite" ]
                then
                    echo "# resetting previous data"
                    # remove files
                    # note $set.starphot.dat is kept because it is created by psfextract
                    flist=$(ls comet/$set.cosub*.$ext comet/$set.{comet,cometbg,bad}.reg comet/$set.newphot.dat 2>/dev/null)
                    test "$flist" && rm -f $flist
                    # delete AC_* keywords
                    sed -i '/^AC_/d' $set.head
                fi
                
                # comet extraction and photometry
                xy2reg $starstack comet/$set.starphot.dat > x.stars.reg
                test "$bgfit10" && opts="-b $bgfit10 $opts"
                test "$rlim" && opts="-r $rlim $opts"
                test "$AI_DEBUG" && echo "AIcomet -m $comult $opts $starstack" \
                    "$cometstack $str x.obs.dat" >&2
                touch $tmpstamp
                AIcomet -m $comult $opts $starstack $cometstack $str x.obs.dat
                test $? -ne 0 &&
                    echo "ERROR: AIcomet failed." && echo "" && return 255
                x=$(cat comet/$set.*reg | grep -vE "DS9|global|physical" | wc -l)
                y=$(cat comet/$set.*reg | grep -vE "DS9|global|physical" | sort -u | wc -l)
                test $x -ne $y &&
                    echo "WARNING: duplicate regions in comet/*reg"

                if [ -e $AI_TMPDIR/x.resid.$ext ] &&
                    [ $AI_TMPDIR/x.resid.$ext -nt $tmpstamp ]
                then
                    # display images and regions to check star/comet removal
                    test -s comet/$set.newphot.dat &&
                        xy2reg $starstack comet/$set.newphot.dat > x.$set.newphot.reg
                    echo "# display check images ..."
                    badreg=comet/$set.bad.reg; test ! -f $badreg && badreg=""
                    AIexamine $AI_TMPDIR/x.cosub.$ext $AI_TMPDIR/x.coblur.$ext comet/$set.comet*.reg $badreg \
                        $AI_TMPDIR/x.stsub.$ext $AI_TMPDIR/x.resid.$ext x.$set.newphot.reg
                    xpaset -p $ds9name scale mode zmax
                    xpaset -p $ds9name cmap value 2.5 0.15
                fi
                echo "$cmd finished"
                echo ""
                ;;
        regphot)  # note: using flaged (red) regions only
                img=$1
                bgrgb=${2:-"2000"}
                #ddiff=${5:-""}   # double star with given mag diff
                echo "running: regphot \"$img\" $bgrgb"
                
                # get image name
                if [ -z "$img" ]
                then
                    img=$(xpaget $ds9name fits header keyword AI_IMAGE)
                    test "$img" && echo "# img=$img"
                fi
                test ! -e "$img" && echo "ERROR: missing image $img" >&2 &&
                    echo >&2 && return 255

                # derive set name
                set=$(basename ${img%%.*})

                # check header file name
                if ! is_setname $set
                then
                    test ! -e ${img%.*}.head &&
                        echo "ERROR: missing header file ${img%.*}.head" >&2 &&
                        return 255
                    if [ -L ${img%.*}.head ]
                    then
                        str=$(basename $(readlink -f ${img%.*}.head))
                    else
                        str=$(get_header ${img%.*}.head AI_SNAME)
                    fi
                    set=${str%%.*}
                fi
                # photcat
                photcat=comet/$set.newphot.dat
                test ! -e $photcat &&
                    echo "WARNING: missing photcat=$photcat" >&2 &&
                    photcat=""
                nid=1000
                test "$photcat" &&
                    x=$(grep "^N[1-9]" $photcat | cut -d ' ' -f1 | sort | tail -1) &&
                    test "$x" && nid=${x:1}
                echo "# set=$set photcat=$photcat nid=$nid"
                
                npix=$(imsize $img | awk '{print $1*$2}')
                xpareg=$(mktemp x.tmp_XXXXXX.reg)
                xpaset -p $ds9name regions background
                xpaset -p $ds9name regions system physical
                xpaset -p $ds9name regions save $xpareg
                cat $xpareg | grep "(.*) #.* color=red" > $tmpdat
                n=$(cat $tmpdat | wc -l)
                test "$AI_DEBUG" && test $n -gt 0 && echo "# red regions: $n"
                if [ $n -eq 0 ]
                then
                    cat $xpareg | grep "(.*) #.* background" > $tmpdat
                    n=$(cat $tmpdat | wc -l)
                    test "$AI_DEBUG" && test $n -gt 0 && echo "# selected: $n"
                fi
                rm -f $xpareg
                xpaset -p $ds9name regions source
                test $n -eq 0 &&
                    echo "ERROR: no region selected." >&2 &&
                    echo && return 255
                test $n -gt 1 &&
                    echo "measuring $n regions ..."
                
                while read
                do
                    id=$(echo $REPLY | tr ' ' '\n' | tr -d '}' | \
                        grep "^text={" | cut -d '{' -f2)
                    echo -e "# Region file format: DS9 version 4.1
global color=green dashlist=8 3 width=1 font=\"helvetica 10 normal roman\" \
select=1 highlite=1 dash=0 fixed=0 edit=1 move=1 delete=1 include=1 source=1
physical" > $tmpreg
                    echo "$REPLY" >> $tmpreg
                    
                    false && (
                    reg2pbm $img $tmpreg > $tmpmask
                    narea=$(identify -verbose $tmpmask | grep FFFFFF | tr -d ':' |
                        awk '{print $1}')
                    x=$(echo $narea | awk '{printf("%.0f", 2*sqrt($1/3.1416))}')
                    pnmarith -mul $img $tmpmask 2>/dev/null > $tmpim1
                    ! is_pnm $tmpim1 &&
                        echo "ERROR: pnmarith failed." >&2 &&
                        echo && return 255
                    cnt=$(identify -verbose $tmpim1 | grep -i "mean:" | head -3 | \
                        awk -v n=$npix -v a=$narea '{
                            if(NR>1) printf(","); printf("%.1f", $2*n/a)
                        }')
                    )
                    
                    set - $(_regstat -q $img $tmpreg)
                    narea=$3
                    cnt=$5  # mean
                    x=$(echo $narea | awk '{printf("%.0f", 2*sqrt($1/3.1416))}')

                    test $n -gt 1 && echo ""
                    echo "# id=\""$id"\"  cnt=$cnt  narea=$narea  d=$x"
                    newmag $set "$photcat" "$id" $narea $cnt 1 $bgrgb > $tmpdat1
                    line=$(tail -1 $tmpdat1)
                    grep -v "^XXXXX" $tmpdat1
                    if [ "$id" ]
                    then
                        sed -i "/^$id /{
                            s/^/#/
                            a$line
                        }
                        " $photcat
                    else
                        nid=$((nid+1))
                        (reg2xy $img $tmpreg | awk -v n=$nid '{printf("N%s       %7.2f %7.2f", n, $2, $3)}'
                        echo $line | awk -v a=$narea '{printf("  %6.3f %6.3f %6.3f  %3d", $4, $5, $6, a)}'
                        echo "   0  $(echo $bgrgb | cut -d ',' -f2)   0 0.0") | tee -a $photcat
                    fi
                    test $? -ne 0 &&
                        echo "ERROR: in newmag $set \"$photcat\" \"$id\" $narea $cnt 1 $bgrgb" >&2 &&
                        echo
                done < $tmpdat
                echo "$cmd finished"
                echo ""
                ;;
        manualdata) set=$1
                idx=$2
                shift 2
                #"$ccorr" "$stlim" "$dtlen" "$dtang" "$ptlen" "$ptang"
                #echo "running manualdata $set $idx \"$1\" \"$2\" \"$3\" \"$4\" \"$5\" \"$6\""
                test ! -f $set.head &&
                    echo "ERROR: file $set.head is missing." >&2 && return 255
                set_header $set.head \
                    AI_ACOR$idx="$1/Manual correction of measured ADU" \
                    AI_ALIM$idx="$2/Limiting star total ADU" \
                    AI_DLEN="$3/Dust tail length in pixel" \
                    AI_DANG="$4/Dust tail angle in image (right=0)" \
                    AI_PLEN="$5/Plasma tail length in pixel" \
                    AI_PANG="$6/Plasma tail angle in image (right=0)"
                echo ""
                ;;
        photcal) set=$1
                idx=$2
                catalog=$3
                color=$4
                # until v4.5: aprad topts aopts skip
                maxstars=$5
                aprad=$6
                maglim=$7
                doext=$8
                skip=$9
                shift 9
                opts=$1
                dodel=$2
                # until v4.5:
                #echo "running photcal $set $idx $catalog \"$color\" \"$aprad\" \"$topts\" \"$aopts\""
                echo "running photcal $set $idx $catalog \"$color\" \"$maxstars\" \"$aprad\" \"$maglim\" \"$doext\""
                test "$skip" && echo "# skip=$skip"
                test "$opts" && echo "# opts=$opts"

                # check valid catalog
                x=$(get_param refcat.dat description $catalog)
                test $? -ne 0 &&
                    echo "  You are likely using an outdated version of refcat.dat." &&
                    echo "  Consider to copy a new one by running the command" &&
                    echo "    cp /usr/share/airtools/refcat.dat ./" &&
                    echo "" &&
                    return 255
                echo "# catalog is $x"
                
                # check upper limit on aprad
                test "$aprad" && test "$(echo $aprad | awk -v max=20 '{if($1>max){print "LIMIT"}}')" &&
                    echo "ERROR: exceeding aprad limit of 20pix" >&2 && return 255
                    
                # note aboute already rejected stars
                str=""
                test -e phot/$set.$catalog.xphot.dat &&
                    str=$(grep "^#" phot/$set.$catalog.xphot.dat | sed -e 's/^[# ]*//' | awk '{
                        if($2!~/^[[:digit:]*$]/) next
                        if($3!~/^[[:digit:]*$]/) next
                        if($4!~/^[[:digit:]*$]/) next
                        if($5!~/^[[:digit:]*$]/) next
                        if($6!~/^[[:digit:]*$]/) next
                        printf("%s\n", $1)
                        }' | tr '\n' ' ')
                test "$str" && echo "# old skip=$str"
                
                # add marked bad objects (red) to variable skip
                xpaaccess -c -t "2,2" $ds9name > /dev/null
        		if [ $? -ne 0 ]
        		then
                    xpareg=$(mktemp x.tmp_XXXXXX.reg)
					xpaset -p $ds9name regions system physical
					xpaset -p $ds9name regions save $xpareg
					x=$(grep "^circle(.* color=red text" $xpareg | tr ' ' '\n' | grep "^text" | \
						tr '={' ' ' | awk '{printf("%s\n", $2)}')
                    rm -f $xpareg
					if [ "$x" ]
					then
						skip=$(echo $skip $x | tr ' ' '\n' | sort -u | tr '\n' ' ')
						echo "# new skip=$skip"
					fi
                fi

                # color band
                opts="$opts -"$(echo ${color//[+c()]/ } | cut -d ' ' -f1)
                # color index
                x=$(echo ${color//[+c()]/ } | awk '{print $2}')
                test "$x" && opts="$opts -ci $x"
                false && case "$catalog" in
                    tycho2) opts="$opts $topts";;
                    *)      opts="$opts $aopts";;
                esac
                test "$maxstars" && opts="$opts -n $maxstars"
                test "$maglim" && opts="$opts -l $maglim"
                test "$doext" && opts="$opts -e"
                test "$skip" && opts="$opts -s \"$skip\""

                # delete previous data
                if [ "$overwrite" ]
                then
                    echo "# resetting previous data"
                    # remove files
                    flist=$(ls phot/$set.* 2>/dev/null)
                    test "$flist" && rm -f $flist
                    # delete AP_* keywords
                    sed -i '/^AP_/d' $set.head
                fi
                
                #test "$AI_DEBUG" && 
                echo "#" AIphotcal $opts $set $idx $catalog $aprad >&2
                
                eval AIphotcal $opts $set $idx $catalog $aprad
                test $? -ne 0 && echo && return 255
                
                # show results
                echo ""
                echo "# ICQ data:"
                phot2icq -v -c $set $catalog
                
                # remove some temp files
                if [ -z "$AI_DEBUG" ]
                then
                    x=$(ls x.* 2>/dev/null | \
                        grep -vE "x.psf.reg|x.obs.dat|x.stars.reg|x.$set.$catalog.reg")
                    test "$x" && rm $x
                fi

                echo "$cmd finished"
                echo ""
                ;;
        coordinates)
                img=$1
                
                # get image name
                if [ -z "$img" ]
                then
                    img=$(xpaget $ds9name fits header keyword AI_IMAGE)
                    test "$img" && test "$AI_DEBUG" && echo "# img=$img"
                fi
                test ! -e "$img" && echo "ERROR: missing image $img" >&2 &&
                    echo >&2 && return 255
                
                # determine set name
                set=$(basename ${img%%.*} | sed -e 's|_m.*||')
                ! is_setname $set &&
                    set=$(get_header -q $img AI_SNAME | sed -e 's|_m.*||')
                ! is_setname $set &&
                    set=$(get_header -q $img AI_COMST | sed -e 's|_m.*||')
                ! is_setname $set &&
                    echo "ERROR: unable to determine set name." >&2 && echo >&2 && return 255
                test ! -e $set.head &&
                    echo "ERROR: missing $set.head" >&2 && echo >&2 && return 255
                test ! -e $set.wcs.head &&
                    echo "ERROR: missing $set.wcs.head" >&2 && echo >&2 && return 255

                # measure coordinates for every circle region
                xpareg=$(mktemp x.tmp_XXXXXX.reg)
                printf "%-8s %-12s %-12s %-5s %-8s %-8s\n" \
                    "# id" "RA" "DE" "epoch" "x" "y"
                xpaset -p $ds9name regions system physical
                xpaset -p $ds9name regions save $xpareg
                grep -iwE "^circle" $xpareg | reg2xy $img - | while read
                do
                    set - $(echo "$REPLY")
                    printf "%-8s " $1
                    echo $1 $2 $3 | xy2rade -s - $set.wcs.head
                done
                rm -f $xpareg
                printf "\n\n"
                ;;
        *)      echo "WARNING: unknown command: $cmd"
                ;;
    esac

    # TODO: reset SAOImage working dir to project dir (e.g. for loading regions)
    xpaaccess -c -t "2,2" $ds9name > /dev/null
    false && if [ $? -ne 0 ]
    then
        #xpaset -p $ds9name cd $wdir
        x=$(mktemp $wdir/tmp_XXXXXX.reg)
        xpaset -p $ds9name regions save $x
        rm -f $x
    fi

    rm -f $tmpdat $tmpreg $tmpim1 $tmpmask $tmpfits1 $tmpfits2 $tmpdat1 $tmpstamp
}

get_frameno () {
    # get ds9 frame number of a given image file
    # return empty string if not found
    local showhelp
    local verbose
    local ds9name="AIRTOOLS"
    local i
    for i in 1 2
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-v" && verbose=1 && shift 1
    done
    local img=$1
    local curr
    local id
    local frameno
    local aiimage

    (test "$showhelp" || test $# -ne 1) &&
        echo "usage: get_frameno [-v] <img>" >&2 &&
        return 1

    test ! -f $img &&
        echo "ERROR: image file $img does not exist." >&2 &&
        return 255
    
    xpaaccess -c -t "2,2" $ds9name > /dev/null
    test $? -eq 0 && return
    curr=$(xpaget AIRTOOLS frame)   # store current frame id
    for id in $(xpaget AIRTOOLS frame all)
    do
        xpaset -p $ds9name frame $id
        test "$(xpaget $ds9name frame has fits)" != "yes" && continue
        aiimage=$(xpaget $ds9name fits header keyword AI_IMAGE)
        test "$verbose" && echo "$id: $aiimage" >&2
        test "$aiimage" == "$(basename $img)" && frameno=$id
        test "$frameno" && test -z "$verbose" && break
    done
    xpaset -p $ds9name frame $curr
    echo $frameno
    return
}

wait_for_saoimage () {
	# wait until SAOImage display is shown
	local showhelp
    local timeout=600
    local verbose
    local ds9name="AIRTOOLS"
    local i
    for i in 1 2 3 4
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-t" && timeout=$2 && shift 2
        test "$1" == "-n" && ds9name=$2 && shift 2
        test "$1" == "-v" && verbose=1 && shift 1
    done
    local found
    local t
    local dt
    
    (test "$showhelp" || test $# -ge 1) &&
        echo "usage: wait_for_saoimage [-v] [-n ds9name] [-t timeout|$timeout]" >&2 &&
        return 1

	t=0; dt=1
    while test ! "$found" && test $t -lt $timeout
    do
        xpaaccess -c -t "2,2" $ds9name > /dev/null
        test $? -ne 0 && found=1
        if [ -z "$found" ]
        then
            test "$verbose" && echo "waiting for SAOImage $ds9name ..." >&2
            sleep $dt
        fi
        t=$((t + dt))
        test $t -ge 3 && dt=2
        test $t -ge 9 && dt=3
        test $t -ge 20 && dt=5
    done
    test ! "$found" &&
        echo "WARNING: still waiting for display of SAOImage $ds9name (maybe loading many images)." >&2 &&
        return 255
    return 0
}

wait_for_frame () {
    # wait until image is loaded into current ds9 frame
    # return last frame number
    local showhelp
    local timeout=120
    local verbose
    local ds9name="AIRTOOLS"
    local i
    for i in 1 2 3
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-t" && timeout=$2 && shift 2
        test "$1" == "-v" && verbose=1 && shift 1
    done
    local img=$1
    local has_display
    local delay=2
    local t
    local fname
    local aiimage
    local found

    (test "$showhelp" || test $# -ne 1) &&
        echo "usage: wait_for_frame [-v] [-t timeout|$timeout] <img>" >&2 &&
        return 1

    test ! -f $img &&
        echo "WARNING: image file $img does not exist." >&2 &&
        return
    
    t=0
    while test ! "$has_display" && test $t -lt 10
    do
        xpaaccess -c -t "2,2" $ds9name > /dev/null
        test $? -ne 0 && has_display=1
        if [ -z "$has_display" ]
        then
            test "$verbose" && echo "waiting for SAOImage $ds9name ..." >&2
            sleep 1
        fi
        t=$((t + 1))
    done
    test ! "$has_display" &&
        echo "WARNING: SAOImage $ds9name is not running." >&2 &&
        return

    t=0
    while test ! "$found" && test $t -lt $timeout
    do
        test "$(xpaget $ds9name frame has fits)" != "yes" && continue
        fname=$(xpaget $ds9name file)
        test "$fname" && test "$(basename $fname)" == "$(basename $img)" && found=1
        if [ -z "$found" ]
        then
            aiimage=$(xpaget $ds9name fits header keyword AI_IMAGE)
            test "$aiimage" && test "$(basename $aiimage)" == "$(basename $img)" && found=1
        fi
        if [ -z "$found" ]
        then
            test "$verbose" && echo "waiting $delay seconds ..." >&2
            sleep $delay
        fi
        t=$((t + delay))
        delay=$((delay * 3/2)) 
    done
    test ! "$found" && return 255
    xpaget $ds9name frame  # show last frame number
    return    
}

# collect some information about image sets
#   default: set target type nref flen fr iso texp n ts black tel
#   long:    day set object ra+de ha jd_ref texp n rms bg fwhm tel site
AIsetinfo () {
    local showhelp
    local otype
    local longinfo
    local baseinfo          # query set.dat only
    local do_skip_header    # if set skip header line
    local do_skip_no_images=1
    local i
    for i in 1 2 3 4 5 6 7
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-o" && otype="o" && shift 1
        test "$1" == "-c" && otype="c" && shift 1
        test "$1" == "-b" && baseinfo=1 && shift 1
        test "$1" == "-l" && longinfo=1 && shift 1
        test "$1" == "-q" && do_skip_header=1 && shift 1
        test "$1" == "-x" && do_skip_no_images="" && shift 1
    done
    local setname=${1:-""}
    local exifdat="exif.dat"
    local rawfilesdat="rawfiles.dat"
    local sdat=${AI_SETS:-"set.dat"}
    local ex=${AI_EXCLUDE:-""}  # space separated list of image numbers
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmp1=$(mktemp "$tdir/tmp_dat1.XXXXXX.dat")
    local tmphead=$(mktemp "$tdir/tmp_hdr.XXXXXX.head")
    local ltime
    local sname
    local target
    local type
    local texp
    local n1
    local n2
    local nref
    local dark
    local flat
    local telid
    local nexp
    local jdref
    local rms
    local bg
    local fwhm
    local flength
    local fratio
    local iso
    local tsens
    local black
    local rhdr
    local retval
    local ra
    local de
    local ha
    local alt
    local az

    test "$showhelp" &&
        echo "usage: AIsetinfo [-o|-c] [-b|-l] [-x] [setname]" >&2 &&
        return 1

    test ! -f $sdat &&
        echo "ERROR: set data file $sdat is missing." >&2 &&
        return 255
    #test ! -f $exifdat &&
    #    echo "ERROR: exif data file $exifdat is missing." >&2 &&
    #    return 255

    test "$setname" && ! is_setname $setname &&
        echo "ERROR: set name $setname is not defined in $sdat." >&2 &&
        return 255

    if [ -z "$setname" ] && [ ! "$do_skip_header" ]
    then
        if [ ! "$baseinfo" ] && [ ! "$longinfo" ]
        then
            echo "#set target type nref flen fr   iso  texp  n  ts black tel"
            #     dk01 bias     d  0011  530 5.0    -   0.0 10 -15    -  T14
        else
            if [ "$baseinfo" ]
            then
                echo "# LT  set  target type texp n1 n2   nref dark flat tel"
            else
                #echo "# date  set   object   ra+de     ha  jd_ref      texp n  rms   bg fwhm tel site"
                ##     200120  co01  2017T2   0234+572  1.8 2458869.319 120 14  0.0    0 0.0  GSOG Weimar
                echo "# date   set   object   ra+de    az alt jd_ref      texp n  rms   bg fwhm tel site"
                #     210902   co01  2020V2   1216+345 303 18 2459460.319 120 15  0.0    0 0.0  RASA Weimar
            fi
        fi
    fi
    
    if [ "$baseinfo" ]
    then
        grep -v "^#" $sdat | sed -e 's|#.*||' | awk -v s="$setname" -v o="$otype" '{
            if ($1!~/^[0-9][0-9]:[0-9][0-9]/) next
            #if ($2!=s) next
            if ($5!~/^[0-9]+$/) next
            if ($6!~/^[0-9]+$/) next
            if ($7!~/^[0-9]+$/) next
            if ($8!~/^[0-9]+$/ && $8!="-") next
            if (NF<10) next

            if (s!="" && s!=$2) next
            if (o!="" && o=="c" && $4!="d" && $4!="f") next
            if (o!="" && o!="c" && $4!=o) next
            gsub(/ $/,"")
            if (NF == 10) {printf("%-50s -\n"), $0} else {print $0}
            }' | tee $tmp1
        retval=255
        test -s $tmp1 && retval=0
        rm -f $tmp1 $tmphead
        return $retval
    fi

    while read ltime sname target type texp n1 n2 nref dark flat telid x
    do
        test "${ltime:0:1}" == "#" && continue
        test "$setname" && test "$sname" != "$setname" && continue
        test "$otype" && test "$otype" != "c" && test "$type" != "$otype" && continue
        test "$otype" && test "$otype" == "c" &&
            test "$type" != "d" && test "$type" != "f" && continue
        test "$longinfo" && test "$type" != "o" && continue
        is_integer $n1 || continue
        is_integer $n2 || continue
        test "$type" == "a" && continue
        
        # get reference image number of calibration sets
        ! is_integer $nref && test -d "$AI_RAWDIR" &&
            nref=$(AIimlist -q -n $sname "" raw 2>/dev/null | lines $((nexp/2 + 1)) | tail -1)
        ! is_integer $nref && nref=$(printf "%04g" $(echo "($n1+$n2)/2" | bc))
        
        # evaluate header file
        nexp=0; rms=0; bg=0; fwhm=0; jdref=0; rhdr=""
        if [ -f $sname.head ]
        then
            x=$(get_header -q $sname.head OBJECT | sed -e 's/^ *//; s/ *$//')
            test "$x" && target=$x
            x=$(get_header $sname.head NEXP); test "$x" && nexp=$x
            test $nexp -gt 0 &&
                x=$(get_header $sname.head EXPTIME | awk -v n=$nexp '{print $1/n}') &&
                test "$x" && texp=$x
            x=$(get_header -q $sname.head JD_OBS)
            test -z "$x" && x=$(get_header -q $sname.head MJD_OBS)
            test -z "$x" && x=$(get_header -q $sname.head MJD_REF)
            test -z "$x" && x=$(get_header -q $sname.head JD)
            test "$x" && jdref=$(echo $x | awk '{printf("%.3f\n", $1)}')
            if [ "$longinfo" ]
            then
                x=$(get_header $sname.head AI_RMSG); test "$x" && rms=$x
                x=$(get_header $sname.head AI_BGG);  test "$x" && bg=$x
                x=$(get_header $sname.head AI_FWHM); test "$x" && fwhm=$x
                x=$(get_header -q $sname.head AI_BGOFF)
                test "$x" && bg=$((bg-x))
            fi
        else
            # examine rawfile
            rhdr=$(get_rawfile -q $nref)
            if [ "$rhdr" ] && (is_fits $rhdr || is_fitsgz $rhdr)
            then
                listhead $rhdr | grep -vE "^Header listing|^$" > $tmphead
                x=$(get_jd -q $tmphead)
                test "$x" && jdref=$x
            else
                # try to examine <nref>.hdr as created by gacam
                rhdr=$(get_rawfile -q $nref | sed -e 's,\.[a-zA-Z]*$,.hdr,')
                if [ "$rhdr" ] && [ -f "$rhdr" ]
                then
                    x=$(grep "^jdmid=" $rhdr | cut -d "=" -f2)
                    test "$x" && jdref=$x
                fi
            fi
        fi
        if [ $nexp -eq 0 ]
        then
            test "$type" == "o" && nexp=$(AIimlist -q -f $sname 2>/dev/null | wc -l)
            # if nexp is missing make best guess
            test $nexp -eq 0 && test -d "$tdir" &&
                nexp=$(AIimlist -q -f $sname 2>/dev/null | wc -l)
            test $nexp -eq 0 && test -d "$AI_RAWDIR" && nexp=$(AIimlist -q -f $sname "" raw 2>/dev/null | wc -l)
            # if nexp is still missing evaluate set.dat
            if [ $nexp -eq 0 ]
            then
                nexp=$(seq $n1 $n2 | wc -l)
                # try to find associated images of the same set (splitted sets)
                nexp=$(grep -w $sname $sdat | awk -v e=$texp -v n1=$n1 -v n2=$n2 -v n=$nexp '{
                    if ($1!~/^#/ && $4=="a" && $5==e && $6!=n1 && $7!=n2) {
                        n=n+$7-$6+1
                    }}END{print n}')
            fi
        fi
        
        
        # if $sname.head does not contain jd try to read from measure/$nref.src.head
        if [ "$jdref" == "0" ] && [ -f measure/$nref.src.head ]
        then
            x=$(grep -E "^MJD_OBS|^JD " measure/$nref.src.head | lines 1 | \
                awk '{printf("%.3f\n", $3)}'); test "$x" && jdref=$x
        fi
        
        # TODO: determine length from first to last exposure
        # TODO: convert jdref to UT date and time
        
        # try to get ra/de from wcs header file
        ra=""; de=""; ha=" -  "; alt=0; az=0
        if [ "$longinfo" ]
        then
			if [ -f $sname.wcs.head ]
			then
				ra=$(dec2sexa -m $(grep "^CRVAL1 " $sname.wcs.head | awk '{print $3}') 15 0)
				de=$(dec2sexa -h $(grep "^CRVAL2 " $sname.wcs.head | awk '{print $3}') 1 1)
			fi
			if [ -z "$ra" ] || [ -z "$de" ]
			then
				hdr=$sname.head
				if [ -f $hdr ]
				then
					x=$(get_header -q $hdr RA);  test "$x" && ra=$(dec2sexa -m $(sexa2dec "$x" 15) 15 0)
					x=$(get_header -q $hdr DEC); test "$x" && de=$(dec2sexa -h $(sexa2dec "$x") 1 1)
				fi
			fi
			if [ -z "$ra" ] || [ -z "$de" ]
			then
				hdr=measure/$nref.src.head
				if [ -f $hdr ]
				then
					x=$(get_header -q $hdr RATEL); test "$x" && ra=$(dec2sexa -m $(sexa2dec "$x" 15) 15 0)
					x=$(get_header -q $hdr DETEL); test "$x" && de=$(dec2sexa -h $(sexa2dec "$x") 1 1)
				fi
			fi
			if [ -z "$ra" ] || [ -z "$de" ]
			then
				rhdr=$(get_rawfile -q $nref)
				if [ "$rhdr" ] && (is_fits "$rhdr" || is_fitsgz "$rhdr")
				then
					x=$(get_header -q $tmphead RA)
					test "$x" && ra=$(dec2sexa -m $(sexa2dec "${x// /:}" 15) 15 0)
					x=$(get_header -q $tmphead DEC)
					test "$x" && de=$(dec2sexa -h $(sexa2dec "${x// /:}") 1 1)
				fi
			fi
			if [ -z "$ra" ] || [ -z "$de" ]
			then
				rhdr=$(get_rawfile -q $nref | sed -e 's,\.[a-zA-Z]*$,.hdr,')
				if [ "$rhdr" ] && [ -f "$rhdr" ]
				then
					x=$(grep "^ra=" $rhdr | cut -d "=" -f2)
					test "$x" && ra=$(dec2sexa -m $(sexa2dec "$x" 15) 15 0)
					x=$(grep "^de=" $rhdr | cut -d "=" -f2)
					test "$x" && de=$(dec2sexa -h $(sexa2dec "$x") 1 1)
				fi
			fi
			if [ -z "$ra" ] || [ -z "$de" ]
			then
				ra="0000"; de="+000"
            else
                # determine hour angle
                x=""
                rhdr=$(get_rawfile -q $nref | sed -e 's,\.[a-zA-Z]*$,.hdr,')
				test -f "$rhdr" && x=$(grep "^st=" $rhdr | cut -d "=" -f2)
                test -z "$x" && x=$(jd2st $jdref)
                test "$x" && ha=$(echo $(sexa2dec "$x" 15) $(sexa2dec "$ra" 15) | \
                    awk '{
                        x=($1-$2)/15
                        if (x<-12) {x=x+24} else {if (x>12) x=x-24}
                        printf("%4.1f", x)}')
                # determine alt and az
                set - $(echo $(sexa2dec $ra 15) $(sexa2dec $de) | \
                    rade2altaz $jdref - | awk '{printf("%.0f %.0f", $1, $2)}')
                az=$1
                alt=$2
			fi
        fi

        # try to get flength and fratio from camera.dat
        test "$telid" && test "${telid:0:1}" == "#" && telid=""
        test -z "$telid" && telid=$(get_telescope -q $sname)
        if [ "$telid" ]
        then
            flength=$(get_param camera.dat flen $sname 2>/dev/null)
            fratio=$(get_param camera.dat fratio $sname 2>/dev/null)
        else
            flength=""
            fratio=""
        fi

        # extract some exif data
        iso="-"
        tsens="-"
        black="-"
        # TODO: determine mean of all images instead of using values from nref 
        set - $(test -s $exifdat && grep -v "^#" $exifdat | grep -w $nref | \
            awk -v n=$nref '{if($2==n){print $0}}') x
        if [ $# -le 9 ]
        then
            set - $(test -s rawfiles.dat && grep -v "^#" $rawfilesdat | grep -w $nref | \
                awk -v n=$nref '{if($1==n){print $0}}') x
            if [ $# -gt 8 ]
            then
                tsens=$8
            else
                echo "# WARNING: $sname: image $nref has no entry in $exifdat/$rawfilesdat." >&2
            fi
        else
            test -z "$flength" && flength="$7"
            test -z "$fratio"  && fratio="${6/F/}"
            iso=$5
            tsens=$8
            black=$9
        fi

        if [ "$longinfo" ]
        then
            pos=$(echo ${ra/+/}$de | tr -d ':.')
            texp=$(echo $texp | awk '{printf("%.0f", $1)}')
            inst=$telid
            test -z "$inst" && test "$flength" && test "$fratio" && inst="f=$flength,f/$fratio"
            test "$inst $AI_SITE" == "f=0.0,f/0 Weimar" && inst="GSO"
            test -z "$inst" && inst="-"
            #printf "%-7s %-5s %-8s %s %s %011.3f %3s %2s %4.1f %4d %3.1f  %s %s\n" \
            #$(basename $(pwd)) $sname $target $pos "$ha" $jdref $texp $nexp $rms $bg $fwhm $inst $AI_SITE
            printf "%-7s %-5s %-8s %s %3d %2d %011.3f %3s %2s %4.1f %4d %3.1f  %s %s\n" \
            $(basename $(pwd)) $sname $target $pos $az $alt $jdref $texp $nexp $rms $bg $fwhm $inst $AI_SITE
        else
            printf "%s %-8s %s  %-4s %4.0f %3.1f %4s %5.1f %2d %2s %4s  %s\n" \
                $sname $target $type $nref "$flength" "$fratio" $iso $texp $nexp $tsens $black $telid
        fi
    done < $sdat
    rm -f $tmp1 $tmphead
    return 0
}

# set image header keywords for image sets from tabular data string
# (first column is set name)
AIsetkeys () {
    local showhelp
    local no_update     # if set then header keywords are not modified/added
    local do_keep_all_values    # if set then a data value of "-" is valid
                        # otherwise it is taken as not-available and keyword
                        # would be ignored
    local i
    for i in 1 2 3
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-a" && do_keep_all_values=1 && shift 1
        test "$1" == "-n" && no_update=1 && shift 1
    done
    local data=$1
    local keylist    # comma separated list of keywords assigned to columns
                        # in <data> starting at column 2
    local sname
    local kv
    local key
    local val
    local com
    local str
    local opts
    
    test "$showhelp" &&
        echo "usage: AIsetkeys [-n] <tabdata_string> <keylist2>" >&2 &&
        return 1

    shift 1
    keylist=("$@")
    test "$no_update" && opts="-n"
    
    echo "$data" | while read
    do
        set - $REPLY x
        test $# -lt 2 && continue
        sname=$1
        test "${sname:0:1}" == "#" && continue
        test ! -e $sname.head &&
            echo "WARNING: file $sname.head not found, skipping line" >&2 && continue
        shift 1
        for kv in "${keylist[@]}"
        do
            # conditionally skip all data entries in this column
            key=${kv%%/*}
            (test -z "$key" || test "$key" == "-") && shift 1 && continue

            # conditionally skip single data entry
            test "$1" == "-" && test -z "$do_keep_all_values" && shift 1 && continue

            # valid entry
            val=$1
            com=${kv#*/}
            test "$com" == "$key" && com=""
            str=$val
            test "$com" && str="$val/$com"
            test "$AI_DEBUG" && echo "set_header" "$opts" "$sname.head $key=\"$str\"" >&2
            set_header $opts $sname.head $key="$str"
            shift 1
        done
    done
}


AIlist () {
    # list airtools results by examining data from image header files
    # valid project directoriy names: YYMMDDxxxx where x is empty or a letter a-z
    local showhelp
    local adirlist  # list of base directories of Airtools reductions
    local color="G" # color channel from multiband image (either R,G or B)
    local photcat   # select given photometric catalog only
    local telid     # telescope identifier
    local site      # if set then limit to data for this site (currently unused)
    local ndays=180 # limit output to last $nday days
    local fields    # additional fields to print out
    local do_current # if set then list only results from current project
    local do_currentsplit # if set then list results from splitdir in current project
    local do_all_obs # if set then do not skip on missing photometry
    local do_jd     # show julian date instead of UT date
    local do_icq    # output similar to ICQ format
    local do_window # show results in a text editor window
    local verbose

    local i
    for i in $(seq 1 12)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-d" && adirlist="$adirlist $2" && shift 2
        test "$1" == "-s" && site="$2" && shift 2
        test "$1" == "-t" && telid="$2" && shift 2
        test "$1" == "-p" && photcat="$2" && shift 2
        test "$1" == "-n" && ndays="$2" && shift 2
        test "$1" == "-f" && fields="$2" && shift 2
        test "$1" == "-c" && do_current=1 && shift 1
        test "$1" == "-cs" && do_currentsplit=1 && shift 1
        test "$1" == "-a" && do_all_obs=1 && shift 1
        test "$1" == "-j" && do_jd=1 && shift 1
        test "$1" == "-i" && do_icq=1 && shift 1
        test "$1" == "-w" && do_window=1 && shift 1
        test "$1" == "-v" && verbose=1 && shift 1
    done
    local target=${1:-""}   # search string in header file
    local first=${2:-""}    # first date YYMMDD
    local last=${3:-""}     # last date YYMMDD
    
    local tdir=${AI_TMPDIR:-"/tmp"}
    test ! -d "$tdir" && echo "WARNING: $AI_TMPDIR does not exist." >&2 && tdir="/tmp"
    local tstamp=$(mktemp "$tdir/tmp_stamp.XXXXXX.dat")
    local tmp1=$(mktemp "$tdir/tmp_dat1.XXXXXX.dat")
    local tmp2=$(mktemp "$tdir/tmp_dat2.XXXXXX.dat")
    local tmpout=$(mktemp "$tdir/tmp_ailist.XXXXXX.dat")
    local tmpsets=$(mktemp "$tdir/tmp_sets.XXXXXX.dat")
    local splitdir="split"  # directory containing stacks of splitted image sets
    local adir
    local dlist
    local jdnow
    local icqid
    local d
    local f
    local l
    local x
    local tmpsh=$(mktemp "/tmp/tmp_script_XXXXXX.sh")
    chmod u+x $tmpsh

    (test "$showhelp") &&
        echo "usage: AIlist [-j] [-i] [-c] [-d airtoolsdir] [-n ndays|$ndays] [-t telid] [-s site] [-p photcat] [-f fields] <target> [first] [last]" >&2 &&
        return 1
    
    (test "$fields" == "list" || test "$fields" == "help") &&
        echo "additional fields:
    texp    EXPTIME/NEXP
    nexp    NEXP
    pscale  pixelscale
    rot     image_rotation
    pier    PIERSIDE
    nfit    AP_NFIT (fitted phot. calib. stars)
    ccoeff  AP_CTRA (color trans. coefficient)
    mrms    AP_MRMS (rms of mag residuals)
    bg      AI_BGG
    rms     AI_RMSG
    fwhm    AI_FWHM
    tail    AI_DLEN/AI_DANG" >&2 &&
        return 1

    # ICQ id of observer
    icqid=$AI_OBSICQID
    test -z "$icqid" && icqid=${AI_OBSERVER:-"OBSxx"}

    if [ "$do_current" ]
    then
        adirlist="."
        do_all_obs=1
        test "$day" && first=$day && last=$day
    fi
    if [ "$do_currentsplit" ]
    then
        adirlist="./$splitdir"
        do_all_obs=1
        test "$day" && first=$day && last=$day
    fi
    if [ -z "$adirlist" ]
    then
        for adir in \
            $(dirname $(pwd))   \
            $(dirname $(pwd))/results
        do
            test -d "$adir" && adirlist=$(echo $adirlist $adir)
        done
        test "$adirlist" && echo "# assuming airtoolsdir=$adirlist" >&2
    fi
    test -z "$adirlist" &&
        echo "ERROR: missing airtoolsdir" >&2

    # determine date range
    test "$first" && first=$(datefmt -6 $first)
    test "$last" && last=$(datefmt -6 $last)
    false && test "$adirlist" != " ." && test -z "$target" && test -z "$ndays$first$last" && ndays=30 &&
        echo "# no target provided, limiting date range" >&2
    test -z "$last" && last=$(date +'%y%m%d')
    test -z "$first" && test "$ndays" && first=$(date +'%y%m%d' -d 'now - '$ndays' days')
    (test -z "$first" || test $first -lt 10000) && first="000000"
    test -z "$do_current" && echo "# using date range: $first - $last" >&2

    for adir in $adirlist
    do
        test ! -d "$adir" &&
            echo "WARNING: directory $adir does not exist" >&2 && continue
        dlist=$(find $adir -maxdepth 1 -type d -regextype posix-egrep -regex "${adir%/}/[0-9]{6}[a-z]{0,4}" | \
            awk -F '/' -v f=$first -v l=$last '{
                d=substr($NF,1,6)
                if (d>=f && d<=l) print $0}')
        (test "$do_current" || test "$do_currentsplit") && dlist=$(realpath $adir)
        test -z "$dlist" && continue
        
        test -z "$do_current" && test -z "$do_currentsplit" &&
            echo "# $adir: scanning $(echo $dlist | wc -w) subdirectories" >&2
        for d in $dlist
        do
            find $d -maxdepth 1 -type f -regextype posix-egrep -regex "$d/[a-z]{2}[0-9]{2}[a-z]{0,1}[0-9]{0,1}.head" \
                -exec grep -H -E "^OBJECT[ ]*|^JD[ ]*=|^AI_TELID[ ]*=" \{\} \; | \
                tr ':=' ' ' | \
                awk -v now=$jdnow -v o="$target" -v t="$telid" '{
                    hdr=$1
                    if (hdr != lasthdr) {
                        if (jd && object && tel) {
                            if (!o || object == o) {
                                if (!t || tel == t) {
                                    printf("%s %s %s %s\n", lasthdr, jd, object, tel)
                                }
                            }
                        }
                        jd=""; object=""; tel=""
                    }
                    if ($2 == "JD")       jd=$3
                    if ($2 == "OBJECT")   object=$3
                    if ($2 == "AI_TELID") tel=$3
                    gsub(/\047/,"",object)
                    gsub(/\047/,"",tel)
                    lasthdr=hdr
                }END{
                        if (jd && object && tel) {
                            if (!o || object == o) {
                                if (!t || tel == t) {
                                    printf("%s %s %s %s\n", lasthdr, jd, object, tel)
                                }
                            }
                        }
                }'
        done
    done | sort -k2,2 >> $tmp1

    test ! -s $tmp1 &&
        echo "WARNING: no match of header files" >&2 &&
        return 1

    # check, if set has been processed already
    # because it might locate under multiple directories
    while read f x
    do        
        l=$(dirname $(dirname $f) | wc -c)
        grep -q "^${f:$l}$" $tmpsets && continue
        echo "${f:$l}" >> $tmpsets
        echo "$f $x"
    done < $tmp1 > $tmp2
        
    # header line
    (if [ "$do_jd" ]
    then
        printf "# dir    set   target   jd          mag   diam pcat   mlim m0    tel  alt  az  moon"
        #       170915s  co01  2016R2   2458012.220 13.63  3.2 apass  20.5 20.77 T33   43  0.23,39,4
    else
        if [ "$do_icq" ]
        then
        printf "#IIYYYYMnL YYYY MM DD.DDdeM[mm.m:rfAAA.ATF/VVVV >dd.ddnDC >t.ttmANG:ICQ XX*OBSxx\n"
        else
        printf "# dir    set   target   ut            mag   diam pcat   mlim m0    tel  alt  az  moon"
        fi
    fi
    test "$fields" &&
        printf "        ${fields//,/ }"
    printf "\n"
    ) > $tmpout
    ! test "$do_window" && cat $tmpout
    
    cat <<EOF > $tmpsh
#!/bin/bash
. airfun.sh > /dev/null
tdir=$tdir
color="$color"
photcat="$photcat"
fields="$fields"
do_all_obs="$do_all_obs"
do_jd="$do_jd"
do_icq="$do_icq"
icqid="$icqid"
verbose="$verbose"

_ailist_parallel \$@
EOF

    _ailist_parallel () {
        local f=$1
        local jd=$2
        local target=$3
        local tel=$4

        local f
        local dir
        local hdr
        local x
        local line
        local sname
        local texp
        local nexp
        local bg
        local bgoff
        local rms
        local fwhm
        local alt
        local az
        local moon
        local pscale
        local rot
        local pier
        local diam
        local apilist
        local jd
        local aidx
        local icol
        local pidx
        local pcol
        local pcat
        local nfit
        local mzer
        local mlim
        local cind
        local ccoeff
        local cter
        local cimd
        local cmag
        local mrms
        local tail
        local prio
        local hopts=""
        local outbase
        local outadd
        local outphot
        local moonfmt
        local catlist=$(mktemp "$tdir/tmp_cat_XXXXXX.dat")

        test "$AI_DEBUG" && echo "#" $f >&2
        hdr=$f
        dir=$(basename $(dirname $f))
        sname=$(basename $f)
        sname=${sname%.head}
        
        # check for photometric data in given color channel
        apilist=$(grep "^AP_AIDX[1-9]" $hdr | cut -c 8)
        if [ -z "$apilist" ]
        then
            test "$verbose" && echo "# $hdr has no photometry" >&2
        else
            test "$photcat" != "all" && test "$photcat" != "any" && if [ "$photcat" ]
            then
                apilist=$(grep "^AP_PCAT[1-9]" $hdr | grep -wi $photcat | cut -c 8)
                test -z "$apilist" &&
                    echo "# $hdr has no photometry using $photcat" >&2
                for i in $apilist
                do
                    aidx=$(get_header -q $hdr AP_AIDX$i); test -z "$aidx" && aidx="-"
                    icol=$(get_header -q $hdr AC_ICOL$aidx)
                    test "$AI_DEBUG" && echo "### i=$i color=$color icol=$icol" >&2
                    test "$color" && test "$icol" != "$color" &&
                        test "$icol$color" != "LG" &&
                        echo "# rejecting: $sname aidx=$aidx icol=$icol color=$color" >&2 &&
                        continue
                    echo $i
                done > $catlist
                apilist=$(cat $catlist)
                rm -f $catlist
            else
                # choose only data from catalog with highest priority
                for i in $apilist
                do
                    aidx=$(get_header -q $hdr AP_AIDX$i); test -z "$aidx" && aidx="-"
                    set - $(get_header -q -l $hdr AC_ICOL$aidx AP_PCOL$i AP_PCAT$i)
                    icol=$1
                    pcol=$2
                    pcat=$3
                    test "$color" && test "$icol" != "$color" &&
                        test "$icol$color" != "LG" &&
                        echo "# rejecting: $sname aidx=$aidx icol=$icol color=$color" >&2 &&
                        continue
                    # choose priority from order in refcat.dat (first=highest)
                    prio=$(grep -nw "^$pcat" refcat.dat | cut -d ":" -f1)
                    echo $prio $i $pcat
                done | sort -n -k1,1 > $catlist
                prio=$(head -1 $catlist | cut -d ' ' -f1)
                apilist=$(grep "^$prio" $catlist | cut -d ' ' -f2)
                rm -f $catlist
            fi
        fi
        test -z "$apilist" && test -z "$do_all_obs" && return
        
        # check for wcs calibration (pixel scale)
        test ! -f ${hdr%.head}.wcs.head &&
            echo "# missing wcs header ${hdr%.head}.wcs.head" >&2 &&
            return
        pscale=$(get_wcspscale ${hdr%.head}.wcs.head)
        rot=$(get_wcsrot ${hdr%.head}.wcs.head | awk '{printf("%.0f", $1)}')
        
        # optional fields related to the image set
        texp=$(echo $(get_header -s -q $hdr EXPTIME,NEXP) | awk '{if(NF==2)printf("%.0f", $1/$2)}');
        test -z "$texp" && texp="-"
        set - $(get_header -q -l $hdr NEXP AI_BGG AI_RMSG AI_FWHM PIERSIDE \
            AI_COALT AI_BGOFF AI_DLEN AI_DANG)
        nexp=$1
        bg=$2
        rms=$3
        fwhm=$4
        pier=$5
        alt=$6
        bgoff=$7
        tail="$8/$9"    # in px/angle from saoimage

        # remove offset from bg
        test "$bgoff" != "-" && test "$bg" != "-" && bg=$((bg-bgoff))
        
        # alt/az and moon ephem
        debuglog "awk_printf"
        test "$alt" != "-" && alt=$(printf "%.0f" $alt)
        az="-"
        moon="-"
        x=$(get_header -q -l $hdr AI_MOP AI_MOD AI_MOALT | \
            awk '{if($1!="-" && $3>=0){printf("%.2f,%d,%d", $1, $2, $3)}}')
        test "$x" && moon=$x
        line=$(pyaltaz $(dirname $f) $sname)
        if [ $? -eq 0 ]
        then
            set - $(echo $line)
            test "$alt" == "-"  && alt=$(printf "%.0f" $1)
            test "$az" == "-"   && az=$(printf  "%.0f" $2)
            test "$moon" == "-" && test $5 -ge 0 && moon="$3,$4,$5"
        fi
        
        # print basic info
        if [ "$do_icq" ]
        then
            # TODO: convert to icq comet designation
            outbase=$(printf "%11s%s  Z " "$(comet2icq ${target//\'/})" "$(jd2ut -p 2 $jd | tr '-' ' ')")
        else
            outbase=$(printf "%-8s %-5s %-8s " $dir $sname ${target//\'/})
            if [ "$do_jd" ]
            then
                outbase="$outbase"$(printf "%11.3f" $jd)
            else
                outbase="$outbase"$(printf "%13s" $(jd2ut -p 2 $jd))
            fi
        fi

        # fields related to photometry
        if [ "$apilist" ]
        then
            for i in $apilist
            do
                pidx=$i
                set - $(get_header -q -l $hdr AP_AIDX$i AP_PCOL$i AP_PCAT$i \
                    AP_NFIT$i AP_MZER$i AP_CIND$i AP_CIMD$i AP_CMAG$i AP_MRMS$i)
                aidx=$1
                pcol=$2
                pcat=$3
                nfit=$4
                mzer=$5
                
                cind=$6
                cimd=$7
                cmag=$8
                mrms=$9

                # formatting some values
                test "$mzer" != "-" && mzer=$(printf "%.2f" $mzer)
                test "$cimd" != "-" && cimd=$(printf "%.2f" $cimd)

                set - $(get_header -q -l $hdr AP_CTRA$i AP_CVAL$i AP_CTER$i AP_CERR$i \
                    AI_ALIM$aidx AC_DIAM$aidx)
                ccoeff=$1
                test "$ccoeff" == "-" && ccoeff=$2
                cter=$3
                test "$cter" == "-" && cter=$4
                mlim=$5     # need to convert from counts to mag
                diam=$6     # need to convert from pix to arcmin
                
                # formatting some values
                test "$ccoeff" != "-" && ccoeff=$(printf "%.2f" $ccoeff)
                test "$cter" != "-" && cter=$(printf "%.2f" $cter)
                test "$mlim" != "-" && mlim=$(i2mag $mlim $texp $mzer | awk '{printf("%.1f", $1)}')
                if [ "$diam" != "-" ]
                then
                    diam=$(echo $diam | awk -v p=$pscale '{
                        x=p*$1/60
                        if (x<=6) printf("%4.1f", x)
                        if (x>6)  printf("%2.0f  ", x)
                    }')
                else
                    diam=" -  "
                fi
                
                # additional output fields
                outadd=""
                if [ "$fields" ]
                then
                    outadd=$(for f in ${fields//,/ }
                    do
                        if [ "${!f}" ]
                        then
                            printf " ${!f}"
                        else
                            printf " $(get_header -q -l $hdr $f)"
                        fi
                    done)
                fi

                # show data
                moonfmt="%s"
                test "$outadd" && moonfmt="%-11s"
                if [ "$do_icq" ]
                then
                    # TODO: deal with unknown cmag, diam
                    outphot=$(printf "%5.2fXX XXXXX XXXXX  %2.0f                        %s" $cmag $diam $icqid)
                else
                    outphot=$(printf " %5s %s %-6s %-4s %s %-5s %2s %3s  $moonfmt" \
                        $cmag "$diam" $pcat $mlim $mzer ${tel//\'/} $alt $az $moon)
                fi
                echo "$outbase$outphot$outadd"
            done
        else
            aidx="-"; pcol="-"; pcat="-"; nfit="-"; mzer="-"; mlim="-"
            cind="-"; ccoeff="-"; cter="-"; cmag="-"; diam="-"

            # additional output fields
            outadd=""
            if [ "$fields" ]
            then
                outadd=$(for f in ${fields//,/ }
                do
                    printf " ${!f}"
                done)
            fi

            moonfmt="%s"
            test "$outadd" && moonfmt="%-11s"
            outphot=$(printf "  -     -   -       -    -    %-5s %2s %3s  $moonfmt" \
                ${tel//\'/} $alt $az $moon)

            echo "$outbase$outphot$outadd"
        fi
    }

    export -f _ailist_parallel
    popts=""; test "$AI_MAXPROCS" && popts="-P $AI_MAXPROCS"
    if [ "$do_window" ]
    then
        cat $tmp2 | parallel $popts -k $tmpsh >> $tmpout
        if [ $(cat $tmpout | wc -l) -gt 1 ]
        then
            cp $tmpout ailist.txt &&
                mousepad ailist.txt 2>/dev/null &
        else
            echo "# WARNING: empty data list"
            rm -f $tmpout
        fi
    else
        cat $tmp2 | parallel $popts -k $tmpsh
    fi
    unset -f _ailist_parallel
    # TODO: error handling
    
    rm -f $tstamp
    test   "$AI_DEBUG" && echo $tmp1 $tmp2 $tmpsets $tmpout $tmpsh >&2
    test ! "$AI_DEBUG" && rm -f $tmp1 $tmp2 $tmpsets $tmpout $tmpsh
    return
}


AIarchive () {
    # create archive of airtools project
    local showhelp
    local archive
    local mode="full"   # allowed modes: base wcs results full
    local copyto
    local verbose
    local i
    for i in $(seq 1 4)
    do
        (test "$1" == "-h" || test "$1" == "--help") && showhelp=1 && shift 1
        test "$1" == "-a" && archive="$2" && shift 2
        (test "$1" == "-base" || test "$1" == "-wcs" || test "$1" == "-results" || test "$1" == "-full") &&
            mode=${1/-/} && shift 1
        test "$1" == "-c" && copyto="$2" && shift 2
        test "$1" == "-v" && verbose=1 && shift 1
    done
    local slist=${1:-""}
    local set
    local pdir
    local compress  # gzip or pigz
    local flist
    local f
    local num
    local retval
    local tmp1=$(mktemp "/tmp/tmp1_$$_XXXXXX.dat")

    (test "$showhelp") &&
        echo "usage: AIarchive [-v] [-c copyto] [-base|-wcs|-results] [slist]" >&2 &&
        return 1

    test "$slist" && for set in ${slist//,/ }
        do
            ! is_setname "$set" &&
                echo "ERROR: $set is not a valid image set name." >&2 && return 255
        done
    test "$copyto" && test -e "$copyto" && ! test -d "$copyto" &&
        echo "ERROR: destination is not a directory." >&2 && return 255
    test "$copyto" && test -e "$copyto" && test "$(ls -A $copyto)" &&
        echo "ERROR: destination directory $copyto is not empty." >&2 && return 255

    pdir=$(basename $(pwd))
    test ! -e .airtoolsrc &&
        echo "ERROR: $(pwd) is not an AIRTOOLS project directory." >&2 && return 255

    # choose compression program
    compress=gzip
    which pigz >/dev/null && compress=pigz

    # set archive name
    if [ -z "$archive" ]
    then
        archive="a${pdir}"
        test "$mode" != "full" && archive="${archive}_${mode}"
        test "$slist" && test $(echo ${slist//,/ } | wc -w) -eq 1 &&
            archive="${archive}_${slist// /}"
        archive="${archive}.$(date +'%y%m%d').tar.gz"
    fi
    
    # create file list
    test -z "$slist" && slist="all"
    case $mode in
        full) if [ "$slist" == "all" ]
            then
                for f in $(find .[a-z]* * -type f)
                do
                    test "${f%.tar.gz}" != "$f" && test "${f#a${pdir}_}" != "$f" && continue
                    echo "$f"
                done | sort -u > $tmp1
            else
                # all data related to single image set
                flist=$(ls -d .[a-z]* *.{log,txt,sh,dat} 2>/dev/null | grep -v ".src.dat$")
                for set in ${slist//,/ }
                do
                    flist="$flist "$(ls -d \
                    badpix*.png \
                    wcs/*log    \
                    *${set}*    \
                    */${set}*   2>/dev/null)
                    # per image files from bgvar, measure
                    for num in $(AI_EXCLUDE="" AIimlist -x $set)
                    do
                        flist="$flist "$(ls bgvar/$num.* measure/$num.* 2>/dev/null)
                    done
                    # master calibration images
                    flist="$flist "$(ls $(AIsetinfo -b $set | awk '{print $9".pgm " $10".pgm"}') 2>/dev/null)
                done
                for f in $flist
                do
                    #test -L "$f" && continue
                    test "${f%.tar.gz}" != "$f" && test "${f#a${pdir}_}" != "$f" && continue
                    echo "$f"
                done | sort -u > $tmp1
            fi
            ;;
        results) # most interesting results (excluding large images)
            flist=$(ls -d .[a-z]* *.{log,txt,dat,sh,env} 2>/dev/null)
            for set in ${slist//,/ }
            do
                test "$set" == "all" && set=""
                flist="$flist "$(ls -d \
                badpix*.png                         \
                bgres*${set}* dk.var* varbgm*${set}* \
                ${set}*.{head,reg,fwhm.png}         \
                bgcorr/${set}*                      \
                wcs/${set}*fgroups*png wcs/*log     \
                comet/${set}*{reg,dat}              \
                phot/${set}*                        \
                chkctr/* mpc/*                      2>/dev/null)
            done
            for f in $flist
            do
                test -L "$f" && continue
                test "${f%.src.dat}" != "$f" && continue
                echo $f | grep -qE "^bad\..*dat$|^bad\..*reg$" && continue
                echo "$f"
            done | sort -u > $tmp1
            ;;
        wcs) # most astrometry results
            flist=$(ls -d .[a-z]* *.{log,txt,dat,sh,env} 2>/dev/null)
            for set in ${slist//,/ }
            do
                test "$set" == "all" && set=""
                flist="$flist "$(ls -d \
                ${set}*.{head,reg,fwhm.png}      \
                wcs/${set}* wcs/*log    2>/dev/null)
            done
            for f in $flist
            do
                test -L "$f" && continue
                test "${f%.src.dat}" != "$f" && continue
                echo $f | grep -qE "^bad\..*dat$|^bad\..*reg$" && continue
                test "${f%.match_1.dat}" != "$f" && continue
                echo "$f"
            done | sort -u > $tmp1
            ;;
        base) # base files required to examine logs/errors
            flist=$(ls -d .[a-z]* *.{log,txt,dat,sh,env} 2>/dev/null)
            for set in ${slist//,/ }
            do
                test "$set" == "all" && set=""
                flist="$flist "$(ls -d \
                ${set}*.{head,reg,fwhm.png}  \
                comet/${set}*.reg   2>/dev/null)
            done
            for f in $flist
            do
                test -L "$f" && continue
                test "${f%.src.dat}" != "$f" && continue
                echo $f | grep -qE "^bad\..*dat$|^bad\..*reg$" && continue
                echo "$f"
            done | sort -u > $tmp1
            ;;
        *)  echo "ERROR: unknown archive mode $mode."
            return 255
            ;;
    esac
    ! test -s $tmp1 &&
        echo "WARNING: empty file list." >&2 && rm -f $tmp1 && return

    # add directory entries to file list
    grep "/" $tmp1 | sed 's,/[^/]*$,,' | sort -u >> $tmp1
    
    
    # create archive
    opts=""
    test "$verbose" && opts="-v"
    if [ "$copyto" ]
    then
        tar $opts -cf - --no-recursion -T $tmp1 | (mkdir -p $copyto &&
            cd $copyto && tar -xpf -) &&
            touch -r ./ $copyto
        retval=$?
        test $retval -eq 0 && echo "# data successfully copied to $copyto" >&2
        test $retval -ne 0 && echo "# ERROR: copying data to $copyto has failed." >&2
    else
        if [ "$compress" ]
        then
            tar $opts -cf $archive -I $compress --no-recursion -T $tmp1
        else
            tar $opts -cf $archive --no-recursion -T $tmp1
        fi
        retval=$?
        test $retval -eq 0 && echo "# archive $archive ($(filesize $archive)) successfully written" >&2
        test $retval -ne 0 && echo "# ERROR: writing archive $archive has failed." >&2
    fi

    test -z "$AI_DEBUG" && test $retval -eq 0 && rm -f $tmp1
    test -e $tmp1 && echo $tmp1 >&2
    return $retval
}


#--------------------
#   main
#--------------------

# load other library functions, show our own environment settings
AIcheck_ok $@
if [ $? -eq 0 ]
then
    AIenv

    # check day
    _aiddir=""
    test -z "$day" &&
        echo "WARNING: day is not defined." &&
        return 255
    test "$day" && echo $(pwd) | grep -q $day
    test $? -ne 0 &&
        echo "WARNING: working dir might not belong to day=$day."
    
    # parallel: skip citing note
    test -d ~/.parallel || mkdir ~/.parallel
    test -f ~/.parallel/will-cite || touch ~/.parallel/will-cite
fi
